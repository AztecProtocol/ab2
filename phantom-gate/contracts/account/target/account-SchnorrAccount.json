{"transpiled":true,"noir_version":"0.35.0+b848cc128d2dc2b461581f21a35509a1af9065a7-aarch64","name":"SchnorrAccount","functions":[{"name":"constructor","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"signing_pub_key_x","type":{"kind":"field"},"visibility":"private"},{"name":"signing_pub_key_y","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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oqyKcirKq7hUxX9UXKbichVXqLhSxVUqrlZxjYprVVynwt3JOSriVSSoqKAiUUVFFZVUJKlIVnG9ihtU3KiisooqKqq618erqK6ihoqaKmqpqK2ijoq6KuqpqK+igYqGKm5S0UjFzSoaq2iioqmKZiqaq2ihoqWKVipaq7hFxa0qblPRRkVbFe1UtFfRQcXtKlJUpKpIU5GuIkNFRxV3qOikorOKO1XcpeJuFfeo6KKiq4puKrqr6KGip4pMFb1U9FbRR0VfFf1U9FcxQMVAFYNUDFYxRMVQFcNUDFcxQsVIFaNUjFYxRsVYFeNUjFcxQcVEFZNUTFYxRcVUFdNUTFcxQ8VMFbNUzFYxR8VcFfNUzFexQMVCFYtULFaxRMVSFctULFexQsVKFatU3KtitYo1KtaqWKdivYoNKjaq2KRis4otKraq2KZiu4odKnaq2KVit4o9Kvaq2Kdiv4oDKg6quE/FIRWHVdyv4gEVR1QcVXFMhfv78u5vt7u/i+7+5rj7e97u71u7vyPi/n6F+3sO7u8buL8d4N6X373nvXs/efde7e590N17jLv373bvje3ed9q9p7N7v2T3XsTufX7de+i696d9U4V7X1X3nqXu/UDde22697F07xHp3n/Rvbehe99A95587v3u3HvJufdpc++B5t5fzL13l3tfLPeeU+79nNx7Jbn3IXLv8ePeP8e9N4173xf3niru/Urce4G499lw72Hh3h/CNQLufQ3cewa41+O717q715G712i71z+71xa71+2618S615u613K610m61yC61/e5186516W513y511O51yq51wG519i416+414a411241zS41wu438V3v+fufofc/X62e4x3v1fsfmfX/T6s+11T93uc7nck3e8fut/Hc7/r5n5fy/3+kvt9Hvf7Le73PdzvUrjfB3DPtbvni91zse75RPdcnXu+yT3/4p6PcD+fdz/7dj+/dT/PdD/fcz/v+vPzHxXu5wPue2/3vaj73sx9r+L6bdd/un4sp2uQ9OPsU4t/ehv3kZKZmXFPt8xgZtdgSnp6sE/nzE7Brr0zenS8u6t7CP7T94QeZfXf+l06Z3ZOubtz/5TMzl27BDul9OwUTO+a0TPYpWtm8J6UzDT3wP+nIwo94sIrM3q4L9cjo2fPYOeTdZmdMoJpXbtk9khJywymZ3S7u2u/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","debug_symbols":"7N3briRLsp3nd1nXvMiD54mvIggCJVECAYEUROqK4Lureq/OWdXtnpldMls+LTy+u90bgbly/sMqw8YfVeH//Y///T/+r//v//m//Kf//H/8l//6x7//n/77H//Xf/nf/sN/+0//5T//+F///Y9j+7f/33/9v//Df/7b//yv/+0//D//7Y9/f7yd2r/74z/+5//9b//nuf2Pf/fH//Gf/q//+Me/vx3/x7/rLj7dLs+LT7fb9evi46kNrj638+XvV58vh/uHq4+H2+3w/CSH2/3nRzkdD6Pr77fT8/L74/h19Xn4w4/H50c5Hq/t14v/53/3x/GCzAsyV2RekLmFyZzv5/vzd73ffl58vF/+7b9w/8v/C494usfDk+jpeD79/C+06zCv4/krrsuvV9//9nlOh9mf53R58jn+GM5/+Dyj6Tl+fZDHL9NzOpyHP/vn1adfJ/NwGlx9/Zrj++3yy7XDKT6cHtcvjOfD49PUt8PXb9lOt8jUn44SKp7QSULFEzpL6F9K6Hz+ebM4t9u8e/upSah4QpeVEjr+ktDjU0LHy+n885e8fbr6GzO61s7o1r56yeHwMaPz19XHy/H882c/HsWo31D/Bur376R+v3dNKqPZff0XTqfz4cPnOV0e56+Wf7x/7IHfltT5gMwLMgnd7tS+ftd/nMrrv/0XErrJDyv0/C+cf9lQXtC83H5+f9wf//D98bfPcy72eVqxz5OwZZ3vX99q7XT+8Hna6dnJ2vXYfZprqU9zK/Vp7qU+TcLd59wePz9N++dvkjb+Fj+3Lxt8/uVjDf8LP4zy8ecd9Jc/KT9+97/9F45/+X/h9Jf/F85/+X+hxf8LP25yXxffD//wXxjdYe5f++Pp8evzgeHP/nFP/LrhPX4+eziPb4+Py+Nna7t++tn345dAup9+8Uf/djNtF2DGYK7AjMHcdgzm/HVnuP+68v4J5g7MGMwDmCGYy2G/YG63208w938Gc1wIzOnnw+TTPzxM/v/x5Xs5ATMGcwZmDKbtGMzbL9+VNt9UMCttvqlgVtp8fxPM+9v1Ypvv/SeY8z/87L/9rosts+9+1+tK++npcP0ydcfDx5/99qZ6XWs/TQSz1n6aCGat/fT3wLy7qV4bMGMwa+2niWDW2k9/C8zbNey6mJm9/wTz6FaTVVfO0e+60sp5Op4uX7/rNeY2bkvtp5lgltpPM8EstZ/+Jph3N9XbUvtpJpgGzBjMUvvp74F5u4bdFvubAz9Xk2tniG7LrpyD33X6yvnzb5Wf2vny6Xf9vn8pdnsgMyZzPyDzgswRmRdkTsi8IHNG5gWZhswLMhdkXpC5IvOCzA2ZF2TswK/I2IFfkHnYgV+RsQO/ImMHfkWm+g78bf8u+NGQeUGm0g78t8+TsXl+Cdsff7g+fZ7NvJ/hcUPmBZmMzfPno8F/JvO3/8KLfw18+Br82y9f3cP/wv38/HV/fV4y/j44P563hPbLuxlOQ+6P2xeax+0XMz2mfv6S3r/+5PFzj9v967nH7fH4EFDiWykPL15v8TPO2+0D7NOlff1D8Mv1l781cR5d/eOK5+Rebsdfwv/bPxYefIFd7l/PAn4M1u0frv+3X+C49V/glPALPJ7/6Pp0bccPv8Dt8fWH4/hzHh6jt++0r1extsvPZzy30bC3w+n557Mdbr/+Qfrztzyv8Vsez19/po+/vqjr779l20WWl11ked1FlrddZHlf4rc8375ernG+3f/5L4IcD4/Jv+X9fvy5hJ7f/5rX2zOg2+2Xvy5w+TOg42HyR//xVf3zReC//EWT4We/XL7+DF0urYVv+cfjrn7bjwvO/fChMZyvt59z//PTj1b00+n482Vrv/SE43VYpE4/XzB+On36ayz7rgrH89Qcjz9fg3c6fsrxcXk8f/Ljerx+mNnH/fr8w/N4HA79xLbd/KaX3fym1938prdVftMf3fjafm4Yx1P/u9539Ls+1vldr5efj22ut/OH6/d93z0dFs391xe+/n3GT8cd/a6nHf2uy+yOfzs26usZ8uF+7r+nT8tsj//C77rM/vgv/K7LbJD/wu+60A758XddaIf8+LsutEN++l3PC+1NH3/Xhfamj7/rQnvTx991R3vTeUd703lHe9N5R3vTeUd703lHe9N5R3tT29He1Ha0N7Ud7U1tR3tT29He1Ha0N7Ud7U1tR3tT29He1Ha0N112tDdddrQ3XXa0N112tDdddrQ3XXa0N112tDdddrQ3XXa0N112tDddd7Q3XXe0N113tDddd7Q3XXe0N113tDddd7Q3XXe0N113tDddd7Q33Xa0N912tDfddrQ33Xa0N912tDfddrQ33Xa0N912tDfddrQ33Xa0N913tDfdd7Q33Xe0N913tDfdd7Q33Xe0N913tDfdd7Q33Xe0N913tDc9drQ3PXa0Nz12tDc9drQ3PXa0Nz12tDc9drQ3PXa0Nz12tDc99rM3nQ772ZtOh7l70+nrNbun868HxQ5/1/vpCeZ+aR+uPV/a8+Lz5ZfX8o6Obrhfn+8Qu//yWrC//dx/I3JC5J+InBH5JyKtLpHj4ZfXEv564Mzw6t95Zff58MTXzsefUE7XwcWX01cwl9Mvrzv+cfG/AbwAGAN4BTAG8AZgDOAdwBjAB4AhgMcDgDGAhZf/bQAs3BW2AbBwtdgGwAZgDKAmEgSoiQQBaiJBgJpIEKAmEgN40kSCADWRIEBNJAhQEwkCbADGAGoiQYCaSBCgJhIEqIkEAWoiMYBnTSQIUBMJAtREggA1kSDABmAMoCYSBKiJBAFqIkGAmkgQoCYSA9g0kSBATSQIUBMJAtREggAbgDGAmkgQoCYSBKiJBAFqIkGAmkgM4EUTCQLURIIANZEgwF02kevl+Lz2er11TBomHZNd9oUPTHZZAT4w2eVWfzs8P0a7HXsmu1zUPzDZ5e79nsl1l+v0Bya73JA/MNnl0vv+vnO1x/ZMGiYdE3tsz2SXe+yH71h7bM/EHtszscd2TG722J6JPbZnsss99gOTXe6xH5g0TDomu9xjPzCxx/ZM7LE9E3tsz8Qe2zG573KPfe8K7rvcYz8w4WN7Jnxsz6T5ju2Y2GN7JvbYnok9tmdij+2Z2GM7Jg8+tmfCx/ZM+NieCR/bM2mYdEzssT0Te2zPxB7bM9nlHvveFTx2uce+ZXI+8LE9Ez62Z2KP7ZnYY3smDZOOiT22Z2KP7ZnYY3smfGzPhI/tmOzzeM0PTPjYnok9tmdij+2ZNEw6JvbYnon3FfRMdrnHfmDCx/ZM+NiOyT4PZ3z/HbvP8xY/MLHH9kzssT2ThknHxB7bM+FjeyZ8bM+Ej+2Z8LEdk30e7feBiT22Z2KP7ZnYY3smjSvomHjvVs+Ej+2Z8LE9E3tsz8Qe2zHZ58FwH5jYY3sm9tieiT22Z9Iw6ZjwsT0TPrZnwsf2TOyxPRN7bMdkn8eKfWBij+2ZeO9Wz8R7t3omDZOOCR/bM7HH9kzssT0Te2zPxB7bMXGe14CJPbZnwsf2TPjYnknDpGPCx/ZM7LE9E3tsz8Qe2zOxx3ZM9nme13tXsM/zvD4w4WN7Jnxsz6T5ju2Y2GN7JvbYnok9tmdij+2Z2GM7Jvs8z+sDEz62Z8LH9kz42J5Jw6RjYo/tmdhjeyb22J6J9271TLx3q2Oyz/O8PjDhY3sm9tieiT22Z9Iw6ZjYY3sm9tieiT22Z8LH9kz42H9m0vZ5ntcHJnxsz8Qe2zOxx/ZMGiYdE3tsz8R7t3om3rvVM+FjeyZ8bMfEeV79d6zzvAZM7LE9E3tsz6Rh0jGxx/ZM+NieCR/bM+FjeyZ8bMfEeV4DJvbYnok9tmdij+2ZNK6gY+K9Wz0TPrZnwsf2TOyxPRN7bMfEeV4DJvbYnok9tmdij+2ZNEw6Jnxsz4SP7ZnwsT0Te2zPxB7bMXGe14CJPbZn4r1bPRPv3eqZNEw6Jnxsz8Qe2zOxx/ZM7LE9E3tsx8R5XgMm9tieCR/bM+FjeyYNk44JH9szscf2TOyxPRN7bM/EHtsx2ed5Xu9dwT7P8/rAhI/tmfCxPZPmO7ZjYo/tmdhjeyb22J6JPbZnYo/tmOzzPK8PTPjYngkf2zPhY3smDZOOiT22Z2KP7ZnYY3sm3rvVM/HerY7JPs/z+sCEj+2Z2GN7JvbYnknDpGNij+2Z2GN7JvbYngkf2zPhYzsm+zzP6wMTPrZnYo/tmdhjeyYNk46JPbZn4r1bPRPv3eqZ8LE9Ez72n5lcnOd17JnYY3sm9tieiT22Z9Iw6ZjYY3smfGzPhI/tmfCxPRM+tmPiPK8BE3tsz8Qe2zOxx/ZMGlfQMfHerZ4JH9sz4WN7JvbYnok9tmPiPK8BE3tsz8Qe2zOxx/ZMGiYdEz62Z8LH9kz42J6JPbZnYo/tmDjPa8DEHtsz8d6tnon3bvVMGiYdEz62Z2KP7ZnYY3sm9tieiT22Y+I8rwETe2zPhI/tmfCxPZOGSceEj+2Z2GN7JvbYnok9tmdij+2Y7PM8r/euYJ/neX1gwsf2TPjYnknzHdsxscf2TOyxPRN7bM/EHtszscd2TPZ5ntcHJnxsz4SP7ZnwsT2ThknHxB7bM7HH9kzssT0T793qmXjvVsdkn+d5fWDCx/ZM7LE9E3tsz6Rh0jGxx/ZM7LE9E3tsz4SP7ZnwsR2TfZ7n9YEJH9szscf2TOyxPZOGScfEHtsz8d6tnon3bvVM+NieCR/bMXGeV/8d6zyvARN7bM/EHtszaZh0TOyxPRM+tmfCx/ZM+NieCR/7z0yuzvMaMLHH9kzssT0Te2zPpHEFHRPv3eqZ8LE9Ez62Z2KP7ZnYYzsmzvMaMLHH9kzssT0Te2zPpGHSMeFjeyZ8bM+Ej+2Z2GN7JvbYjonzvAZM7LE9E+/d6pl471bPpGHSMeFjeyb22J6JPbZnYo/tmdhjOybO8xowscf2TPjYngkf2zNpmHRM+NieiT22Z2KP7ZnYY3sm9tiOyT7P83rvCvZ5ntcHJnxsz4SP7Zk037EdE3tsz8Qe2zOxx/ZM7LE9E3tsx2Sf53l9YMLH9kz42J4JH9szaZh0TOyxPRN7bM/EHtsz8d6tnon3bnVM9nme1wcmfGzPxB7bM7HH9kwaJh0Te2zPxB7bM7HH9kz42J4JH9sx2ed5Xh+Y8LE9E3tsz8Qe2zNpmHRM7LE9E+/d6pl471bPhI/tmfCxHRPnefXfsc7zGjCxx/ZM7LE9k4ZJx8Qe2zPhY3smfGzPhI/tmfCxHRPneQ2Y2GN7JvbYnok9tmfSuIKOifdu9Uz42J4JH9szscf2TOyx/8zk5jyvARN7bM/EHtszscf2TBomHRM+tmfCx/ZM+NieiT22Z2KP7Zg4z2vAxB7bM/HerZ6J9271TBomHRM+tmdij+2Z2GN7JvbYnok9tmPiPK8BE3tsz4SP7ZnwsT2ThknHhI/tmdhjeyb22J6JPbZnYo/tmOzzPK/3rmCf53l9YMLH9kz42J5J8x3bMbHH9kzssT0Te2zPxB7bM7HHdkz2eZ7XByZ8bM+Ej+2Z8LE9k4ZJx8Qe2zOxx/ZM7LE9E+/d6pl471bHZJ/neX1gwsf2TOyxPRN7bM+kYdIxscf2TOyxPRN7bM+Ej+2Z8LEdk32e5/WBCR/bM7HH9kzssT2ThknHxB7bM/HerZ6J9271TPjYnok9tmPiPK8BE3tsz8Qe2zOxx/ZMGiYdE+8r6JnYY3sm9tieCR/bM7HHdkyc5zVgYo/tmdhjeyb22J5Jcy/umNhjeyb22J6JPbZnYo/tmdhjOybO8xowscf2TOyxPRN7bM+kYdIx8fcKeib+fmzPxN+P7ZnYY3smu9xj76f789r7+fBPTO77PM/rfDg/rz0fH78y6S++nE7Piy+nduwA7nLpzQS4yw05E+Au1+lMgA3AGMBdLuqZAHe51WcC3GUFyAS4y76QCXCX5SIR4D5PZMsEqIkEAWoiQYCaSBBgAzAGUBMJAtREggA1kSBATSQIUBOJAdznmXqZADWRIEBNJAhQEwkCbADGAGoiQYCaSBCgJhIEqIkEAWoiMYD7PBUxE6AmEgSoiQQBaiJBgA3AGEBNJAhQEwkC1ESCADWRIEBNJAZwn+daZgLURIIANZEgQE0kCLABGAOoiQQBaiJBgJpIEKAmEgTosNF//of5d4eNDpg4bLRnsssK8IGJlyn1TBomHRMvU+qZeJlSz8TLlHomDmnqmdhjOyb7PGz0AxN7bM/ES0F7JvbYnknDpGNij+2Z2GN7JvbYnomXgvZMvNy+Y+Kw0QETL7fvmdhjeyb22J5Jw6RjYo/tmTikqWfikKaeCR/bM+FjOyYOG+2/Yx02OmBij+2Z2GN7Jg2Tjok9tmfCx/ZM+NieCR/bM+FjOyYOGx0wscf2TOyxPRN7bM+kcQUdk13usR+Y8LE9Ez62Z2KP7ZnYY/+ZyWOfh41+YGKP7ZnYY3sm9tieScOkY8LH9kz42J4JH9szscf2TOyxHZN9HlX5gYk9tmfifQU9k13usR+YNEw6Jnxsz8Qe2zOxx/ZM7LE9E3tsx2SfBx1+YGKP7ZnwsT0TPrZn0jDpmPCxPRN7bM/EHtszscf2TOyxHZN9HpP33hXs8+S7D0z42J4JH9szab5jOyb22J6JPbZnYo/tmdhjeyb22I7JPg9Z+8CEj+2Z8LE9Ez62Z9Iw6ZjYY3sm9tieiT22Z+K9Wz0T793qmDjPa8CEj+2Z2GN7JvbYnknDpGNij+2Z2GN7JvbYngkf2zPhYzsm+zzP6wMTPrZnYo/tmdhjeyYNk46JPbZn4r1bPRPv3eqZ8LE9Ez62Y+I8r/471nleAyb22J6JPbZn0jDpmNhjeyZ8bM+Ej+2Z8LE9Ez62Y+I8rwETe2zPxB7bM7HH9kwaV9Ax8d6tngkf2zPhY3sm9tieiT22Y+I8rwETe2zPxB7bM7HH9kwaJh0TPrZnwsf2TPjYnok9tmdij/1nJseDA71GUGyyAyhevTWA4t1bAygNlB4KKzuAYp0dQLHPDqBYaAdQbLQ9FEd7jaDYaAdQyNkBFHZ2AKWB0kPhZwdQbLQDKDbaARQb7QCKjbaHss9Dvj6og32e8vUJCkc7gMLRDqA0X7Q9FBvtAIqNdgDFRjuAYqMdQLHR9lD2edzXJygc7QAKRzuAwtEOoDRQeig22gEUG+0Aio12AMXruQZQvJ+rh7LPg78+QeFoB1BstAMoNtoBlAZKD8VGO4Biox1AsdEOoHC0AygcbQ9ln0eAfYLC0Q6g2GgHUGy0AygNlB6KjXYAxQu7BlC8sWsAhaMdQOFoeygOAxt80ToNbATFRjuAYqMdQGmg9FBstAMoHO0ACkc7gMLRDqBwtD0Ux4KNoNhoB1BstAMoNtoBlEYd9FC8vWsAhaMdQOFoB1BstAMoNtoeigPCRlBstAMoNtoBFBvtAEoDpYfC0Q6gcLQDKBztAIqNdgDFRttDcVTYCIqNdgDF27sGULy9awClgdJD4WgHUGy0Ayg22gEUG+0Aio22g3J0ZtgIio12AIWjHUDhaAdQGig9FI52AMVGO4Biox1AsdEOoNhoeyj7PDPsvTo47vPMsE9QONoBFI52AKX5ou2h2GgHUGy0Ayg22gEUG+0Aio22h7LPM8M+QeFoB1A42gEUjnYApYHSQ7HRDqDYaAdQbLQDKN7eNYDi7V09lH2eGfYJCkc7gGKjHUCx0Q6gNFB6KDbaARQb7QCKjXYAhaMdQOFoeyj7PDPsExSOdgDFRjuAYqMdQGmg9FBstAMo3t41gOLtXQMoHO0ACkfbQ3Fm2OCL1plhIyg22gEUG+0ASgOlh2KjHUDhaAdQONoBFI52AIWj7aE4M2wExUY7gGKjHUCx0Q6gNOqgh+LtXQMoHO0ACkc7gGKjHUCx0fZQnBk2gmKjHUCx0Q6g2GgHUBooPRSOdgCFox1A4WgHUGy0Ayg22h6KM8NGUGy0Ayje3jWA4u1dAygNlB4KRzuAYqMdQLHRDqDYaAdQbLQ9FGeGjaDYaAdQONoBFI52AKWB0kPhaAdQbLQDKDbaARQb7QCKjbaDctrnmWHv1cFpn2eGfYLC0Q6gcLQDKM0X7f/ooNhoB1BstAMoNtoBFBvtAIqNtoeyzzPDPkHhaAdQONoBFI52AKWB0kOx0Q6g2GgHUGy0Ayje3jWA4u1dPZR9nhn2CQpHO4Biox1AsdEOoDRQeig22gEUG+0Aio12AIWjHUDhaHso+zwz7BMUjnYAxUY7gGKjHUBpoPRQbLQDKN7eNYDi7V0DKBztAApH20NxZtjgi9aZYSMoNtoBFBvtAEoDpYdiox1A4WgHUDjaARSOdgCFo+2hODNsBMVGO4Biox1AsdEOoDTqoIfi7V0DKBztAApHO4Biox1AsdH2UJwZNoJiox1AsdEOoNhoB1AaKD0UjnYAhaMdQOFoB1BstAMoNtoeijPDRlBstAMo3t41gOLtXQMoDZQeCkc7gGKjHUCx0Q6g2GgHUGy0PRRnho2g2GgHUDjaARSOdgClgdJD4WgHUGy0Ayg22gEUG+0Aio22h7LPM8M+qIN9nhn2CQpHO4DC0Q6gNF+0PRQb7QCKjXYAxUY7gGKjHUCx0XZQzvs8M+wTFI52AIWjHUDhaAdQGig9FBvtAIqNdgDFRjuA4u1dAyje3tVD2eeZYZ+gcLQDKDbaARQb7QBKA6WHYqMdQLHRDqDYaAdQONoBFI62h7LPM8M+QeFoB1BstAMoNtoBlAZKD8VGO4Di7V0DKN7eNYDC0Q6gcLQ9FGeGDb5onRk2gmKjHUCx0Q6gNFB6KDbaARSOdgCFox1A4WgHUDjaHoozw0ZQbLQDKDbaARQb7QBKow56KN7eNYDC0Q6gcLQDKDbaARQbbQ/FmWEjKDbaARQb7QCKjXYApYHSQ+FoB1A42gEUjnYAxUY7gGKj7aE4M2wExUY7gOLtXQMo3t41gNJA6aHYaAdQbLQDKDbaARQb7QCKjbaH4sywERTvOhhAsdEOoNhoB1Ca75Qeio12AMVGO4Biox1AsdEOoNhoeyj7PDPswy15n2eGfYJiox1AsdEOoDRftD0UG+0Aio12AMVGO4Biox1AsdH2UPZ5ZtgnKP7WwQCKv0c7gOLv0Q6gNFB6KLvcaO+n+/Pa+/nQQ9nlRns+nJ/Xno+PX6H0F19Op+fFl1M79gR3uf6mEtzlrpxKcJeLdSLBts9zzlIJ7nJlTyW4y/0+leAuy0AqwYZgkOAua0YqQZ0kSlAniRLUSaIEdZIgwX2eVJdKUCeJEtRJogR1kijBhmCQoE4SJaiTRAnqJFGCOkmUoE4SJLjPswZTCeokUYI6SZSgThIl2BAMEtRJogR1kihBnSRKUCeJEtRJggT3eVpkKkGdJEpQJ4kS1EmiBBuCQYI6SZSgThIlqJNECeokUYI6SZDgPs/7TCWok0QJ6iRRgjpJlGBDMEjQgaa3HooDTQdQHGg6gLLLMvAJihcx9VAcaDqC4kVMAyhexDSA4kVMAyjN3aeHYqMdQLHRDqDYaAdQvFp0AMVG20NxoOkIio12AMVGO4Biox1AaaD0ULwsfwDFy/IHULwsfwDFRjuAYqPtoTjQdATFRjuA4vinARTHPw2gNFB6KBztAIqNdgDFRjuAYqMdQLHR9lD2eaDpJyg22gEUjnYAhaMdQGmg9FA42gEUG+0Aio12AMVGO4Bio+2h7PNA0w/qYJ8Hmn6CwtEOoHC0AyjNF20PxUY7gGKjHUCx0Q6g2GgHUGy0HZTLPg8H/QSFox1A4WgHUDjaAZQGSg/FRjuAYqMdQLHRDqB418EAyi432g9Q9nm05CcoHO0Aio12AMVGO4DSQOmh2GgHUGy0Ayg22gEUjnYAhaPtoezzYMJPUDjaARQb7QCKjXYApYHSQ7HRDqB4e9cAird3DaBwtAMoHG0PZZ/H2n34ot3nSXWfoNhoB1BstAMoDZQeio12AIWjHUDhaAdQONoBFI62h7LPQ9E+QbHRDqDYaAdQbLQDKI066KF4e9cACkc7gMLRDqDYaAdQbLQ9FGeGjaDYaAdQbLQDKDbaAZQGSg+Fox1A4WgHUDjaARQb7QCKjbaH4sywERQb7QCKt3cNoHh71wBKA6WHwtEOoNhoB1BstAMoNtoBFBttD8WZYSMoNtoBFI52AIWjHUBpoPRQONoBFBvtAIqNdgDFRjuAYqPtoezzzLAP6mCfZ4Z9gsLRDqBwtAMozRdtD8VGO4Biox1AsdEOoNhoB1BstD2UfZ4Z9gkKRzuAwtEOoHC0AygNlB6KjXYAxUY7gGKjHUDx9q4BFG/v6qBc93lm2CcoHO0Aio12AMVGO4DSQOmh2GgHUGy0Ayg22gEUjnYAhaPtoezzzLBPUDjaARQb7QCKjXYApYHSQ7HRDqB4e9cAird3DaBwtAMoHG0PxZlhgy9aZ4aNoNhoB1BstAMoDZQeio12AIWjHUDhaAdQONoBFI62h+LMsBEUG+0Aio12AMVGO4DSqIMeird3DaBwtAMoHO0Aio12AMVG20NxZtgIio12AMVGO4Biox1AaaD0UDjaARSOdgCFox1AsdEOoNhoeyjODBtBsdEOoHh71wCKt3cNoDRQeigc7QCKjXYAxUY7gGKjHUCx0fZQnBk2gmKjHUDhaAdQONoBlAZKD4WjHUCx0Q6g2GgHUGy0Ayg22h7KPs8M+6AO9nlm2CcoHO0ACkc7gNJ80fZQbLQDKDbaARQb7QCKjXYAxUbbQ9nnmWGfoHC0Aygc7QAKRzuA0kDpodhoB1BstAMoNtoBFG/vGkDx9q4eyj7PDPsEhaMdQLHRDqDYaAdQGig9FBvtAIqNdgDFRjuAwtEOoHC0HZTbPs8M+wSFox1AsdEOoNhoB1AaKD0UG+0Aird3DaB4e9cACkc7gMLR9lCcGTb4onVm2AiKjXYAxUY7gNJA6aHYaAdQONoBFI52AIWjHUDhaHsozgwbQbHRDqDYaAdQbLQDKI066KF4e9cACkc7gMLRDqDYaAdQbLQ9FGeGjaDYaAdQbLQDKDbaAZQGSg+Fox1A4WgHUDjaARQb7QCKjbaH4sywERQb7QCKt3cNoHh71wBKA6WHwtEOoNhoB1BstAMoNtoBFBttD8WZYSMoNtoBFI52AIWjHUBpoPRQONoBFBvtAIqNdgDFRjuAYqPtoezzzLAP6mCfZ4Z9gsLRDqBwtAMozRdtD8VGO4Biox1AsdEOoNhoB1BstD2UfZ4Z9gkKRzuAwtEOoHC0AygNlB6KjXYAxUY7gGKjHUDx9q4BFG/v6qHs88ywT1A42gEUG+0Aio12AKWB0kOx0Q6g2GgHUGy0Aygc7QAKR9tD2eeZYZ+gcLQDKDbaARQb7QBKA6WHYqMdQPH2rgEUb+8aQOFoB1A42g7K3ZlhxwEUG+0Aio12AMVGO4DSQOmh2GgHUDjaARSOdgCFox1A4Wh7KM4MG0Gx0Q6g2GgHUGy0AyiNOuiheHvXAApHO4DC0Q6g2GgHUGy0PRRnho2g2GgHUGy0Ayg22gGUBkoPhaMdQOFoB1A42gEUG+0Aio22h+LMsBEUG+0Aird3DaB4e9cASgOlh8LRDqDYaAdQbLQDKDbaARQbbQ/FmWEjKDbaARSOdgCFox1AaaD0UDjaARQb7QCKjXYAxUY7gGKj7aHs88ywD+pgn2eGfYLC0Q6gcLQDKM0XbQ/FRjuAYqMdQLHRDqDYaAdQbLQ9lH2eGfYJCkc7gMLRDqBwtAMoDZQeio12AMVGO4Biox1A8fauARRv7+qh7PPMsE9QONoBFBvtAIqNdgClgdJDsdEOoNhoB1BstAMoHO0ACkfbQ9nnmWGfoHC0Ayg22gEUG+0ASgOlh2KjHUDx9q4BFG/vGkDhaAdQONoeijPDBl+0zgwbQbHRDqDYaAdQGig9FBvtAApHO4DC0Q6gcLQDKBxtB+XhzLARFBvtAIqNdgDFRjuA0qiDHoq3dw2gcLQDKBztAIqNdgDFRttDcWbYCIqNdgDFRjuAYqMdQGmg9FA42gEUjnYAhaMdQLHRDqDYaHsozgwbQbHRDqB4e9cAird3DaA0UHooHO0Aio12AMVGO4Biox1AsdH2UJwZNoJiox1A4WgHUDjaAZQGSg+Fox1AsdEOoNhoB1BstAMoNtoeyj7PDPugDvZ5ZtgnKBztAApHO4DSfNH2UGy0Ayg22gEUG+0Aio12AMVG20PZ55lhn6BwtAMoHO0ACkc7gNJA6aHYaAdQbLQDKDbaARRv7xpA8fauHso+zwz7BMVGO4Biox1AsdEOoDRQeig22gEUG+0AincdDKDYaAdQbLQ9lH2eGfbhO2WfZ4Z9gmKjHUCx0Q6gNFB6KDbaARRv7xpAsdEOoNhoB1BstD0UZ4YNvmidGTaCYqMdQLHRDqA0UHooNtoBFI52AMXfOhhA8fdoB1D8PdoeijPDRlB2udHeT/fntffzoYdSeaM9/vwUp9Onq2+P58e4//jlvq4df+TT16icT8fDP1z9J5bKO+1fh+V8Oz8/czscPlzdDqfnj26H2y+j9fg7w4bhR4bH8+PJ8Pg49gwrb8x/HcMfLL4YtvaJYbt/6Z3L8efnOLXRj761408ct18v/hN45W18k8Dv18vzR99HwCtv+ksCr9wilgReuaGsB/x0KH2+3JLAKzerJYHvs7V9I/B99sFvBN4Anwt8mab5OD8/xuN6+oTw8YRyab929ZFKu7Sva381dMf7b9fMH7SXqZklaH+a7WU65iZoL1MwN0F7mXa5BdqlD3pcj/YyvXITtJcplZugvUyj3ATthvZE2rrkB9rXw/Xv117Plw+079fntff78Zefe/07bFUyEfbj6+/hPH79Y/AD9uAznA/PR/3tfHz8/GMwuvjy4/d/fuJTO/568Z8x6qhLxKj8LhGjVr1CjKVPsRXjvxwjD7BEjATDEjEyF0vE2MS4QoxcyxIxsjhLxMjiLBEji7NEjCzOCjGWPrldjP9yjCzOEjGyOEvEyOIsEWMT4woxsjhLxMjiLBEji7NEjCzOEjGyOCvE2FicJWJkcZaIkcVZIkYWZ4kYmxhXiJHFWSJGFmeJGFmcJWJkcZaIkcVZIcYLi7NEjCzOEjGyOEvEyOIsEWMT4woxsjhLxMjiLBEji7NEjCzOEjGyOCvEeGVxloiRxVkiRhZniRhZnCVibGJcIUYWZ4kYWZzvivF6+Tpd6nq99ckQM1WT4VqqJkOfFE3mxoh8VzK3w5NFux0HyZAcVZPhLaomQ0VUTaZJpmgyhEHV3YwDqJoMB1A1GQ6gajIcQNEN4M4BVE2GA6iaDAdQNRkOoGoyTTJFk+EAqibDAVRNhgOomgwHUDUZDqBoMg8OoGoyHEDVZDiAqslwAN+VzIenAI8mmaLJcABVk+EAqibDAVTdADiAqslwADWTOR44gKrJcABVk+EAqibDAVRNpkmmaDIcQNVkOICqyXAAVZPhAKomwwEUTebIAVRNhgP4rmTePwU4HjmAqslwAFWTaZIpmgwHUHUD4ACqJsMBVE2GA6iaDAdQNJkTB1A1GQ6gajIcQNVkOICqyTTJFE2GA6iaDAdQNRkOoGoyHEDVZDiA70rmw1OAMwdQNRkOoGoyHEDVZDiAohvAuUmmaDIcQNVkOICqyXAAVZPhAKomwwEUTaZxAFWT4QCqJsMBVE2GA6iaTJNM0WQ4gKrJcABVk+EAviuZD08BGgdQNRkOoGgyFw6gajIcQNEN4MIBVE2GA6iaTJNM0WQ4gKrJcABVk+EAqibDAVRNhgMomsyVA6iaDAdQNRkOoGoyHEDVZJpkiibDAXxXMh+eAlw5gKrJcABVk+EAqibDARTdAG4cQNVkOICqyXAAVZPhAKom0yRTNBkOoGoyHEDVZDiAqslwAFWT4QCKJnPnAKomwwFUTYYDqJoMB/BdyXx4CnBvkimaDAdQNRkOoGoyHEDVDYADqJoMB1A0mQcHUDUZDqBqMhxA1WQ4gKrJNMkUTYYDqJoMB1A1GQ6gajIcQNVkOICayZwOHEDVZDiA70rm/VOA04EDqJoMB1A1mSaZoslwAFU3AA6gajIcQNVkOICqyXAARZM5cgBVk+EAqibDAVRNhgOomkyTTNFkOICqyXAAVZPhAKomwwFUTYYD+K5kPjwFOHEAVZPhAKomwwFUTYYDKLoBnJpkiibDAVRNhgOomgwHUDUZDqBqMhxA0WTOHEDVZDiAqslwAFWT4QCqJtMkUzQZDqBqMhxA1WQ4gO9K5sNTgDMHUDUZDqBoMo0DqJoMB1B0A2gcQNVkOICqyTTJFE2GA6iaDAdQNRkOoGoyHEDVZDiAoslcOICqyXAA/6NoMhxA1WQ4gKrJNMkUTYYD+K5kPjwFuHAAVZPhAKomwwFUTYYDKLoBXDmAqslwAFWT4QCqJsMBVE2mSaZoMhxA1WQ4gKrJcABVk+EAqibDARRN5sYBVE2GA6iaDAdQNRkO4LuS+fAU4NYkUzQZDqBqMhxA1WQ4gKobAAdQNRkOoGgydw6gajIcQNVkOICqyXAAVZNpkimaDAdQNRkOoGoyHEDVZDiAqslwAEWTeXAAVZPhAL4rmQ9PAR4cQNVkOICqyTTJFE2GA6i6AXAAVZPhAKomwwFUTYYDqJnM+cABVE2GA6iaDAdQNRkOoGoyTTJFk+EAqibDAVRNhgOomgwHUDUZDuC7knn/FOB85ACqJsMBVE2GA6iaDAdQdAM4NskUTYYDqJoMB1A1GQ6gajIcQNVkOICiyZw4gKrJcABVk+EAqibDAVRNpkmmaDIcQNVkOICqyXAA35XMh6cAJw6gajIcQNFkzhxA1WQ4gKIbwJkDqJoMB1A1mSaZoslwAFWT4QCqJsMBVE2GA6iaDAdQNJnGAVRNhgOomgwHUDUZDqBqMk0yRZPhAL4rmQ9PARoHUDUZDqBqMhxA1WQ4gKIbwIUDqJoMB1A1GQ6gajIcQNVkmmSKJsMBVE2GA6iaDAdQNRkOoGoyHEDRZK4cQNVkOICqyXAAVZPhAL4rmQ9PAa5NMkWT4QCqJsMBVE2GA6i6AXAAVZPhAIomc+MAqibDAVRNhgOomgwHUDWZJpmiyXAAVZPhAKomwwFUTYYDqJoMB1A0mTsHUDUZDuC7kvnwFODOAVRNhgOomkyTTNFkOICqGwAHUDUZDqBqMhxA1WQ4gKLJPDiAqslwAFWT4QCqJsMBVE2mSaZoMhxA1WQ4gKrJcABVk+EAqibDAXxXMu+fArQDB1A1GQ6gajIcQNVkOICaG0A7NMkUTYYDqJoMB1A1GQ6gajIcQNVkOICiyRw5gKrJcABVk+EAqibDAVRNpkmmaDIcQNVkOICqyXAA35XMh6cARw6gajIcQNFkThxA1WQ4gKIbwIkDqJoMB1A1mSaZoslwAFWT4QCqJsMBVE2GA6iaDAdQNJkzB1A1GQ6gajIcQNVkOICqyTTJFE2GA/iuZD48BThzAFWT4QCqJsMBVE2GAyi6ATQOoGoyHEDVZDiAqslwAFWTaZIpmgwHUDUZDqBqMhxA1WQ4gKrJcABFk7lwAFWT4QCqJsMBVE2GA/iuZD48Bbg0yRRNhgOomgwHUDUZDqDqBsABVE2GAyiazJUDqJoMB1A1GQ6gajIcQNVkmmSKJsMBVE2GA6iaDAdQNRkOoGoyHEDRZG4cQNVkOIDvSubDU4AbB1A1GQ6gajJNMkWT4QCqbgAcQNVkOICqyXAAVZPhAIomc+cAqibDAVRNhgOomgwHUDWZJpmiyXAAVZPhAKomwwFUTYYDqJoMB/BdyXx4CvDgAKomwwFUTYYDqJoMB1B0A3g0yRRNhgOomgwHUDUZDqBqMhxA1WQ4gJrJXA4cQNVkOICqyXAAVZPhAKom0yRTNBkOoGoyHEDVZDiA70rm/VOAy4EDqJoMB1A0mSMHUDUZDqDoBnDkAKomwwFUTaZJpmgyHEDVZDiAqslwAFWT4QCqJsMBFE3mxAFUTYYDqJoMB1A1GQ6gajJNMkWT4QC+K5kPTwFOHEDVZDiAqslwAFWT4QCKbgBnDqBqMhxA1WQ4gKrJcABVk2mSKZoMB1A1GQ6gajIcQNVkOICqyXAARZNpHEDVZDiAqslwAFWT4QC+K5kPTwFak0zRZDiAqslwAFWT4QCqbgAcQNVkOICiyVw4gKrJcABVk+EAqibDAVRNpkmmaDIcQNVkOICqyXAAVZPhAKomwwEUTebKAVRNhgP4rmQ+PAW4cgBVk+EAqibTJFM0GQ6g6gbAAVRNhgOomgwHUDUZDqBoMjcOoGoyHEDVZDiAqslwAFWTaZIpmgwHUDUZDqBqMhxA1WQ4gKrJcADflcyHpwB3DqBqMhxA1WQ4gKL3mTsHUDWZJpmiyXAAVZPhAKomwwFUTYYDqLo1cwBFk3lwAFWT4QCK3mceHEDVZDiAqsk0yRRNhgOomgwHUDUZDqDq1swBVE2GA6iZzPXAAVRNhgOouQFcDxxA1WQ4gKrJNMkUTYYDqJoMB1A1GQ6gajIcQNVkOICiyRw5gKrJcABVk+EAviuZ++n+TOZ+PvTJcACJyRzb+Wkpj+1y/ZDN9Xw6fv3o1n7NZkT5+gzyB/CfP/p0GV18Pj6eF59Pl18v/jP1JvUdps5d7DF1XmSPqXMuK6be2pPzuV3ufep8zh5T54qWTP32lUl7nN5ffHrcv37y4XD4cHG7PNGd2u3+/uLL4Qvz+djVxxMZZvS+afTYPqP3W6P3eP7k0+V0CI0enWn0vmn0+Fqj9zujdzs/cZxut8uHiw/t+QueDtcWmtNmTs3pBuaUEzenf92c3p6S9nQ8nEJzyuKb0y3MqecOe5/T8+HUvub0/OEnn873rzlth/OvF/85T55omKffmadEweixitH7ntE7e6xi9L5p9DxWMXq/NXppbvvssYrR+6bR81jF6P3O6F2/xulvt8yutp6beTJPifPkMYV5ypwnjxPMU+Y80f7m6Xfm6XceTx3vX3EfH8f+GcHZMwLD923D5ymB4furhi/xLzo1jxTM6Rbm1PMHc7qFOfWwwpz+dXOa9hfymicb5nQLc9rM6d7n9Pj1Frnz8Rzs5c0TE/OUOU+emJin35inzKrh4YrR+6bR82jF6H3T6HmwYvR+a/TSuujFsxKj902j5/HHiqN3uZyfF1+uH/59zu/9O+8P/3724jGFefqeF/RdPHkwet80es3oGb3vGT3PHYze97wb8uIRhdH7ptHziMLo/c7offj3RBfPHcxT5jx5mGCeEufp6gmBecqcJ9rfPP1Vr3f99Ffbrp4RGL5vGz5PCQzfBg4KuDZzak43MKeeP5jTLcyphxXmdAMHWlw92TCnW5hTT0z2Pqff9cr4q4crRu97Ru/mOYzR+55Xxt88sjF63zR6HtgYvQ28I+3m2Y453cKcNnNqTuu/I+3m2Y453cKceraz+znNfPfazTMY85Q5T56VmKfveavVzbMSo/c9o3f3rMTofdPoeVZi9L7nhWp3z0qM3jeNnscfmaN3/4J9vJ+O/zB6f+JucM/ETUZPxc2pTsVNOf5VuI9tgJuRm4qbhZqJ+8G8TMXNNkzFrWFPxa1VzlwEHw3umbi1yqm4tcqpuLXKqbi1yqm4tcqJuG8HrXIqbq1yKm6tcipurXIq7gZ3Iu43fyvhT9xa5VTcWuVU3FrlVNxa5VTcWuUH3Lf2/Mj34+ED7uvh+bfbrqefDxfOx+OfsI865UTYGuVE2PrkRNja5ETYDex5sDXJibD1yImwtciJsHXIibA1yHmwTxrkRNga5ETYGuRE2BrkRNgN7HmwNciJsDXIibA1yImwNciJsDXIebDPGuRE2BrkRNga5ETYGuRE2A3sebA1yImwNciJsDXIibA1yImwNch5sJsGORG2BjkRtgY5EbYGORF2A3sebA1yImwNciJsDXIibA1yImwNch7siwY5EbYGORG2BjkRtgY5EXYDex5sDXIibA1yImwNciJsDXIibA1yHuyrBjkRtgY5EbYGORG2BjkRdgN7HmwNciJsDXIibA1yImwN8gPs++N5VPbj49tYT9fnzz39guJ8GX6EJ4nL8fbh0sP1+ULYdjxef734zwwV081neNN3t5+hGr39DLXz7Weo9G8/wybDzWdIUWw/Q+Zj+xkSKtvPkKfZfoY8zeYzvPM028+Qp9l+hjzN9jPkabafYZPh5jPkabafIU+z/Qx5mu1nyNNsP0OeZvMZPnia7WfI02w/Q55m+xnyNNvPsMlw8xnyNNvPkKfZfoY8zfYz5Gm2nyFPs/UM7weeZvsZ8jTbz5Cn2X6GPM32M2wy3HyGPM32M+Rptp8hT7P9DHma7WfI02w+wyNPs/0MeZrtZ8jTbD9Dnmb7GTYZbj5Dnmb7GfI028+Qp9l+hjzN9jPkaTaf4Ymn2X6GPM32M+Rptp8hT7P9DJsMN58hT7P9DHma7WfI02w/Q55m+xnyNJvP8MzTbD9Dnmb7GfI028+Qp6mf4en+/LHt3E7vLz4dj8/Pezq21gfeBL6vwBmgnQVOF+0scG5pZ4ETUTsLnLXaV+CN4tpZ4HzYzgInz3YWONO2s8CbwPcVONO2s8CZtp0FzrTtLHCmbWeBM237CvzCtO0scKZtZ4EzbTsLnGnbWeBN4PsKnGnbWeBM284CZ9p2FjjTtrPAmbZ9BX5l2nYWONO2s8CZtp0FzrTtLPAm8H0FzrTtLHCmrXzgl9P9+atdzqdLnyF5tv0M+bDtZ0hxbT7DG2u1/QyJqO1nyC1tP0O6aPsZNhluPkNSZ/sZ8jTbz5Cn2X6GPM32M+RpNp/hnafZfoY8zfYz5Gm2nyFPs/0Mmww3nyFPs/0MeZrtZ8jTbD9Dnmb7GfI0m8/wwdNsP0OeZvsZ8jTbz5Cn2X6GTYabz5Cn2X6GPM32M+Rptp8hT7P9DHmarWf4OPA028+Qp9l+hjzN9jPkabafYZPh5jPkabafIU+z/Qx5mu1nyNNsP0OeZvMZHnma7WfI02w/Q55m+xnyNNvPsMlw8xnyNNvPkKfZfoY8zfYz5Gm2nyFPs/kMTzzN9jPkabafIU+z/Qx5mu1n2GS4+Qx5mu1nyNNsP0OeZvsZ8jTbz5Cn2XyGZ56mfoaX29e1l79x/ecMeZrtZ8jTbD9Dnmb7GTYZbj5Dnmb7GfI028+Qp9l+hjzN9jPkaTafYeNptp8hT7P9DHma7WfI02w/wybDzWfI02w/Q55m+xnyNNvPkKfZfoY8zeYzvPA028+Qp9l+hjzN9jPkabafYZPh5jPkabafIU+z/Qx5mu1nyNNsP0OeZvMZXnma7WfI02w/Q55m+xnyNNvPsMlw8xnyNNvPkKfZfoY8zfYz5Gm2nyFPs/kMbzzN9jPkabafIU+z/Qx5mu1n2GS4+Qx5mu1nyNNsP0OeZvsZ8jTbz5Cn2XyGd55m+xnyNNvPkKfZfoY8zfYzbDLcfIY8zfYz5Gm2nyFPs/0MeZrtZ8jTbD7DB0+z/Qx5mu1nyNNsP0OeZvsZNhlWz/B6ase/X3s9H859hjzN9jPkabafIU+z/Qx5mu1nyNNsPMPz4cDTbD9Dnmb7GfI028+Qp9l+hk2Gm8+Qp9l+hjzN9jPkabafIU+z/Qx5ms1neORptp8hT7P9DHma7WfI02w/wybDzWfI02w/Q55m+xnyNNvPkKfZfoY8zeYzPPE028+Qp9l+hjzN9jPkabafYZPh5jPkabafIU+z/Qx5mu1nyNNsP0OeZvMZnnma7WfI02w/Q55m+xnyNNvPsMlw8xnyNPUz/HHFM8NLa32GPM32M+Rptp8hT7P9DHmazWfYeJrtZ8jTbD9Dnmb7GfI028+wyXDzGfI028+Qp9l+hjzN9jPkabafIU+z+QwvPM32M+Rptp8hT7P9DHma7WfYZLj5DHma7WfI02w/Q55m+xnyNNvPkKfZfIZXnmb7GfI028+Qp9l+hjzN9jNsMtx8hjzN9jPkabafIU+z/Qx5mu1nyNNsPsMbT7P9DHma7WfI02w/Q55m+xk2GW4+Q55m+xnyNNvPkKfZfoY8zfYz5Gk2n+Gdp9l+hjzN9jPkabafIU+z/QybDDefIU+z/Qx5mu1nyNNsP0OeZvsZ8jSbz/DB02w/Q56mfob32/PHXh+Ha58hT7P9DHma7WfYZFg+w8fp8JXh5fD+4vv5/PzB9/Pl+uHi9mR2v/bnSD34H7PxajZ4JbPxajb4KrPxajZ4MLPxajb4NbMxno3jgbczG69mgw80G69mg2c0G69mg780G69mo5kNs/FiNnhRs/FqNnhRs/FqNnhRs/FqNnhRs/FqNnhRs/FiNo68qNl4NRu8qNl4NRu8qNl4NRu8qNl4NRvNbJiNF7PBi5qNV7PBi5qNV7PBi5qNV7PBi5qNV7PBi5qNF7Nx4kXNxqvZ4EXNxqvZ4EXNxqvZ4EXNxqvZaGbDbLyYDV7UbLyaDV7UbLyaDV7UbLyaDV7UbLyaDV7UbLyYjTMvajZezQYvajZezQYvajZezQYvajZezUYzG2bjxWzwombj1Wzwombj1Wzwombj1Wzwombj1WzwombjxWw0XtRsvJoNXtRsvJoNXtRsvJoNXtRsvJqNZjbMxovZ4EXNxqvZ4EXNxqvZ4EXNxqvZ4EXNxqvZ4EXNxovZuPCiZuPVbPCiZuPVbPCiZuPVbPCiZuPVbDSzYTZezAYvajZezQYvajZezQYvajZezQYvajZezQYvajZezMaVFzUbr2aDFzUbr2aDFzUbr2aDFzUbr2ajmQ2z8WI2eFGz8Wo2eFGz8Wo2eFGz8Wo2eFGz8Wo2eFGz8WI2bryo2Xg1G7yo2Xg1G7yo2Xg1G7yo2Xg1G81smI0Xs8GLmo1Xs8GLmo1Xs8GLmo1Xs8GLmo1Xs8GLmo0Xs3HnRc3Gq9ngRc3Gq9ngRc3Gq9ngRc3Gq9loZsNsvJgNXtRsvJoNXtRsvJoNXtRsvJoNXtRsvJoNXtRsvJiNBy9qNl7NBi9qNl7NBi9qNl7NBi9qNl7NRjMbZuPFbPCiZuPVbPCiZuPVbPCiZuPVbPCiZuPVbPCiZmM8G6cDL2o2Xs0GL2o2Xs0GL2o2Xs0GL7rabBzPX7NxbX3gTeD7CpzB3FngtOTOAucadxY4gbizwFnBfQV+pPp2Fjh/t7PASbmdBc60LRZ4u3yZ1R//jfcXnx63+/MDPx4/p+N0HVx8OXyN0uVwPv568Z+j1IySUcoZJXbQKCWNEu9olJJGidE0SkmjxJUapaRRYmGNUs4onfhdo5Q0SsyxUUoaJU7aKCWNEtttlJJGqRklo5QzSmy3UUoaJbbbKCWNEtttlJJGie02SkmjxHYbpZxROrPdRilplNhuo5Q0Smy3UUoaJbbbKCWNUjNKRilnlNhuo5Q0Smy3UUoaJbbbKCWNEtttlJJGie02Sjmj1Nhuo5Q0Smy3UUoaJbbbKCWNEtttlJJGqRklo5QzSmy3UUoaJbbbKCWNEtttlJJGie02SkmjxHYbpZxRurDdRilplNhuo5Q0Smy3UUoaJbbbKCWNUjNKRilnlNhuo5Q0Smy3UUoaJbbbKCWNEtttlJJGie02SjmjdGW7jVLSKLHdRilplNhuo5Q0Smy3UUoapWaUjFLOKLHdRilplNhuo5Q0Smy3UUoaJbbbKCWN0i5t9+3y/MG3++XDKLXz4UmwnY+PD7h/fM4n7lPrcd92aYS/D/curen34d6lWfw+3Lu0b9+Hu8E9E/cuLc734d6l6fg+3Lu0Ad+He5eN+ftwa5Uzcd+1yqm4tcqpuLXKqbi1yqm4G9wzcWuVU3FrlVNxa5VTcWuVU3FrlTNxP7TKqbi1yqm4tcqpuLXKqbgb3DNxa5VTcWuVU3FrlVNxa5VTcWuVE3GfD1rlVNxa5VTcWuVU3FrlVNwN7pm4tcqpuLXKqbi1yqm4tcqpuLXKmbiPWuVU3FrlVNxa5VTcWuVU3A3umbi1yqm4tcqpuLXKqbi1yk+4r5fjE/f1eusJKopBgifdL0pQnYsS1NA+Ebwdnp+53Y4DgkpXlGBDMEhQNYoS1HaiBBWY6L1YJ4kS1EmCBM86SZSgThK8k5x1kihBnSRKsCEYJKiTRAnqJFGCOkmUoE4SJaiTBAk2nSRKUCeJEtRJogR1kijBhmCQoE4StFtNJ4kS1EmiBHWSKEGdJHgnuegkUYI6SZSgThIlqJNECTYEgwR1kihBnSRKUCeJEtRJogR1kiDBq04SJaiTRAnqJFGCOknQbl0bgkGCOkmUoE4SJaiTRO8kOkmUoE4SJHjTSaIEdZIoQZ0kSlAniRJsCAYJ6iRRgjpJlKBOEiWok0QJ6iRBgnedJEpQJwnarbtOEiWok0QJNgSDBHWS6J1EJ4kS1EmiBHWSKEGdJEjwoZNECeokUYI6SZSgThIl2BAMEtRJogR1kihBnSRKUCeJEtRJYnarHXSSKEGdJEpQJ4kS1Elid5J2aAgGCeokUYI6SZSgThIlqJNECeokQYJHnSRKUCeJEtRJogR1kijBhmCQoE4SJaiTRAnqJEG75Rz3MEGdJEjQOe5hgjpJ8E7iHPcwQZ0kSrAhGCSok0QJ6iRRgjpJlKBOEiWokwQJOsc9TFAniRLUSaIEdZIowYZgkKBOErRbznEPE9RJogR1kihBnSR4J3GOe5igThIlqJNECeokUYINwSBBnSRKUCeJEtRJogR1kihBnSRI0DnuYYI6SZSgThIlqJME7ZZz3MMEdZIoQZ0kSlAnid5JdJIoQZ0kSNA57mGCOkmUoE4SJaiTRAk2BIMEdZIoQZ0kSlAniRLUSaIEdZIgQee4hwnqJEG75Rz3MEGdJEqwIRgkqJNE7yQ6SZSgThIlqJNECeokQYLOcQ8T1EmiBHWSKEGdJEqwIRgkqJNECeokUYI6SZSgThIlqJME7ZZz3MMEdZIoQZ0kSlAnCd5JnOMeJqiTRAnqJFGCOkmUoE4SJaiTxAhenOMeJqiTRAnqJFGCOkmUYEMwSFAniRLUSaIEdZKY3bo4xz1MUCcJEnSOe5igThK8kzjHPUxQJ4kSbAgGCeokUYI6SZSgThIlqJNECeokQYLOcQ8T1EmiBHWSKEGdJEqwIRgkqJME7ZZz3MMEdZIoQZ0kSlAnCd5JnOMeJqiTRAnqJFGCOkmUYEMwSFAniRLUSaIEdZIoQZ0kSlAnCRJ0jnuYoE4SJaiTRAnqJEG75Rz3MEGdJEpQJ4kS1EmidxKdJEpQJwkSdI57mKBOEiWok0QJ6iRRgg3BIEGdJEpQJ4kS1EmiBHWSKEGdJEjQOe5hgjpJ0G45xz1MUCeJEmwIBgnqJNE7iU4SJaiTRAnqJFGCOkmQoHPcwwR1kihBnSRKUCeJEmwIBgnqJFGCOkmUoE4SJaiTRAnqJEG75Rz3MEGdJEpQJ4kS1EmCdxLnuIcJ6iRRgjpJlKBOEiWok0QJ6iRBgs5xDxPUSaIEdZIoQZ0kSrAhGCSok0QJ6iRRgjpJ0G45xz1MUCeJEbw6xz1MUCeJ3UmuznEPE9RJogQbgkGCOkmUoE4SJaiTRAnqJFGCOkmQoHPcwwR1kihBnSRKUCeJEmwIBgnqJEG75Rz3MEGdJEpQJ4kS1EmCdxLnuIcJ6iRRgjpJlKBOEiXYEAwS1EmiBHWSKEGdJEpQJ4kS1EmCBJ3jHiaok0QJ6iRRgjpJ0G45xz1MUCeJEtRJogR1kuidRCeJEtRJggSd4x4mqJNECeokUYI6SZRgQzBIUCeJEtRJogR1kihBnSRKUCcJEnSOe5igThK0W85xDxPUSaIEG4JBgjpJ9E6ik0QJ6iRRgjpJlKBOEiToHPcwQZ0kSlAniRLUSaIEG4JBgjpJlKBOEiWok0QJ6iRRgjpJ0G45xz1MUCeJEtRJogR1kuCdxDnuYYI6SZSgThIlqJNECeokUYI6SZCgc9zDBHWSKEGdJEpQJ4kSbAgGCeokUYI6SZSgThK0W85xDxPUSYIEneMeJqiTBO8kznEPE9RJogQbgkGCOkmUoE4SJaiTRAnqJFGCOkmM4M057mGCOkmUoE4SJaiTRAk2BIMEdZKY3bo5xz1MUCeJEtRJogR1kuCdxDnuYYI6SZSgThIlqJNECTYEgwR1kihBnSRKUCeJEtRJogR1kiBB57iHCeokUYI6SZSgThK0W85xDxPUSaIEdZIoQZ0keifRSaIEdZIgQee4hwnqJFGCOkmUoE4SJdgQDBLUSaIEdZIoQZ0kSlAniRLUSYIEneMeJqiTBO2Wc9zDBHWSKMGGYJCgThK9k+gkUYI6SZSgThIlqJMECTrHPUxQJ4kS1EmiBHWSKMGGYJCgThIlqJNECeokUYI6SZSgThK0W85xDxPUSaIEdZIoQZ0keCdxjnuYoE4SJaiTRAnqJFGCOkmUoE4SJOgc9zBBnSRKUCeJEtRJogQbgkGCOkmUoE4SJaiTBO2Wc9zDBHWSIEHnuIcJ6iTBO4lz3MMEdZIowYZgkKBOEiWok0QJ6iRRgjpJlKBOEiToHPcwQZ0kSlAniRLUSaIEG4JBgjpJ0G45xz1MUCeJEtRJogR1ktid5O4c9zBBnSRKUCeJEtRJogQbgkGCOkmUoE4SJaiTRAnqJFGCOkmQoHPcwwR1kihBnSRKUCeJ2a27c9zDBHWSKEGdJEpQJ4neSXSSKEGdJEjQOe5hgjpJlKBOEiWok0QJNgSDBHWSKEGdJEpQJ4kS1EmiBHWSIEHnuIcJ6iRBu+Uc9zBBnSRKsCEY/B7USaIEdZIoQZ0kSlAniRLUSYIEneMe3Wac4x4mqJNECeok0e/BhmCQoE4SJaiTRAnqJFGCOkmUoE4S3Gac4x4mqJNECeokUYI6SfBO4hz3MEGdJEpQJ4kS1EmiBHWSKEGdJEjQOe5hgjpJlKBOEiWok0QJNgQ/ELyf7k+C9/OhJ7jPTvJ4Xns/H/+B4J9QlqkZx8Pp8rz6cDl8wNIez4sv7fBhsC7t69r7L9ce7yMYt3b8SeOXP8bt77yXKSVFeP/4Y/2kcR/xXqbCbIT3MoVnG7zXOVJ+I7yXKVMb4b1M9doI72WK2kZ4N7yn8l6mBG6Et375kff1cP37tdfz5QPvH4X9Wefvv9b5vzuOm3qZivtxbU/T8usfhR+4B5/hfDg//dP5+PjVPw3+jP0g8PzEp3bsZNVNb10kSIV4jSDvmvYiQarwiwTJDSwSJOmwSJBNkGsESZMsEiT/skiQzM4iQTI7iwTJ7KwR5IPZWSRIZmeRIJmdRYJkdhYJsglyjSCZnUWCZHYWCZLZWSRIZmeRIJmdJYJ8HJidRYJkdhYJktlZJEhmZ5EgmyDXCJLZWSRIZmeRIJmdRYJkdhYJktlZI8gjs7NIkMzOIkEyO4sEyewsEmQT5BpBMjuLBMnsLBIks7NIkMzOIkEyO2sEeWJ2FgmS2VkkSGZnkSCZnUWCbIJcI0hmZ5EgmZ1FgmR2vi/I9ydbP05kTd1s+Jey2ZwplbrZsCTfl837MzcfZ+KjbjZcRt1smmzKZsM41M2GRKi7p/ECdbPhBepmwwuUzabxAmV3gcYL1M2GF6ibDS9QN5smm7LZ8AJ1s+EF6mbDC9TNhheomw0vUDabCy9QNxteoG42vEDdbHiButk02VR9RnDhBepmwwvUzYYXqJsNL1B3F+AFymZz5QXqZsML1M2GF6ibDS9QN5smm7LZ8AJ1s+EF6mbDC9TNhheomw0vUDabGy9QNxteoG42vEDZZwQ3XqBuNk02ZbPhBepmwwvU3QV4gbrZ8AJ1s+EFymZz5wXqZsML1M2GF6ibDS9QN5smm7LZ8AJ1s+EF6mbDC9TNhheomw0vUDabBy9Q9hnBgxeomw0vUDcbXqBuNk02ZXcBXqBuNrxA3Wx4gbrZ8AJ1s+EFimbTDgdeoG42vEDdbHiButnwAnWzabIpmw0vUDcbXqBuNrxA3Wx4gaLPCH5kwwuUzebIC9TNhheomw0vUHYXOPICdbNpsimbDS9QNxteoG42vEDdbHiButnwAmWzOfECdbPhBepmwwvUzYYXqJtNk03ZbHiButnwAmWfEZx4gbrZ8AJ1s+EFymZz5gXK7gJnXqBuNrxA3Wx4gbrZNNmUzYYXqJsNL1A3G16gbja8QN1seIGy2TReoG42vEDdbHiButnwAnWzabKp+oyg8QJ1s+EF6mbDC9TNhheouwvwAmWzufACdbPhBepmwwvUzYYXqJtNk03ZbHiButnwAnWz4QXqZsML1M2GFyibzZUXqJsNL1A3G16g7DOCKy9QN5smm7LZ8AJ1s+EF6u4CvEDdbHiButnwAmWzufECdbPhBepmwwvUzYYXqJtNk03ZbHiButnwAnWz4QXqZsML1M2GFyibzZ0XKPuM4M4L1M2GF6ibDS9QN5smm7K7AC9QNxteoG42vEDdbHiButnwAmWzefACdbPhBepmwwvUzYYXqJtNk03ZbHiButnwAnWz4QXqZsMLlH1G8OAFqmZzPPACdbPhBepmwwtU3QWOB16gbjZNNmWz4QXqZsML1M2GF6ibDS9QNxteoGw2R16gbja8QN1seIG62fACdbNpsimbDS9QNxteoOwzgiMvUDcbXqBuNrxA2WxOvEDZXeDEC9TNhheomw0vUDebJpuy2fACdbPhBepmwwvUzYYXqJsNL1A2mzMvUDcbXqBuNrxA3Wx4gbrZNNlUfUZw5gXqZsML1M2GF6ibDS9QdxfgBcpm03iButnwAnWz4QXqZsML1M2myaZsNrxA3Wx4gbrZ8AJ1s+EF6mbDC5TN5sIL1M2GF6ibDS9Q9hnBhReom02TTdlseIG62fACdXcBXqBuNrxA3Wx4gbLZXHmButnwAnWz4QXqZsML1M2myaZsNrxA3Wx4gbrZ8AJ1s+EF6mbDC5TN5sYLlH1GcOMF6mbDC9TNhheom02TTdldgBeomw0vUDcbXqBuNrxA3Wx4gbLZ3HmButnwAnWz4QXqZsML1M2myaZsNrxA3Wx4gbrZ8AJ1s+EFyj4juPMCZbN58AJ1s+EF6mbDC5TdBR68QN1smmzKZsML1M2GF6ibDS9QNxteoG42vEDVbE4HXqBuNrxA3Wx4gbrZ8AJ1s2myKZsNL1A3G16g6jOC04EXqJsNL1A3G16gbDZHXqDsLnDkBepmwwvUzYYXqJtNk03ZbHiButnwAnWz4QXqZsML1M2GFyibzYkXqJsNL1A3G16gbja8QN1smmyqPiM48QJ1s+EF6mbDC9TNhheouwvwAmWzOfMCdbPhBepmwwvUzYYXqJtNk03ZbHiButnwAnWz4QXqZsML1M2GFyibTeMF6mbDC9TNhhco+4yg8QJ1s2myKZsNL1A3G16g7i7AC9TNhheomw0vUDabCy9QNxteoG42vEDdbHiButk02ZTNhheomw0vUDcbXqBuNrxA3Wx4gbLZXHmBss8IrrxA3Wx4gbrZ8AJ1s2myKbsL8AJ1s+EF6mbDC9TNhheomw0vUDabGy9QNxteoG42vEDdbHiButk02ZTNhheomw0vUDcbXqBuNrxA2WcEN16gbDZ3XqBuNrxA3Wx4gbK7wJ0XqJtNk03ZbHiButnwAnWz4QXqZsML1M2GFyibzYMXqJsNL1A3G16gbja8QN1smmzKZsML1M2GFyj7jODBC9TNhheomw0vUDWb84EXqLoLnA+8QN1seIG62fACdbNpsimbDS9QNxteoG42vEDdbHiButnwAmWzOfICdbPhBepmwwvUzYYXqJtNk03VZwRHXqBuNrxA3Wx4gbrZ8AJ1dwFeoGw2J16gbja8QN1seIG62fACdbNpsimbDS9QNxteoG42vEDdbHiButnwAmWzOfMCdbPhBepmwwuUfUZw5gXqZtNkUzYbXqBuNrxA3V2AF6ibDS9QNxteoGw2jReomw0vUDcbXqBuNrxA3WyabMpmwwvUzYYXqJsNL1A3G16gbja8QNlsLrxA2WcEF16gbja8QN1seIG62TTZlN0FeIG62fACdbPhBepmwwvUzYYXKJvNlReomw0vUDcbXqBuNrxA3WyabMpmwwvUzYYXqJsNL1A3G16g7DOCKy9QNpsbL1A3G16gbja8QNld4MYL1M2myaZsNrxA3Wx4gbrZ8AJ1s+EF6mbDC5TN5s4L1M2GF6ibDS9QNxteoG42TTZls+EF6mbDC5R9RnDnBepmwwvUzYYXKJvNgxcouws8eIG62fACdbPhBepm02RTNhteoG42vEDdbHiButnwAnWz4QWqZtMOvEDdbHiButnwAnWz4QXqZtNkU/QZQTvwAnWz4QXqZsML1M2GF6i7C/ACZbM58gJ1s+EF6mbDC9TNhheom02TTdlseIG62fACdbPhBepmwwvUzYYXKJvNiReomw0vUDcbXqDsM4ITL1A3myabstnwAnWz4QXq7gK8QN1seIG62fACZbM58wJ1s+EF6mbDC9TNhheom02TTdlseIG62fACdbPhBepmwwvUzYYXKJtN4wXKPiNovEDdbHiButnwAnXvN002ZbPhBepmwwvUzYYXqJsNL1A3G16g7A594QXqZsML1M2GFyh7v7nwAnWzabIpmw0vUDcbXqBuNrxA3Wx4gbo7NC9QNpsrL1A3G16gbja8QNld4MoL1M2myaZsNrxA3Wx4gbrZ8AJ1s+EF6mbDC5TN5sYL1M2GF6ibDS9QNxte4PuyuZ/uz2zu50OfTZNNZjbHdn76y+OPh8of0rmeT8evH93ar+mMOF+fUf5A/vNHny6ji8/Hx/Pi8+ny68V/5s457DN3PmOfuXMl+8ydh1kz99aepM/tcu9z53h2mfudP1o099tXKu1xen/x6XH/+smHw+HDxe3yRHdqt/v7iy+HL8znY1cm7wSZ4fu24WMADd9vDt/j+ZNPl9MhNHwUp+H7tuFrhs/w/dbw3c5PHKfb7fLh4kN7/oKnw7WFJpV1NqnbmFSe3KT+lZN6e2rb04+AQpPK7JvUbUyqZxEm9Xw4ta9JPX/4yafz/WtS2+H868V/TpSnHCbq9yYqTzg+PGoxfN82fB61GL5vGz6PWgzfbw5fmu1+eNRi+L5t+JrhM3y/NXzXr4E6XX+dqL9X2IdHIiYqd6I8ujBRuRPlEYOJyp0ojwJM1O9N1O88tDrevwI/Po79c4OH5wbG79vG73Lw5MD4/XXjl/fXoC4HjxlM6jYm1TMJk7qNSfUAw6T+lZOa9Rf2LodmUk3qJibVUxSTej5+vYfufDxHO7qnKCYqd6I8RTFRvzVRmaXDAxfD923D53GL4fuu4Tt62GL4fnP40nrp0fMTw/dtw+eRyJrDd7mcnxdfrh/+Jc/v/cvw9//e9nL06MJEfdML/i7HZvgM33cNnwcMhu/bhs+zCMP3TW+XvBw9tjB83zZ8HlsYvt8bvvf/8uhy9CzCRKVO1MkDBhOVO1GeGpio3InyKMBE/XUvif30V99OnhsYv28cv2b8jN8Gjh24nDxmMKnbmFTPJEzqNibVAwyTuoUDMi4nTztM6jYm1VMUk/pNr5+/nD1wMXzfNnyezRi+b3r9/OXsMY7h+7bh8xDH8G3iDWvnZlJN6iYm1fMek7qJN6ydPe8xqduYVM97TGrqm9vOnsuYqNyJ8vzERH3XG7Ga5yeG79uGz/MTw/dtw+f5ieH7rtexNc9PDN+3DV8zfKnDd//Cfbyfjv8wfH8CZ/YnAyeoJwPnWScDpyH/OuDHNgDO0s0FfmGmJgNnYyYDZyAmA9e6524plwb4XOCa5mTgmuZk4JrmZOCa5mTgmuZc4FdNczJwTXMycE1zMnBNczLwBvisB+p/Atc0JwPXNCcD1zQnA9c0JwPXND8Cv7Xnh74fDx+AXw/Pv6J1Pf18/HA+Hv/EfdMzp+LWMqfi1jGn4tYwp+JucM/ErV1Oxa1bTsWtWU7FrVdOxa1VzsR91yqn4tYqp+LWKqfi1iqn4m5wz8StVU7FrVVOxa1VTsWtVU7FrVXOxP3QKqfi1iqn4tYqp+LWKqfibnDPxK1VTsWtVU7FrVVOxa1VTsWtVU7EfT1olR9x3x/PN0g+Pv4N79P1+XNPv8A4X4Yf4cnicrx9uPRwff4l83Y8Xn+9+M8UldUVUtSBV0hRtV4hxSbFBVIkAlZIkV9YIUXaYoUU2ZAVUiRZFkjxyN2skCJ3s0KK3M0KKXI3K6TYpLhAitzNCilyNyukyN2skCJ3s0KK3M0CKZ64mxVS5G5WSJG7WSFF7maFFJsUF0iRu1khRe5mhRS5mxVS5G5WSJG7WSDFM3ezQorczQopcjcrpMjdrJBik+ICKXI3K6TI3ayQInezQorczQopcjcLpNi4mxVS5G5WSJG7WSFF7maFFJsUF0iRu1khRe5mhRS5mxVS5G5WSJG7WSDFC3ezQorczQopcjcrpMjdrJBik+ICKXI3K6TI3ayQInezQorczQopcjcLpHjlblZIkbtZIUXuZoUUuZsVUmxSXCBF7mYLKZ7uzx/bzu30/uLT8fj8vKdja33kRM/uImeFdhc5hbS7yPmmvUV+I6d2FzmTtbvIaa/dRc6R7S7yJvK9Rc6+7S5y9m13kbNvu4ucfdtd5Ozb3iK/s2+7i5x9213k7NvuImffdhd5E/neImffdhc5+7a7yNm33UXOvu0ucvZtb5E/2LfdRc6+7S5y9m13kbNvu4u8iXxvkbNvu4ucfdtd5Ozb7iJn3zYQ+eV0fzK+nE+XPkVCbfsp3g4c2Qop0l4rpMhkrZAiObVCik2KC6RIIa2QIiu0QopEzwopcjcrpMjdLJDikbtZIUXuZoUUuZsVUuRuVkixSXGBFLmbFVLkblZIkbtZIUXuZoUUuZsFUjxxNyukyN2skCJ3s0KK3M0KKTYpLpAid7NCitzNCilyNyukyN2skCJ3s0CKZ+5mhRS5mxVS5G5WSJG7WSHFJsUFUuRuVkiRu1khRe5mhRS5mxVS5G4WSLFxNyukyN2skCJ3s0KK3M0KKTYpLpAid7NCitzNCilyNyukyN2skCJ3s0CKF+5mhRS5mxVS5G5WSJG7WSHFJsUFUuRuVkiRu1khRe5mhRS5mxVS5G4WSPHK3ayQInezQorczRZSvNy+rr38jew/p8jdrJBik+ICKXI3K6TI3ayQInezQorczQopcjcLpHjjblZIkbtZIUXuZoUUuZsVUmxSXCBF7maFFLmbFVLkblZIkbtZIUXuZoEU79zNCilyNyukyN2skCJ3s0KKTYoLpMjdrJAid7NCitzNCilyNyukyN0skOKDu1khRe5mhRS5mxVS5G5WSLFJcYEUuZsVUuRuVkiRu1khRe5mhRS5m+2neD9wNyukyN2skCJ3s0KK3M0KKTYpLpAid7NCitzNCilyNyukyN2skCJ3s0CKR+5mhRS5mxVS5G5WSJG7WSHFJsUFUuRuVkiRu1khRe5mhRS5mxVS5G4WSPHE3ayQInezQorczQopcjcrpNikuECK3M0KKXI3G0jxemrHv197PR/OfYrczQopcjcrpMjdLJDimbtZIUXuZoUUuZsVUuRuVkixSXGBFLmbFVLkblZIkbtZIUXuZoUUuZsFUmzczQopcjcrpMjdrJAid7NCik2KC6TI3ayQInezQorczQopcjcrpMjdLJDihbtZIUXuZoUUuZsVUuRuVkixSXGBFLmbFVLkblZIkbtZIUXuZoUUuZsFUrxyNyukyN2skCJ3s0KK3M0KKTYpLpAid7NCitzNCilyN1tI8ccVzxQvrfUpcjcrpMjdLJDijbtZIUXuZoUUuZsVUuRuVkixSXGBFLmbFVLkblZIkbtZIUXuZoUUuZsFUrxzNyukyN2skCJ3s0KK3M0KKTYpLpAid7NCitzNCilyNyukyN2skCJ3s0CKD+5mhRS5mxVS5G5WSJG7WSHFJsUFUuRuVkiRu1khRe5mhRS5mxVS5G62n+LjwN2skCJ3s0KK3M0KKXI3K6TYpLhAitzNCilyNyukyN2skCJ3s0KK3M0CKR65mxVS5G5WSJG7WSFF7maFFJsUF0iRu1khRe5mhRS5mxVS5G5WSJG7WSDFE3ezQorczQopcjcrpMjdbCHF++35Y68/Huz3KTYpLpAid7NCitzNFlL80SW+UvzldxtefD+fnz/4fr5cP1zcnuHdr+d+Ojgh0/F6Orgm0/F6Ojgs0/FyOs7cmOl4PR2cm+l4PR1cnul4PR0coel4PR3NdJiOl9PBaZqO19PBlZqO19PBlZqO19PBlZqO19PBlZqOl9PRuFLT8Xo6uFLT8Xo6uFLT8Xo6uFLT8Xo6mukwHS+ngys1Ha+ngys1Ha+ngys1Ha+ngys1Ha+ngys1HS+n48KVmo7X08GVmo7X08GVmo7X08GVmo7X09FMh+l4OR1cqel4PR1cqel4PR1cqel4PR1cqel4PR1cqel4OR1XrtR0vJ4OrtR0vJ4OrtR0vJ4OrtR0vJ6OZjpMx8vp4EpNx+vp4EpNx+vp4EpNx+vp4EpNx+vp4EpNx8vpuHGlpuP1dHClpuP1dHClpuP1dHClpuP1dDTTYTpeTgdXajpeTwdXajpeTwdXajpeTwdXajpeTwdXajpeTsedKzUdr6eDKzUdr6eDKzUdr6eDKzUdr6ejmQ7T8XI6uFLT8Xo6uFLT8Xo6uFLT8Xo6uFLT8Xo6uFLT8XI6Hlyp6Xg9HVyp6Xg9HVyp6Xg9HVyp6Xg9Hc10mI6X08GVmo7X08GVmo7X08GVmo7X08GVmo7X08GVmo4X03E5HLhS0/F6OrhS0/F6OrhS0/F6OrhS0/F6OprpMB0vp4MrNR2vp4MrNR2vp4MrNR2vp4MrNR2vp4MrNR0vp+PIlZqO19PBlZqO19PBlZqO19PBlZqO19PRTIfpeDkdXKnpeD0dXKnpeD0dXKnpeD0dXKnpeD0dXKnpeDkdJ67UdLyeDq7UdLyeDq7UdLyeDq7UdLyejmY6TMfL6eBKTcfr6eBKTcfr6eBKTcfr6eBKTcfr6eBKTcfL6Thzpabj9XRwpabj9XRwpabj9XRwpabj9XQ002E6Xk4HV7redBzPX9NxbX3kBOhykbfL1x/yH/+N9xefHrf78wM/Hj/n43QdXPy3f7Xy/Mg/SsqvF/85THypYUobJnrVMKUNExtrmLKGqZG3hiltmLhew5Q2TNSwYUobJibZMKUNUzNMhilrmHhqw5Q2TAy4YUobJgbcMKUNEwNumNKGiQE3TFnDdGHADVPaMDHghiltmBhww5Q2TAy4YUobpmaYDFPWMDHghiltmBhww5Q2TAy4YUobJgbcMKUNEwNumLKG6cqAG6a0YWLADVPaMDHghiltmBhww5Q2TM0wGaasYWLADVPaMDHghiltmBhww5Q2TAy4YUobJgbcMGUN040BN0xpw8SAG6a0YWLADVPaMDHghiltmJphMkxZw8SAG6a0YWLADVPaMDHghiltmBhww5Q2TAy4YcoapjsDbpjShokBN0xpw8SAG6a0YWLADVPaMDXDZJiyhokBN0xpw8SAG6a0YWLADVPaMDHghiltmBhww5Q1TA8G3DClDRMDbpjShmmnBvx2ef7o2/3yYZja+fBk2M7HxwfgPz7pE/ipDYDv1BJ/H/AG+FzgO7WN3wd8p0bu+4Dv1Fp9H/Cdmp3vA75T+/FdwI+HnRqC7wO+0xb9fcA1zcnANc3JwBvgc4FrmpOBa5qTgWuak4FrmpOBa5pzgR81zcnANc3JwDXNycA1zcnAG+BzgWuak4FrmpOBa5qTgWuak4FrmnOBnzTNycA1zcnANc3JwDXNycAb4HOBa5qTgWuak4FrmpOBa5qTgWuac4GfNc3JwDXNycA1zcnANc3JwBvgc4FrmpOBa5qTgWuak4FrmpOBa5pzgTdNczJwTfMz8Ovl+AR+vd56hspjnKE+GGfYMAwz1No+M7wdnp+63Y4DhopYnKFuFWeoLsUZakBhhhelJnxfvugpcYZ6SpyhnhJn2DAM31P0lDhDPSXOUE+JM9RT4gz1lDDDq54SZ6inxBnqKXGGekqcYcMwzFBPiTPUU+IM9ZQ4Qz0l7L6uekqY4U1PiTPUU+IM9ZTwPeWmp8QZNgzDDPWUOEM9Jc5QT4kz1FPiDPWUMMO7nhJnqKfEGeopcYZ6SpxhwzDMUE+JM9RTwu7rrqfEGeopcYZ6SpjhQ08J31MeekqcoZ4SZ6inxBk2DMMM9ZQ4Qz0lzlBPiTPUU+IM9ZQow9NBT4kz1FPiDPWUOEM9Jc6wYRh0X6eDnhJnqKfEGeopcYZ6SvyeoqeEGR71lDhDPSXOUE+JM9RT4gwbhmGGekqcoZ4SZ6inxBnqKXGGekqY4UlPiTPUU+IM9ZSw+zrpKXGGDcMwQz0lzlBPid9T9JQ4Qz0lzlBPCTM86ylxhnpKnKGeEmeop8QZNgzDDPWUOEM9Jc5QT4kz1FPiDPWUMEOH18fdl/PoExjqKXGGekqcYcMwfE/RU+IM9ZQ4Qz0lzlBPiTPUU8IMnUefwFBPiTPUU+IM9ZQ4w4ZhmKGeEmeop8QZ6ilxhnpK2H05jz7O0Hn0CQz1lDhDPSV8T3EefQLDhmGYoZ4SZ6inxBnqKXGGekqcoZ4SZug8+gSGekqcoZ4SZ6inxBk2DMMM9ZQ4Qz0l7L6cR5/AUE+JM9RTwgydRx+/pziPPoGhnhJnqKfEGTYMwwz1lDhDPSXOUE+JM9RT4gz1lDBD59EnMNRT4gz1lDhDPSXOsGEYdV/Oo09gqKfEGeopcYZ6SvyeoqdEGZ6dR5/AUE+JM9RT4gz1lDjDhmGYoZ4SZ6inxBnqKXGGekqcoZ4SZug8+gSGekqcoZ4SdV9n59EnMGwYhhnqKXGGekr8nqKnxBnqKXGGekqYofPoExjqKXGGekqcoZ4SZ9gwDDPUU+IM9ZQ4Qz0lzlBPiTPUU8IMnUcfd1/Oo09gqKfEGeopcYYNw/A9RU+JM9RT4gz1lDhDPSXOUE8JM3QefQJDPSXOUE+JM9RT4gwbhmGGekqcoZ4SZ6inxBnqKWH35Tz6OEPn0Scw1FPiDPWU8D3FefQJDBuGYYZ6SpyhnhJnqKfEGeopcYZ6Spih8+gTGOopcYZ6SpyhnhJn2DAMM9RT4gz1lLD7ch59AkM9Jc5QTwkzdB59/J7iPPoEhnpKnKGeEmfYMAwz1FPiDPWUOEM9Jc5QT4kz1FPCDJ1Hn8BQT4kz1FPiDPWUOMOGYdR9OY8+gaGeEmeop8QZ6inxe4qeEmboPPoEhnpKnKGeEmeop8QZNgzDDPWUOEM9Jc5QT4kz1FPiDPWUKMPmPPoEhnpKnKGeEnVfzXn0CQwbhmGGekqcoZ4Sv6foKXGGekqcoZ4SZug8+gSGekqcoZ4SZ6inxBk2DMMM9ZQ4Qz0lzlBPiTPUU+IM9ZQwQ+fRx92X8+gTGOopcYZ6SpxhwzB8T9FT4gz1lDhDPSXOUE+JM9RTwgydR5/AUE+JM9RT4gz1lDjDhmGYoZ4SZ6inxBnqKXGGekrYfTmPPs7QefQJDPWUOEM9JXxPcR59AsOGYZihnhJnqKfEGeopcYZ6SpyhnhJm6Dz6BIZ6SpyhnhJnqKfEGTYMwwz1lDhDPSXsvpxHn8BQT4kz1FPCDJ1HH7+nOI8+gaGeEmeop8QZNgzDDPWUOEM9Jc5QT4kz1FPiDPWUMEPn0Scw1FPiDPWUOEM9Jc6wYRh1X86jT2Cop8QZ6ilxhnpK/J6ip4QZOo8+gaGeEmeop8QZ6ilxhg3DMEM9Jc5QT4kz1FPiDPWUOEM9JczQefQJDPWUOEM9Jey+nEefwLBhGGaop8QZ6inxe4qeEmeop8QZ6ilRhhfn0Scw1FPiDPWUOEM9Jc6wYRhmqKfEGeopcYZ6SpyhnhJnqKeEGTqPPuy+Ls6jT2Cop8QZ6ilxhg3D8D1FT4kz1FPiDPWUOEM9Jc5QTwkzdB59AkM9Jc5QT4kz1FPiDBuGYYZ6SpyhnhJnqKfEGeopYfflPPo4Q+fRJzDUU+IM9ZTwPcV59AkMG4ZhhnpKnKGeEmeop8QZ6ilxhnpKmKHz6BMY6ilxhnpKnKGeEmfYMAwz1FPiDPWUsPtyHn0CQz0lzlBPCTN0Hn38nuI8+gSGekqcoZ4SZ9gwDDPUU+IM9ZQ4Qz0lzlBPiTPUU8IMnUefwFBPiTPUU+IM9ZQ4w4Zh1H05jz6BoZ4SZ6inxBnqKfF7ip4SZug8+gSGekqcoZ4SZ6inxBk2DMMM9ZQ4Qz0lzlBPiTPUU+IM9ZQwQ+fRJzDUU+IM9ZSw+3IefQLDhmGYoZ4SZ6inxO8pekqcoZ4SZ6inhBk6jz6BoZ4SZ6inxBnqKXGGDcMwQz0lzlBPiTPUU+IM9ZQ4Qz0lyvDqPPqw+7o6jz6BoZ4SZ6inxBk2DMP3FD0lzlBPiTPUU+IM9ZQ4Qz0lzNB59AkM9ZQ4Qz0lzlBPiTNsGIYZ6ilxhnpKnKGeEmeop4Tdl/Po4wydR5/AUE+JM9RTwvcU59EnMGwYhhnqKXGGekqcoZ4SZ6inxBnqKWGGzqNPYKinxBnqKXGGekqcYcMwzFBPiTPUU8Luy3n0CQz1lDhDPSXM0Hn08XuK8+gTGOopcYZ6SpxhwzDMUE+JM9RT4gz1lDhDPSXOUE8JM3QefQJDPSXOUE+JM9RT4gwbhlH35Tz6BIZ6SpyhnhL/PtRT4gz1lDBD59EnMNRT4gz1lDhDPSW82ziPPoGhnhJnqKfEvw/1lDhDPSXOUE8JM3QefQJDPSXOUE8J7zbOo09g2DAMM9RT4gz1lPg9RU+JM9RT4gz1lDBD59EnMNRT4gz1lDhDPSXOsGEYZqinxBnqKXGGespnhvfT/cnwfj70DPfaUx7PD30/H/+B4Z9Y1qkex8NTmByPl/sHLOfr19Xna/t09aU9iV/uvwA/3kc/+daOP3n88oe5/Ul8oQPpqxC/X58Xn+8j4uvUmq0QX6cEbYX4OpVpK8Qb4pOJr1PHtkJ8nfK2FeLrVL2tEF+nGG6FuM75LxC/Hq5/v/h6vnwgfr8+r73ffy35f7qP20HlTAb+uLa/X/v49Y/DD+ADM3U+nJ9m6nx8/GqmBn/OfjB4/kE7teM/a6zbQZddJkoleZkote9lomyiXCVKvmCZKImIZaJkOJaJkjpZJkpOZpUoj2zPMlGyPctEyfYsEyXbs0yUTZSrRMn2LBMl27NMlGzPMlGyPctEyfasEuWJ7VkmSrZnmSjZnmWiZHuWibKJcpUo2Z5lomR7lomS7VkmSrZnmSjZnlWiPLM9y0TJ9iwTJduzTJRszzJRNlGuEiXbs0yUbM8yUbI9y0TJ9iwTJduzSpSN7VkmSrZnmSjZnmWiZHuWibKJcpUo2Z5lomR7lomS7VkmSrZnmSjZnlWivLA93xnl+/O2bxcCp3I6nEzldGiWyuk06XxjOu/P/rxdyJDK6fAbldOhLCqnw0JUTodYKLyzXbmCyulwBZXT4Qoqp8MVFN4Krk06hdPhCiqnwxVUTocrqJwOV1A5Ha6gcDo3rqByOlxB5XS4gsrpcAWV02nSKZwOV1A5Ha6gcjpcQeEnCDeuoHI6XEHhdO5cQeV0uILCW8GdK6icDldQOZ0mncLpcAWV0+EKKqfDFVROhyuonA5XUDidB1dQOR2uoHI6XEHldLiCyuk06RROhyso/AThwRVUTocrqJwOV1A5Ha6g7lZwP3AFldPhCiqnwxVUTocrqJxOk07hdLiCyulwBZXT4Qoqp8MVVE6HKyiczpErqJwOV1A5Ha6gcjpcQd0nCPdjk07hdLiCyulwBZXT4QoqbwVcQeV0uILC6Zy4gsrpcAWV0+EKKqfDFVROp0mncDpcQeV0uILK6XAFldPhCiqnwxUUTufMFVROhyso/AThzBVUTocrqJxOk07hdLiCylsBV1A5Ha6gcjpcQeV0uILC6TSuoHI6XEHldLiCyulwBZXTadIpnA5XUDkdrqByOlxB5XS4gsrpcAWFnyBcuILK6XAFldPhCiqnwxUU3gouTTqF0+EKKqfDFVROhyuonA5XUDkdrqBwOleuoHI6XEHldLiCyulwBZXTadIpnA5XUDkdrqByOlxB4ScIV66gcjpcQeF0blxB5XS4gsJbwY0rqJwOV1A5nSadwulwBZXT4Qoqp8MVVE6HK6icDldQOJ07V1A5Ha6gcjpcQeV0uILK6TTpFE6HKyj8BOHOFVROhyuonA5XUDkdrqDwVvDgCiqnwxVUTocrqJwOV1A5nSadwulwBZXT4Qoqp8MVVE6HK6icDldQN53HgSuonA5XUDkdrqByOlxB3ScIj0OTTuF0uILK6XAFldPhCipvBVxB5XS4gsLpHLmCyulwBZXT4Qoqp8MVVE6nSadwOlxB5XS4gsrpcAWV0+EKKqfDFRRO58QVVE6HKyj8BOHEFVROhyuonE6TTuF0uILKWwFXUDkdrqByOlxB5XS4gsLpnLmCyulwBZXT4Qoqp8MVVE6nSadwOlxB5XS4gsrpcAWV0+EKKqfDFRR+gtC4gsrpcAWV0+EKKqfDFRTeClqTTuF0uILK6XAFldPhCiqnwxVUTocrKJzOhSuonA5XUDkdrqByOlxB5XSadAqnwxVUTocrqJwOV1D4CcKFK6icDldQOJ0rV1A5Ha6g8FZw5Qoqp8MVVE6nSadwOlxB5XS4gsrpcAWV0+EKKqfDFRRO58YVVE6HK6icDldQOR2uoHI6TTqF0+EKCj9BuHEFldPhCiqnwxVUTocrKLwV3LmCyulwBZXT4Qoqp8MVVE6nSadwOlxB5XS4gsrpcAWV0+EKKqfDFRRO58EVVE6HK6icDldQOR2uoPAThEeTTuF0uILK6XAFldPhCipvBVxB5XS4grLpXA8HrqByOlxB5XS4gsrpcAWV02nSKZwOV1A5Ha6gcjpcQeV0uILK6XAFhdM5cgWV0+EKyj5B+PERuYLK6XAFldNp0imcDldQeSvgCiqnwxVUTocrqJwOV1A4nRNXUDkdrqByOlxB5XS4gsrpNOkUTocrqJwOV1A5Ha6gcjpcQeV0uILCTxDOXEHldLiCyulwBZXT4QoKbwXnJp3C6XAFldPhCiqnwxVUTocrqJwOV1A4ncYVVE6HK6icDldQOR2uoHI6TTqF0+EKKqfDFVROhyso/AShcQWV0+EKCqdz4Qoqp8MVFN4KLlxB5XS4gsrpNOkUTocrqJwOV1A5Ha6gcjpcQeV0uILC6Vy5gsrpcAWV0+EKKqfDFVROp0mncDpcQeEnCFeuoHI6XEHldLiCyulwBYW3ghtXUDkdrqByOlxB5XS4gsrpNOkUTocrqJwOV1A5Ha6gcjpcQeV0uILC6dy5gsrpcAWV0+EKKqfDFRR+gnBv0imcDldQOR2uoHI6XEHlrYArqJwOV1A4nQdXUDkdrqByOlxB5XS4gsrpNOkUTocrqJwOV1A5Ha6gcjpcQeV0uIK66RwPXEHldLiCuk8QjgeuoHI6XEHldJp0CqfDFVTeCriCyulwBZXT4Qoqp8MVFE7nyBVUTocrqJwOV1A5Ha6gcjpNOoXT4Qoqp8MVVE6HK6icDldQOR2uoPAThBNXUDkdrqByOlxB5XS4gsJbwalJp3A6XEHldLiCyulwBZXT4Qoqp8MVFE7nzBVUTocrqJwOV1A5Ha6gcjpNOoXT4Qoqp8MVVE6HKyj8BOHMFVROhysonE7jCiqnwxUU3goaV1A5Ha6gcjpNOoXT4Qoqp8MVVE6HK6icDldQOR2uoHA6F66gcjpcQeV0uILK6XAFldNp0imcDldQ+AnChSuonA5XUDkdrqByOlxB4a3gyhVUTocrqJwOV1A5Ha6gcjpNOoXT4Qoqp8MVVE6HK6icDldQOR2uoHA6N66gcjpcQeV0uILK6XAFhZ8g3Jp0CqfDFVROhyuonA5XUHkr4Aoqp8MVFE7nzhVUTocrqJwOV1A5Ha6gcjpNOoXT4Qoqp8MVVE6HK6icDldQOR2uoHA6D66gcjpcQeEnCA+uoHI6XEHldJp0CqfDFVTeCriCyulwBZXT4Qoqp8MV1E3ndOAKKqfDFVROhyuonA5XUDmdJp3C6XAFldPhCiqnwxVUTocrqJwOV1D3CcLpyBVUTocrqJwOV1A5Ha6g8FZwbNIpnA5XUDkdrqByOlxB5XS4gsrpcAWF0zlxBZXT4Qoqp8MVVE6HK6icTpNO4XS4gsrpcAWV0+EKCj9BOHEFldPhCgqnc+YKKqfDFRTeCs5cQeV0uILK6TTpFE6HK6icDldQOR2uoHI6XEHldLiCwuk0rqByOlxB5XS4gsrpcAWV02nSKZwOV1D4CULjCiqnwxVUTocrqJwOV1B4K7hwBZXT4Qoqp8MVVE6HK6icTpNO4XS4gsrpcAWV0+EKKqfDFVROhysonM6VK6icDldQOR2uoHI6XEHhJwjXJp3C6XAFldPhCirfd7iCyulwBZXT4QoKp3PjCiqnwxVUTocrKLxR37iCyuk06RROhyuofN/hCiqnwxVUTocrqJwOV1A4nTtXUDkdrqDwRn3nCiqnwxVUTqdJp3A6XEHlrYArqJwOV1A5Ha6gcjpcQeF0HlxB5XS4gsrpcAWV0+EKKqfTpFM4Ha6gcjpcwXemcz/dn+ncz4c+Ha4gOZ1jO399jna5fsjnej4dv350a7/mM/rQ1/vXh779/NGny+ji8/HxvPh8uvx68Z/J8xB7TZ7j2Gfy5wN/stfkuZlVk2/tyfrcfuHxlTzvs9fkOaVlk7995dIep/cX/9j0v37y4XD4cHG7XJ4pttv9/cWXw/Pay/n4z9XyfGjGz/h93/ixgsbvt8fv8fzJp8vpEBo/2tP4feP48brG73fH73Z+4jjdbpcPFx/a8xc8Ha4tNKtMtFndyqxy52b1r53V21Pkno6HU2RWj2y/Wd3KrHo+YVb/NqCn9jWr5w8/+XS+f81qO5x/vfjPmfLkw0z97kzlCcijxy/G7xvHrxk/4/d94+fxi/H77fFL899Hj1+M3zeOn8cvxu93x+/6NVKn668z9ayzHpOYqeyZ8jjDTCXP1MljBzOVPVMeD5ip352p33mUdbx/RX58HPtnCSfPEgzgtw6gpwkG8K8cwMS/JHVqZtWsbmRWPacwq1uZVQ81zOpfO6tpf6Hv5AmIWd3KrHqyYlZ/XHH8epPd+XiO9nVPVsxU8kydPVkxU785U4n14+whjPH7xvHzCMb4feP4eQBj/H57/NI66rkZP+P3fePnMcmq43e5nJ8XX64f/s3P7/1b8g//PvfscYaZ+uPbXhB49oTC+H3j+HnoYPy+cfw8nzB+f3zb+ymbRxnG7xvHz6MM4/e74/fh3yg1zyfMVPZMeehgprJnqpkpM5U8Ux4PmKk//sJXzX76q3HNswQD+K0D6GmCAfxjG4cYNI8ezOpWZtVzCrO6kVm9eKhhVv/YxoEbF09AzOpWZtWTFbP6x7e9yv7iIYzx+8bxa8bP+H3bq+wvHu0Yv28cPw92jN8f23g/28UzILO6lVn1DMis/rGN97NdPAMyqxuZ1atnQGb1j9z3vl09qzFT2TPlmYqZ+uPb3qZ19UzF+H3j+DXjZ/y+b/w8UzF+f3zby9yunqkYv28cP49Jssfv/gX8eD8d/2H8/kTO9k9HTlrPRn7jXqcjpyb/SuTHNkDO3E1HzlZNR94gn42clZiOXBOfvrFon9ORa5/TkWufs5Hftc/pyLXP6ci1z+nItc/pyBvks5Frn9ORa5/TkWufEx+9/4lc+5yOXPucjfyhfU5Hrn1OR659/gvIb+35se/Hwwfk18Pzr3VdTz8fUJyPx78D1z0nA2+AzwWud04GrnVOBq5zTgaucU4Grm9OBd4O2uZk4LrmZOCa5mTgmuZk4A3wucA1zcnANc3JwDXNycA1zcnANc25wI+a5mTgmuZk4JrmZOCa5mTgDfC5wDXNycA1zcnANc3JwDXNycA1zbnAT5rmZOCa5mTgmuZk4JrmvwD8/ni+s/Lx8W+In65fx2r+guM8egll+6JxOd4+XHq4Pv+S+g//df314j9zbHJcIke9eI0c1e01ctTi18iRHFgjR85hiRzPVMYaOTIka+RIvKyRI5+zRo5NjkvkyOeskSOfs0aOfM4aOfI5a+TI5yyRY+Nz1siRz1kjRz5njRz5nDVybHJcIkc+Z40c+Zw1cuRz1siRz1kjRz5niRwvfM4aOfI5a+TI56yRI5+zRo5NjkvkyOeskSOfs0aOfM4aOfI5a+TI5yyR45XPWSNHPmeNHPmcNXLkc9bIsclxiRz5nDVy5HPWyJHPWSNHPmeNHPmcJXK88Tlr5MjnrJEjn7NGjnzOGjk2OS6RI5+zRo58zho58jlr5MjnrJEjn7NEjnc+Z40c+Zw1cuRz1siRz1kjxybHJXLkc9bIkc9ZI0c+Z40c+Zxt5Hi6P39sO7fT+4tPx+Pz856OrfWhkz/7C/3BFO0wdFpph6FzUDsMnbDaYehN6PsLnQrbYei82Q5DJ9l2GDojt8PQGbndhX45MHI7DJ2R22HojNwOQ2fkdhh6E/r+Qmfkdhg6I7fD0Bm5HYbOyO0wdEZuf6EfGbkdhs7I7TB0Rm6HoTNyOwy9CX1/oTNyOwydkdth6IzcDkNn5HYYOiO3v9BPjNwOQ2fkNhH65XR/Ur6cT5c+R5JtjRx5szVybHJcIkd2a40cCas1cuSg1siRVlojR6ZoiRzP5M8aOfI5a+TI56yRI5+zRo5NjkvkyOeskSOfs0aOfM4aOfI5a+TI5yyRY+Nz1siRz1kjRz5njRz5nDVybHJcIkc+Z40c+Zw1cuRz1siRz1kjRz5niRwvfM4aOfI5a+TI56yRI5+zRo5NjkvkyOeskSOfs0aOfM4aOfI5a+TI5yyR45XPWSNHPmeNHPmcNXLkc9bIsclxiRz5nDVy5HPWyJHPWSNHPmeNHPmcJXK88Tlr5MjnrJEjn7NGjnzOGjk2OS6RI5+zRo58zho58jlr5MjnrJEjn7NEjnc+Z40c+Zw1cuRz1siRz1kjxybHJXLkc7aR448nGs9rL39j+8858jlr5MjnrJEjn7NGjnzOEjk++Jw1cuRz1siRz1kjRz5njRybHJfIkc9ZI0c+Z40c+Zw1cuRz1siRz1khx+uBz1kjRz5njRz5nDVy5HPWyLHJcYkc+Zw1cuRz1siRz1kjRz5njRz5nCVyPPI5a+TI56yRI5+zRo58zho5NjkukSOfs0aOfM4aOfI5a+TI56yRI5+zRI4nPmeNHPmcNXLkc9bIkc9ZI8cmxyVy5HPWyJHPWSNHPmeNHPmcNXLkc5bI8cznrJEjn7NGjnzOGjnyOWvk2OS4RI58zho58jlr5MjnrJEjn7NGjnzOEjk2PmeNHPmcNXLkc9bIkc9ZI8cmxyVy5HPWyJHPWSNHPmeNHPmcNXLkczaR4/XUnp/3ej6cuxwvfM4aOfI5a+TI56yRI5+zRo5NjkvkyOeskSOfs0aOfM4aOfI5a+TI5yyR45XPWSNHPmeNHPmcNXLkc9bIsclxiRz5nDVy5HPWyJHPWSNHPmeNHPmcJXK88Tlr5MjnrJEjn7NGjnzOGjk2OS6RI5+zRo58zho58jlr5MjnrJEjn7NEjnc+Z40c+Zw1cuRz1siRz1kjxybHJXLkc9bIkc9ZI0c+Z40c+Zw1cuRzlsjxwedsI8cfVzxzvLTW58jnrJEjn7NGjnzOGjk2OS6RI5+zRo58zho58jlr5MjnrJEjn7NCjrcDn7NGjnzOGjnyOWvkyOeskWOT4xI58jlr5MjnrJEjn7NGjnzOGjnyOUvkeORz1siRz1kjRz5njRz5nDVybHJcIkc+Z40c+Zw1cuRz1siRz1kjRz5niRxPfM4aOfI5a+TI56yRI5+zRo5NjkvkyOeskSOfs0aOfM4aOfI5a+TI5yyR45nPWSNHPmeNHPmcNXLkc9bIsclxiRz5nDVy5HPWyJHPWSNHPmeNHPmcJXJsfM4aOfI5a+TI56yRI5+zRo5NjkvkyOeskSOfs40c77fnj70+Dtc+Rz5njRz5nDVy5HO2kePjdPjK8XJ4f/H9fH7+4Pv5cv1wcXvGd79252bdLjyR+Xg3H/yT+Xg3H7yW+Xg3H3yZ+Xg3H818mI8388HvmY9388Ebmo9388FHmo9388Fzmo9388Gfmo8383HlT83Hu/ngT83Hu/ngT83Hu/ngT83Hu/lo5sN8vJkP/tR8vJsP/tR8vJsP/tR8vJsP/tR8vJsP/tR8vJmPG39qPt7NB39qPt7NB39qPt7NB39qPt7NRzMf5uPNfPCn5uPdfPCn5uPdfPCn5uPdfPCn5uPdfPCn5uPNfNz5U/Pxbj74U/Pxbj74U/Pxbj74U/Pxbj6a+TAfb+aDPzUf7+aDPzUf7+aDPzUf7+aDPzUf7+aDPzUfb+bjwZ+aj3fzwZ+aj3fzwZ+aj3fzwZ+aj3fz0cyH+XgzH/yp+Xg3H/yp+Xg3H/yp+Xg3H/yp+Xg3H/yp+Xg9H/cDf2o+3s0Hf2o+3s0Hf2o+3s0Hf2o+3s1HMx/m48188Kfm49188Kfm49188Kfm49188Kfm49188Kfm4818HPlT8/FuPvhT8/FuPvhT8/FuPvhT8/FuPpr5MB9v5oM/NR/v5oM/NR/v5oM/NR/v5oM/NR/v5oM/NR9v5uPEn5qPd/PBn5qPd/PBn5qPd/PBn5qPd/PRzIf5eDMf/Kn5eDcf/Kn5eDcf/Kn5eDcf/Kn5eDcf/Kn5eDMfZ/7UfLybD/7UfLybD/7UfLybD/7UfLybj2Y+zMeb+eBPzce7+eBPzce7+eBPzce7+eBPzce7+eBPzceb+Wj8qfl4Nx/8qfl4Nx/8qfl4Nx/8qfl4Nx/NfJiPN/PBn5qPd/PBn5qPd/PBn5qPd/PBn5qPd/PBn5qPN/Nx4U/Nx7v54E/Nx7v54E/Nx7v54E/Nx7v5aObDfLyZD/7UfLybD/7UfLybD/7UfLybD/50xfk4nr/m49r60EnRBUNvl68/6D/+G+8vPj1u9+cHfjx+TsjpOrj4cvgap8vhfPz14n8bpyuHapwSx4lyNU6J48TQGqfEcSJ0jVPiODXjZJzyxokuNk6J48QuG6fEcSKjjVPiOHHXxilxnFhx45Q3TjdW3DgljhMrbpwSx4kVN06J48SKG6fEcWrGyTjljRMrbpwSx4kVN06J48SKG6fEcWLFjVPiOLHixilvnO6suHFKHCdW3DgljhMrbpwSx4kVN06J49SMk3HKGydW3DgljhMrbpwSx4kVN06J48SKG6fEcWLFjVPeOD1YceOUOE6suHFKHCdW3DgljhMrbpwSx6kZJ+OUN06suHFKHCdW3DgljhMrbpwSx4kVN06J48SKG6e0cXocWHHjlDhOrLhxShwnVtw4JY4TK26cEsepGSfjlDdOrLhxShwnVtw4JY4TK26cEseJFTdOiePEihunvHE6suLGKXGcWHHjlDhOrLhxShwnVtw4JY5TM07GKW+c9mrF74evT/2D/j9c/SeYdfzu6XL9uvrWPoA5Xe6P5ye5/vIbvrj6fH/+7FM7/Pwkp8vfKa6jNf9Kiu3y9RXUfvklT5fhn+jntZfRn+d1xN9fCvzx/B1Pl9MhBHwdNfZXAr9+QTxdf6X49++J0zpG6K+keDt/fdvebpf3Y3u8f/2Sxx8lpEe+jjXZDPJ1zEIV5KdDe259p8O1Rb7JT+sU9RXTadJJT+f29aOPh1MonXVq5IrpLNRlDz/TeXzi3X72qtZu109Xnw9PVdLOx8evFAfAf3zWJ/FTGyBfqPhuBflC1XcryBcqvxtBfl6oKW8F+UJNeSvIF2rKW0G+UP3dCvIG+WzkCxXVrSDXPqcj1z6nI9c+pyPXPmcjb9rndOTa53Tk2ud05NrndOQN8tnItc/pyLXP6ci1z+nItc/pyLXP2cgv2ud05NrndOTa53Tk2ud05A3y2ci1z+nItc/pyLXP6ci1z+nItc/ZyK/a53Tk2ud05NrndOTa53TkDfLZyLXP6ci1z+nItc/pyLXP6ci1z9nIb9rndOTa53Tk2ud05NrndOQN8tnItc9/Bfn18nxfV7tebz1FhTKDoo6YQVHty6Coyf0rFG+H5+dut2NP8a6cZVDUtzIoqlAZFLWiDIoNxfg9+q67ZFDUXTIo6i4ZFHWXjLuL7pJA8aG7ZFDUXTIo6i4ZFHWXDIoNxQSKuksGRd0lg6LukkFRd8mgqLuEKd4OB90lg6LukkFRdwmbsR8UdZcMig3FBIq6SwZF3SXj7qK7ZFDUXTIo6i4JFI+6SwZF3SWDou6SQVF3yaDYUEygqLtkUNRdMijqLhkUdZcMirpLAsWT7pJgxk66SwZF3SWDou6SQbGhmHB30V0yKOouGRR1lwyKuksGRd0lgeJZd8mgqLtkUNRdMijqLhkUG4oJFHWXDIq6SwZF3SWDou6SYMbOuksCxaa7ZFDUXTIo6i4Jd5emu2RQbCgmUNRdMijqLhkUdZcMirpLBkXdJYHiRXfJoKi7ZFDUXTIo6i4ZFBuKCRR1lwyKukuCGbvoLhkUdZcMirpLAsWr7pJwd7nqLhkUdZcMirpLBsWGYgJF3SWDou6SQVF3yaCou2RQ1F0SKN50lwyKuksGRd0lg6LukkGxoRg3YzfdJYOi7pJBUXfJoKi7ZNxddJcEinfdJYOi7pJBUXfJoKi7ZFBsKCZQ1F0yKOouGRR1lwyKuksGRd0lgeJDd8mgqLtkUNRdEszYQ3fJoNhQTKCou2RQ1F0y7i66SwZF3SWDou4Sp3g86C4ZFHWXDIq6SwZF3SWDYkMxgaLukkFRd8mgqLtkUNRdMijqLgkUj7pL3Iwdj7pLBkXdJYOi7pJBsaGYcHfRXTIo6i4ZFHWXDIq6SwZF3SWB4kl3yaCou2RQ1F0yKOouGRQbigkUdZcMirpLBkXdJYOi7pJgxk66SwLFs+6SQVF3yaCouyTcXc66SwbFhmICRd0lg6LukkFRd8mgqLtkUNRdEig23SWDou6SQVF3yaCou2RQbCgmUNRdMijqLglmrOkuGRR1lwyKuksCxYvuknB3ueguGRR1lwyKuksGxYZiAkXdJYOi7pJBUXfJoKi7ZFDUXRIoXnWXDIq6SwZF3SWDou6SQbGhGDdjV90lg6LukkFRd8mgqLtk3F10lwSKN90lg6LukkFRd8mgqLtkUGwoJlDUXTIo6i4ZFHWXDIq6SwZF3SWB4l13yaCou2RQ1F0SzNhdd8mg2FBMoKi7ZFDUXTLuLrpLBkXdJYOi7pJA8aG7ZFDUXTIo6i4ZFHWXDIoNxQSKuksGRd0lg6LukkFRd8mgqLvEKZ4OukvcjJ0OuksGRd0lg6LukkGxoZhwd9FdMijqLhkUdZcMirpLBkXdJYHiUXfJoKi7ZFDUXTIo6i4ZFBuKCRR1lwyKuksGRd0lg6LukmDGjrpLAsWT7pJBUXfJoKi7JNxdTrpLBsWGYgJF3SWDou6SQVF3yaCou2RQ1F0SKJ51lwyKuksGRd0lg6LukkGxoZhAUXfJoKi7JJixs+6SQVF3yaCouyRQbLpLwt2l6S4ZFHWXDIq6SwbFhmICRd0lg6LukkFRd8mgqLtkUNRdEihedJcMirpLBkXdJYOi7pJBsaEYN2MX3SWDou6SQVF3yaCou2TcXXSXBIpX3SWDou6SQVF3yaCou2RQbCgmUNRdMijqLhkUdZcMirpLBkXdJYHiTXfJoKi7ZFDUXRLM2E13yaDYUEygqLtkUNRdMu4uuksGRd0lg6LukkDxrrtkUNRdMijqLhkUdZcMig3FBIq6SwZF3SWDou6SQVF3yaCouyRQfOguCWbsobtkUNRdMijqLhkUG4oJdxfdJYOi7pJBUXfJoKi7ZFDUXeIUzwfdJYOi7pJBUXfJoKi7ZFBsKCZQ1F0yKOouGRR1lwyKukvcjJ0PuksCxaPukkFRd8mgqLsk3F2OuksGxYZiAkXdJYOi7pJBUXfJoKi7ZFDUXRIonnSXDIq6SwZF3SWDou6SQbGhmEBRd8mgqLskmLGT7pJBUXfJoKi7JFA86y4Jd5ez7pJBUXfJoKi7ZFBsKCZQ1F0yKOouGRR1lwyKuksGRd0lgWLTXTIo6i4ZFHWXDIq6SwbFhmLcjDXdJYOi7pJBUXfJoKi7ZNxddJcEihfdJYOi7pJBUXfJoKi7ZFBsKCZQ1F0yKOouGRR1lwyKuksGRd0lgeJVd8mgqLtkUNRdEszYVXfJoNhQTKCou2RQ1F0y7i66SwZF3SWDou6SQPGmu2RQ1F0yKOouGRR1lwyKDcUEirpLBkXdJYOi7pJBUXfJoKi7JFC86y4JZuyuu2RQ1F0yKOouGRQbigl3F90lg6LukkFRd8mgqLtkUNRdEig+dJcMirpLBkXdJYOi7pJBsaGYQFF3yaCou2RQ1F0yKOouCWbsobvEKbaD7pJBUXfJoKi7xO8u7aC7ZFBsKCZQ1F0yKOouGRR1lwyKuksGRd0lgeJRd8mgqLtkUNRdMijqLhkUG4oJFHWXDIq6S4IZO+ouGRR1lwyKuksCxZPuknB3OekuGRR1lwyKuksGxYZiAkXdJYOi7pJBUXfJoKi7ZFDUXRIonnWXDIq6SwZF3SWDou6SQbGhGDdjZ90lg6LukkFRd8mgqLtk3F10lwSKTXfJoKi7ZFDUXTIo6i4ZFBuKCRR1lwyKuksGRd0lg6LukkFRd0mgeNFdMijqLhkUdZcEM3bRXTIoNhQTKOouGRR1l4y7i+6SQVF3yaCouyRQvOouGRR1lwyKuksGRd0lg2JDMYGi7pJBUXfJoKi7ZFDUXTIo6i4JFG+6S4IZu+kuGRR1lwyKuksGxYZiwt1Fd8mgqLtkUNRdMijqLhkUdZcEinfdJYOi7pJBUXfJoKi7ZFBsKCZQ1F0yKOouGRR1lwyKukuCGbvrLgkUH7pLBkXdJeF78aG7ZFDUXTIoNhQTKOouGRR1lwyKukvGpqO7ZFDUXeIULwfdJf69eDnoLhkUdZcMirpLBsWGYgJF3SWDou6SsenoLhkUdZcMirpLAsWj7pJwdznqLhkUdZcMirpLBsWGYgJF3SWDou6SQVF3yaCou2RQ1F0SKJ50lwyKusu/QvF+uj+vvp8PPcW9dpcfv/mTy6WdP119PpyfV5+Pj18p9hf/+MnPiy+nduyR77XofCPyBvls5HutUN+IfK996xuR77WcfSPyvTa5b0S+19r3fcjPe+2I34h8r4XyG5Frn9ORa5/TkTfIZyPXPqcj1z6nI9c+pyPXPqcj1z5nI2/a53Tk2ud05NrndOTa53TkDfLZyLXP6ci1z+nItc/pyLXP6ci1z9nIL9rndOTa53Tk2ud05NrndOQN8tnItc/pyLXP6ci1z+nItc/pyLXP2civ2ud05NrndOTa53Tk2ud05A3y2ci1z+nItc/pyLXP6ci1z+nItc/ZyG/a53Tk2ue/gvzDC3lvCmUGRR0xg2JDMYGiJvevUPzwmrqbcpZBUd/KoKhCZVDUihIo3hWdhHv0XXfJoKi7ZFDUXTIoNhQT7i66SwZF3SWDou6SQVF3yaCouyRQfOguGRR1lwyKuksGRd0lg2JDMYGi7pJBUXfJoKi7ZFDUXRLM2EN3iVO8HnSXDIq6SwZF3SV+d7kedJcMig3FBIq6SwZF3SWDou6SQVF3yaCouyRQPOouGRR1lwyKuksGRd0lg2JDMYGi7pJBUXdJMGNH3SWDou6SQVF3SaB40l0S7i4n3SWDou6SQVF3yaDYUEygqLtkUNRdMijqLhkUdZcMirpLAsWz7pJBUXfJoKi7ZFDUXTIoNhTjZuysu2RQ1F0yKOouGRR1l4y7i+6SQLHpLhkUdZcMirpLBkXdJYNiQzGBou6SQVF3yaCou2RQ1F0yKOouCRQvuksGRd0lg6LukmDGLrpLBsWGYgJF3SWDou6ScXfRXTIo6i4ZFHWXBIpX3SWDou6SQVF3yaCou2RQbCgmUNRdMijqLhkUdZcMirpLBkXdJYHiTXdJMGM33SWDou6SQVF3yaDYUEy4u+guGRR1lwyKuksGRd0lg6LukkDxrrtkUNRdMijqLhkUdZcMig3FBIq6SwZF3SWDou6SQVF3STBjd90lgeJDd8mgqLtkUNRdEu4uD90lg2JDMYGi7pJBUXfJoKi7ZFDUXTIo6i5xireD7pJBUXfJoKi7ZFDUXTIoNhQTKOouGRR1l7gZux10lwyKuksGRd0lgeJRd0m4uxx1lwyKuksGRd0lg2JDMYGi7pJBUXfJoKi7ZFDUXTIo6i4JFE+6SwZF3SWDou6SQVF3yaDYUIybsZPukkFRd8mgqLtkUNRdMu4uuksCxbPukkFRd8mgqLtkUNRdMig2FBMo6i4ZFHWXDIq6SwZF3SWDou6SQLHpLhkUdZcMirpLghlruksGxYZiAkXdJYOi7pJxd9FdMijqLhkUdZcEihfdJYOi7pJBUXfJoKi7ZFBsKCZQ1F0yKOouGRR1lwyKuksGRd0lgeJVd0kwY1fdJYOi7pJBUXfJoNhQTLi76C4ZFHWXDIq6SwZF3SWDou6SQPGmu2RQ1F0yKOouGRR1lwyKDcUEirpLBkXdJYOi7pJBUXdJMGM33SWB4l13yaCou2RQ1F0S7i533SWDYkMxgaLukkFRd8mgqLtkUNRdMijqLgkUH7pLBkXdJYOi7pJBUXfJoNhQTKCou2RQ1F0SzNhDd8mgqLtkUNRd4hTvB90lfnf5gQjFBIq6SwZF3SWDYkMxgaLukkFRd8mgqLtkUNRdMijqLgkUj7pLBkXdJYOi7pJBUXfJoNhQjJuxo+6SQVF3yaCou2RQ1F0y7i66SwLFk+6SQVF3yaCou2RQ1F0yKDYUEyjqLhkUdZcMirpLBkXdJYOi7pJA8ay7ZFDUXTIo6i4JZuysu2RQbCgmUNRdMijqLhl3F90lg6LukkFRd0mg2HSXDIq6SwZF3SWDou6SQbGhmEBRd8mgqLtkUNRdMijqLhkUdZcEihfdJcGMXXSXDIq6SwZF3SWDYkMx4e6iu2RQ1F0yKOouGRR1lwyKuksCxavukkFRd8mgqLtkUNRdMig2FBMo6i4ZFHWXDIq6SwZF3SXBjF11lwSKN90lg6LukkFRd0m4u9x0lwyKDcUEirpLBkXdJYOi7pJBUXfJoKi7JFC86y4ZFHWXDIq6SwZF3SWDYkMxgaLukkFRd0kwY3fdJYOi7pJBUXdJoPjQXRLuLg/dJYOi7pJBUXfJoNhQTKCou2RQ1F0yKOouGRR1lwyKukuc4uOgu2RQ1F0yKOouGRR1lwyKDcWwGXscdJcMirpLBkXdJYOi7pJxd9FdEigedZcMirpLBkXdJYOi7pJBsaGYQFF3yaCou2RQ1F0yKOouGRR1lwSKJ90lg6LukkFRd0kwYyfdJYNiQzGBou6SQVF3ybi76C4ZFHWXDIq6SwLFs+6SQVF3yaCou2RQ1F0yKDYUEyjqLhkUdZcMirpLBkXdJYOi7pJAsekuCWas6S4ZFHWXDIq6SwbFhmLC3UV3yaCou2RQ1F0yKOouGRR1lwSKF90lg6LukkFRd8mgqLtkUGwoJlDUXTIo6i4ZFHWXDIq6S4IZu+guCRSvuksGRd0lg6LuknB3ueouGRQbigkUdZcMirpLBkXdJYOi7pJBUXdJoHjTXTIo6i4ZFHWXDIq6SwbFhmICRd0lg6LukmDGbrpLBkXdJYOi7pJA8a67JNxd7rpLBkXdJYOi7pJBsaGYQFF3yaCou2RQ1F0yKOouGRR1lwSKD90lg6LukkFRd8mgqLtkUGwoxs3YQ3fJoKi7ZFDUXTIo6i4ZdxfdJUzxfjjoLhkUdZcMirpLBkXdJYNiQzGBou6SQVF3yaCou2RQ1F0yKOouCRSPuksGRd0lg6LuEjZjPwjpLhkUG4oJFHWXDIq6S8bdRXfJoKi7ZFDUXRIonnSXDIq6SwZF3SWDou6SQbGhmEBRd8mgqLtkUNRdMijqLhkUdZcEimfdJcGMnXWXDIq6SwZF3SWDYkMx4e6iu2RQ1F0yKOouGRR1lwyKuksCxaa7ZFDUXTIo6i4ZFHWXDIoNxQSKuksGRd0lg6LukkFRd0kwY013SaB40V0yKOouGRR1l4S7y0V3yaDYUEygqLtkUNRdMijqLhkUdZcMirpLAsWr7pJBUXfJoKi7ZFDUXTIoNhQTKOouGRR1lwQzdtVdMijqLhkUdZcEijfdJeHuctNdMijqLhkUdZcMig3FBIq6SwZF3SWDou6SQVF3yaCouyRQvOsuGRR1lwyKuksGRd0lg2JDMW7G7rpLBkXdJYOi7pLxvai7ZFDUXRIoPnSXDIq6SwZF3SWDou6SsOk8GooJFHWXDIq6S8b3ou6SQVF3yaCou8QpHg+6SwZF3SWDou4S33SOB90lg2JDMYGi7pJBUXfJuLvoLhkUdZcMirpLAsWj7pJBUXfJoKi7ZFDUXTIoNhQTKOouGRR1lwyKusu/QvF+uj+vvp8PPcXddpf7F8XrsX26+nw4P68+Hx+/Uuwv/pHP8+LLqR175LstOt+G/LTbVvR9yHdbob4P+W771vch3205+z7kDfLZyHdb+74P+W474vch322h/D7k2ud05NrnbORn7XM6cu1zOnLtczpy7XM68gb5bOTa53Tk2ud05NrndOTa53Tk2uds5E37nI5c+5yOXPucjlz7nI68QT4bufY5Hbn2OR259jkdufY5Hbn2ORv5Rfucjlz7nI5c+5yOXPucjrxBPhu59jkdufY5Hbn2OR259jkdufY5G/lV+5yOXPucjlz7nI5c+5yOvEE+G7n2OR259jkdufb5ryD/8ELeq0KZQVFHTKB4U/syKGpy/wrFD6+puylnGRT1rQyKDcUEilpRBkVFJ+MerbtkUNRdMijqLgkU77pLwt3lrrtkUNRdMijqLhkUG4oJFHWXDIq6SwZF3SWDou6SQVF3SaD40F0yKOouGRR1lwyKuksGxYZi3Iw9dJcMirpLBkXdJYOi7pJxd9Fd4hRPB90lg6LukkFRd8mgqLtkUGwoJlDUXTIo6i4ZFHWXDIq6SwZF3SWB4lF3yaCou2RQ1F3iZux01F0yKDYUEyjqLhkUdZeMu4vukkFRd8mgqLskUDzpLhkUdZcMirpLBkXdJYNiQzGBou6SQVF3yaCou2RQ1F0yKOouCRTPukuCGTvrLhkUdZcMirpLBsWGYsLdRXfJoKi7ZFDUXTIo6i4ZFHWXBIpNd8mgqLtkUNRdMijqLhkUG4oJFHWXDIq6SwZF3SWDou6SYMaa7pJA8aK7ZFDUXTIo6i4Jd5eL7pJBsaGYQFF3yaCou2RQ1F0yKOouGRR1lwSKV90lg6LukkFRd8mgqLtkUGwoJlDUXTIo6i4JZuyqu2RQ1F0yKOouCRRvukvC3eWmu2RQ1F0yKOouGRQbigkUdZcMirpLBkXdJYOi7pJBUXdJoHjXXTIo6i4ZFHWXDIq6SwbFhmLcjN11lwyKuksGRd0lg6LuknF30V0SKD50lwyKuksGRd0lg6LukkGxoZhAUXfJoKi7ZFDUXTIo6i4ZFHWXOMXzQXfJoKi7ZFDUXeJm7HzQXTIoNhQTKOouGRR1l4y7i+6SQVF3yaCouyRQPOouGRR1lwyKuksGRd0lg2JDMYGi7pJBUXfJoKi7ZFDUXTIo6i4JFE+6S4IZO+kuGRR1lwyKuksGxYZiwt1Fd8mgqLtkUNRdMijqLhkUdZcEimfdJYOi7pJBUXfJoKi7ZFBsKCZQ1F0yKOouGRR1lwyKukuCGTvrLgkUm+6SQVF3yaCouyTcXZrukkGxoZhAUXfJoKi7ZFDUXTIo6i4ZFHWXBIoX3SWDou6SQVF3yaCou2RQbCgmUNRdMijqLglm7KK7ZFDUXTIo6i4JFK+6S8Ld5aq7ZFDUXTIo6i4ZFBuKCRR1lwyKuksGRd0lg6LukkFRd0mgeNNdMijqLhkUdZcMirpLBsWGYtyM3XSXDIq6SwZF3SWDou6ScXfRXRIo3nWXDIq6SwZF3SWDou6SQbGhmEBRd8mgqLtkUNRdMijqLhkUdZcEig/dJYOi7pJBUXdJMGMP3SWDYkMxgaLukkFRd8m4u+guGRR1lwyKukucYjvoLhkUdZcMirpLBkXdJYNiQzGBou6SQVF3yaCou2RQ1F0yKOouCRSPukvcjLWj7pJBUXfJoKi7ZFBsKCbcXXSXDIq6SwZF3SWDou6SQVF3SaB40l0yKOouGRR1lwyKuksGxYZiAkXdJYOi7pJBUXfJoKi7JJixk+6SQPGsu2RQ1F0yKOouCXeXs+6SQbGhmEBRd8mgqLtkUNRdMijqLhkUdZcEik13yaCou2RQ1F0yKOouGRQbigkUdZcMirpLghlruksGRd0lg6LukkDxorsk3F0uuksGRd0lg6LukkGxoZhAUXfJoKi7ZFDUXTIo6i4ZFHWXBIpX3SWDou6SQVF3yaCou2RQbCjGzdhVd8mgqLtkUNRdMijqLhl3F90lgeJNd8mgqLtkUNRdMijqLhkUG4oJFHWXDIq6SwZF3SWDou6SQVF3SaB4110yKOouGRR1lwQzdtddMig2FBMo6i4ZFHWXjLuL7pJBUXfJoKi7JFB86C4ZFHWXDIq6SwZF3SWDYkMxgaLukkFRd8mgqLtkUNRdMijqLnGKl4PuEjdjl4PukkFRd8mgqLtkUGwoJtxddJcMirpLBkXdJYOi7pJBUXdJoHjUXTIo6i4ZFHWXDIq6SwbFhmICRd0lg6LukkFRd8mgqLskmLGj7pJA8aS7ZFDUXTIo6i4Jd5eT7pJBsaGYQFF3yaCou2RQ1F0yKOouGRR1lwSKZ90lg6LukkFRd8mgqLtkUGwoJlDUXTIo6i4JZuysu2RQ1F0yKOouCRSb7pJwd2m6SwZF3SWDou6SQbGhmEBRd8mgqLtkUNRdMijqLhkUdZcEihfdJYOi7pJBUXfJoKi7ZFBsKMbN2EV3yaCou2RQ1F0yKOouGXcX3SWB4lV3yaCou2RQ1F0yKOouGRQbigkUdZcMirpLBkXdJYOi7pJBUXdJoHjTXTIo6i4ZFHWXBDN2010yKDYUEyjqLhkUdZeMu4vukkFRd8mgqLskULzrLhkUdZcMirpLBkXdJYNiQzGBou6SQVF3yaCou2RQ1F0yKOouCRQfukuCGXvoLhkUdZcMirpLBsWGYsLdRXfJoKi7ZFDUXTIo6i4ZFHWXOMXrQXfJoKi7ZFDUXTIo6i4ZFBuKCRR1lwyKuksGRd0lg6LuEjdj14PukkDxqLtkUNRdMijqLgl3l6PukkGxoZhAUXfJoKi7ZFDUXTIo6i4ZFHWXBIon3SWDou6SQVF3yaCou2RQbCgmUNRdMijqLglm7KS7ZFDUXTIo6i4JFM+6S8Ld5ay7ZFDUXTIo6i4ZFBuKCRR1lwyKuksGRd0lg6LukkFRd0mg2HSXDIq6SwZF3SWDou6SQbGhGDdjTXfJoKi7ZFDUXTIo6i4ZdxfdJYHiRXfJoKi7ZFDUXTIo6i4ZFBuKCRR1lwyKuksGRd0lg6LukkFRd0mgeNVdMijqLhkUdZcEM3bVXTIoNhQTKOouGRR1l4y7i+6SQVF3yaCouyRQvOkuGRR1lwyKuksGRd0lg2JDMYGi7pJBUXfJoKi7ZFDUXTIo6i4JFO+6S4IZu+suGRR1lwyKukvG92JDMYGi7pJBUXfJoKi7ZFDUXTIo6i4Jm85Dd8mgqLtkUNRdEr4XH7pLBsWGYgJF3SWDou6SQVF3yaCou2RsOrpLnOLtoLtkUNRdMijqLvG7y+2gu2RQbCgmUNRdMijqLhkUdZcMirpLBkXdJYHiUXfJoKi7ZFDUXTIo6i7/CsX76f68+n4+9BTbTileL+2L4uPy4er79fmj7/dff/IT4l6ry29BfFyfFz/uh3+AOPjJ58P5+ZPPx8evY9tffPnxe/394supHfsZ32sn2kg8ey1bG4lnry1uI/HstR5uI57TXnvnRuLZa6HdSDx7bcobiWevFXwj8TTxVI6HNSgdD2tQOh7WoHQ8rEHpeFiDyvGcWYPS8bAGpeNhDUrHwxqUjqeJp3I8rEHpeFiD0vGwBqXjYQ1Kx8MaVI6nsQal42ENSsfDGpSOhzUoHU8TT+V4WIPS8bAGpeNhDUrHwxqUjoc1qBzPhTUoHQ9rUDoe1qB0PKxB6XiaeCrHwxqUjoc1KB0Pa1A6HtagdDysQeV4rqxB6XhYg9LxsAal42ENSsfTxFM5HtYgO54Ph2FciYDZxHX72cTV9dnENfBs4h9eaX1TqmcT15NnE1d9ZxPXZmcTb4jP3VVuOuds4jrnbOI652ziOufsO6fOOZn4XeecTVznnE1c55xNXOecTbwhPpm4zjmbuM45m7jOOZu4zjmbuM45mfhD55xNXOecTVznnGxrHzrnbOIN8cnEdc7ZxHXO2XdOnXM2cZ1zNnGdcy7x+0HnnE1c55xNXOecTVznnE28IT6ZuM45m7jOOZu4zjmbuM45m7jOOZn4Ueeca2vvR51zNnGdczZxnXM28Yb45DunzjmbuM45m7jOOZu4zjmbuM45mfhJ55xNXOecTVznnE1c55xNvCE+mbjOOZu4zjmbuM45m7jOOdnWnnTOycTPOuds4jrnbOI65+Q751nnnE28IT6ZuM45m7jOOZu4zjmbuM45m7jOOZl40zlnE9c5ZxPXOWcT1zlnE2+ITyauc84mrnNOtrVN55xNXOecTVznnEz8onNOvnNedM7ZxHXO2cR1ztnEG+KTieucs4nrnLOJ65yzieucs4nrnJOJX3XO2cR1ztnEdc7ZxHXO2cQb4nNt7VXnnE1c55xNXOecTVznnH3n1DknE7/pnLOJ65yzieucs4nrnLOJN8QnE9c5ZxPXOWcT1zlnE9c5ZxPXOScTv+ucs4nrnLOJ65yTbe1d55xNvCE+mbjOOZu4zjn7zqlzziauc84mrnNOJv7QOWcT1zlnE9c5ZxPXOWcTb4hPJq5zziauc84mrnPOJq5zziauc84l/jjonHNt7eOgc84mrnPOJq5zzibeEJ9859Q5ZxPXOWcT1zlnE9c5ZxPXOScTP+qcs4nrnLOJ65yzieucs4k3xCcT1zlnE9c5ZxPXOWcT1zkn29qjzjmZ+EnnnE1c55xNXOecfOc86ZyziTfEJxPXOWcT1zlnE9c5ZxPXOWcT1zknEz/rnLOJ65yzieucs4nrnLOJN8QnE9c5ZxPXOSfb2rPOOZu4zjmbuM45mXjTOSffOZvOOZu4zjmbuM45m3hDfDJxnXM2cZ1zNnGdczZxnXM2cZ1zMvGLzjmbuM45m7jOOZu4zjmbeEN8rq296Jyzieucs4nrnLOJ65yz75w652TiV51zNnGdczZxnXM2cZ1zNvGG+GTiOuds4jrnbOI652ziOuds4jrnZOI3nXM2cZ1zNnGdc7Ktvemcs4k3xCcT1zlnE9c5Z985dc7ZxHXO2cR1zsnE7zrnbOI652ziOuds4jrnbOIN8cnEdc7ZxHXO2cR1ztnEdc7ZxHXOycQfOudkW/vQOWcT1zlnE9c5ZxNviE++c+qcs4nrnLOJ65yzieucs4nrnFOJPw4HnXM2cZ1zNnGdczZxnXM28Yb4ZOI652ziOuds4jrnbOI651Rb+4O4zjmZ+FHnnE1c55xNXOecfOc86pyziTfEJxPXOWcT1zlnE9c5ZxPXOWcT1zknEz/pnLOJ65yzieucs4nrnLOJN8QnE9c5ZxPXOSfb2pPOOZu4zjmbuM45mfhZ55x85zzrnLOJ65yzieucs4k3xCcT1zlnE9c5ZxPXOWcT1zlnE9c5JxNvOuds4jrnbOI652ziOuds4g3xuba26Zyzieucs4nrnLOJ65yz75w652TiF51zNnGdczZxnXM2cZ1zNvGG+GTiOuds4jrnbOI652ziOuds4jrnZOJXnXM2cZ1zNnGdc7Ktveqcs4k3xCcT1zlnE9c5Z985dc7ZxHXO2cR1zsnEbzrnbOI652ziOuds4jrnbOIN8cnEdc7ZxHXO2cR1ztnEdc7ZxHXOycTvOudkW3vXOWcT1zlnE9c5ZxNviE++c+qcs4nrnLOJ65yzieucs4nrnJOJP3TO2cR1ztnEdc7ZxHXO2cQb4pOJ65yzieucs4nrnLOJ65yTbe1D55xL/HjQOWcT1zlnE9c55945jwedczbxhvhk4jrnbOI652ziOuds4jrnbOI652TiR51zNnGdczZxnXM2cZ1zNvGG+GTiOuds4jrnZFt71DlnE9c5ZxPXOScTP+mck++cJ51zNnGdczZxnXM28Yb4ZOI652ziOuds4jrnbOI652ziOudk4medczZxnXM2cZ1zNnGdczbxhvj/19657TayZVf2X85zPcRl7bh8TKFRNhqNAgpVDbu6AcOof7cyT5LSSZFiMmJyaoox/GD4wNyh4BhbihhLTIV3WjvSnG7iNKebOM3pJk5zuq+cNKeZeNGcbuI0p5s4zekmTnO6iRfEzcRpTjdxmtNNnOZ0E6c53cRpTjPxRnO6idOcbuI0p3la22hON/GCuJk4zekmTnO6r5w0p5s4zekmTnOaiU80p5s4zekmTnO6idOcbuIFcTNxmtNNnOZ0E6c53cRpTjdxmtNMfKY5zdPameZ0E6c53cRpTjfxgrj5yklzuonTnG7iNKebOM3pJk5zmokvNKebOM3pJk5zuonTnG7iBXEzcZrTTZzmdBOnOd3EaU7ztHahOc3EV5rTTZzmdBOnOc1XzpXmdBMviJuJ05xu4jSnmzjN6SZOc7qJ05xe4kNHc7qJ05xu4jSnmzjN6SZeEDcTpzndxGlO77R26GhON3Ga002c5jQT72lO85WzpzndxGlON3Ga0028IG4mTnO6idOcbuI0p5s4zekmTnOaiQ80p5s4zekmTnO6idOcbuIFce+0dqA53cRpTjdxmtNNnOZ0XzlpTjPxkeZ0E6c53cRpTjdxmtNNvCBuJk5zuonTnG7iNKebOM3pJk5zmokXzekmTnO6idOc5mlt0Zxu4gVxM3Ga002c5nRfOWlON3Ga002c5jQTbzSnmzjN6SZOc7qJ05xu4gVxM3Ga002c5nQTpzndxGlON3Ga00x8ojnN09qJ5nQTpzndxGlON/GCuPnKSXO6idOcbuI0p5s4zekmTnOaic80p5s4zekmTnO6idOcbuIFcTNxmtNNnOZ0E6c53cRpTvO0dqY5zcQXmtNNnOY0/xxfaE43cZrTTbwgbiZOc7qJ05xu4jSn++6Q5nQTpznNxFea0/xzfKU53cRpTjdxmtNNvCBuJk5zuonTnO67Q5rTTZzmdBOnOb3Ex47m9F45x47mdBOnOd3EaU438YK4mTjN6SZOc7qJ05xu4jSnmzjNaSbe05xu4jSnmvgyLKcjL2P3njjN+QvE+xpP06m+2nSD+TQOp1dPY9Vb5pfoTSdBLyBfDz20Sy8e+/X04nFob1/8u0169plsFjafyCYd/kw2afyvZLPqxG+stry3yfzgmWwym/hSNucz61qHj188rMv5yF3X3XhxtXYyU/Py8Ytbd3ptG/v3mcTwhS2l3VID0yW21PcttZ6OPLSh27WlGJ+xpcRbivkgW+rbi+fxRG+Y53bjxV2d3uAL9Nq1/5hosv8+c/8V+4/9d/f+m0/Dw6Hvhl37j6kx++8z9x9z7mfdf2M31Hn/jTeOPIzLef9VN7598e/7hAk6+0Q8IGOMz5YSbynG+Gwp7ZYaGeOzpbQz15ExPltKvKUY47OlvpmZzttkmN7ukx8ZNzJuZ5/8yj4p9gn75Bf2CeNr9smv7BPGzOyTf975a45+OWvs1/79THpkJs2mkm8qptJsqns3lfADKSMjbPbfJ+6/Yt7N/vvM/cdwnP13//6TfSCqmKSz/z5z/zGhf9r915//OtLYjzs7tYp9wj75hX3ChJ59Ir5FZ5jPlhJvKUb5bCnxlmKQz5YStxmzebaUdks1xu1faUu1Np5e3KYb/67gvn//eePf3zXG4uyTby/W/cuWxqSbLSXeUgyv2VLiLVVsKbbUb8p/LNUYibOlxFuKkThb6tuLb/w7iMacm33yK/uE4TX75Ff2CRNp9skv7JOJMTP75NuLlf9UamImzaaSbyqm0myqezeV8GMjEyNs9t9n7r9i/7H/PnH/MRxn/92//2QfiJqYpLP/PnP/MaF/1v33WX9CeGKYz5YSbynm/myp71tK9hGGmV8RsKXEW4pfELClPnGWMfO7BPbfZ+4/fpfA/vvEWcZc7D/23yfuP36X8LT7T/k3imZm/uyTX9knzObZJ+JbdGbzbCnxlmI2z5bSbqmF2TxbSttmC7N5tpR4SzFu/5UttZwh9svQ/2FL/Y6RqbEEY4FRgZEZngQjI657MfZ1ASMTIAlGph4SjJS+AuNK3UowUnSKK/VKxUgwUjESjAVGBUYqRoKRipFgpGIkGKkYCUYqRoCxOipGgpGKkWCkYnb+eu93jFSMBGOBUYGRipFgpGIkGI9aMWt/OpN6ofCHV/8O5qhdchPMUUvjFpj+qO1wE8xRa+AmmKPe398Ec9Q79ptgCjCXwRz1rvommKPeJ98Ew53vFTDc+V4Bw53vZTADd75XwHDnewUMd75XwHDnewVMAeYyGO58r4DhzvcKGO58r4DhzvcKGO58L4MZufO9AoY73ytguPO9AoY73ytgCjCXwXDnewUMd75XwHDnewXMQe98Wzeejt36ubvx6r4b1vPBX1au59cPfXfp9dWd/jpI/1Jd51ePdfFt9udPg/Zv/tLQy4t/V3TQe/AvpKgOWgNfSdFBu+ReReM4viqq+ZaiZT7/zc/lzblsU3TQQvpKig7aal9JUaGoX4ZbN8ZjdzL0MrJ6cyW69Mfe2su5ng49VP/2xb8jP2iPfibyg5buZyI/aEN/JnLq3I6c2nYjb9SzHTk1bEdO3dqRU6t25AVyN3Lq046c+rQjpz7tyKlPO3Lq0418oj7tyKlPO3Lq046c+rQjL5C7kVOfduTUpx059WlHTn3akVOfbuQz9WlHTn3akVOfduTUpx15gdyNnPq0I6c+7cipTzty6tOOnPp0I1+oTzty6tOOnPq0I6c+7cgL5G7k1KcdOfVpR0592pFTn3bk1Kcb+Up92pFTn3bk1KcdOfX5K8indnpEaE3T/J5iQVFAkUZUUCT7FBQpuV+hOHfnv5k79xcoEmcKivTWfoqtI6EUFKkiBUVCZ/81+uVgUBRQLCgKKNIuCoq0i+LqQrsoKNIuCoq0i4BiT7soKNIuCoq0i4Ii7aKgWFAUUKRdFBRpFwVF2kVBkXZRUKRdBBQH2kUwGRtoFwVF2kVBkXZRUCwoCq4utIuCIu2ioEi7KCjSLgqKtIuA4ki7KCjSLgqKtIuCIu2ioFhQFFCkXRQUaRcFRdpFQZF2EUzGRtpFQLFoFwVF2kVBkXYRXF2KdlFQLCgKKNIuCoq0i4Ii7aKgSLsoKNIuAoqNdlFQpF0UFGkXBUXaRUGxoCigSLsoKNIugslYo10UFGkXBUXaRUBxol0EV5eJdlFQpF0UFGkXBcWCooAi7aKgSLsoKNIuCoq0i4Ii7SKgONMuCoq0i4Ii7aKgSLsoKBYU90/GZtpFQZF2UVCkXRQUaRfF1YV2EVBcaBcFRdpFQZF2UVCkXRQUC4oCirSLgiLtoqBIuygo0i4KirSLgOJKuygo0i4KirSLYDK20i4KigVFAUXaRUGRdlFcXWgXBUXaRUGRdtlPcepoFwVF2kVBkXZRUKRdFBQLigKKtIuCIu2ioEi7KCjSLgqKtIuAYk+77J+MTT3toqBIuygo0i4KigVFwdWFdlFQpF0UFGkXBUXaRUGRdhFQHGgXBUXaRUGRdlFQpF0UFAuKAoq0i4Ii7aKgSLsoKNIugsnYQLsIKI60i4Ii7aKgSLsIri4j7aKgWFAUUKRdFBRpFwVF2kVBkXZRUKRdBBSLdlFQpF0UFGkXBUXaRUGxoCigSLsoKNIugslY0S4KirSLgiLtIqDYaBfB1aXRLgqKtIuCIu2ioFhQFFCkXRQUaRcFRdpFQZF2UVCkXQQUJ9pFQZF2UVCkXRQUaRcFxYLi/snYRLsoKNIuCoq0i4Ii7aK4utAuAooz7aKgSLsoKNIuCoq0i4JiQVFAkXZRUKRdFBRpFwVF2kVBkXYRUFxoFwVF2kVBkXYRTMYW2kVBsaAooEi7KCjSLoqrC+2ioEi7KCjSLgKKK+2ioEi7KCjSLgqKtIuCYkFRQJF2UVCkXRQUaRcFRdpFQZF22U9x7miX/ZOxuaNdFBRpFwVF2kVBsaAouLrQLgqKtIuCIu2ioEi7KCjSLgKKPe2ioEi7KCjSLgqKtIuCYkFRQJF2UVCkXRQUaRcFRdpFMBnraRcBxYF2UVCkXRQUaRfB1WWgXRQUC4oCirSLgiLtoqBIuygo0i4KirSLgOJIuygo0i4KirSLgiLtoqBYUBRQpF0UFGkXwWRspF0UFGkXBUXaRUCxaBfB1aVoFwVF2kVBkXZRUCwoCijSLgqKtIuCIu2ioEi7KCjSLgKKjXZRUKRdFBRpFwVF2kVBsaC4fzLWaBcFRdpFQZF2UVCkXRRXF9pFQHGiXRQUaRcFRdpFQZF2UVAsKAoo0i4KirSLgiLtoqBIuygo0i4CijPtoqBIuygo0i6CydhMuygoFhQFFGkXBUXaRXF1oV0UFGkXBUXaRUBxoV0UFGkXBUXaRUGRdlFQLCgKKNIuCoq0i4Ii7aKgSLsoKNIuAoor7SKYjK20i4Ii7aKgSLsoKBYUBVcX2kVBkXZRUKRdFBRpFwVF2mU/xaWjXRQUaRcFRdpFQZF2UVAsKAoo0i4KirSLgiLtoqBIu+yfjC0d7SKg2NMuCoq0i4Ii7SK4uvS0i4JiQVFAkXZRUKRdFBRpFwVF2kVBkXYRUBxoFwVF2kVBkXZRUKRdFBQLigKKtIuCIu0imIwNtIuCIu2ioEi7CCiOtIvg6jLSLgqKtIuCIu2ioFhQFFCkXRQUaRcFRdpFQZF2UVCkXQQUi3ZRUKRdFBRpFwVF2kVBsaC4fzJWtIuCIu2ioEi7KCjSLoqrC+0ioNhoFwVF2kVBkXZRUKRdFBQLigKKtIuCIu2ioEi7KCjSLgqKtIuA4kS7KCjSLgqKtItgMjbRLgqKBUUBRdpFQZF2UVxdaBcFRdpFQZF2EVCcaRcFRdpFQZF2UVCkXRQUC4oCirSLgiLtoqBIuygo0i4KirSLgOJCuwgmYwvtoqBIuygo0i4KigVFwdWFdlFQpF0UFGkXBUXaRUGRdhFQXGkXBUXaRUGRdlFQpF0UFAuKAoq0i4Ii7aKgSLsoKNIugsnYSrvsp7h2tIuCIu2ioEi77L+6rB3toqBYUBRQpF0UFGkXBUXaRUGRdlFQpF0EFHvaRUGRdlFQpF0UFGkXBcWCooAi7aKgSLsIJmM97aKgSLsoKNIuAooD7SK4ugy0i4Ii7aKgSLsoKBYUBRRpFwVF2kVBkXZRUKRdFBRpFwHFkXZRUKRdFBRpFwVF2kVBsaC4fzI20i4KirSLgiLtoqBIuyiuLrSLgGLRLgqKtIuCIu2ioEi7KCgWFAUUaRcFRdpFQZF2UVCkXRQUaRcBxUa7KCjSLgqKtItgMtZoFwXFgqKAIu2ioEi7KK4utIuCIu2ioEi7CChOtIuCIu2ioEi7KCjSLgqKBUUBRdpFQZF2UVCkXRQUaRcFRdpFQHGmXQSTsZl2UVCkXRQUaRcFxYKi4OpCuygo0i4KirSLgiLtoqBIuwgoLrSLgiLtoqBIuygo0i4KigVFAUXaRUGRdlFQpF0UFGkXwWRsoV0EFFfaRUGRdlFQpF0EV5eVdlFQLCgKKNIuCoq0i4Ii7aKgSLsoKNIuuyn23cv/gFGBkXqRYCRfJBjpFwnGAqMCIwUjwUjC7B6QfcNIw0gwEjESjFSM4mdjT8VIMFIxEoxUjAQjFSPBWGBUYKRiFDc8PRUjwUjFSDBSMZKfjVSMAuNAxUgwUjESjFSMBCMVI8FYYBTc8AxUjAQjFSPBSMVIMFIxkksMFaPAOFIxEoxUjAQjFSPBSMVIMBYYFRipGAlGKkaCkYqRYKRiJBipmF/BuAzLCeMydu8x1lErZqw6YRzn9Q+v/kHmqGFym8zztEZ17fTqGuYbZJbphHFZ3lI8fy89TzzcxWWdThtmXbo/cLnwA2nsxtMPpLFf3/5AurAVX870tBWH6i/89CqIm4k/T5J8FeLPUy9fhfjzhM5XIf48TfRViD9PPn0R4u15SuurEH+egvsqxA9ahp9InOZ0Ey+Im4nTnG7iNKebOM3pJk5zuonTnGbiE83pJk5zuonTnG7iNKebeEHcTJzmdBOnOd3EaU43cZrTTZzmNBOfaU43cZrTTZzmdBOnOd3EC+Jm4jSnmzjN6SZOc7qJ05xu4jSnmfhCc7qJ05xu4jSnmzjN6SZeEDcTpzndxGlON3Ga002c5nQTpznNxFea002c5nQTpzndxGnO28Rv/aHwtYC4HyJlKIBI7Akg0m+3Id76e5krSSaASGXthviCEYj7IdJCAojkze6rc99RLAKIBcT9ECkWAUSKRXBhoVgEECkWAUSKZT/EnmIRQKRYBBApFgFEikUAsYC4HyLFIoBIsQggUiwCiBSLACLFsh/iQLHsH4UNFIsAIsUigEixCCAWEPdfWCgWAUSKRQCRYhFApFgEECmW/RBHikUAkWIRQKRYBBApFgHEAuJ+iBSLACLFIoBIsQggUiz7R2EjxbIfYlEsAogUiwAixbL/wlIUiwBiAXE/RIpFAJFiEUCkWAQQKRYBRIplP8RGsQggUiwCiBSLACLFIoBYQNwPkWIRQKRY9o/CGsUigEixCCBSLPshThTL/gvLRLEIIFIsAogUiwBiAXE/RIpFAJFiEUCkWAQQKRYBRIplP8SZYhFApFgEECkWAUSKRQCxgLh7FDZTLAKIFIsAIsUigEixCC4sFMt+iAvFIoBIsQggUiwCiBSLAGIBcT9EikUAkWIRQKRYBBApFgFEimU/xJViEUCkWAQQKZb9ozCeea+AWEDcD5FiEUCkWAQXFopFAJFiEUCkWHZDHHjmvQIixSKASLEIIFIsAogFxP0QKRYBRIpFAJFiEUCkWAQQKZb9EHnm/f5R2MAz7xUQKRYBRIpFALGAuP/CQrEIIFIsAogUiwAixSKASLHsh8gz7xUQKRYBRIpFAJFiEUAsIO6HSLEIIFIsAogUiwAixbJ/FMYz7wUQeea9AiLFIoBIsey/sPDMewXEAuJ+iBSLACLFIoBIsQggUiwCiBTLfog8814BkWIRQKRYBBApFgHEAuJ+iBSLACLFsn8UxjPvFRApFgFEimU/RJ55L7iw8Mx7BUSKRQCRYhFALCDuh0ixCCBSLAKIFIsAIsUigEix7IfIM+8VECkWAUSKRQCRYhFALCDuHoXxzHsFRIpFAJFiEUCkWAQXFoplP0Seea+ASLEIIFIsAogUiwBiAXE/RIpFAJFiEUCkWAQQKRYBRIplP0Seea+ASLEIIFIs+0dhPPNeAbGAuB8ixSKASLEILiwUiwAixSKASLHsh8gz7xUQKRYBRIpFAJFiEUAsIO6HSLEIIFIsAogUiwAixSKASLHshjjyzPv9o7CRZ94rIFIsAogUiwBiAXH/hYViEUCkWAQQKRYBRIpFAJFi2Q+RZ94rIFIsAogUiwAixSKAWEDcD5FiEUCkWAQQKRYBRIpl/yiMZ94LIPLMewVEikUAkWLZf2HhmfcKiAXE/RApFgFEikUAkWIRQKRYBBAplv0Qeea9AiLFIoBIsQggUiwCiAXE/RApFgFEimX/KIxn3isgUiwCiBTLfog8815wYeGZ9wqIFIsAIsUigFhA3A+RYhFApFgEECkWAUSKRQCRYtkPkWfeKyBSLAKIFIsAIsUigFhA3D0K45n3CogUiwAixSKASLEILiwUy36IPPNeAZFiEUCkWAQQKRYBxALifogUiwAixSKASLEIIFIsAogUy36IPPNeAZFiEUCkWPaPwnjmvQJiAXE/RIpFAJFiEVxYKBYBRIpFAJFi2Q+RZ94rIFIsAogUiwAixSKAWEDcD5FiEUCkWAQQKRYBRIpFAJFi2Q+RZ94LRmE8814BkWIRQKRYBBALiPsvLBSLACLFIoBIsQggUiwCiBTLbojFM+8VECkWAUSKRQCRYhFALCDuh0ixCCBSLAKIFIsAIsWyexRWPPNeAJFn3isgUiwCiBTL/gsLz7xXQCwg7odIsQggUiwCiBSLACLFIoBIseyHyDPvFRApFgFEikUAkWIRQCwg7odIsQggUiz7R2E8814BkWIRQKRY9kPkmfeCCwvPvFdApFgEECkWAcQC4n6IFIsAIsUigEixCCBSLAKIFMt+iDzzXgGRYhFApFgEECkWAcQC4u5RGM+8V0CkWAQQKRYBRIpFcGGhWPZD5Jn3CogUiwAixSKASLEIIBYQ90OkWAQQKRYBRIpFAJFiEUCkWPZD5Jn3CogUiwAixbJ/FMYz7xUQC4j7IVIsAogUi+DCQrEIIFIsAogUy36IPPNeAZFiEUCkWAQQKRYBxALifogUiwAixSKASLEIIFIsAogUy36IPPNeMArjmfcKiBSLACLFIoBYQNx/YaFYBBApFgFEikUAkWIRQKRY9kPkmfcKiBSLACLFIoBIsQggFhD3Q6RYBBApFgFEikUAkWLZPwrjmff7ITaeea+ASLEIIFIsuy8sjWfeKyAWEPdDpFgEECkWAUSKRQCRYhFApFj2Q+SZ9wqIFIsAIsUigEixCCAWEPdDpFgEECmW/aMwnnmvgEixCCBSLPsh8sx7wYWFZ94rIFIsAogUiwBiAXE/RIpFAJFiEUCkWAQQKRYBRIplP0Seea+ASLEIIFIsAogUiwBiAXH3KIxn3isgUiwCiBSLACLFIriwUCz7IfLMewVEikUAkWIRQKRYBBALiPshUiwCiBSLACLFIoBIsQggUiz7IfLMewVEikUAkWLZPwrjmfcKiAXE/RApFgFEikVwYaFYBBApFgFEimU/RJ55r4BIsQggUiwCiBSLAGIBcT9EikUAkWIRQKRYBBApFgFEimU/RJ55LxiF8cx7BUSKRQCRYhFALCDuv7BQLAKIFIsAIsUigEixCCBSLPsh8sx7BUSKRQCRYhFApFgEEAuI+yFSLAKIFIsAIsUigEix7B+F8cx7AUSeea+ASLEIIFIs+y8sPPNeAbGAuB8ixSKASLEIIFIsAogUiwAixbIb4sQz7xUQKRYBRIpFAJFiEUAsIO6HSLEIIFIsu0dhE8+8V0CkWAQQKZb9PxN55r0CIsUigEixCCBSLAKIBcT9ECmW/bc4PPNeAZFiEUCkWAQ/EymW/RB55r0CIsUigEixCCBSLAKIBcTdtzg8814BkWIRQKRYBBApFsGFhWLZD5Fn3isgUiwCiBSLACLFIoBYQNwPkWIRQKRYBBApFgFEikUAkWK5DXEZlhPEZezeQzzqM+/7Gvvzq9t0A+PL7fTp1S/3M/UW4yUe04n5C5rXQw/t0ovHfj29ePz2itcX/xB00Br6OoIOWlpfR9BBK+7rCCoEfaqgqhORsdpyQdBB6/PrCDpo2eYIms/0ah0+fvGwLucjd11348XVTjyGmpePX9zO7NrYX7jXP2i6s0vu2iUHnU0cYZespyMPbej27ZKDDl/YJffsksZ06Vl3yTxOJ9bz3G68uKvTGxxefnTs21LMw9hS4i3FBI8t9W0fzac51dB3w74txcyRLSXeUsWW+jJbauyGOm+p8caRh3E5b6nqxn+9G+815q/Pql44uGkMgdklt3cJQ2B2ye1dwhD4aXeJcLzHEJhdcnOXTAyBn3WXTGcew/RW/SlcJoa1h1XPUPWw6hl+HlZ9of5J1d8z9+6Xs5h+7S9MNCcmmuyTX9knzDTZJ79Jf9s/MQBlS4m3FNNStpR4SzFaZUv9Jv0Aycwcli0l3lLMd7/QlurPf1Bj7Me9ZTYz3z2seua7T6peeQc7F7uEXXJzlzAIZpfc3iWMgZ92lwhrhMkuu+T2LmFY+7m7pLXx9OI23fiY8n3/NOvWv6OZGao+q3rhZ98X5qTsktu7hNEnu+T2LmFK+rS7RPcvJBYGquyS27uk2CVPuktufax6YUp6WPWMPg+rnnnmYdUzpHxW9dJ/H7Ew0WSf/MI+WZlpsk9+k/5OfmUAypYSbymmpWwp8ZZitMqW+k36AZK12FJsKe2WYr77dbbUp/1RxpVRMLvk9i5havy0u0T3y+SVATO75PYuYbz8rLvkk4J87phEs6XEW4pJNFtKGuRzxySaLSXeUkyiv9CWUv7BjLkr1B9VPZPdJ1UvvYNlsssuub1LmOyyS27vEia7T7tLhDXCZJddcnOX9Ecd1i6vr16G/g+75AeZo84cb5M56ujsNpmjToBukynILH1dInPU+cFtMkdt5ttkjtqJt8kctY1ukzlqD9y8Ng3cA18jwz3wNTLcA18jwz3wNTIFmStkuAe+RoZ74GtkuAe+RoZ74GtkuAe+QmbkQ7vvflvwgwyfPb1Gho9QXiPDJwGvkSnIXCHzRPfAS53f67ev/obMj/f6RHe1N9/rE92n3nyvT3TnefO9PtG95K33Wk90d3jzvT7R/d7N9/pEd3A33+sT3ZPdfK91oPd6oPumOtB9Ux3ovqkOdN9UB7pvage6b2oHum9qB7pvage6b2p1oPd6oPumdqD7pnag+6Z2oPumdqD7pulA903Tge6bpgPdN00Hum+a6kDv9UD3TVPyfdNQ57Mf5rrx6rWd/snkur6e8dB3l85jOv+p1jenPF7615V1PuPWzx+/dFi7E7Vhbd3bF/+AnXzj9nSwk+8cvxjssV9PpzAObz7bcNlM35/+WfTQv/kH169mku9zD21mTr4rP7aZ5IY4tpnk4jm2meQ+O7aZwkyomeT2PbYZSj3VDFmfaoYZQKoZZgChZhZmAKlmmAGkmmEGkGqGGUCqmcJMqBlmAKlmmAGkmmEGkGqGGUCqGWYAoWZWZgCpZpgBpJphBpBqhhlAqpnCTKgZZgCpZpgBpJphBpBqhhlAqhlmAJlmlo4ZQKoZZgCpZpgBpJphBpBqpjATaoYZQKoZZgCpZpgBpJphBpBqhhlAqJnoZ8cf2wwzgFQzzABSzTADSDVTmAk1wwwg1QwzgFQzzABSzTADSDXDDCDUzMAMINUMM4BUM8wAUs0wA0g1U5gJNcMMINUMM4BUM8wAUs0wA0g1wwwg1MzIDCDVDDOAVDPMAHRmpvZKorsEm6yXwb71ZKVlLGD7YBPfRtj0tBE2iWyETfUaYROyPthFmxphk5tG2BSkETYFaYRdwPbBpiCNsClII2wK0gibgjTCpiB9sBsFaYRNQRphU5BG2BSkEXYB2webgjTCpiCNsClII2wK0gibgvTBnihII2wK0gibgjTCpiCNsAvYPtgUpBE2BWmETUEaYVOQRtgUpA/2TEEaYVOQRtgUpBE2BWmEXcD2waYgjbApSCNsCtIIm4I0wqYgfbAXCtIIm4I0wqYgjbApSCPsArYPNgVphE1BGmFTkEbYFKQRNgXpg71SkEbYFKQRNgVphE1BGmEXsH2wKUgjbArSCJuCNMKmII2wKUgZbOkDEl7EYSbUDG2aaoaQTTVD9aaaKcyEmqGnU80Q36lmKPVUM2R9qhlmAKFmemYAqWaYAaSaYQaQaoYZQKqZwkyoGWYAqWaYAaSaYQaQaoYZQKoZZgChZgZmAKlmmAGkmmEGkGqGGUCqmcJMqBlmAKlmmAGkmmEGkGqGGUCqGWYAoWZGZgCpZpgBpJphBpBqhhlAqpnCTKgZZgCpZpgBpJphBpBqhhlAqhlmAKFmihlAqhlmAKlmmAGkmmEGkGqmMBNqhhlAqhlmAKlmmAGkmmEGkGqGGUComcYMINUMM4BUM8wAUs0wA0g1U5gJNcMMINUMM4BUM8wAUs0wA0g1wwwg1MzEDCDVDDOAVDPMAFLNMAPQmZnm6Uyi6z5+8VInassbEK9eCi+RXuj/TC/Uf6YX2j/TC+Wf6YXuj/QyU/2ZXmj+TC8Uf6YXej/TS+El0gu9n+mF3s/0Qu9neqH3M73Q+5FeFno/0wu9n+mF3s/0Qu9neim8RHqh9zO90PuZXuj9TC/0fqYXej/Sy0rvZ3qh9zO90PuZXuj9TC+Fl0gv9H6mF3o/0wu9n+mF3s/0Qu8Heum7jt7P9ELvZ3qh9zO90PuZXgovkV7o/Uwv9H6mF3o/0wu9n+mF3o/00tP7mV7o/Uwv9H6mF3o/00vhJdILvZ/phd7P9ELvZ3qh9zO90PuRXgZ6P9MLvZ/phd7P9ELvZ3opvER6ofczvdD7mV7o/Uwv9H6mF3o/0stI72d6ofczvdD7mV7o/UwvhZdIL/R+phd6P9MLvZ/phd7P9ELvR3opej/TC72f6YXez/RC72d6KbxEeqH3M73Q+5le6P1ML/R+phd6P9JLo/czvdD7mV7o/Uwv9H6ml8JLpBd6P9MLvZ/phd7P9ELvZ3qh9yO9TPR+phd6P9MLvZ/phd7P9FJ4ifRC72d6ofczvdD7mV7o/Uwv9H6kl5nez/RC72d6ofczvdD7mV4KL5Fe6P1ML/R+phd6P9MLvZ/phd6P9LLQ+5le6P1ML/R+phd6P9NL4SXSC72f6YXez/RC72d6ofczvdD7kV5Wej/TC72f6YXez/RC72d6KbxEeqH3M73Q+5le6P1ML/R+phd6P9FL39H7mV7o/Uwv9H6mF3o/00vhJdILvZ/phd7P9ELvZ3qh9zO90PuRXnp6P9MLvZ/phd7P9ELvZ3opvER6ofczvdD7mV7o/Uwv9H6mF3o/0stA72d6ofczvdD7mV7o/UwvhZdIL/R+phd6P9MLvZ/phd7P9ELvR3oZ6f1ML/R+phd6P9MLvZ/ppfAS6YXez/RC72d6ofczvdD7mV7ofaGX9kqiq/ewi4iXwR7W7kRtWFt3ATZlboRNbhth09BG2AVsH2xq1wibhDXCpkuNsIlNI2wK0ge7UZBG2BSkETYFaYRNQRphF7B9sClII2wK0gibgjTCpiCNsClIH+yJgjTCpiCNsClII2wK0gi7gO2DTUEaYVOQRtgUpBE2BWmETUH6YM8UpBE2BWmETUEaYVOQRtgFbB9sCtIIm4I0wqYgjbApSCNsCtIHe6EgjbApSCNsCtIIm4I0wi5g+2BTkEbYFKQRNgVphE1BGmFTkD7YKwVphE1BGmFTkEbYFKQRdgHbB5uCNMKmII2wKUgjbArSCJuCtMEeOgrSCJuCNMKmII2wKUgj7AK2DzYFaYRNQcpgjy830icSQ5tumOn78XQOfdUFM+RmqhnaNNUMIRtqpqd6U82QyKlm6OlUM8R3qpnCTKgZsj7VDDOAVDPMAFLNMANINcMMINTMwAwg1QwzgFQzzABSzTADSDVTmAk1wwwg1QwzgFQzzABSzTADSDXDDCDUzMgMINUMM4BUM8wAUs0wA0g1U5gJNcMMINUMM4BUM8wAUs0wA0g1wwwg1EwxA0g1wwwg1QwzgFQzzABSzRRmQs0wA0g1wwwg1QwzgFQzzABSzTADCDXTmAGkmmEGkGqGGUCqGWYAqWYKM6FmmAGkmmEGkGqGGUCqGWYAqWaYAYSamZgBpJphBpBqhhlAqhlmAKlmCjOhZpgBpJphBpBqhhlAqhlmAKlmmAGEmpmZAejMTPN0JtF1H794qRO15Q2IVy9MADK90P+ZXqj/TC+Fl0gvlH+mF7o/0wvVn+mF5s/0QvFHelno/Uwv9H6mF3o/0wu9n+ml8BLphd7P9ELvZ3qh9zO90PuZXuj9SC8rvZ/phd7P9ELvZ3qh9zO9FF4ivdD7mV7o/Uwv9H6mF3o/0wu9n+hl7Oj9TC/0fqYXej/TC72f6aXwEumF3s/0Qu9neqH3M73Q+5le6P1ILz29n+mF3s/0Qu9neqH3M70UXiK90PuZXuj9TC/0fqYXej/TC70f6WWg9zO90PuZXuj9TC/0fqaXwkukF3o/0wu9n+mF3s/0Qu9neqH3I72M9H6mF3o/0wu9n+mF3s/0UniJ9ELvZ3qh9zO90PuZXuj9TC/0fqSXovczvdD7mV7o/Uwv9H6ml8JLpBd6P9MLvZ/phd7P9ELvZ3qh9yO9NHo/0wu9n+mF3s/0Qu9neim8RHqh9zO90PuZXuj9TC/0fqYXej/Sy0TvZ3qh9zO90PuZXuj9TC+Fl0gv9H6mF3o/0wu9n+mF3s/0Qu9Hepnp/Uwv9H6mF3o/0wu9n+ml8BLphd7P9ELvZ3qh9zO90PuZXuj9SC8LvZ/phd7P9ELvZ3qh9zO9FF4ivdD7mV7o/Uwv9H6mF3o/0wu9H+llpfczvdD7mV7o/Uwv9H6ml8JLpBd6P9MLvZ/phd7P9ELvZ3qh9xO9VEfvZ3qh9zO90PuZXuj9TC+Fl0gv9H6mF3o/0wu9n+mF3s/0Qu9Heunp/Uwv9H6mF3o/0wu9n+ml8BLphd7P9ELvZ3qh9zO90PuZXuj9SC8DvZ/phd7P9ELvZ3qh9zO9FF4ivdD7mV7o/Uwv9H6mF3o/0wu9H+llpPczvdD7mV7o/Uwv9H6ml8JLpBd6P9MLvZ/phd7P9ELvZ3qh9yO9FL2f6YXez/RC72d6ofczvRReIr3Q+5le6H2hl/ZKoqsLsIl4Gexh7U7UhrV1F2BT5kbY5LYPdqOhjbAJYyNsatcIm4Q1wi5g+2ATm0bYFKQRNgVphE1BGmFTkD7YEwVphE1BGmFTkEbYFKQRdgHbB5uCNMKmII2wKUgjbArSCJuC9MGeKUgjbArSCJuCNMKmII2wC9g+2BSkETYFaYRNQRphU5BG2BSkD/ZCQRphU5BG2BSkETYFaYRdwPbBpiCNsClII2wK0gibgjTCpiB9sFcK0gibgjTCpiCNsClII+wCtg82BWmETUEaYVOQRtgUpBE2BWmD3ToK0gibgjTCpiCNsClII+wCtg82BWmETUEaYVOQRtgUpBE2BemD3VOQRtgUpBE2BWmETUHKYI/9ejqFcWjTDTN9P57Ooa+6YKYwE2qGNk01Q8immqF6U82QyKlm6OlQMwPxnWqGUk81Q9anmmEGkGqmMBNqhhlAqhlmAKlmmAGkmmEGkGqGGUComZEZQKoZZgCpZpgBpJphBpBqpjATaoYZQKoZZgCpZpgBpJphBpBqhhlAqJliBpBqhhlAqhlmAKlmmAGkminMhJphBpBqhhlAqhlmAKlmmAGkmmEGEGqmMQNINcMMINUMM4BUM8wAUs0UZkLNMANINcMMINUMM4BUM8wAUs0wAwg1MzEDSDXDDCDVDDOAVDPMAFLNFGZCzTADSDXDDCDVDDOAVDPMAFLNMAMINTMzA0g1wwwg1QwzgFQzzABSzRRmQs0wA0g1wwwg1QwzAJ2ZaZ7OJLru4xcvdaK2vAHx6oUJQKYX+j/Sy0L9Z3qh/TO9UP6ZXuj+TC+Fl0gvNH+mF4o/0wu9n+mF3s/0Qu9Helnp/Uwv9H6mF3o/0wu9n+ml8BLphd7P9ELvZ3qh9zO90PuZXuj9RC9TR+9neqH3M73Q+5le6P1ML4WXSC/0fqYXej/TC72f6YXez/RC70d66en9TC/0fqYXej/TC72f6aXwEumF3s/0Qu9neqH3M73Q+5le6P1ILwO9n+mF3s/0Qu9neqH3M70UXiK90PuZXuj9TC/0fqYXej/TC70f6WWk9zO90PuZXuj9TC/0fqaXwkukF3o/0wu9n+mF3s/0Qu9neqH3I70UvZ/phd7P9ELvZ3qh9zO9FF4ivdD7mV7o/Uwv9H6mF3o/0wu9H+ml0fuZXuj9TC/0fqYXej/TS+El0gu9n+mF3s/0Qu9neqH3M73Q+5FeJno/0wu9n+mF3s/0Qu9neim8RHqh9zO90PuZXuj9TC/0fqYXej/Sy0zvZ3qh9zO90PuZXuj9TC+Fl0gv9H6mF3o/0wu9n+mF3s/0Qu9Helno/Uwv9H6mF3o/0wu9n+ml8BLphd7P9ELvZ3qh9zO90PuZXuj9SC8rvZ/phd7P9ELvZ3qh9zO9FF4ivdD7mV7o/Uwv9H6mF3o/0wu9n+jlZTleIr3Q+5le6P1ML/R+ppfCS6QXej/TC72f6YXez/RC72d6ofcjvfT0fqYXej/TC72f6YXez/RSeIn0Qu9neqH3M73Q+5le6P1ML/R+pJeB3s/0Qu9neqH3M73Q+5leCi+RXuj9TC/0fqYXej/TC72f6YXej/Qy0vuZXuj9TC/0fqYXej/TS+El0gu9n+mF3s/0Qu9neqH3M73Q+5Feit7P9ELvZ3qh9zO90PuZXgovkV7o/Uwv9H6mF3o/0wu9n+mF3o/00uj9TC/0fqYXej/TC70v9NJeSXR1AXYBWwV7WLsTtWFt3QXYlLkRNrlthE1DG2ETxkbY1K4P9kTCGmHTpUbYxKYRNgVphF3A9sGmII2wKUgjbArSCJuCNMKmIH2wZwrSCJuCNMKmII2wKUgj7AK2DzYFaYRNQRphU5BG2BSkETYF6YO9UJBG2BSkETYFaYRNQRphF7B9sClII2wK0gibgjTCpiCNsClIH+yVgjTCpiCNsClII2wK0gi7gO2DTUEaYVOQRtgUpBE2BWmETUHaYC8dBWmETUEaYVOQRtgUpBF2AdsHm4I0wqYgjbApSCNsCtIIm4L0we4pSCNsCtIIm4I0wqYgjbAL2D7YFKQRNgVphE1BGmFTkEbYFKQP9kBBymCP/Xo6hXFo0w0zfT+ezqGvumCG3Ew1Q5ummiFkU80UZkLNkMipZujpVDPEd6oZSj3VDFkfamZkBpBqhhlAqhlmAKlmmAGkminMhJphBpBqhhlAqhlmAKlmmAGkmmEGEGqmmAGkmmEGkGqGGUCqGWYAqWYKM6FmmAGkmmEGkGqGGUCqGWYAqWaYAYSaacwAUs0wA0g1wwwg1QwzgFQzhZlQM8wAUs0wA0g1wwwg1QwzgFQzzABCzUzMAFLNMANINcMMINUMM4BUM4WZUDPMAFLNMANINcMMINUMM4BUM8wAQs3MzABSzTADSDXDDCDVDDOAVDOFmVAzzABSzTADSDXDDCDVDDOAVDPMAELNLMwAUs0wA0g1wwwg1QwzgFQzhRmZmWmeziS67uMXL3WitrwB8eqFCUCmF/o/0wv1n+mF9s/0QvlHelnp/kwvVH+mF5o/0wvFn+ml8BLphd7P9ELvZ3qh9zO90PuZXuj9RC9rR+9neqH3M73Q+5le6P1ML4WXSC/0fqYXej/TC72f6YXez/RC70d66en9TC/0fqYXej/TC72f6aXwEumF3s/0Qu9neqH3M73Q+5le6P1ILwO9n+mF3s/0Qu9neqH3M70UXiK90PuZXuj9TC/0fqYXej/TC70f6WWk9zO90PuZXuj9TC/0fqaXwkukF3o/0wu9n+mF3s/0Qu9neqH3I70UvZ/phd7P9ELvZ3qh9zO9FF4ivdD7mV7o/Uwv9H6mF3o/0wu9H+ml0fuZXuj9TC/0fqYXej/TS+El0gu9n+mF3s/0Qu9neqH3M73Q+5FeJno/0wu9n+mF3s/0Qu9neim8RHqh9zO90PuZXuj9TC/0fqYXej/Sy0zvZ3qh9zO90PuZXuj9TC+Fl0gv9H6mF3o/0wu9n+mF3s/0Qu9Helno/Uwv9H6mF3o/0wu9n+ml8BLphd7P9ELvZ3qh9zO90PuZXuj9SC8rvZ/phd7P9ELvZ3qh9zO9FF4ivdD7mV7o/Uwv9H6mF3o/0wu9H+hl6Dp6P9MLvZ/phd7P9ELvZ3opvER6ofczvdD7mV7o/Uwv9H6mF3o/0ktP72d6ofczvdD7mV7o/UwvhZdIL/R+phd6P9MLvZ/phd7P9ELvR3oZ6P1ML/R+phd6P9MLvZ/ppfAS6YXez/RC72d6ofczvdD7mV7o/UgvI72f6YXez/RC72d6ofczvRReIr3Q+5le6P1ML/R+phd6P9MLvR/ppej9TC/0fqYXej/TC72f6aXwEumF3s/0Qu9neqH3M73Q+5le6P1IL43ez/RC72d6ofczvdD7mV4KL5Fe6P1ML/R+phd6P9MLvZ/phd6P9DLR+0Iv7ZVEVxdgE/Ey2MPanagNa+suwKbMjbDJbSPsArYPNmFshE3tGmGTsEbYdKkRNrHpgz1TkEbYFKQRNgVphE1BGmEXsH2wKUgjbArSCJuCNMKmII2wKUgf7IWCNMKmII2wKUgjbArSCLuA7YNNQRphU5BG2BSkETYFaYRNQfpgrxSkETYFaYRNQRphU5BG2AVsH2wK0gibgjTCpiCNsClII2wK0ga77yhII2wK0gibgjTCpiCNsAvYPtgUpBE2BWmETUEaYVOQRtgUpA92T0EaYVOQRtgUpBE2BWmEXcD2waYgjbApSCNsCtIIm4I0wqYgfbAHCtIIm4I0wqYgjbApSCPsArYPNgVphE1BGmFTkDLYY7+eTmEc2nTDzMvA9XQOfdUFM+RmqhnaNNTMSMimmqF6U82QyKlm6OlUM4WZUDOUeqoZsj7VDDOAVDPMAFLNMAMINVPMAFLNMANINcMMINUMM4BUM4WZUDPMAFLNMANINcMMINUMM4BUM8wAQs00ZgCpZpgBpJphBpBqhhlAqpnCTKgZZgCpZpgBpJphBpBqhhlAqhlmAKFmJmYAqWaYAaSaYQaQaoYZQKqZwkyoGWYAqWaYAaSaYQaQaoYZQKoZZgChZmZmAKlmmAGkmmEGkGqGGUCqmcJMqBlmAKlmmAGkmmEGkGqGGUCqGWYAoWYWZgCpZpgBpJphBpBqhhlAqpnCTKgZZgCpZpgBpJphBpBqhhlAqhlmAKFmVmYAqWaYAejMTPN0JtF1H794qRO15Q2IVy9MADK90P+ZXgovkV5o/0wvlH+mF7o/0wvVn+mF5k/0MnQUf6YXej/TC72f6YXez/RSeIn0Qu9neqH3M73Q+5le6P1ML/R+pJee3s/0Qu9neqH3M73Q+5leCi+RXuj9TC/0fqYXej/TC72f6YXej/Qy0PuZXuj9TC/0fqYXej/TS+El0gu9n+mF3s/0Qu9neqH3M73Q+5FeRno/0wu9n+mF3s/0Qu9neim8RHqh9zO90PuZXuj9TC/0fqYXej/SS9H7mV7o/Uwv9H6mF3o/00vhJdILvZ/phd7P9ELvZ3qh9zO90PuRXhq9n+mF3s/0Qu9neqH3M70UXiK90PuZXuj9TC/0fqYXej/TC70f6WWi9zO90PuZXuj9TC/0fqaXwkukF3o/0wu9n+mF3s/0Qu9neqH3I73M9H6mF3o/0wu9n+mF3s/0UniJ9ELvZ3qh9zO90PuZXuj9TC/0fqSXhd7P9ELvZ3qh9zO90PuZXgovkV7o/Uwv9H6mF3o/0wu9n+mF3o/0stL7mV7o/Uwv9H6mF3o/00vhJdILvZ/phd7P9ELvZ3qh9zO90PuJXsaO3s/0Qu9neqH3M73Q+5leCi+RXuj9TC/0fqYXej/TC72f6YXej/TS0/uZXuj9TC/0fqYXej/TS+El0gu9n+mF3s/0Qu9neqH3M73Q+5FeBno/0wu9n+mF3s/0Qu9neim8RHqh9zO90PuZXuj9TC/0fqYXej/Sy0jvZ3qh9zO90PuZXuj9TC+Fl0gv9H6mF3o/0wu9n+mF3s/0Qu9Heil6P9MLvZ/phd7P9ELvZ3opvER6ofczvdD7mV7o/Uwv9H6mF3o/0kuj9zO90PuZXuj9TC/0fqaXwkukF3o/0wu9n+mF3s/0Qu9neqH3I71M9H6mF3o/0wu9n+mF3s/0UniJ9ELvZ3qh9zO90PtCL+2VRFcXYBPxMtjD2p2oDWvrLsCmzH2wZ3LbCJuGNsImjI2wqV0j7AK2DzZdaoRNbBphU5BG2BSkETYF6YO9UJBG2BSkETYFaYRNQRphF7B9sClII2wK0gibgjTCpiCNsClIH+yVgjTCpiCNsClII2wK0gi7gO2DTUEaYVOQRtgUpBE2BWmETUHaYFdHQRphU5BG2BSkETYFaYRdwPbBpiCNsClII2wK0gibgjTCpiB9sHsK0gibgjTCpiCNsClII+wCtg82BWmETUEaYVOQRtgUpBE2BemDPVCQRtgUpBE2BWmETUEaYRewfbApSCNsCtIIm4I0wqYgjbApSB/skYI0wqYgjbApSCNsCtIIu4Ctgj326+kUxqFNN8z0/Xg6h77qghlyM9UMbZpqhpBNNUP1ppohkUPNFD2daob4TjVDqaeaIetTzRRmQs0wA0g1wwwg1QwzgFQzzABSzTADCDXTmAGkmmEGkGqGGUCqGWYAqWYKM6FmmAGkmmEGkGqGGUCqGWYAqWaYAYSamZgBpJphBpBqhhlAqhlmAKlmCjOhZpgBpJphBpBqhhlAqhlmAKlmmAGEmpmZAaSaYQaQaoYZQKoZZgCpZgozoWaYAaSaYQaQaoYZQKoZZgCpZpgBhJpZmAGkmmEGkGqGGUCqGWYAqWYKM6FmmAGkmmEGkGqGGUCqGWYAqWaYAYSaWZkBpJphBpBqhhlAqhlmAKlmCjOhZpgBpJphBpBqhhlAqhlmADoz0zydSXTdxy9e6kRteQPi1QsTgEQvraP/M71Q/5leaP9ML5R/ppfCS6QXqj/TC82f6YXiz/RC72d6ofcjvfT0fqYXej/TC72f6YXez/RSeIn0Qu9neqH3M73Q+5le6P1ML/R+pJeB3s/0Qu9neqH3M73Q+5leCi+RXuj9TC/0fqYXej/TC72f6YXej/Qy0vuZXuj9TC/0fqYXej/TS+El0gu9n+mF3s/0Qu9neqH3M73Q+5Feit7P9ELvZ3qh9zO90PuZXgovkV7o/Uwv9H6mF3o/0wu9n+mF3o/00uj9TC/0fqYXej/TC72f6aXwEumF3s/0Qu9neqH3M73Q+5le6P1ILxO9n+mF3s/0Qu9neqH3M70UXiK90PuZXuj9TC/0fqYXej/TC70f6WWm9zO90PuZXuj9TC/0fqaXwkukF3o/0wu9n+mF3s/0Qu9neqH3I70s9H6mF3o/0wu9n+mF3s/0UniJ9ELvZ3qh9zO90PuZXuj9TC/0fqSXld7P9ELvZ3qh9zO90PuZXgovkV7o/Uwv9H6mF3o/0wu9n+mF3k/0MnX0fqYXej/TC72f6YXez/RSeIn0Qu9neqH3M73Q+5le6P1ML/R+pJee3s/0Qu9neqH3M73Q+5leCi+RXuj9TC/0fqYXej/TC72f6YXej/Qy0PuZXuj9TC/0fqYXej/TS+El0gu9n+mF3s/0Qu9neqH3M73Q+5FeRno/0wu9n+mF3s/0Qu9neim8RHqh9zO90PuZXuj9TC/0fqYXej/SS9H7mV7o/Uwv9H6mF3o/00vhJdILvZ/phd7P9ELvZ3qh9zO90PuRXhq9n+mF3s/0Qu9neqH3M70UXiK90PuZXuj9TC/0fqYXej/TC70f6WWi9zO90PuZXuj9TC/0fqaXwkukF3o/0wu9n+mF3s/0Qu9neqH3I73M9H6mF3o/0wu9n+mF3s/0UnjReWmvJLq6AJuIl8Ee1u5EbVhbdwE2ZW6ETW4bYdPQRtiEsQ/2Qu0aYZOwRth0qRE2sWmEXcD2waYgjbApSCNsCtIIm4I0wqYgfbBXCtIIm4I0wqYgjbApSCPsArYPNgVphE1BGmFTkEbYFKQRNgVpgz13FKQRNgVphE1BGmFTkEbYBWwfbArSCJuCNMKmII2wKUgjbArSB7unII2wKUgjbArSCJuCNMIuYPtgU5BG2BSkETYFaYRNQRphU5A+2AMFaYRNQRphU5BG2BSkEXYB2webgjTCpiCNsClII2wK0gibgvTBHilII2wK0gibgjTCpiCNsAvYPtgUpBE2BWmETUEaYVOQRtgUpA92UZBG2BSkDPbYr6dTGIc23TDT9+PpHPqqC2bIzVQztGmqmcJMqBmqN9UMiZxqhp5ONUN8p5qh1EPNNLI+1QwzgFQzzABSzTADSDVTmAk1wwwg1QwzgFQzzABSzTADSDXDDCDUzMQMINUMM4BUM8wAUs0wA0g1U5gJNcMMINUMM4BUM8wAUs0wA0g1wwwg1MzMDCDVDDOAVDPMAFLNMANINVOYCTXDDCDVDDOAVDPMAFLNMANINcMMINTMwgwg1QwzgFQzzABSzTADSDVTmAk1wwwg1QwzgFQzzABSzTADSDXDDCDUzMoMINUMM4BUM8wAUs0wA0g1U5gJNcMMINUMM4BUM8wAUs0wA0g1wwwg08zSMQNINcMMINUMM4BUM8wAUs0UZkLNMAPQmZnm6Uyi6z5+8VInassbEK9emABkeqH/M71Q/5leaP9ILz3ln+mF7s/0QvVneqH5M70UXiK90PuZXuj9TC/0fqYXej/TC70f6WWg9zO90PuZXuj9TC/0fqaXwkukF3o/0wu9n+mF3s/0Qu9neqH3I72M9H6mF3o/0wu9n+mF3s/0UniJ9ELvZ3qh9zO90PuZXuj9TC/0fqSXovczvdD7mV7o/Uwv9H6ml8JLpBd6P9MLvZ/phd7P9ELvZ3qh9yO9NHo/0wu9n+mF3s/0Qu9neim8RHqh9zO90PuZXuj9TC/0fqYXej/Sy0TvZ3qh9zO90PuZXuj9TC+Fl0gv9H6mF3o/0wu9n+mF3s/0Qu9Hepnp/Uwv9H6mF3o/0wu9n+ml8BLphd7P9ELvZ3qh9zO90PuZXuj9SC8LvZ/phd7P9ELvZ3qh9zO9FF4ivdD7mV7o/Uwv9H6mF3o/0wu9H+llpfczvdD7mV7o/Uwv9H6ml8JLpBd6P9MLvZ/phd7P9ELvZ3qh9xO9rB29n+mF3s/0Qu9neqH3M70UXiK90PuZXuj9TC/0fqYXej/TC70f6aWn9zO90PuZXuj9TC/0fqaXwkukF3o/0wu9n+mF3s/0Qu9neqH3I70M9H6mF3o/0wu9n+mF3s/0UniJ9ELvZ3qh9zO90PuZXuj9TC/0fqSXkd7P9ELvZ3qh9zO90PuZXgovkV7o/Uwv9H6mF3o/0wu9n+mF3o/0UvR+phd6P9MLvZ/phd7P9FJ4ifRC72d6ofczvdD7mV7o/Uwv9H6kl0bvZ3qh9zO90PuZXuj9TC+Fl0gv9H6mF3o/0wu9n+mF3s/0Qu9Hepno/Uwv9H6mF3o/0wu9n+ml8BLphd7P9ELvZ3qh9zO90PuZXuj9SC8zvZ/phd7P9ELvZ3qh9zO9FF4ivdD7mV7o/Uwv9H6mF3o/0wu9H+llofczvdD7Qi/tlURXF2AT8TLYbVhOJNo4tAuwKXMj7AK2DzYNbYRNGBthU7tG2CSsETZd6oO9EptG2BSkETYFaYRNQRphF7B9sClII2wK0gibgjTCpiCNsClIF+yx6yhII2wK0gibgjTCpiCNsAvYPtgUpBE2BWmETUEaYVOQRtgUpA92T0EaYVOQRtgUpBE2BWmEXcD2waYgjbApSCNsCtIIm4I0wqYgfbAHCtIIm4I0wqYgjbApSCPsArYPNgVphE1BGmFTkEbYFKQRNgXpgz1SkEbYFKQRNgVphE1BGmEXsH2wKUgjbArSCJuCNMKmII2wKUgf7KIgjbApSCNsCtIIm4I0wi5g+2BTkEbYFKQRNgWpg93m82vbt/f/DjYFaYRNQfpgNwrSCJuCNMKmII2wKUgj7AK2DzYFaYRNQRphU5BG2BSkETYF6YM9UZBG2BSkETYFaYRNQRphF7B9sClII2wK0gibgjTCpiCNsClIH+yZgjTCpiCNsClII2wK0gi7gO2DTUEaYVOQRtgUpBE2BWmETUH6YC8UpBE2BWmETUEaYVOQRtgFbB9sCtIIm4I0wqYgjbApSCNsCtIHe6UgjbApSCNsCtIIm4I0wi5g+2BTkEbYFKQRNgVphE1BGmFTkDbYfUdBGmFTkEbYFKQRNgVphF3A9sGmII2wKUgjbArSCJuCNMKmIH2wewrSCJuClMGehup/vHYau/ECbArSCJuCNMIuYPtgU5BG2BSkETYFaYRNQRphU5A+2AMFqYP98ooT7FZ1ATYFaYRNQRphU5BG2AVsH2wK0gibgjTCpiCNsClII2wK0gd7pCCNsClII2wK0gibgjTCLmD7YFOQRtgUpBE2BWmETUEaYVOQPthFQRphU5BG2BSkETYFaYRdwPbBpiCNsClII2wK0gibgjTCpiB9sBsFaYRNQRphU5BG2BSkEXYB2webgjTCpiCNsClII2wK0gibgvTBnihII2wK0gibgjTCpiCNsAvYPtgUpBE2BWmETUEaYVOQRtgUpA/2TEEaYVOQRtgUpBE2BWmEXcD2waYgjbApSB3sZT4ddlq76QJsCtIIm4I0wqYgdbDXoTvDbt3HL17G8XTgZWzTjRfXCfEyXfgbrwtl+gQSKd4nkEhJP4FECv0JJBYSv75EJgpPIJFJxRNIZALyBBKZrDyBRCY2X1/iysTmCSQysXkCiUxsnkAiE5snkFhI/PoSmdg8gUQmNk8gkYnNE0hkYvMEEpnYfHmJQ8fE5rMk9uNZ4lQXzDCGSTXDbOWTzFQ7/zB7+Rofv3hY5+V0wuv6SmKYLry4dWfnrRv7ty/+4ZxRzPGcF84P55xBz/GcMxc6nnPGSMdzztTpeM4ZUh3Oec9M63jOmZYdzzlzuOM5Zw53POeF88M5Zw53POfM4Y7nnDnc8Zwzhzuec+Zwh3M+MIc7nnPmcMdzzhzueM6Zwx3PeeH8cM6Zwx3POXO44zlnDnc858zhjuecOdzhnI/M4Y7nnDnc8Zwzhzuec+Zwx3NeOD+cc+Zwx3POHO54zpnDHc85c7jjOWcOdzjnxRzueM6Zwx3POXO44zlnDnc854XzwzlnDnc858zhjuecOdzxnDOHO55z5nCHc96Ywx3POXO44zlnDnc858zhjue8cH4458zhjuecOdzxnDOHO55z7xxunMez83W56Xyu5VX61F5fv1wkM7Zled1SbxR9e/2P97se6/1OXfL7XefT92k/duOt91vDev72ez3nvp3f65W5w3D+yTGP9fF7nVv/47Xz/OZHUl383prW8/fW3HcKWcNXfwOj+Q305x0xjeuNNzAt6+uP5P71p+x8Ovn6yiffvvLJT1/55OevefIv//e//cdf//a3v/6f//W3f/z7X/7513/8/T+/rey+/a/LfxJ8mvrzwd78cK/lO4rp/iXz/UuW+5esdy+5/Nc0P1jy8l/9t1de/pOMNZ4W1jK8uSj237/WcP+S8f4ldf+Sdv+S6f4lF/dAa+cr0/R+yXL/kvXuJZf/ksPHSy7ab+f7pzZP75YM9y8Z719S9y+5aL+t52+Brnu3ZLp/yXz/kuX+JeutJcvPSy7/+4GPl/T3L7lof2rTacnbBvixZLx/Sd2/pN2/5PLP//l8/ZnXd0vm+5cs9y9Z715y+bfW03q6pM/d+G5Jf/+S4f4l4/1L6saSty31Y0m7f8l0/5KL9ufz6Gae3n2/XJ5WfLxkvXvJ5Wb+eMlF+/O5huf3F77LsffxkvH+JXX/kov25/U8oureXSwu38B/vGS+f8ly/5L1xpK+fl4yd/cv6e9fctH+Mp1+KC3Tux9K83j/krp/Sbt/yUX7y3z63l+W929/vn/Jcv+S9e4ly0X7y3qeJ3fv3v7S379kuH/JeP+SurHk7Qznx5J2/5Lp/iUX7a/LeB7av7uKLcv9S9a7l6zdnUte/mv43suXf2jM0/lH0+tN6fDxbLNq+Pilyl8A9F/ztIevedrj1zzt+pqn3b7maU9f87Tnvac9n363Wm9moEO7PvRTHXx94MGH7pEH3/vT+0Xp2ejw88GHRx58fOTB9/68asPppW2Yfz54e+TBp0cefH7gwcfdzOv0KYxW7w6+98yntpxnPf3PB18eePAaHoildn8TTdOF+e+Pg9cjD94eefDpkQefH3nw5ZEHXx948NbpDr60nw/eP/Lgu79Dzx8fa+u7g+/+Dj3/bLlw8HrkwdsjD773O3QaTjdF07D8fPD5kQdfHnnw9YEHn/Z+h059nQ++/nzw/pEHHx558PGRB69HHrw98uDTIw8+6w4+vtvnyyMPvvs79JzQU/188Hn3d2jXrh+8f+TBh0cefPd36Af353M98uDtkQefHnnwRwbX/LjgevmP8dsLr/wB79eY6qfxza8K23r90ysfLnr5r/r22suD3Wk5vaW53vzaoA2XxjztfBf5h482D9cHsLrDt8cefnrs4efHHn557OHXvYdv/flDXG258dq+G8//vqB7O0/48FOPn3QyfdLJDEknM3pPpg3nk5n6dydTSSfTkk5mSjqZ2Xsy56t5370dufw4mSXpZNagkxm7pJPpP+1k3nzM4nQyQ9LJjEkn4/0J3J9bre/ffKztdDIt6WSmpJOZY07m5b/at9de/DFc50/H1fLmg1utvq+bvufO5X9T2qbzP+Zsy/pxwy3nf0m9du3jlz78405f4cSHr3ri41c98fqqJ96+6olPX/XE590nvo6nH+1v/1bEw098+aonvn7REx+6r3ri/Vc98eGrnvj4uBP/87W5je7w7bGHnx57+Pmxh18ee/j1oYcf98Ppu+FcJ92bP47w45NK+39I9sP0+od0lp8/N1vjo99BPfoLKByc/2HySyz+/FvXWh79BdYHf4HWPfoL9IIvcP6XRS9f4OfPSbTh0V9gfPQXqEd/gfboLzA9+gvMj/4Cgu/kfjwPIPvp54/bt/XBX2DqHv0F+kd/geHRX2B89BeoR38BwXdyv77+icj+59uWaXr0F1gffNsyP/q+aO4f/QXGR3+BevQXaI/+AtNDv8DLf8y/XR/hv/6Bl36a5xtfpoZTJPQ1vvtXdSX4Auc/0dLXeuPFUcPWZ3uX0yHe5XyId7kc4l2uR3iXQ3eId9l732XUnPrZ3uV4iHdZh3iX7RDvcjrEu5xD3uWfr/525HPOZc05l7ELOpeUa/Kfr30y9JPOJeX69uerv0Z72Lnc+I2VmcyN3wBOUWzmpLNp9n2z4bdsn3U2Q9TZjFFnU+6z2fCbwc86mynqbOaos1mizmZNOpupizob98/iLb9U/ayzGaPOpqLOpkWdzRR1NnPU2bh/Fm/5jfonnc08JBXMHNVTc0WdzRR1NnPU2SxRZ7PmnM3LfyzfXnrlIx5dvfmbDK93RuNHO+7jNfOGNcuGNev9ay4/BeHGmn7DmmHDmnHDmtqwZsM+WDbsg2XDPlg27INlwz5YN+yDdcM+WDfsg3XDPlg37IN1wz5YL++D/vwIob5f+p/XzBvWLBvWrPev6btuy6L+5qJ1erfoMoaX+7HzD+43I8sfi658nK3OD7/sW/9+Ub9l0bBl0bhh0bV/ALa8LlrfIb/268ru/Mdhpvdf6cpvlj7+Std+BTScR4TTe0/Xflfz8aJxy6LasuhKqJ7/8MLLovZu0bRl0bxl0bJl0bph0bXfHX28qN+yaNiwYa/9MunjRbVlUduyaMs34bVfAn28aNmyaN2w6NpvhT5e1G9ZtGVHtC07om3ZEW3LjmhbdkS7e0e8/Mf67aUvdySXlrZhOH8GZKh3n5ns2pZF05ZF85ZFy5ZF64ZFVx7mNZz/7ug8zNOv3U3cWjRsWHTl4SnjfH4+5bisv3ZjMFd3fkBn9dOv3RgMQ52+0jC0X7wxuLVo2LJo2gDiysNEboBYtixaNyy6fOW9tajfsmjYsmjcsqi2LGpbFm3Z5bVlR9SWHVFbdkTbsiPalh3R7t4R//rT939J9N9XLx4ff0r/ysXjxqJ5y6Jly6J1w6LLF49bi648P/f8lKuX/3N8d/G48mzb8xPq53V6fx3otizqtywatiwatyyqLYvalkXTlkXzlkWXn3bbnXfE8rKj3i1aryw6P7y3G/7wDfx+Ql5jdzqtGvv17Ub90733UZdvHz7vdPqs0xmyTmfMOp3KOp2WdTpT1unMWaezZJ1O1k/luvKNXq8P4HjzN+c/vLFeunOoLt3cfu3G+taiZcuidcOiNmwA0a7Qm958pV8cNN1a1LYsmrYsuuJpfl20du8WLVsWrRsWTd2WRf2WRcOWReOWRbVhw05ty6It37nTlu/cact37rTlO3futizqtywatiwatyzasiPmLTti3rIj5i07Yt6yI+YtO2IZNgT0ciU2z0+Am9fh3ZBkqS2L2pZF05ZF85ZFy5ZF64ZFa7dlUb9l0bBl0ZYdsW7ZEeuWHbFu2RHrlh2x3r0j/vWn739e/79/a1d+rfbhB2Zaa1sWTVsWzVsWLVsWbfjEVZu6LYv6LYuGLYvGLYu27Ihpy46YtuyIacuOmLbsiGnLjpi37Ih5y46Yt+yIecuOmLfsiCufzP3wQ2htnrYsmrcsWrYs2vBpvLbc/jTeuw/WtSufTf3wg3XtyodGP/zkWlu7LYv6LYs2fBpv6q78Nc6PPu42dRs+9jF164avdO1P8330ybWp77csGrYsGrcsuvzt/uFHw6a+bVk0bVk0b1m0bFm04dN409BtWbThs1fTMGxZNG5ZVFsWbfkm3PKR2GmYtyxatiza8Gm8aey2LNqyI8YtO2LcsiPGLTti3LIjxrt3xLe4Gb7HzbXPdo7nH+lz97r2ZYj7/Tp17cOdH6z618t//v+//Mdf//Jvf/vf//my6Nv/9//9/d//+dd//P3Hf/7zv/7v7/+flxf/Dw==","brillig_names":["get_contract_instance_internal","get_public_keys_and_partial_address","decompose_hint","notify_created_note_oracle_wrapper","get_key_validation_request","random","lt_32_hint","lte_16_hint","build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","build_msg_block_iter","emit_encrypted_note_log_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["private","noinitcheck"],"abi":{"error_types":{"12265343917440897559":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"},"visibility":"private"},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"},"visibility":"private"},{"name":"cancellable","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2T1m2z1i2z1i2z1i2z1i2zxZUKhvL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9hnL9jnL9jnL9jnL9jnL9vmCSmVn2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2T5n2b5g2b5g2b5g2b5g2b5YUKkcLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNsXLNuXLNuXLNuXLNuXLNuXCyqVk2X7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX7kmX78nDbJ+qXcsTz/p5tLf7nxqZjXjeWuLGxi1w2drHxduPfFjq6LFS6LFS7LNS6LNS7LDS6LDS7LLS6LHT2WGgtTTqjWpp0RrU06YxqadIZ1WJdFtqkM6qlSWdUS5POqJYmnVEtXTqj0aUzGl06o9GlMxpdOqPDZwl82UK7dEajS2c0unRGo0tnNLp0RtKlM5IunZF06YykS2d0+DyPL1tol85IunRG0qUzki6dkXTpjLRLZ6RdOiPt0hlpl87o8Jk6X7bQLp2RdumMtEtnpF06I0V3RuGXPVtE/rF2Qzc7G7Wj+5eN2tEtyUbt6C4jF7nUnuN97Xbi2tG9wEbt6Mv7Ru3oK/ZG7eiL8EbOnPi66ie+rvqJr6uOvq7eP1f9xNfVwwd37Vn7ia+rfuLrqp/4uuro6+pG7ejr6v3aA31d3agdfV3dqP3E19U48XX18NFre9Z+4utqoK+r93vgQF9XN2o/8efVOPHn1TzxdTVPfF3NE19X88TX1cOH5+1Z+4mvq3niz6t54s+reeLPq3niz6t14utqnfi6Wie+rtaJr6uHjz/csQcu9HV1o/YTf16tE39erRNfV+vE11X2MMiN2k98XWWPbNyo/cTXVfZgxY3aT/x5lT3+cKP2E39eZQ8p3Kj9vNfVyR4luFH7ea+rkz3w724PPNkz/DZqR19XN2o/7+fVyR6et3Gunve6Otkj7jZqP/F1lT2IbqP2E19X2ePiNmo/7+fVyR7qtlH7eT+vTvbotY3aT3xdZQ9I26j9xNdV9hiz+z0wezLZRu0n/rzKnh+2UfuJr6vsKV8btZ/4usqexbVR+4mvq+yJWfdrZw/B2qj9xJ9X2aOqNmo/8edV9kCpjdpPfF1lj33aqP3E11X2cKb7PfCJ5y3NE89bmieetzTZ85bun6snnrc0TzxvaZ543tI88byleeJ5S5M9b2mj9hN/XmXPW9qo/cSfV088b2meeN7SPPG8pXnieUuTPW/pfg/Mnre0UfuJP6+y5y3dr/3E85bmiectzRPPW5onnrc0TzxvaZ543tJkz1vaqP3En1fZ85Y2aj/x59UTz1uaJ563NE88b2meeN7SZM9but8Ds+ctbdR+4s+r7HlLG7Wf+Lp64nlL88TzluaJ5y3NE89bmieetzTZ85Y2aj/x51X2vKWN2k/8efXE85bmiectzRPPW5onnrc02fOW7vfA7HlLG7Wjr6sbtZ/48+qJ5y3NE89bmieetzRPPG9pLCceuLQWf94r61r8eT+yrsWf9zPrWjz64rpV/Hk/ta7Fn/fyuhZ/3uvrWvx5L7Br8We+wrJHL91th9fiz2tu1uLP++F1Lf68n17X4s98hT3x/KW1+DNfYU88gWkt/sxX2BPPYBoLewjTVvFn/gzLHsO0VfyZP8OeeBDTWvyZr7AnHsW0Fn/mKyx7GNNGS8yexrRRPHsc01bxZ/4Me+KBTGvxZ77Cnngk01r8ma+wJx7KtBZ/5isseyzTVvFn/gzLHsy0VfyZP8OeeDTTWvyZr7AnHs60Fn/mKyx7PNNGS8yez7RV/Jk/w7InNG0Uf+IRTWvxZ77CnnhI01r8ma+wJx7TtBZ/5isse1DTVvFn/gzLHtW0VfyZP8OeeFjTWvyZr7AnHte0Fn/mKyx7YNNGS8ye2LRV/Jk/w7JnNm0Vf+Yr7ImnNo3lxGOb1uLPfIU98eCmtfgzX2HZo5u2ij/zZ1j28Kat4s/8GfbE45vW4s98hT3xAKe1+DNfYdkjnDZaYvYMp63i0VfYreLP/Bn2xGOc1uLPfIU98SCntfgzX2FPPMppLf7MV1j2MKet4s/8GZY9zmmr+DN/hj3xQKe1+DNfYU880mkt/sRX2MGe6XS/JR7smU5bxZ/4M+xgz3TaKv7EV9hx5plO48wzncaZZzqNM890Gmee6TTYM522ij/xZ9jBnum0VfyJP8OOM890Gmee6TTOPNNpnHmm02DPdNpoidkznTaKZ8902ir+zJ9hzzzTaZx5ptM480ynceaZTuPMM53GmWc6DfZMp63iz/wZlj3Taav4M3+GPfNMp3HmmU7jzDOdxplnOg32TKeNlpg902mr+DN/hmXPdNoo/swzncaZZzqNM890Gmee6TTOPNNpnHmm02DPdNoq/syfYdkznbaKP/Nn2DPPdBpnnuk0zjzTaZx5ptNgz3TaaInZM522ij/zZ1j2TKet4s98hT3zTKdx5plO48wzncaZZzqNM890GuyZTlvFn/kzLHum01bxZ/4Me+aZTuPMM53GmWc6jTPPdBrsmU4bLTF7ptNW8egr7FbxZ/4Me+aZTuPMM53GmWc6jTPPdBpnnuk0zjzTabBnOm0Vf+bPsOyZTlvFn/kz7JlnOo0zz3QaZ57pNM4802mwZzpttMTsmU5bxZ/5Myx7ptNW8We+wp55ptM480ynceaZTuPMM53GmWc6CXum01bxJ/4MK+yZTlvFn/gzrCwnvsLKmWc6yZlnOsmZZzoJe6bT/ZZY2DOdNopnz3TaKv7En2HlzDOd5MwzneTMM53kzDOd5MwzneTMM52EPdNpq/gzf4Zlz3TaKv7Mn2HPPNNJzjzTSc4800nOPNNJ2DOdNlpi9kynreLP/BmWPdNpo/gzz3SSM890kjPPdJIzz3SSM890kjPPdBL2TKet4s/8GZY902mr+DN/hj3zTCc580wnOfNMJznzTCdhz3TaaInZM522ij/zZ1j2TKet4s98hT3zTCc580wnOfNMJznzTCc580wnYc902ir+zJ9h2TOdtoo/82fYM890kjPPdJIzz3SSM890EvZMp42WmD3Taat49BV2q/gzf4Y980wnOfNMJznzTCc580wnOfNMJznzTCdhz3TaKv7Mn2HZM522ij/zZ9gzz3SSM890kjPPdJIzz3QS9kynjZaYPdNpq/gzf4Zlz3TaKv7MV9gzz3SSM890kjPPdJIzz3SSM890EvZMp63iz/wZlj3Taav4M3+GPfNMJznzTCc580wnOfNMJ2HPdNpoidkzne4Xr+yZTlvFn/gzrJ55ppOeeaaTLie+wuqZZzrpmWc66ZlnOil7ptNW8Sf+DKvsmU5bxZ/4M6yeeaaTnnmmk555ppOeeaaTsmc6bbTE7JlOW8Wf+DOssmc6bRR/5plOeuaZTnrmmU565plOeuaZTnrmmU7Knum0VfyZP8OyZzptFX/mz7BnnumkZ57ppGee6aRnnumk7JlOGy0xe6bTVvFn/gzLnum0VfyZr7BnnumkZ57ppGee6aRnnumkZ57ppOyZTlvFn/kzLHum01bxZ/4Me+aZTnrmmU565plOeuaZTsqe6bTRErNnOm0Vj77CbhV/5ivsmWc66ZlnOumZZzrpmWc66ZlnOil7ptNGVJ55ppOeeaaTsmc6bb3nz3yFPfNMJz3zTCc980wnPfNMJ2XPdNqISvZMp63iz3yFZc902ir+zFfYM8900jPPdNIzz3TSM8900jPPdFL2TKet4s98l5g902mr+DN/D3vmmU7KnulUUpfiS5f3xR99hR0jrsWnv93zj3oeetH88RI7XNpy1PUlTO8vedRy+fcapfK653lrY0+7bOw1rxuPOX9WP89c/R7jlL6w+nF09VMvG0+tjeqn1fV9P22+bj7Kb2y/pkhdSpH15nP+bvsf65Vm69Vm67Vm63XwemVZ5iV+ZNHFbtQfx9a/7s6ve37Z3f30jHndtc8xb9SfJ6+/0PVPz9f669b7Z566fluWk9c/Tl5/r37All79gC3WbL3kfuAR641m681m661m65291juWZuvtdb/FRrP+ahzdX2VcO9yseLveH/UYrB6H1cO+/+CyXD+/eMaN99vB38jL6/GUWuT+nqVcrhvXm7NLb22tHtcvgWJ5/V5nvLzMu63nUpclzrHoDmduPY/kTkdyPo/kPkdS2HeHtu4umrDvDm3XLyev359n4k5nYjyP5E5H8tmx7HUkm90bkWb3RrTZvRFtdm9Em90b0WbfPe0x7G7Pex0asHoSVg/7txCb94J0so6nnfzT69ET2L5vp3r0OLhvfCT15OeUnbx+2PcXxv5M5BrXrX3K++Pp5M84279fNX9eI3ZKNn9eI/Y6kod/ztpRpNge49W+sHo/dfXNfk3nzX5N583uGHuzO8Zx8m4qyHeAZcm5XOsvWTb+vaJ0/tw8yt+07j/XSr77u/dayXd+916rNVorWx/uu1Zyb/Tra71uHnPIu7WS+6K910ruifZeK7kf2nmtye6F9l3r9+qb7q/1e/VN99f6vfqm+2u1Rmv9Xn3T/bU26puyUd+UjfqmbNQ3VaO+qRr1TdWob6pGfdMegyZPs9ZGfVM16puqUd9UjfqmatQ3zUZ9E3pq6N5rbdQ3oaeF7r1Wa7TWRn3TbNQ3zUZ902zUN80+fZMvffomX/r0TY6erLr3Wvv0Tb5Yo7X26ZscPUl177X26ZscPUF177U26pvQk1P3Xmujvgk9MXXvtTbqmw6fxPqVa23UN41GfdNo1DeNRn3TaNQ3SaO+SRr1TdKob5JGfZNYo7U26pukUd8kjfom9FTavdfaqG9CT6Pde62N+ib0FNq91/qt+qYpV68+7f1ardFav1XftLHWcz8x2fXcT0x2+JTgrSfeup77ickOnyq8Xf+5n5jshn4mTpReBjWu/x1b0xTvz3xx9rTdnddqjdbqjdaK7hd2Xiu6t/jltd79LGPoPmTntaJ7ln3X6uj+Zue1onuhndf6vfqm+2v9Xn3T/bVao7V+r77p/lq/V990f62N+iZv1Dd5o74pGvVN0ahvikZ9UzTqm46ek/2la23UN0Wjvika9U3RqG+KRn1TNuqbslHflI36pmzUNx09J/tL19qob8pGfVM26puyUd+UjfqmatQ3VaO+qRr1TdWobzp6TvaXrrVR31SN+qZq1DdVo76pGvVNs1HfNBv1TbNR3zQb9U1Hz8n+0rU26ptmo75pNuqbZqO+afbpm2Lp0zfF0qdviqVP3xRLn74pFmu01j59Uyx9+qZY+vRNsfTpm2Jp1DeNRn3TaNQ3jUZ902jUNx09J/tL19qobxqN+qbRqG8ajfqm0ahvkkZ9kzTqm6RR3ySN+qaj52R/6Vob9U3SqG+SRn2TNOqbpFHfpI36Jv1WfdPdubuh36pv2ljrt+qbNtZq4NnRY1qN69Y2a2Otol6XUkTX+xC/2/7Hesmzsh+xXvJzRh6xXvKzRh6xXvLzRh6xXvIzRx6wXiM/d+QR6yU/e+QR6yU/f+QR6yU/g+QR67Vm6z28v1ouvfNYG+O36/1RT8DqSVg9BatnsurxBVbP0dfHjOsTMbLifT0Cq0dh9RisHofVE7B6ElZPweqZrHqOnnu7Wc9gXS9CYPUorB6D1YP+btddLl+IvIxNj/f9P3v+6Z+on/18vu362c/n266f/Xy+zfoT9nkhYdejhF2PEnY9Onq+5WY9sPs5e8yJXJu0az1LbOTDa78ntcj9PUu5XDeuN3fT9NbW6nFZqsayvG798jLvtp5LXZY4x7L1re+fuFO3xxTK55H87UjW80judCTn80jucyT3mM/5PJK/HcnxPJI7HUl5HsmdjqQ+j+ROR9KeR3KnI+nPI7nTkYR9Z12w76zZs1E95nXXPse88e/Lvse1WT97humfqB/9u/0/UT/6t/h/on707+v/RP128vrZ3zFt18/+jmm7fvZ3TNv1w34zNlm/GcuF9R1QLqzvgHJhfQeUC+s7oFwMVg/rO6BcWJ+PcmF9PsqFlc+5wPJ5wPJ5wPJ5wPJ5wPJ5wPJ5wPJ5wPJ5wPJ5wPJ5wPJZYPkssHwWWD4LLJ8Fls8Cy2eB5bPA8llg+SywfFZYPissnxWWzwrLZ4Xls8LyWWH5rLB8Vlg+KyyfDZbPBstng+WzwfLZYPkMmymRsJkSCZspkbCZEgmbKZGwmRLpsHx2WD47LJ8dls8Oy2eH5bPD8tlh+eywfA5YPsNmSiRspkTCZkokbKZEBiyfA5bPAcvngOVzwPIZNmMhYTMWEjZjIWEzFhI2YyFhMxYyYfmcsHxOWD4nLJ8Lls8Fy+eC5XPB8rlg+Vzf6nlbd58HkvWtnre1sdZv9bytjbV+q+dtbaz1Wz1v6/5a2RZ357X2ed5Wso3vzmvt87ytZNvhndfaqG+asM/ME/aZGWaGE2aGC2aGC2aGC2aGC2aGazFYPax7mgUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzwwUzw1WwfIY9U7Zgz5StguVzwfJ5wvJ5wvJ5wvJ5wvJ5wvJ5wvIZ5gcL5gcL5gcL5gcnzA9OmB+cMD84YX5wLqx8njA/OGF+cML84IT5wQnzgxPmByfMD06YH5wwPzhhfnDC/OCE+cEJ84MT5gcnzA9OmB+cMD84YX5wwvzghPnBCfODE+YHJ8wPTpgfnDA/OGF+cML84IT5wQnzgxPmByfMD06YH5wwPzhhfnDC/OCE+cEJ84MT5gcnzA9OmB+cMD84YX5wwvzghPnBCfODE+YHJ8wPTpgfnDA/OGF+cML84IT5wQnzgxPmByfMD06YH5wwPzhhfnDC/OCE+cEJ84MT5gcnzA9OmB+cMD84YX5wwvzghPnBCfODE+YHJ8wPTpgfnDA/OGF+cML84IT5wQnzgxPmByfMD06YH5wwPzhhfnDC/OCE+cEJ84MT5gcnzA9OmB+cMD84YX5wwvzghPnBCfODE+YHJ8sPysLyg2s9qHxe60Hl81oPKp/XelD5vNaDyue1HlQ+r/Wg8nmtB5XPaz2wfGb5wbUeWD6z/OBaDyyfWX5wrQeWzyw/uNYDy2eWH1zrgeUzyw+u9cDymeUH13pg+czyg2s9sHxm+cG1Hlg+s/zgWg8sn1l+cK0Hls8sP7jWA8tnlh9c64HlM8sPrvXA8pnlB9d6YPnM8oNrPbB8ZvnBtR5YPrP84FoPLJ9ZfnCtB5bPLD+41gPLZ5YfXOuB5TPLD671wPKZ5QfXemD5zPKDaz2wfGb5wbUeWD6z/OD6srB8ZvnB9WVh+czyg+vLwvKZ5QfXl4XlM8sPri8Ly2eWH1zrgeUzyw+u9cDymeUH13pg+czyg2s9sHxm+cG1Hlg+s/zgWg8sn1l+cK0Hls8sP7jWA8tnlh9c64HlM8sPrvXA8pnlB9d6YPnM8oNrPbB8ZvnBtR5YPrP84FoPLJ9ZfnCth5XPA+YHB8wPDpgfHDA/OBZWPg+YHxwwPzhgfnDA/OCA+cEB84MD5gcHzA8OmB8cMD84YH5wwPzggPnBAfODA+YHB8wPDpgfHDA/OGB+cMD84ID5wQHzgwPmBwfMDw6YHxwwPzhgfnDA/OCA+cEB84MD5gcHzA8OmB8cMD84YH5wwPzggPnBAfODA+YHB8wPDpgfHDA/OGB+cMD84ID5wQHzgwPmBwfMDw6YHxwwPzhgfnDA/OCA+cEB84MD5gcHzA8OmB8cx/vBqZeNp9bbet5v/PJz+uVSx1KyXDcf5Te2jynz5+Yx7c1if65VG63VGq3VG601Gq01G621Gq119lnr8T72C9c6Gq21Ud+U5L5pTKtx3dpmbaxV1OtSimiM/N32P9ZrzdZL7p8esV5yD/WI9ZL7qEesl9xLPWK9R/dTGXnduOLdPYXDzflWPQNWD+yeOMycD5g5H4eb8633T8DqSVg9BasHls8Tls8Tls+Hm/OtemD5fLQ5X3fn1z2/7O5uf+Uul8++639nvO+Xjjbqu9cfJ68/T14/7PoyWdcXWVjXFznazP/i+y3mddc+x3z3fpOjjf3u9evJ69/hehdx/dCfS2zU//p+llrk/p6lXK4b15u7CXpra/W4HBqN5c194ZeXebf1XOqyxDkW/ct3KmSP6QPPI/nbkYznkdzpSObzSO50JOt5JHc6kvN5JPc5kkfPB9m79xgn713HyXvXcfLe9ej5JrvXz75Xs10/6/frApufIrD5KQKbnyKw+SkCm58isPkpApufIrD5KQKbnyKw+SkCm58isPkpApufIrD5KQKbnyKw+SkCm58isPkpApufIrD5KQKbnyKw+SkCm58isPkpApufIrD5KQKbnyKw+SkCm58isPkpApufIrD5KQKbnyKw+SkCm58isPkpApufIrD5KeLo+9WxlnzZdVRsfb923wWKo3+HuPNa0b9Z3Hmt1Wits89aA/1d+M5rhV3HA3YdD9h1/Ph5NRv1wD5nBexzVsA+ZwXsc1bAPmcl7HNWwvI5YfmcsHxOWD4nLJ8Tls8Jy+eE5XPC8rlg+VywfIbNTBDYzASBzUyQguVzwfK5YPlcsHwuWD5PWD5PWD5PWD7DZibIhOXzhOXzhOXzhOXzhOXzZOWzLqx81oWVz7qw8lkXVj7rwspnXVj5rAsrn3Vh5bMurHzWBZbPA5bPA5bPA5bPA5bPA5bPA5bPMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqMGeqDstnh+Wzw/LZYfnssHwOWD7D/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDC/KDB/KDB/KDB/KDB/KAtrHw2mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB80mB+04/3g1MvGU+ttPe83liXncqljKVmum3/mWSh2vE38wrWORmuVRmvVRmu1Rms9+nl5XnbZcywba63hlz2XRG2sNGdeNn5zwRH5ecXZRbBGXlda8/5KK5ZxqScqN4ofuVzfA5mv5Y+In+Xv0FDUtaKxHs+NN+W06wV8viko69bGnpd/1fWf7PXAjHk5+HXq6ueZq9+D3v5K9bKoXgMqa6P6aXXd9bS5dZK/SL5LJrwosd+fVz/WO5qtV5qtV5ut18DrlWWZ1wv6oovdqN/R9f9iO1V6bafK44/t1B4M+zRrzUZrrUZrnX3WGuTe6NfXet085nj3US/IfdHeayX3RHuvldwP7b1Wa7TW79U33V/r9+qb7q/1e/VN99f6vfqm+2v9Xn3T3bVmo74pG/VN2ahvykZ90x7jP06z1kZ9Uzbqm7JR35SN+qZs1DdVo76pGvVN1ahvqkZ90x5jeU6z1kZ9UzXqm6pR31SN+qZq1DfNRn3TbNQ3zUZ902zUN+0xLus0a23UN81GfdNs1DfNRn3T7NM3+dKnb/KlT9/kS5++yZc+fZMv1mitffomX/r0Tb706Zt86dM3+dKobxqN+qbRqG8ajfqm0ahv2mO85GnW2qhvGo36ptGobxqN+qbRqG+SRn2TNOqbpFHfJI36pj3Gvp5mrY36JmnUN0mjvkka9U3SqG/SRn2TNuqbtFHfpI36pj3GMZ9mrY36Jm3UN2mjvkkb9U3aqG+yRn2TNeqbrFHfZI36pj1Ga59mrY36JmvUN1mjvska9U3WqG9CzwTfe62N+ib0LPC919qob4LPAN93rY36pm82L/z+Whv1Td9sXvj9tTbqmxrNC/dG88K90bxwbzQv3BvNC/dG88K90bxwbzQv3BvNC/dG88K90bxwbzQv3BvNC/dG88K90bxwbzQv3BvNC/dG88K90bxwbzQv3BvNC/dG88K90bxwbzQv3BvNC/dG88K90bxwbzQv3BvNC/dG88K90bxwbzQv3BvNC/dG88K90bxwbzQv3BvNC/dG88K90bxwbzQvPBrNC49G88Kj0bzwaDQvPBZrtNY+fVM0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhce32te+JR5Xau9X6s1WuvRfZOGX/ZsY9xf6/CYddm1zzF/t9Yf9cfJ6090/dPztf6yG/XXyeuf567/8Jnae9c/yPVHqVx2HRW6eQ3Va9aWxx+z9vA52V+5Vm20Vmu0VnS/sPNa0b3FL6/1bn+v6D5k57Wie5ad14rub/Zdq6F7oZ3X+r36pvtr/V590/21fq++6f5ardFav1ffdH+tjfoma9Q3WaO+yRr1Td6ob/JGfZM36pu8Ud90+Jzsr1xro77JG/VN3qhv8kZ9kzfqm6JR3xSN+qZo1DdFo77p8DnZX7nWRn1TNOqbolHfFI36pmjUN2Wjvikb9U3ZqG/KRn3T4XOyv3KtjfqmbNQ3ZaO+KRv1Tdmob6pGfVM16puqUd9Ujfqmw+dkf+VaG/VN1ahvqkZ9UzXqm6pR3zQb9U2zUd80G/VNs1HfdPic7K9ca6O+aTbqm2ajvmk26ptmn74plz59Uy59+qZc+vRNufTpm3KxRmvt0zfl0qdvyqVP35RLn74pl0Z902jUN41GfdNo1DeNRn3T4XOyv3Ktjfqm0ahvGo36ptGobxqN+iZp1DdJo75JGvVN0qhvOnxO9leutVHfxJ6pvfNaG/VN7FndO6+1Ud/EngG+81ob9U3fbF74/bU26pu+2bzw+2tt1Dc1mheejeaFZ6N54dloXng2mheejeaFZ6N54dloXng2mheejeaFZ6N54dloXng2mheejeaF5/eaF373+Zj5veaFb6yV/DzbMa2uu542a2Otol6XZ2+uB3Xk77b/sV7yM20fsV5rtl5vtt5ott5stt5qtt7Za72HzxP/6vWOZutt1l8dPVt8LduvK0h5u94f9RisHofVE7B6dri+57i8Scd6r3SjnvUVrxvXa/E5f9ZTsHomq5495jrvWs+A1SOwehRWj8HqcVg9AasnWdeLPDqfa7nWs96Ie398JqueWmD1DFg9AqsH1j8fPc90s56D83nd3fXevOR4++91Y8/ucvkSZf3vjPefjypOXn+evP46ef3z3PUfPZdzK0+Onp25WY/A6oFdj46eE7lZD+x+zh7zFiOu9eSydb/x9fOC1CL39yzlct243txt1Ftbq1+/FtdYltetX17m3dZzqcsS51i2vhX/E3cy95jm+DySvx3Jeh7JnY7kfB7JXY5k7THn8nkkfzuS43kkdzqS8jySOx1JfR7JnY6kPY/kTkfSn0dypyPJ+s66FtZ3IrWw73HFvO7a55g3/n3Z97g26x/LyesfJ69fTl6/nrx+O3n97O+Ytutnf8e0XT/7O6bt+ovVDxw9T3KrHmF9B1TC+g6ohPUdUAnrO6A6egbhZj2s74BKjv7N2P3ftJQkrB7Wb8ZKWL8ZK2X9ZqyU9ZuxUtZvxkoVVo/B6nFYPbD7Vwq7f6WwfFZYPhssnw2WzwbLZ4P1z0fPVNqsB5bPBuufDdY/GyyfDZbPDru/4bD7Gw67v+GwfHZYPjvs/obD8tlh+eywfHZYPgesfw5Y/xyw/jlg9zf2mCmxaz2w/hk2U6ICdn8jYPkcsHxOWD4nLJ8Tls8Jy+eE5XPC8jlh/XPC+ueE/X4jYb/fKNj9jYLd3yjY/Q3YTImCzZSogt3fKFg+FyyfC9Y/F6x/nrD+ecL65wnrnyesf95jxsKu9cD65wm7vzFh9zcmLJ8nK5/nwsrnubDyeS6sfJ4Lq3+eC6t/ngsrn+fC6p/nwuqf58LK57nA8nmw7m/Mwbq/MQfr/sYcsHwesHwerPsbc8DyecDyecDyecDyWWD9s8D6Z4H1z8K6vzH38IO71gPrn4V1f2MK6/7GhPnBCfODE+YHJ8wPTpgfnDA/OGF+cML84FRY/6yw/llZv9+Yyvr9xjTY/Q2D3d8w2P0NmB+cMD84DXZ/A+YHJ8wPTpgfnDA/OB3WPzusf3ZY/+yw/nkPP7hrPQ6rB3Z/w2H3N2B+cML84IT5wQnzgxPmByfsmdQT9kzqCfODM2D9c8D6Z5gfnDA/OBN2fyNh9zcSdn8jYfmcsHzeww/uWg8sn2F+cMKeST1hz6SesGdST9gzqSfsmdSzYPc39vCDu9YD658Ldn+jYPc3YH5wwvzghPnBCfODE+YHJ8wPTpgfnDA/OCesf56w/nke/PsN0evj7MTGeHu9uLHnWEu+7DoqXtd6+3l2MWX+3DymvVnsz7XOLmvVZVkarXU0Wqs0Wqs2Wqs1Wqs3Wms0Wms2Wivqd69rPajfverCcr1rPajvhdZ6UN8LrfWgvhda6zFYPajvhdZ6UPcd13pQ9x3XemD5zHouqC6s54Ku9cDymfVc0LUeWD6zngu61gPLZ5brXeuB5bPA8llg+aywfFZYPissnxWWzwrLZ4XlM+u5oGs9sHxmud61Hlg+s1zvWg8sn1mud60Hls8s17vWA8tng+WzwfLZYPlssHxmPRd0rQeWz6zngq71wPKZ9VzQtR5YPrNc71oPLJ8dls8Oy+eA5XPA8jlg+cxyvWs9sHwOWD6zngu61gPL54Dlc8DymeV613pg+cxyvWs9sHxmud61Hlg+JyyfE5bPrOeCrvXA8pn1XNC1Hlg+s54LutYDy2fWc0HXemD5zHK9az2wfC5YPhcsnycsnycsnycsnycsnycsnycsn1nPBV3rgeXzhOXzZOXzWFj5PBZWPo+Flc+D9VzQtR5WPo+Flc9jYeXzWFj5PGB+cMD84ID5wQHzgwPmBwfMDw6YHxwwPzhgfnDA/OCA+cEB84MD5gcHzA8OmB8cMD84YH5wwPzggPnBAfODA+YHB8wPDpgfHDA/OGB+cMD84ID5wQHzgwPmBwfMDw6YHxwwPzhgfnDA/OCA+cEB84MD5gcHzA8OmB8cMD84YH5wwPzggPnBAfODA+YHB8wPDpgfHDA/OGB+cMD84ID5wQHzgwPmBwfMDw6YHxwwPzhgfnDA/OCA+cEB84MD5gcHzA8OmB8cMD84YH5wwPzggPnBAfODA+YHB8wPDpgfHDA/OGB+cMD84ID5wQHzgwPmBwfMDw6YHxwwPzhgfnDA/OCA+cEB84MD5gcHzA8OmB8cMD84YH5wwPzggPnBAfODAvODAvODAvODAvODsrDyWWB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGB+UGF+UGF+UGF+UGF+UBdWPivMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDyrMDxrMDxrMDxrMDxrMD9rCymeD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGD+UGH+UGH+UGH+UGH+UFfWPnsMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD/oMD8YMD8YMD8YMD8YMD8YCyufA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YHA+YH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Dw6YHxwwPzhgfnDA/OCA+cEB84MD5gcHzA8OmB8cMD84YH5wwPzggPnBAfODA+YHB8wPDpgfHDA/OGB+cMD84ID5wQHzgwPmBwfMDw6YHxwwPzhgfnDA/OCA+cEB84MD5gcHzA8OmB8cMD84YH5wwPzggPnBAfODA+YHB8wPDpgfHDA/OGB+cMD84ID5wQHzgwPmBwfMDw6YHxwwPzhgfnDA/OCA+cEB84MD5gcHzA8OmB8cMD84YH5wwPzggPnBAfODA+YHB8wPDpgfHDA/OGB+cMD84ID5wQHzgwPmBwfMDw6YHxwwPzhgflBgflBgflBgflBgflAWVj4LzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8KzA8qzA8qzA8qzA8qzA/qwspnhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBg/lBg/lBg/lBg/lBW1j5bDA/aDA/aDA/aDA/aDA/aDA/aDA/aDA/aDA/aDA/aDA/aDA/aDA/aDA/aDA/aDA/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flBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhflBhftBgftBgftBgftBgftAWVj4bzA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA8azA86zA86zA86zA86zA/6wspnh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/lBh/nBgPnBgPnBgPnBgPnBWFj5HDA/GDA/GDA/GDA/GDA/GDA/GDA/GDA/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oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oML8oMH8oMH8oMH8oMH8oC2sfDaYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYHzSYH3SYH3SYH3SYH3SYH/SFlc8O84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MO84MB84MB84MB84MB84OxsPI5YH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYH4wYX4wYX4wYX4wYX4wF1Y+J8wPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPJswPFswPFswPFswPFswP1sLK54L5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wYL5wQnzgxPmByfMD06YH5wLK58nzA9OmB+cMD84YX5wwvzghPnBCfODE+YHJ8wPTpgfnDA/OGF+cML84IT5wQnzgxPmByfMD06YH5wwPzhhfnDC/OA82g/KonrZ87IW8aaeWxuvDeN165Lluvkov7F9TJk/N49pbxb7c63ZaK3VaK2zz1qP9ppfutbRaK3SaK3aaK3WaK3eaK3kvmlt+uq662mzNtYq6lWXvWuM/N32P9ZL7p0esV5y//SI9ZJ7qAes18h91CPWS+6lHrHeHfqpHJcXGWm68Tk7I68b1+vByfmzHoXVY7B6/OB6arneFymV9/UErJ6E1VOw989k1bOHC9+1ngGrB5bPDstnh+WzO6yegNUDy2cvWD2TVU8ssHoOzud1d37d88vuXuu5sWd3udw7Wf87432/HXLy+vXk9dvJ64ddXwJ2fYmE1VPo91vM6659jnnj/TbPXX8uJ69/h+tdxPWmUS5b96Ne389Si9zfs5TLdeN6czdKb22tHpdDo7G8+V7h5WXebT2XuixxjkX/4y/f6dpjQsDzSP52JPV5JHc6kvY8kjsdSX8eyZ2OZDyP5E5HMk/ee5y8d82T96518t612Pdqtutn36vZrl9Z9+72mHGyaz2w71IL9l1qwe7VF+xefcHu1U/Yvfo5YPUIrB5YPk9YPk9YPk9YPk9YPk9YPk9UPteyoPJ5rQeVz2s9qHxe60Hl81oPKp/XelD5vNaDyue1HlQ+r/Wg8nmtB5bPA5bPA5bPA5bPA5bPA5bPA5bPA5bPA5bPA5bPA5bPAstngeWzwPJZYPkssHwWWD4LLJ8Fls8Cy2eB5bPC8llh+aywfFZYPissnxWWzwrLZ4Xls8LyWWH5bLB8Nlg+GyyfDZbPBstnloVf64HlM8vCr/XA8tlg+eywfHZYPjssnx2Wzw7LZ4fls8PymWXh1/8jLJ9ZFr4WloVf64Hlc8DyOWD5HLB8Dlg+ByyfA5bPAcvngOVzwvI5YfmcsHxOWD4nLJ8Tls8Jy+eE5XPC8jlh+VywfC5YPhcsn1l+cK0Hls8sP7jWA8tnlh9c64HlM8sP1sLyg2s9sHxm+cG1Hlg+s/zgWg8sn1l+cK0Hls8sP7jWw8rnAfODA+YHB8wPDpgfHAsrnwfMD46jn5Eueh1PJTbezHu5+eyPWEu+7DoqXtf6iecyrWvNRmutRmudfdZ69DPpv3Sto9FaUc9qXutBPat5rcdg9aCe1bzWE7B6ElZPweqZrHpkgdUzYPXA8llg+SywfBZYPgssnwWWzwLLZ4Hls8LyWWH5rLB8Vlg+KyyfFZbPCstnheWzwvJZYflssHw2WD4bLJ8Nls8Gy2eD5bPB8tlg+WywfDZYPjssnx2Wzw7LZ4fls8Py2WH57LB8dlg+OyyfHZbPAcvngOVzwPI5YPkcsHwOWD4HLJ8Dls8By+eA5XPC8jlh+ZywfE5YPicsnxOWzwnL54Tlc8LyOWH5XLB8Llg+FyyfC5bPBcvnguVzwfK5YPlcsHwuWD5PWD5PWD5PWD5PWD5PWD5PWD5PWD5PWD5PWD5PVj7LwspnWVj5LAsrn2Vh5bMsrHyWhZXPsrDyWRZWPsvCymdZYPk8YPk8YPkM84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MC84MK84MK84MK84MK84O6sPJZYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX5QYX7QYH7QYH7QYH7QYH7QFlY+G8wPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPGswPOswPOswPOswPOswP+sLKZ4f5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5QYf5wYD5wYD5wYD5wYD5wVhY+RwwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxgwPxhH+0FZVC97XtYi3tRza+Ocy3XrkuW6+Si/sX1MmT83j2lvFvtzrd5ordFordlordVorbPPWkHO9MbGnnbZeP2G53Wlc/6snnPV/0z1nB7hM9Ur+CxZl1rXXU+btXGWiK7faF72ruunkd9t/2O91my95K7lEesldy6PWC+7e1mmXbfWxW7U/606ktLrVbo83l2lv1VHcn+tR8vqL13raLRWabRWcm/062u9bh5zvPsEcbRk/9K1fqs7ORtr/VZ3cjbW+q3u5Gys9Xv1TffX+r36prtr9e/VN91f6/fqm+6v9Xv1TffX2qhvOnrCxJeutVHf5I36Jm/UN3mjvskb9U3RqG+KRn1TNOqbolHfdPTkly9da6O+KRr1TdGob4pGfVM06puyUd+UjfqmbNQ3ZaO+6eiJTF+61kZ9Uzbqm7JR35SN+qZs1DdVo76pGvVN1ahvqkZ909GT0r50rY36pmrUN1Wjvqka9U3VqG+ajfqm2ahvmo36ptmobzp6guGXrrVR3zQb9U2zUd80G/VNs0/flEufvimXPn1TLn36plz69E25WKO19umbcunTN+XSp2/KpU/flEujvmk06ptGo75pNOqbRqO+6eiJv1+61kZ902jUN41GfdNo1DeNRn2TNOqbpFHfJI36JmnUN32vSdwba23UN32vSdwba23UN32vSdwba23UN2mjvkkb9U3aqG9CzwTfe63WaK2N+ib0HPC919qob/pm88Lvr7VR3/TN5oXfX2ujvumbzQu/v9ZGfVOjeeHZaF54NpoXno3mhWejeeHZaF54NpoXno3mhWejeeHZaF54NpoXno3mhWejeeHZaF54NpoXno3mhWejeeHZaF54NpoXno3mhWejeeHZaF54NpoXno3mhWejeeHZaF54NpoXno3mhWejeeHZaF54NpoXno3mhWejeeHZaF54NpoXno3mhWejeeHZaF54NpoXno3mhWejeeHZaF54NpoXno3mhWejeeHZaF54NpoXno3mhWejeeHZaF54NpoXno3mhWejeeHZaF54NpoXno3mhVejeeHVaF54NZoXXo3mhddijdbap2+qRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Go0L7wazQuvRvPCq9G88Dp8XriGX/ZsY9xf6/CYddm1zzF/t9Yf9efJ6y90/dPztf6yG/XPU9c/D5+/vXf94+T1C7n+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qLDnDyrMDyrMD6rD8tlh+eywfHZYPjssn2F+UGF+UB2Wz7DnDyrs+YMasHwOWD7D/KDC/KDC/KDC/KDC/KDC/KAGLJ8Tls+w5w8q7PmDCnv+oMKeP6iw5w8q7PmDCnv+oMKeP6gwP6gwP6gFy+eC5XPB8rlg+VywfC5YPhcsnwuWz7DnDyrs+YMK84MK84MK84MK84MK84MK84MK84MK84MK84MG84MG84MG84MG84O2sPLZYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYX7QYX7QYX7QYX7QF1Y+O8wPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPBswPBswPBswPBswPxsLK54D5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5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oBnFQTOKg2YUB80oDppRHDSjOGhGcdCM4mA9QfqlINjz7wbrGdIvBRmtINjz7wbrMdIvBcGefzdYD5J+KQj2/LvBepT0S0G0pGY9TPqlIFpSsx4n/VIQLalZD5R+KYiW1KxHSr8UBEtqoT1TWmjPlBbaM6WF9kxpWWBJLbRnSgvtmdJCe6a00J4pLbRnSgvtmdIyaEk9aEk9aEk9aEk9aEk9aEk9aEk9aEk9aEkttKQWWlILLamFltRCS2qhJbXQklpoSS20pBZaUistqZWW1EpLaqUltdKSWmlJrbSkVlpSKy2plZbURktqoyW10ZLaaElttKQ2WlIbLamNltRGS2qjJbXTktppSe20pHZaUjstqZ2W1E5LaqcltdOS2mlJHbSkDlpSBy2pg5bUQUvqoCV10JI6aEkdtKQOWlInLamTltRJS+qkJXXSkjppSZ20pE5aUictqZOW1EVLappRFJpRFJpRFJpRFJpRFJpRFJpRFJpRFJpRFJpRFJpRFJpRFJpRFJpRFJpRFJpRFJpRFJpRFJpRVJpRVJpRVJpRVJpR1AWW1EozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikozikYzikYzikYzikYzirbAktpoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFoRtFo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","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","enqueue_public_function_call_internal","call_private_function_internal","debug_log_oracle_wrapper","notify_set_min_revertible_side_effect_counter_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"lookup_validity","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"consumer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"5Z3dbiTHkYXfZa51kZEZ+edXWSwM2ZaNAQTJsOQFFobefXvY7OoedTNjWaphf5F5I3GkSvJ8nOpzorIqov7z6W8//OXf//jz55/+/vMvn/70X//59OPPf/3+188//3T6039+++7TX/71+ccfP//jz7f/+VP48g8JL8f/8s/vf/ryx19+/f5fv376k9So33364ae/ffky6ek7/P3zjz98+lOV3767O7j29HpsE9kOldYeHJtjfj0253A9Npff/vu7TyJ/WEvTy7GtFEOLpv56rJZ2pyX+cS1dXo/tIRtaSrj8Xkosd1rSH9bS44W1a7S0tPB6bA33f0f6Ti1f1uQda8qONXXHmrZjTX//mhh2rJEda+KONWnHmh3nQdxxHsSH50GqevlspVrr+NxPefsBKdebT2J6+Emp2+nfa7/KkRBf9FSYngbT01l6UoDpEZieCNOTYHoUpifD9MD8OcH8OcH8OcH8WWH+rDB/Vpg/K8yfFebPCvNnhfmzwvxZYf6sMH/OMH/OMH/OMH/OMH/OMH/OMH/OMH/OMH/OMH/OMH8uMH8uMH8uMH8uMH8uMH8uMH8uMH8uMH8uMH8uMH+uMH+uMH+uMH+uMH+uMH+uMH+uMH+uMH+uMH+uMH9uMH9uMH9uMH9uMH9uMH9uMH9uMH9uMH9uMH9uMH/uMH/uMH/uMH/uMH/uMH/uMH/uMH/uMH/uMH/uMH+WADNoCTCHPv2LJgjm0RJgJi0B5tISYDYtAebTEmBGLYHm1EJzaqE5tdCcWmhOLTSnFppTC82phebUQnNqoTl1pDl1pDl1pDl1pDl1pDl1pDk1rbVQaL2FQmsuFFp3odDaC4XWXyi0BkOhdRgKrcVQaD2GQmsyFFqXodDaDIXWZyi0RkOhdRoKrdVQaL2GQms2FFq3odDaDYXWbyi0hkOhdRwKreVQaD2HQms6FFrXodDaDoXWdyi0xkOhdR4KrfVQaL2HQms+FFr3odDaD4XWfyi0BkShdSAKrQVRaD2IQmtCFFoXotDaEIXWhyi0RkShdSIKrRVRaL2IQmtGFFo3otDaEYXWjyi0hkShdSQKrSVRaD2JQmtKFFpXotDaEoXWlyi0xkShdSYKrTVRaL2JQmtOFFp3otDaE4XWnyi0BkX5+A7Fru31aAl6+4qVk6L7w2PVi/7Tl9ej61l9c62+O1YfP75V8lD14lp9dK0+sdVrLtu7lLreeGbuj6SkcHljVCpdvjr6hVaXos1L0ZalaOG1wsG08NriYFp4LXIsrcBrl4Np4bXOwbTw2uhg2qVqqY9v2H4q7VK1lCxVS8lStZQsVUvJUrVUXKqWikvVUnGpWiouVUt9/EiFp9IuVUvFpWqpuFQtFZeqpeJStVRaqpZKS9VSaalaKi1VS3380JOn0i5VS6Wlaqm0VC2Vlqql0lK1lC5VS+lStZQuVUvpUrXUx48leirtUrWULlVL6VK1lC5VS+lStVReqpbKS9VSealaKi9VS3384LCn0i5VS+Wlaqm8VC2Vl6ql8lK1VKHXUr2Ujfb2m1/006sjSz+93rH00yuYW/0t3utX5/rpVYalH1435JAu+nPQB+c/vBIw9cOz3dJf8b//opv+B/nb4PmbW4oX/S2Xe/3w/DX1w/PX1A/PX1P/R+fvSXTSK0D+GuBFUuZJKjxJlSep8SR1nKQPH631/5AkPEmRJynxJPHcu/Pcu/Pcu/Pcu/Pcu+PcOwWce6eAc+8UcO6dAs69U8C5dwo4904B594p4Nw7BZx7p8Bzb+G5t/DcW3juLTz3Fp57C8+9hefewnNv4bm38Nw78tw78tw78tw78tw78tw78tw78tw78tw78tw78tw78dw78dw78dw78dw78dw78dw78dw78dw78dw78dxbee6tPPdWnnsrz72V597Kc2/lubfy3Ft57q0898489848984898489848984898489848984898489y489y489y489y489y489y489y489y489y489y48964896489648964896489648964896489648964892489248924892489+b1WiZer2Xi9VomXq9l4vVaJl6vZeL1WiZer2Xi9VomXq9l4vVaJl6vZeL1WiZer2Xi9VomXq+l8notlddrqbxeS+X1WmrAubfyei2V12upvF5L5fVaKq/XUnm9lsrrtVRer6Xyei2V12upvF5L5fVaKq/XUnm9lsrrtVRer6Xyei2V12upvF5L5fVaKq/XUnm9lsrrtVRer6Xyei2V12upvF5L5fVaKq/XUnm9lsrrtVRer6Xyei31Gc1o29s6Tl+3ci/p4//icrpKytrvJVWepKNjtxuSUtzmtqfYwvVbn+V0lJzD26v+oBz5aDkp5cvRKacbOffHnnYp6uux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","brillig_names":["lookup_validity"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"12265343917440897559":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"H4sIAAAAAAAA/+19fXBk2XXX7VHro1urkWY0HzuSZuZpRprRjEY77/WXpICT2XzZzuKUCZBAsElaUgsvGC/ZzGZtl0M+DDbGmCJOUhViDMSumFCYCpUYcP4jKUwcHBaSqkASh5BNJQW4HMcOIRQ4X7qad9S//um8+17f7tvSJH5VM/30+nzdc88599xz77tdMo+u6YN/pfR+PP2cMMcvgXmQfsaDXckQacUh5Sw9JnKeeUzkHHtM5CwPUU4r25jpvYYt73gAvQ5bxonHQMbJIfe7yFhO76cO/lUO/lXNo9h77Ets2JnUcOz3toOtAicBJovoi6Qce1XBAq+kn08//3z7LdGzb9rrvDl67oWH0XP70c5zL7xp75sR8bwv4oIv4m1AXEo/2w8fdv7aX38YPXwuau/tRS8++/AN0XPf0nl+/43PvYi4LV+mr/JF/NoBpH3HALjv9RX4+30RP+CL+MMDNPPIyPtlOuWLOOeLeLXs38x7vky/2BfxTw0g7dsGwP3bvgL/fV/E7/NF/MEBmhmPezLd8kV84Iv4mnH/Zr7Ol+mbfBHfNoC0Hx4A96O+Av9bX8SP+yL+3ADNfNmX6f/yRfycL+LvD9DMmQlPptd9ETcm/KV9/QC4z/oK/E2+iG/xRXzHAM38vC/TsUlPxGlfxCcn/Zt525fpti/iKweQ9sUBcN/uK/C7fRG/2xfxnwzQzH/qy/QjAzD9qC/TnxyA6Uu+TD85ANP/7sv0MwMw/T++TM9M+TOdmPJkenEApku+TO8MwHTDl+mfHIDpq3yZvtYX8c/7InYGaOZDX6bv8EX8ngGk/XcD4P5nX4F/3hfxV3wRf2OAZv4/X6aliidixRfxUsW/mau+TDd9Eb9iAGlfGAD3O3wFfpcv4nf5Iv6jAZr5g75Mf2QApv/al+nHBmD6075Mf2EApv/Nl+mnB2D6v32ZHq5seDItVz2Zzg/AdMGX6e0BmK77Mv2iAZg+7cv0Vb6If6ZPaY+Wwd6YIlorPJM+k+W3B+nf8WBXAhY+XNpbjf1KKnsAubdk+TAA7djOhr5sqqt7A7zsytAr0+/ks5T+mzHddXPBnzHdFaEvh2dSCvwKeCYVoa+EZzIzeyXIMxWmv7YC9ld9xvQExaO2TIfh1ygRL1gZOeJZNcFs6HAfzjTxF17iy4f2knbmFDwrT/XKeWgvZI/2zwi+n4I2yffr1DaUZYxksXTHQ+hiq7FjaU+EoH3Qz6jDsqLDcUWHE4oO5w/+PUN0rNyTU0HkPtxrMQUyloGXyHkGYKZAjnH4+67pPq/A1KkMehG6s6ZbdalMZeOVCW8OYCYAb5LwJkHuQ9iDf8vp/bTpbvmQ60H6GXte7c1Ge2tvNxb6h7oz3f4VXmx/JTO8fuRxaIi0D8fmJ4B2echyzwyxL+Qah774e2AHdegLjPnD2wfY2OaxcXi0W83DWBCE9uYmx94hyt2pmG48G7K+G5b2WBidHPbl2SC0a4e2PxtG3zvWp+ZM72X5nQN+w/PjpOnKc4RnFWQKkeecI/7CC/Oc8yST1cl8kD5oNueAH/I4T3KeJzkRb9wTb3YE/KzuLgD8EO13H2W64NmWyRHoAPHOjphfP3qxfXUR4IcYIxso00XPtkx54vnq3FfOsT7wrM4vAfwQdR6jTJc82zJqnU974mHecA6e2b85xx4HmG9LP2eIn71s31wGukMcC1uusfAyyCT356ENKNMg7ya02/XNRtLodPaTOKklmyWgLTLJ31jTe5JgeAy1ersSRm89c+gnQU8yD0TdydxUZME5dAXwhy2jS4/Ccw6e4bwpT//nzXGfngEaBto3H6R9sTOPE55VE2w+eJjHzRP/J0hPVicXSKY5eDYDsl0gWheI1mnAs59ST5O22rj22Ynu92dN7+XqJ9TTLMFVTLAc3FnrFJ5V05ubDtt25oj/rKKTcyTTHDzDvuT5xDmiNUw8+0z6eBY+5+iZ1sY5hf4s3NsrYL8n4eaVj+r1kjegb3wQ+GEeXQb4c/BcYF5R7dL4EOiWc5tZuMc86Sy1U/5G3U8ptKbgXvB5/WRKoTWryICvu2m5E8ppiPYTIMcsyanhabQ5Pp8FeYW28BNYrqMM0UZqWtzV5L5IMBeo/bMgr8BquWPR2HvBE++iJ94lT7zLnnhPeuJd8cDTahs4lk7BM9Ef5gaimzF4dpn42WfSpnF4JvKK71hbXgDZh2bLSRxb/Sya3svyWwrBL64lLt0LzyrIFGLMXiL+wkv63sZx28/S7wskXyTIM0RMBM5qIBrXEtCQz6uetK4qtK550LIdfx2eP0g/48GuZA7kuQ68IpBtiJOmw0L38rDbkTqLlhy8DO24kd5zchDBc4G5BMnBr6XPrNGJQS7BM7m/Cvq72n8bk7xmGpD5DPBAO78B9yIrLvrjouQs4eBC2afTTx7w7JU1mRA6owxMwjP0ZOIG8efJhAQmGXwWSL7IgPKQmAic1UAMJjeAhnxOe9KaVmjd9KQleNeBlgQVdMbfA7or6b04o8BH8FxgfrPSpSFCYdYqepmFe83o0WmwD7Ddsw78w10OhINOM5nKluU0rN9gO6dynAZ35twMwv+R0/DsRHix00h2tkDyRQaUh8RE4KwGalOwUE6z4klL8PKc5slSl+5q+tzlNALzcXCaRXAa6QSchsp9ntNgH2C7bzrwrUzzhINOcyPHaebpWQXojNJphGfVBCu5JhgYhb/wYqeRackCyRcZUN6gxhnKaVY9aQlentPUwWlupc9dTiMwPwBO0wKnYQOehfs8p8E+wHbPO/DHTbeD0enl+1fkOA3rN9heyjjedvWd8KyCTCGcZpz4Cy+sNUyTTGibOKflPbLTRAvxljzxZj3xbnji3fTEm/LEm/fEE19Be7XXg/QzbiS1Wj1pbO60tuKtZry3u1XrbLWbzfZ2s7bX2NuvxbVma78TN7fre9uN7YPHjWS3Hcf7cXtnP2lWSB6hm9S2d/b3kr12s7GzGbdqe62dZqPR2ezUWzvb8Wa9VW/G+639nfbBCmpta/eA5mYt3t5uxtv7zc04OdzTdkuhW48btVan1Wh3OvW4s729tZvUd7d2O53dvXa9vbm5FW/u7XTae83azm5tv76zH3fana1msnMgRhLvHtbTb2t6aG8dSNBpxXvxwX/7zb2tuNFsbO81tvYPWDb24lbSiHe2tzp7m8lme3unWa+191v1A4rNery5fUh3TaPb2dtJOrXt+m59t7Od7Ozvxo3OwW27faDr2u6BMvfb23vxtm1/Z6cR1zv7O8nufru2u1OvNzcP36+4o+k3qSfNVjtube234npcq9ca8e52a6dhNb7ZaLUO1FDf2dpMkt1m7YB4Y6uW1NpJc2c3rjc67Zb137um97K81tP7IceUPVdME55V07vXedgxbZ34Cy+MafdIpjl4dgtku0e07hEtxLvjiTfRB57tuw2AeZB+1rZqzd3N7d3dVru5u7PT6exv7rXaW/vJTqud1HbqB0bRrte3Go243dk/MMD69oGhb+1ubR+EhANT3UZ5NjzbMT2C9iPeWh94Vm9PAcyD9DOpN5K91mZzv33gXZ3dTv3A4Q6iSn23XW8cxLX6TrK90+psb7ZqcaO1efCscaC2WmO3caDdvU69ifI8NeL2j3vi3R5QTus/6GP2qgDcKNfEhWfVBItpiaYnjim2/ffD8N+19GLiv6rwT8Lw37L0asR/nfifS/tA9CS6ELlFNqGDewBXcmhbmFmCERxci8Vqlr00Oy26ZIAyPUg/4/6uOj/IKv+e9D6kkOVfXufW9pIskUzaUpK2xrVEtE4SD+e383AvtFgP8wotgZ8HWbiIU3R92GcJz7dYaOVehXvBWyU8jlnY5tUAtCqE9yD9jAe76lnry4Eqws7xT3iGXl++Sfx5fdnqpEYyzcEzrGHwWFIjWog3MyAeFm5RP9yemwqtRWrPLN33Q2uWaNln6ySXfcaxA2MM7rUTP51QZNPaWTLDa2epj3aG9IusGuZPQA0Tc2WsYZ6F5wJzBWqYH4MapuDwipNJP0sAM0H87PVTOTXHe0obPgFtuEY0BR735gnMZ+G96JegDWJrOLbwdopwe2TcuQjukbkWhr+6R4bzTH6/ctgx/D7xv0b8bX+eBzlFlvv0N8YQ6c9r8IzPD9DyD+at1U0EB3NsoS2wvttyTkue5DM/sHj3PfBm4Tnn3IhXJjxsczkArQrhPUg/48GuhpaHWl4xyTssfq4+EJ5VEyzGJdo8necMVicJyTQHzzD+JEQrIVqINzMg3izIg/rh9sQKrSVqzyzd90NrlmjhNjvMg7Q8CWu58il+OqHIprWzZIbXzlIf7czKA6bPHKfLeQDmMgLzBsgDzp7pyih1l/uKvJLLjAF/pns+pdVPLnMB2jCW0QbMZQTmS6ANl6ENRXMZrDGNKpcRnqFzmTHir+UyIeMsx5isXEbk5Dpg0VzmPuhT2jKsXEZoC6y1PXnf/U5KzNre7fQe7Vvi5uFW2YkuTZEF99nzu+azcH8Rnsn9JXgm95fhGb8rOQv3V0A+fkcgXK3RvQEIa41h3nvVa43CizcASR8tkHyRAeX5JJRoxLhpZ9KT1qRCa8yTluDhBiAxfAzWTzsGHIGP4LnAPAnB+sshWEsn4IAt96iXSZD5KuEY09vuKw58nAzjYCPfP5MzgLF+KyZUIHc7jfCsmmADWYLFBeHPh8mJ04i+Fki+yIDyfGaCmOGFcprYk5bg5TnN68BpZIRzOY3AfG6yS+MblCxN9IIjS57TYB9gu8cc+Ph2Jzq9fL+f4zSs3wrAjtJp8BSIQNnPIX8+eYMzfHEaGeUXSL7IgPJ8Xo2cA7xQTpN40hK8PKd5EZxGyvYupxGY/wBO81ZwmqMpiuk+42OM8B6dBvsA2x078K1MFwgHneY7cpyG9cvH0o3KaYRn1QTbQnDIn389lMsS4jSS3i6QfJEB5S2Y3quocS4ADfkcptPUPGkJXp7TvBecRmBdTiMwHwSn+V5wmuX0e9HLrDmueLxHp8E+wNf2lh34VqbLhINO8w9znIZfJw13BpF7f7bwrIJMIZyGz7sRXlhPnCSZ0DZxvsUOOEm0EG/eE2/ME++aJ17siXfeE2/ZEw/jDp8VEC7wu2viGPgD+ZAa+LW9c1EY/rsYJ4X/VYX/KPfO8ZlVsneOBzqR27V37k4ObQuzRjCCg7Uw8SPcU4tnO9h/TxLeGaDFZ67J8x9JhT1cl4c62obpvYqun92Fe8G7S3h3CQ/r7fKdti++6NrfHU+8NQ88K/dtuBe824R3m/CwzbcD01rsk9ZiQLnssw2Syz5ju7HP7sC9fEofTSiyae0smeG1s9RHO609yX5zzA9//cxxupIfCjyuFwnMXfDT/3nmuLwYF+T9iDLxwfUigfl0Tj6nteEzBdpwTmlDCdrwOWiD4KDvc/zB929GuV4kPKum972LYY/BPE6ITnAMvB2GfwNtRvhvEH9ZLxI5RRa0NXvhepH05wY8WwN9Slvu5vAumd53Q3AMwTFSaAssztEwbnxkrIsj7UDb4vdqhR7a+hEM2PSKQhfj2i16FjCvamjzT2lHBM8FZjqVXYsDWo4mbcE+ighGcJ4CHSyTDKiXjfB6qWNJ3aUXgZnP0cs1D71cU/RynWQwptcnRW94lBHOdYZtO1k6WobnArPo0NHhkk269HQbZC+H+a2XpiX7ddUu7yMfAH7cZwKDfbZMMNxncwBzC56JbwtNjAtazoT0BOYW4ObFn7Uc3TMujt8zplcee+H7viF8z1D75RKeVRNsnEu0cY5zOasTrV/lGZ5DzjayTLQQT+ZvAf22hrHG5bcCs5kT2yJqH+tK04HgYGy7RTJk5a0R0MnKWwXmix2yZ43rEdDH9pxT6H89jOtfqozrG8BrmXjNAh15Fm6Z+pFfYa0W+wHjuMC8+vTE60aReI015ax4zTFdcKL0E1exxR6xn64DrYhoRcRvzhwfrzW8ZYAXGLRphBFcnC99naOfcB59HZ7dIXqWz9tTOhjve1bHYXzCOJHlIwLzLvCRbyjoIzjHi0zvhUdBjnKOJzyrJljemWg5NI8XAWNEQ/OjiPjLHE/kFFmuAo698N0jaQOO2Ty+aeOiwC8XpGU8aUV90oqI1knHwyN/dMRDbocrHj4BbdXiIY/VWs7EcxwtF0ZaUZ+0IqKFsQ5j6l2ir9UMMf5h/BX+g+bf7/TIv39dWd/V8hSOwVoO9x6IwR8eO04X6w8RPRtVvOF2aDnJd+fkonmxy2XzWNPl2IZ62Qivl8NcbaGAXgTmfTl6WfDQy4KiF213WgT3ojftKOAQtpOlI7QpgflgwXx2GWQ/yfoD95mWz7K9c5/NGT3H1eoPH1byO6GL9AQmAty8+PMvc3TPuJhvYn02hu8/AvJugKxZa5zyDOvz4/D8h8pd2h8F3j7ri9ZXcJ4neFy/v0N4uEYk3416rVKr9xRtM47rgldkLBf4W4FpLfVJaymgXOiH+E4c2w2uh+AaJ9c98tpZMv21swz3iI/3ZUc75Ttcp8P55CfHjssocVzgcY3zKE8EP/1lyGUkRuC8gNc414E/0/3VnBilteHXoA3rGW3AObHA/F/Ix/4HtEFw0Pe1M7oCnbvnnP8Kz9BndOWt8+HZjSFyCvZl7Yys8yCnyOJa45T+xHdbb4M+pS13cnjjWCcw2j4grq1kzTHeA++88Rqoyy/R1gXm82DTC+XjdDGu3aJnodepoox2aLlKKZW9aL1bW8vj/ElwsNa1SjJkrf0G0ksda00uvRytJebopcjaL+vluqKXiGQwptcnRW8CN+r18Q3ijzo659ARzjHWQfZRzTGOztEGftxnfB6XZu/cZ1m1GPFtoYlxAcdLoYv0BIZrLK74cy1H94yL4/eM6bUxe+G5YyF8z1D75RKeVRNsjfVwnF0l/uyvWFcUWKzh4e9Gs19rNVN5hrYfKLbV+o35G6cg5t9W+Enein7AsjccsiP9rDVUbI+2xvlayLe3ysfpYu1wmXhhPJdnp2mN80sKxutbIPsfpTVO7bxGXFsrcl7jdaKl4S0DvMBE6T2vceLvPQjMaxz9pNWzcM6M489bUjoY73E+9zUwPmGcyPIRgfk28JE/V9BHcI4Xmd7rC2ucj+8aJ47ZPL5p46K278VFy3jSivqkFRGtk46HR/4YcI0T4+FpXeO8S3Jp+zm0miHGP42/ln9j7EQYrAsIzLcWzL8xl/mkshap5Skcg7Uc7u0Qgz9QPk73hPZdqWucR3MWeC4w78rJRQdZ40SbdK1xjmDt9zBXWyqgF4H5rhy9LHnoRat7n7Y1ziwdoU0JzD8omM8ug+wnucbJfVZkjZP7LGuNU3wb1zg/oOR3QhfpCUwEuHnx50M5umdczDftdRdoXgI8eSbfv2uii//PIZ/1WSPE92FwnYffNV0jPFznWQNZR7neqNVsirYZ8yPBK5ITCfxyYFqLfdJaDCgX+hK+i8l2g2sauE7JtYu8dpb6bOci3As+n6G/6GinfIdr/TgnfAliBs5NywCP65RH82Dw05+BfERwMLcXHKn33AX+TPfncuKMdt7If4U23KU2CDzOawXm58e7NH5RaQP6PsefgO8iOuewuK4W6F3Qwzks7xG8m97jHDZQ/bih+TLvJZE5rMjJtUeew6JP4/7IW6BPactaDm+0M4ERHFyn5PrI4z6O+Z5FsOyBhzU7bHORmp3ArwamtdQnraWAcuE4hvtttHHsLtzLJ+ZtLJvWzpLpr51luEd8vC872infZY0B0+NdWvw+vsBrZwq8FsaAs+NdGXnPHtYUysRH229zPqXVzzh2oUAbtDMFbkMbLkMbeM+D5sOn4UyBkL+zmbfnZNRnCvA46nOmgPQn+vEy6FPaspbDu2SOr1Nr45jQxt/T4PVGa3vvhv02/O4/6oJtWnunYB1s+qsUv8S4xmuAo94z4TrTLnHEAaRlTPbaa0QwgrMOOlglGbL2IUVAd9j1rmsF9CIw2zl6GeRMAdRL3pkCvC4YOq/N0hHOvQTm6Zwx5HE8U4BzG+6zOYDBmpX4Nta7vkoZL4Uu/84Gxp8Jkx9/vrrg+I05gIzfWWcKnPR+m5BnCnC/amcKRCQTrgHhfpuIaEVES1s7Chjbav3G/Nf3GfO1MwUigika87W89TrQycpbBWbPIXvWuI70sT3nFPrfDuP6G5RxXVvHwv0F1+lZwPUJdQ2H10dwfeK50xOvj60vH407jvUJ7TdKstYncC+KwOB8j9ffNLvn8QHXqq878CKAFxg+UyAiOjhf+lZHP+E8Gn/jRXun7J8p8R7nc98J41MEcmT5iMD8MPjI3yroIzjHQ33ZK+A6p3OOhz8PEWi/j/rzEFF6j3O8UaxhCn+2a5nj8T4b/g1F3G8TpffavsmSyR4XBT4qSMt40hr0rJCTjocihysecjtc8RD322jxkMfqonW+yEFr0L2MeXtrMMZzzRDjX9H8m/fbaPm3wPwLj/x7GmJllD7X8hSOwRE8F5gfhRj8swpdrD9cp2ej3jOhvRcuMD+Wk4sOskcB353n2IZ6uRNeL4e52mIBvQjMj+foZdFDL9pZukskgzG94zP/bmTA3zduuHSENiUwP1Uwn41A9lHVH7R8lvtMy2fZ3rnPcP1C22+Nv6H9s0p+J3S1MwUwd8yLP/8lR/eMi/kmrmHjmI81Joy/uGYuML8E8e/zCl2Mf6v07DTVX3+1z7k4j5tF5+LLJAPq5TTWXz/VZ/21iF6K1l8xVxG9Yf010FzBWX9FmxKY3yoY/7AWMar4J3pz1V8FBvuM7V2rv2p5ovi20MS4UDLH90P0k/9p8ecPCuZ/uJdI9gHh+6ByhX7X2FD75RKeVROs/ns4B14m/uyvOOcRWJxf4JmuEdGKiBbi4fuOUZj2qfVXPvcMY/7ZtLAZIuZr7zpF8IzXLpCf1F/RD1j2iw7Zkf7tDPrYHq3+msC+vSsTx+lqtSXt7DCcs48yp9fqrwITOXSH8XoVZD/J+muRfDVrjqHVX8Ue0Tax7scxgscHrL8uO/AigBcYzm0jooM2+JSjn7Lqr9oZWl+f0sF4j/XX+kRXvgjkyPIRgflG8JFWQR/5Qv21yz9K70dVf82bq2fVXxcBx15a/RXH7IjawO3EteuoIC3jSWuY9deTiIcihysecjtc8VCrv2rxMAJaReJh5KB1vU9a14lWP/VXridg/MOcQvhzvRZlnCAYrAsIzF/KGUsZF98lyFpz4ByO7btnHRpi8NsnjtM9yfrrYkY7tJzkr+TkooPUGXFN4DTUXxcK6EVgns/RyyDng6JeFkkGY/T6q8CFflc2S0faubdvLZjPRiD7qOoPRz7gONOV30vScgXuM20PAMZEoYlxQRsDkZ7AcI7qij/vzNE942K+mXUe07vhezmvbgO+fw98/8f9XETep23Hd/n9zr/cefhM5y1f237js3vth88+96av6XzTC51vflgC8e5SU/C7rOaegWcX4H5G+R6vIuJbGN6KLjgyBZkFvq4jMl3dha/PYKkiS84v/Axpb5uL/gxmP7QqhPcg/YwHuurNER/r5vyZZuF52o916/dnNZaB7iB4WaXBIts2blF7hv3a2DrJhds98LUxfG1SPrWfonW1s2T6ayceXSH4bF+3HO2U77KOOP4YpBD8ypV2TLPALE52aXwcpieCg8e8CI6Uf3HIZ7o/nZN2aD9F+xK0YYPaoP0UrcD8Fr7CDW0o+lO0gdIBZzoiPEP/FC2/FqX9FG2g1+Ya2jjDx0RLSYuPH0Zbs5fPT9Gu5fDW8gjttTGhiXZ0j/hZs3tZSYvlqphg/ey0sw2QU2QKYWd83DXbGeZ/2G/y7AbIxjbLOSjiTXni3ffEuwftqaT30lbb/Z8FG0hPzTqCmza9sRX9jmM2T6swtv4OxLuLafxGujjm8WsOofOqlYx2YGlOYH43p3SyAn9rOaqWKwiO9pOVq4pe1sPrpY65lksvAlOedOtl2UMvy4peVkgGY3rjtehN4ComWE7ccOkIX7cVmCccOsKS0gbIPqqS0pEPAD/uM4HBPuNXrLnPMLfEMrr4ttDEuOCKza7XTlzx50qO7rWS0EsQF7VXCgPZ1WPzM8U818BlMxy3i8yN5JnUYALGtpoW86XftZi/lhPbBon5eIS3K+avKfxkTqO9Uigw9x2ya681MX1szzmF/jMwF6tPHqervTKJS/gr9Cz0Nk1eBhP+ETwXmC8qGK9P4hWao3HH8ZMLXBvRSvWCI3rQXu/NerW1SD1Oq/0wnrZcwK+L89arcYB5laOfMA9ehmc8Z7N8HqZ0sl4pfA2MTxgnsnxEYN4KPvLagj6C8zaML/YKuJ3SOS8TnlWQKcTYw3kHjxej2uIu/Dnvkfm/yCmy4FZAe+GWFm3rYJG6HB+xlkfLeNJa6ZMW5+EnHQ+P/HFIP0GDW1oEBuMhj9VazqTVRlcdtFb6pLVCtDDWYUzlXFurJ2P8c9XAXDFaYLQY/eacsZRxsT6s5Q5aDsf2jXnK34AY/P7J43Sx/rBCz0b9So3r1aS/mZOL5sUul83jmhvHNtTLCLadq6/UaHoRmL+bo5drHnq5puhFe6UGx2fRG75SE2isbrh0hHUJgfmegvnsKsh+2o804lyB+wxzUIx/2pES71fyO6GL9AQGaxd58ecHcnTPuJhvot3Jlh3bNw2QZXh9U4stvSa0AevLDXguMD+U43tN+NvSStJ77McGwQgO5sZ1kmEM4OqAj7A1eN4Avhoe3l8nHNvvCwSHfCYdbeFXATFO8+tYqF+B+VcO/VagLSHsoAXylEE+tA+B+bEcO2iZXr1odsC20iK9oC8I7Bh8j+MfwqIdtICvhof3dcKxdjBJcEX4aNuPawSn6Uh7lS/LdrCvBObjOXGHcS3N957ptktkFPzTFHf+U59xJ07vRxF3EnjeT9ypEY7t9/MEN0jcEfquuCMwv/SYxJ1f6TPuaHZQJO7USAaMO+j3CIt2oMUdxMN7V9yp9cFHvse4kxBc0biTZTvYVwLzmx5x50WIOyKj5HPW3uogy7DtDe0f21aH5wLzOzn2xn4oa+pob3WCERyMOzWSoYi9xfC8Dnzz7C0hHNwKrtnbpKMtWtwR+mw7qF+BkXlIVtwZ5fjDsR/Hn0mHnFpM0ewga/zBWJ+QDGNGH2cQFu2gCXw1PLznGIdxJ+mDj3yPcScmOE1HWtzJsh3sK4G55OiTGQXX0nwdxB2RcT79tPZWA1mGbW9o/9i2GjwXmKs59sZ+eCW9R3urEYzgYNxJSIYi9jYGz2vAN8/eYsKx/T5PcMhn0tEWLe4IfbYd1K/A3M2JO6Mcfzj24/jzVI4dcEzR7CBr/MFYH5MMY0YfZxAW7QDzXg0P7znGYdyJ++Aj32PcGSM4V66McSfLdrCvBOYVBeNOA2g+DXFHZFxX+ItNyD6+MYX/l0116e5MHacrPjXaGPeoRlnPaIcW417dZ4zTcvmsGHcPdMAxDvVyLbxe6prPa3oRmD/dp88X0UtD0YtWN9P8VODCxcVHtpOlIy0u/oUcH5S8Eve4jqq+LXrD+jb3mVYPy4rTooc5gInhGY+hGBdKpjd+lomewHD8c8Wf/RzdM66leeFM9/uYcCogewjfM9R+uYRnFWQKscchIf7sr1YnPLfHmuEYyMZ+XSNaiCd7zwPGtlq/Mf+FUxDz7yv8yua4H7Dsb3PIjvTXM+hje84p9L8PxvVvnzpOF39iuUa8MJ7jmm2Yut0jv+K6nfDX6nbvLBivY5B9VPtJjsYd4Mc1Msw7BSarjoh1FYHR5jeYo3KM4PFhDuATBx7OrQRG5JkgmKNxCmC+19FPWCfC3H2d6Fk+P57SwXiP++u+H3SNcSLLRwTmJ8FH3l/QR2R8nDG98cVe4WpM7v11wrNqguVUiZZ38HgRMEY0ND+qE3/ZX8c1/xbg2Av31/H8Em2oZLLHRa4/5NEynrTqfdLiPPyk4+GRPzriIbfDFQ9xf50rHmIfFomHNQetep+0uHal1cQx18YYz/UEjH+YUwh/Lf/muqfAYF1AYD5WMP/GXGZaWefV8hSOwVoO9wmIwZ+aOk4X6w91ejaqeMPt0HKSn8nJRfNil8vmsY7FsQ31ci28Xg5ztU2TrxeB+YUcvWya/vWyqeilRTIY0zs+i94ELuBY3XDpCOsSAvNywXy2BrKPqv5w5APAj/sM140FhnMF7jPMQTH+iW/j+u6nlPxO6CI9geEc1RV/PpOje8bFfBOPcOOffxA+GH95z6W9fhvi33zlOF2Mf2V6VjHBag0NHEe4Hdo48v9z/JzHTWkL2gyPbYKDc/H7JAPqZT28XuraHEPTy1FOU3Hrpeahl5qiF21dFecIojeBq5je2sWwbSdLR/fhucBUHTrC+Ifj20nWX7nPtPrrfYLhPpsDmDI80+qvEhdK5vjeZi3/KwNuXvy5nKN7xrU0P1E6/r1cAe3KWX8VnlWQKcQcmPtVeGH9lWuDOMcrg2zsq1yfRLwb6WfA2FbTYr70uxbzb+XENo75rCtXzMfaixbzhdaUwk/qrwIzoci+4ZAd6S9l0Mf2nFPov7rS5Z1UjtPFWmtMvDCe409MBartqGuKPPfF9bKtgvH6Hsh+kvWGvLoV5owCw/VRnNeLPQ6z3uBa28HYjjaNMOi3AvOVjn7CWgPWJJaInuXzfEoH4z3WX5+B8Slr7wH6iMC8GXzkqwv6CNZfUV/2Crg25ay/HuUxJtjaY+Ka+2D9dRRr6sKf7Vrqr1y7bACOvbD+Km3AMZvHN21c5Jw7j5bxpJX0SYvz8JOOh0f+6IiH2rpoVjzE+qsWD3ms1nKm+8QP8xyNVtInrYRoYaxz7XXA+If11+chvt0j/tcIHmWcIBjBHQeYb8kZSxnX0vyJNBhpuUO/8/a3QQx+X+U4Xaw/JPTsNO3h+c6cXHQYe2a0dRnUy3p4vdSxHurSi8D8nRy9FHnHkvXSVPTCtTxj9P3hAhe6/pqlI20//nsL5rMjWD9rFslnuc+0fDbr/QCsF2g5rvg21jvfp+R3QnfQ9ad/XLD+gOtPz0CcupU+X0k/7VdrIMvw+ubRfus70AaM7WvwXGA+lON7d+BvS0t0j/3I57ryz2xpZ32NmePnFDHsKjxfA74annZOouDYfl8hOOQzbbLbIm2IAIbPBtH0KzA/6tBvuLN+H9kB/vxlGeRD+xCYf5NjB3wur2YHWb9DgD+pc4tkGIPv8VwY7RwaY3p/V0DDw3s+a9XawTTBFeEj3y8DHT5bRdORlndl2Q72lcD8+4J5F/5UaR3yLpER90WGOVfxkb2h/WPb8MwcgfmPOfbGfijzMbQ3PsdHcDDu8PmcRextBZ7juW959rZKOLbfpwgO+Uw72qLFHTw/I0u/AvOLOXFnlOMPx34cf365z/FHs4Os8Qdj/SrJMGb0cUY7N8wAzTMZeHjPMQ7jzmoffOR7jDsrBKfpSIs7WbaDfSUwv1Ew7twBmk9C3BEZcT0gzHmyj+yNz+oW+fCcYoH57Rx7Yz+cTe/R3rLOj8W4s0oyFLG3m/Acz0TLs7cVwrH9foPgkM+0oy1a3BH6bDuoX4EppfOCrLgzyvGHYz+OP+MOObWYotlB1viDsZ7zzjGjjzMIi3aAea+Gh/cc4zDurPTBR77HuHOT4Fy5MsadLNvBvhKYC44+mVFwLc3fM912ic3jetSRXZrh29sqtMHSZl1jTF3MsTf0Z0tL+4m7FYJhf7Y6uEkyjBk9viAsrtevAF8ND+9vEA7WJm8qfK462iJtiABG6E+YbP0KzFpO3FkFusO2A4yDZXP8/FDM6e/l2AHHY80O2FY4LqAvCOyYOT4uMyzaAY4/Gh7e3yQcawdXCa4IH/ke4w6PNZqOpgFeYLJsB/tKYP5ETtxhXEvzZdNtl+DJ7zlZe7sAsgy7tnoR2oBtuwDPBeZLc+ztIvxtacl8Be3tAsEIDsadeZIhtA4uFdCBwLw6p3/5TJZRrn0d9SXwuwTyob5dfSI46AsCMw9484Sn+Y7ogX1HcMcB5s86dGtpik9IG2YUepbPB9N7a0sT8i4z6ETOoymn/wTmDMgkMH+x2qX7etD1ONG13/9V5Xu5Sr1/9qyni31YW6mEsZXDsaU61W1fGXiVof0CUwU5xuHvZ6vd59NTve0RXVRgv/BUej89lY03TnhzADMFeBXCq1C/2T74xlS+qun1gyHqMsG+tvb3h+hOR2uHawEA","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"verify_private_authwit","is_unconstrained":false,"custom_attributes":["private","noinitcheck","view"],"abi":{"error_types":{"12265343917440897559":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7Z3tbhzHsYbvRb/9Y+qjq7tzKwdB4CROIMCQg9g5wEGQez9DWbukxOV2NNxuPaXlH8O0Z7rene2q6lru8/Lf7/7605//9fc/vf/wt19+ffeH//n3u59/+cuPv73/5cP+07/fiX38b7/+48cPDz/++tuP//zt3R+kqv/w7qcPf334V/P//PDub+9//undH6r854dnF2stp4u11jhfLOoXrja38ulqK1sbXC1brdtJyVbboxSV7dL1rerp8tblfLVdXFzkJEUk/OnFf/zhnfjbk3nhyZS3J/PCk4m3J/PCk6mvfjLWrJ1ea6uPF0srHyO06RH6V0bY79Ht0j3qpZ/eZG99sCP6dnrTbHuiql16y3Qr57dBt+jb49rl4o7QHucdYVsf7QjfTk9IXOtrdoTK25N54cno25N54ckY/MmY2eOT8bquvqq/PZkXnkx5ezIvPJl49ZMxsVPzM6nb4MnUqKeV26aDZ96Kni9uT042dlHH/rBOOtQfn8peqz6+0no3r7R9P6/U7XT1nhb9s1d6YatHyPkYtpVnz6Xf63OpT55Ljy+fi23fz3Mp0s+zUBk+l83b4yi0Pbn6kmw/D2VeHnXUi5duenqF/nRh7R+ft7w97xs/b7GTDJcnDfHT89a35710f9vb8166v/3teS/d3+XteS/d39/RjMJ43lb9dCC02p6Mmx9nQvuOJqWve95Sz89b+ufP++G5fEdz1U2fy3c0V93yufjdzlV6nk5Fn/4O5WLdku5x/qxM2uizr2/3WZnf7dz2nb6fdzsXfqfv5/c0d8b5d/qxbYP3s2/t9A71/Zk/Xt0u/bZBrbRT21ILqZ9d//Ac/e053uQ5rp4T9/w5rdzls5Uf1Cyeomz/tfDp4s3jSzUVpaah1HSSmrKh1AhKjaLUGEqNo9QUlBpULS6oWlxQtbiganGganGganGganGganGganGganGganGganGganGganFF1eKKqsUVVYsrqhZXVC2uqFpcUbW4ompxRdXiiqrFDVWLG6oWN1Qtbqha3FC1uKFqcUPV4oaqxQ1VixuqFndULe6oWtxRtbijanFH1eKOqsUdVYs7qhZ3VC3uqFosG6oYy4aqxrKhyrFsqHosG6ogy4aqyLKhSrJsqJosG6ooy8aqysKqysKqysKqysKqysKqysKqysKqysKqysKqysKqysqqysqqysqqysqq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","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","pack_returns_oracle_wrapper","directive_invert","directive_integer_quotient"]}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000a74a8dc0"},{"kind":"string","value":"PublicKeyNote"},{"fields":[{"name":"x","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"y","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"SchnorrAccount"}},{"name":"fields","value":{"fields":[{"name":"signing_public_key","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrAccount::verify_private_authwit_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrAccount::verify_private_authwit_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"signing_pub_key_x","type":{"kind":"field"}},{"name":"signing_pub_key_y","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrAccount::constructor_parameters"}}],"kind":"struct","path":"SchnorrAccount::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"}},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"}},{"name":"cancellable","type":{"kind":"boolean"}}],"kind":"struct","path":"SchnorrAccount::entrypoint_parameters"}}],"kind":"struct","path":"SchnorrAccount::entrypoint_abi"}]}},"file_map":{"100":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\nunconstrained pub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"102":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N> + NullifiableNote {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\nunconstrained pub fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"},"118":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"121":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m: NpkM { inner: Point::empty() },\n            ivpk_m: IvpkM { inner: Point::empty() },\n            ovpk_m: OvpkM { inner: Point::empty() },\n            tpk_m: TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x: serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x: serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x: serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"123":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"},"124":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"131":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr","source":"use dep::protocol_types::{constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note where Note: NoteInterface<N> + NullifiableNote {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    unconstrained pub fn view_note<let N: u32>(self) -> Note  where Note: NoteInterface<N> + NullifiableNote {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"},"146":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"148":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"150":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\nunconstrained pub fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"151":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: u32 = 24;\n\npub struct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"152":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"154":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr","source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\nunconstrained pub fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"},"155":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(contract_address: AztecAddress, randomness: Field, encrypted_event: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(contract_address, randomness, encrypted_event, counter)\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\nunconstrained pub fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n"},"156":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n"},"159":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(storage_slot, note_type_id, serialized_note, note_hash, counter)\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter)\n    };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"},"161":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained pub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"162":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"166":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> Field {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> Field {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe {\n        notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter)\n    };\n}\n\nunconstrained pub fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"169":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::get_ovsk_app, public_keys::{PublicKeys, OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_log\n};\nuse dep::protocol_types::{hash::sha256_to_field, address::AztecAddress, abis::note_hash::NoteHash};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] = compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress\n) {\n    let ovsk_app: Field  = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"},"170":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"171":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes, encrypted_logs::{header::EncryptedLogHeader},\n    keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::{OvpkM, IvpkM}}\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P]\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe {\n        random()\n    };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(plaintext: [u8; P], eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field\n    ).to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::{compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext},\n        keys::public_keys::{OvpkM, IvpkM}\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{address::AztecAddress, point::Point, scalar::Scalar};\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41, 2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239, 247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118, 183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183, 12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78, 101, 153, 0, 0, 16, 39\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_log(contract_address, ovsk_app, ovpk_m, ivpk_m, recipient, plaintext);\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239, 95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25, 244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91, 68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76, 26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178, 143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189, 117, 147, 101, 230, 132\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(recipient, recipient_ivpk, sender_ovsk_app, eph_sk, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n"},"176":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n"},"185":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"188":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{execution::{get_chain_id, get_version, get_contract_address, get_block_number}, storage::storage_read};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"},"199":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"200":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"202":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"203":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"210":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"229":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        debug_log_oracle_wrapper(msg, args)\n    };\n}\n\nunconstrained pub fn debug_log_oracle_wrapper<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"248":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"265":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\npub struct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self { nullifier: 0, next_nullifier: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable<ScopedReadRequest> for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.next_nullifier == other.next_nullifier)\n            & (self.next_index == other.next_index)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    pedersen_hash_with_separator_noir(input, separator)\n}\n\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator_noir(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n"},"299":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    /// \n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    /// \n    /// example\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    /// \n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    /// \n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    /// \n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    /// \n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    /// \n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Ord + Eq {\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Eq {\n    /// Returns a new sorted array by sorting it with a custom comparison function. \n    /// The original array remains untouched. \n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    /// \n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    /// \n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]), \"Array has not been sorted correctly according to `ordering`.\"\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n"},"310":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"311":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"334":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl <let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\nglobal ZERO = 0;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"70":{"path":"/home/lima.linux/aztec/alpha-build2/azguard-nft/contracts/account/src/public_key_note.nr","source":"use dep::aztec::prelude::{NoteHeader, NullifiableNote, PrivateContext};\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify, keys::getters::get_nsk_app,\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note\n};\n\n// Stores a public key composed of two fields\n// TODO: Do we need to include a nonce, in case we want to read/nullify/recreate with the same pubkey value?\n#[note]\npub struct PublicKeyNote {\n    x: Field,\n    y: Field,\n    // We store the npk_m_hash only to get the secret key to compute the nullifier\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for PublicKeyNote {\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl PublicKeyNote {\n    pub fn new(x: Field, y: Field, npk_m_hash: Field) -> Self {\n        PublicKeyNote { x, y, npk_m_hash, header: NoteHeader::empty() }\n    }\n}"},"71":{"path":"/home/lima.linux/aztec/alpha-build2/azguard-nft/contracts/account/src/main.nr","source":"mod public_key_note;\n\n// Account contract that uses Schnorr signatures for authentication.\n// The signing key is stored in an immutable private note and should be different from the encryption/nullifying key.\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract SchnorrAccount {\n    use dep::std;\n\n    use dep::aztec::prelude::{AztecAddress, PrivateContext, PrivateImmutable};\n    use dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\n    use dep::authwit::{\n        entrypoint::{app::AppPayload, fee::FeePayload}, account::AccountActions,\n        auth_witness::get_auth_witness, auth::{compute_authwit_nullifier, compute_authwit_message_hash}\n    };\n    use dep::aztec::{hash::compute_siloed_nullifier, keys::getters::get_public_keys};\n    use dep::aztec::oracle::get_nullifier_membership_witness::get_low_nullifier_membership_witness;\n    use dep::aztec::macros::{storage::storage, functions::{private, initializer, view, noinitcheck}};\n\n    use crate::public_key_note::PublicKeyNote;\n\n    #[storage]\n    struct Storage<Context> {\n        signing_public_key: PrivateImmutable<PublicKeyNote, Context>,\n    }\n\n    // Constructs the contract\n    #[private]\n    #[initializer]\n    fn constructor(signing_pub_key_x: Field, signing_pub_key_y: Field) {\n        let this = context.this_address();\n        let this_keys = get_public_keys(this);\n        // Not emitting outgoing for msg_sender here to not have to register keys for the contract through which we\n        // deploy this (typically MultiCallEntrypoint). I think it's ok here as I feel the outgoing here is not that\n        // important.\n\n        let mut pub_key_note = PublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this_keys.npk_m.hash());\n        storage.signing_public_key.initialize(&mut pub_key_note).emit(encode_and_encrypt_note(&mut context, this_keys.ovpk_m, this_keys.ivpk_m, this));\n    }\n\n    // Note: If you globally change the entrypoint signature don't forget to update account_entrypoint.ts file\n    #[private]\n    #[noinitcheck]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload, cancellable);\n    }\n\n    #[private]\n    #[noinitcheck]\n    #[view]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    #[contract_library_method]\n    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {\n        // docs:start:is_valid_impl\n        // Load public key from storage\n        let storage = Storage::init(context);\n        let public_key = storage.signing_public_key.get_note();\n        // Load auth witness\n        let witness: [Field; 64] = unsafe {\n            get_auth_witness(outer_hash)\n        };\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n\n        // Verify signature of the payload bytes\n        std::schnorr::verify_signature(\n            public_key.x,\n            public_key.y,\n            signature,\n            outer_hash.to_be_bytes::<32>()\n        )\n        // docs:end:is_valid_impl\n    }\n\n    /**\n    * @notice Helper function to check validity of private authwitnesses\n    * @param consumer The address of the consumer of the message\n    * @param message_hash The message hash of the message to check the validity\n    * @return True if the message_hash can be consumed, false otherwise\n    */\n    unconstrained fn lookup_validity(consumer: AztecAddress, inner_hash: Field) -> pub bool {\n        let public_key = storage.signing_public_key.view_note();\n\n        let message_hash = compute_authwit_message_hash(consumer, context.chain_id(), context.version(), inner_hash);\n\n        let witness: [Field; 64] = get_auth_witness(message_hash);\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n        let valid_in_private = std::schnorr::verify_signature(\n            public_key.x,\n            public_key.y,\n            signature,\n            message_hash.to_be_bytes::<32>()\n        );\n\n        // Compute the nullifier and check if it is spent\n        // This will BLINDLY TRUST the oracle, but the oracle is us, and\n        // it is not as part of execution of the contract, so we are good.\n        let nullifier = compute_authwit_nullifier(context.this_address(), inner_hash);\n        let siloed_nullifier = compute_siloed_nullifier(consumer, nullifier);\n        let lower_wit = get_low_nullifier_membership_witness(context.block_number(), siloed_nullifier);\n        let is_spent = lower_wit.leaf_preimage.nullifier == siloed_nullifier;\n\n        !is_spent & valid_in_private\n    }\n}"},"73":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/authwit/src/auth_witness.nr","source":"#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n * \n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\nunconstrained pub fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n"},"75":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::poseidon2_hash_with_separator\n};\nuse dep::aztec::{context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        comptime {\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\")\n    },\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress\n) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime {\n        FunctionSelector::from_signature(\"consume((Field),Field)\")\n    },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(consumer: AztecAddress, chain_id: Field, version: Field, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime {\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\")\n    },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime {\n        FunctionSelector::from_signature(\"set_reject_all(bool)\")\n    },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n"},"78":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize}\n};\n\nuse crate::entrypoint::function_call::FunctionCall;\n\n// FUNCTION_CALL_SIZE * ACCOUNT_MAX_CALLS + 1\nglobal APP_PAYLOAD_SIZE: u32 = 21;\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\npub struct AppPayload {\n  function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Serialize<APP_PAYLOAD_SIZE> for AppPayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; APP_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, APP_PAYLOAD_SIZE> = BoundedVec::new();\n        for call in self.function_calls {\n            fields.extend_from_array(call.serialize());\n        }\n        fields.push(self.nonce);\n        fields.storage\n    }\n}\n\nimpl Hash for AppPayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n    }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"},"79":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__FEE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize}\n};\nuse crate::entrypoint::function_call::FunctionCall;\n\n// 2 * 5 (FUNCTION_CALL_SIZE) + 2\nglobal FEE_PAYLOAD_SIZE: u32 = 12;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: u32 = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS: u32 = 2;\n\n// docs:start:fee-payload-struct\npub struct FeePayload {\n  function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n  nonce: Field,\n  is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Serialize<FEE_PAYLOAD_SIZE> for FeePayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; FEE_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, FEE_PAYLOAD_SIZE> = BoundedVec::new();\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            fields.extend_from_array(self.function_calls[i].serialize());\n        }\n        fields.push(self.nonce);\n        fields.push(self.is_fee_payer as Field);\n        fields.storage\n    }\n}\n\nimpl Hash for FeePayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__FEE_PAYLOAD)\n    }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage\n    }\n\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n"},"80":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/authwit/src/account.nr","source":"use dep::aztec::{\n    context::PrivateContext,\n    protocol_types::constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\n    hash::poseidon2_hash_with_separator\n};\n\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\nuse crate::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash};\n\npub struct AccountActions<Context> {\n  context: Context,\n  is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n *\n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /**\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     *\n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     *\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let valid_fn = self.is_valid_impl;\n\n        let combined_payload_hash = poseidon2_hash_with_separator(\n            [app_payload.hash(), fee_payload.hash()],\n            GENERATOR_INDEX__COMBINED_PAYLOAD\n        );\n        assert(valid_fn(self.context, combined_payload_hash));\n\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n        app_payload.execute_calls(self.context);\n        if cancellable {\n            let tx_nullifier = poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\n            self.context.push_nullifier(tx_nullifier);\n        }\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     *\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     *\n     * Will revert if the message is not authorized.\n     *\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can\n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n"},"98":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"},"99":{"path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"}}}