{"noir_version":"0.36.0+1094f036be7b102252a3a5c0d4b8c621779cf4bd-aarch64","name":"SchnorrAccount","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"3469988399892582431":{"error_kind":"fmtstring","length":20,"item_types":[]}}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["private","noinitcheck"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"app_payload","type":{"kind":"struct","path":"authwit::entrypoint::app::AppPayload","fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"target_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}]}}},{"name":"nonce","type":{"kind":"field"}}]},"visibility":"private"},{"name":"fee_payload","type":{"kind":"struct","path":"authwit::entrypoint::fee::FeePayload","fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"target_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}]}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"cancellable","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"databus"},"error_types":{"3469988399892582431":{"error_kind":"fmtstring","length":20,"item_types":[]}}},"bytecode":"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Y1tl26rYlmRbsm1VbatmW3Xbath2hW1X2naVbTVtu9q2a5zPgtlW27ZrbbvOtjq21bWtnm3X21bftga2NbTtBtsa2dbYtia23WhbU9ua2XaTbTfb1ty2FrbdYtuttrW0rZVtrW27zbY2trW17Xbb7rCtnW3tbetgW0fbOtmWYltn27rY1tW2brbdadtdtnW3rYdtPW3rZVtv2/rY1te2fral2tbftrttG2DbQNsG2TbYtntsG2LbUNvute0+24bZNty2Ebbdb9tI20bZNtq2B2wbY9tY28bZNt62CbZNtG2SbZNtm2LbVNum2Tbdthm2zbRtlm0P2jbbtjm2PWTbXNvm2Tbftodte8S2BbYttO1R2x6zbZFti2173DbnO+id71F3vlfc+d5l57uDne9Wdb4v0vnOQ+c7AJ3vSHO+58v53ivnO6Wc72tyvgvJ+Z4h5zt8nO/Hcb57xvleF+c7U5zvI3G+68P57gvneyXW2OZ8h4Hz/QDOs/ed59o7z4x3nsfuPOvceY6484xu5/nXzrOlnec2O89Edp437DzL13lOrvMMWuf5rs6zU53nkjrP/HSep+k8q9J5DqTzjEXn+YXOswGd5+45z7RznhfnPIttp23OM8Sc53M5z75ynivlPLPJeR6S86wh5zk+zjNynOfPOM92cZ6b4jyTxHneh/MsDec5Fc4zIJznKzjPLnCeC+DULufz7M5nxZ3PYTufcXY+P+x8Ntf53KvzmVLn85rOZyGdwu58hs/5fJzz2TPnc13OZ6aczyM5n/VxPkfjfEbF+fyH89kK53MLzmcCnPvtnXvZnfvEnXuwnfubnXuHnftynXtenftJnXs1nfsgnXsMnfv3nHvjnHvFnHunnHuJnHtrgrY591449yI41+ada9XOtVvnWqZzbc+51uVc+3GuhTjXBpy9cmfv2NlLdfYWnb02Z+/J2Ytx9iactbqzdnXWcs7axtH6jvZ1tKCjjRytkO1/aS/g1HrnVT9w+pU2JX9pAOd9554x5x4q554i5x4b554T5x4M554E5xq9c83auYbrXNN0rvE517yca0DONRHnGoGzZ+7sITt7qs4eo7Pn5uxBOXsyzh6Fs2Z31rDOmi5oWynbStvmaEJHIznf91LOtottK29bBdsuse1S2yraVsm2y2y73DZHsBnbKttWxbYk25Jtq2pbNduq21bDtits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","debug_symbols":"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udNJz9zppGfudNIzdzrpmTudFN7ptCH+zPew8E6nDfFnvoc9c6eTnrnTSc/c6aRn7nRSeKfT/UgM73TaEH/me1h4p9OG+DNfYc/c6aRn7nTSM3c66Zk7nfTMnU4K73TaEM++wm6IP/M9LLzTaUP8ma+wZ+500jN3OumZO50U3ul0PxLDO502xJ/5HvbMnU565k4nPXOnk56500nP3OmkZ+50Unin032rPHOnk56500nhnU4bn/kzX2HP3OmkZ+500jN3OumZO50U3ul03yrhnU4b4s98hYV3Om2IP/MV9sydTnrmTic9c6eTnrnTSc/c6aTwTqf74uGdThviz/w9LLzTaUP8ma+w7E6nyHERH6kfxR99hR1jXsWHv9/zDz0PvWj+OMQOl7YQux7C6v7II4dcNk592zjq1vosb/+4i7992EbVT/V5avV1ZvV79Cn9kfpalsvGZX5f/UjXcZ3VLd/0p9/YXta/vqzN+uccv2z/Y97RbF5pNq82m9fI89aw665rvbLf0O/H6l/3fF1RefcPcFu/25vX+vpI5Yb+eXL9gdY/7Z3+WTf058n116n127KcXH+vPGBLrzxgS688YIs1m9ebzTubzRvN5s1m81aveUev5y02muWrcXS+injbuPT9vD/0KEyPwfSwnz+IXnftUsuNz9vB38hLXDeWXOT+niVDLxvX8u7uS29+j+J5GVbneLf1t8N82Lo0Lqdurd8g7HDmxmsld1rJfK3kTivJfjq09XTRhP10aFv/OLl+e52J+5yJRxeUPfFKvhLLXivZ7NmINHs2Is2ejWizZyPa7NmINvvuaY++uD2fdajD9EyYHvbvQmw+C9KErefJ716PbmB73qR6dB3cE6+knPyc0pPrh11DDX5PlPOaqabJjfVE3+Ns/v6q+esasZOz+esasddKHn2ftSeRYq6nVm+nVt/st+m82W/TebMnxt7sibGfPE1N9BPgivDr1rn4xr/XfLPmmfLOmn/Oin76u/Os6Ce/O8+KJg52ntUazYrORn8869TrrOkfZkXnop1nRWeinWdF56GdZ2VnoV1njefKTfdnfa7cdH/W58pN92d9rtx0f1ZrNGuj3BSNclM0yk3RKDdFo9yUjXJTNspN2Sg3ZaPctEcv5WlmbZSbslFuyka5KRvlpmyUm9itoTvP2ig3sdtCd561UW6Ct4TuO2uj3FSN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CeMHJ4wfnDB+cML4wQnjByeMH5wwfnDC+MEJ4wcnjB+cMH5wwvjBCeMHJ4wfnDB+cML4wQnjByeMH5wwfnDC+MEJ4wcnjB+cMH5wwvjBCeMHJ4wfnDB+cML4wQnjByeMH5wwfnDC+MEJ4wcnjB+cMH5wwvjBCeMHJ4wfnDB+cML4wQnjByeMH5wwfnDC+MEJ4wcnjB+cMH5wwvjBCeMHJ4wfnDB+cML4wQnjByeMH5wwfnDC+MEJ4wcnjB+cMH5wwvjBCeMHJ4wfnDB+cML4wQnjByeMH5wwfnDC+MEJ4wcnjB+cMH5wwvjBCeMHJ4wfnDB+cML4wQnjByeMH5wwfnDC+MEJ4wcnjB+cMH5wwvjBCeMHJ4wfDBg/GDB+MGD8YMD4wVhY/hwwfjBg/GDA+MGA8YMB4wcDxg8GjB8MGD8YMH4wYPxgwPjBgPGDAeMHA8YPBowfDBg/GDB+MGD8YMD4wYDxgwHjBwPGDwaMHwwYPxgwfjBg/GDA+MGA8YMB4wcDxg8GjB8MGD8YMH4wYPxgwPjBgPGDAeMHA8YPBowfDBg/GDB+MGD8YMD4wYDxgwHjBwPGDwaMHwwYPxgwfjBg/GDA+MGA8YMB4wcDxg8GjB8MGD8YMH4wYPxgwPjBgPGDAeMHA8YPBowfDBg/GDB+MGD8YMD4wYDxgwHjBwPGDwaMHwwYPxgwfjBg/GDA+MGA8YMB4wcDxg8GjB8MGD8YMH4wYPxgwPjBgPGDAeMHA8YPBowfDBg/GDB+MGD8YMD4wYDxgwHjBwPGDwaMH0wYP5gwfjBh/GDC+MFcWP6cMH4wYfxgwvjBhPGDCeMHE8YPJowfTBg/mDB+MGH8YML4wYTxgwnjBxPGDyaMH0wYP5gwfjBh/GDC+MGE8YMJ4wcTxg8mjB9MGD+YMH4wYfxgwvjBhPGDCeMHE8YPJowfTBg/mDB+MGH8YML4wYTxgwnjBxPGDyaMH0wYP5gwfjBh/GDC+MGE8YMJ4wcTxg8mjB9MGD+YMH4wYfxgwvjBhPGDCeMHE8YPJowfTBg/mDB+MGH8YML4wYTxgwnjBxPGDyaMH0wYP5gwfjBh/GDC+MGE8YMJ4wcTxg8mjB9MGD+YMH4wYfxgwvjBhPGDCeMHE8YPJowfTBg/mDB+MGH8YML4wYTxgwnjBxPGDyaMH0wYP5gwfjBh/GDC+MGE8YMJ4wcT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","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","enqueue_public_function_call_internal","call_private_function_internal","debug_log_oracle_wrapper","notify_set_min_revertible_side_effect_counter_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"constructor","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"signing_pub_key_x","type":{"kind":"field"},"visibility":"private"},{"name":"signing_pub_key_y","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"databus"},"error_types":{}},"bytecode":"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","debug_symbols":"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J6+1F845mXjjnLOJc87ZxDnn5HfOxjlnE2+ITybOOWcT55yziXPO2cQ552zinHMy8SvnnE2cc84mzjlnE+ecs4k3xCcT55yziXPOyWvtlXPOJs45ZxPnnJOJ3zjn5HfOG+ecTZxzzibOOWcTb4hPJs45ZxPnnLOJc87ZxDnnbOKcczLxO+ecTZxzzibOOWcT55yziTfE5661d845mzjnnE2cc84mzjlnv3NyzsnEH5xzNnHOOZs455xNnHPOJt4Qn0ycc84mzjlnE+ecs4lzztnEOedk4k/OOZs455xNnHNOXmufnHM28Yb4ZOKcczZxzjn7nZNzzibOOWcT55xziV9PnHM2cc45mzjnnE2cc84m3hCfTJxzzibOOWcT55yziXPO2cQ552TiZ845d629njnnbOKcczZxzjmbeEN88jsn55xNnHPOJs45ZxPnnLOJc87JxDfOOZs455xNnHPOJs45ZxNviE8mzjlnE+ecs4lzztnEOefktXbjnJOJXzjnbOKcczZxzjn5nfPCOWcTb4hPJs45ZxPnnLOJc87ZxDnnbOKcczLxxjlnE+ecs4lzztnEOeds4g3xycQ552zinHPyWts452zinHM2cc45mfiVc05+57xyztnEOeds4pxzNvGG+GTinHM2cc45mzjnnE2cc84mzjknE79xztnEOeds4pxzNnHOOZt4Q3zuWnvjnLOJc87ZxDnnbOKcc/Y7J+ecTPzOOWcT55yziXPO2cQ552ziDfHJxDnnbOKcczZxzjmbOOecTZxzTib+4JyziXPO2cQ55+S19sE5ZxNviE8mzjlnE+ecs985Oeds4pxzNnHOOZn4k3POJs45ZxPnnLOJc87ZxBvik4lzztnEOeds4pxzNnHOOZs455xL/HbinHPX2tuJc84mzjlnE+ecs4k3xCe/c3LO2cQ552zinHM2cc45mzjnnEz8zDlnE+ecs4lzztnEOeds4g3xycQ552zinHM2cc45mzjnnLzWnjnnZOIb55xNnHPOJs45J79zbpxzNvGG+GTinHM2cc45mzjnnE2cc84mzjknE79wztnEOeds4pxzNnHOOZt4Q3wycc45mzjnnLzWXjjnbOKcczZxzjmZeOOck985G+ecTZxzzibOOWcTb4hPJs45ZxPnnLOJc87ZxDnnbOKcczLxK+ecTZxzzibOOWcT55yziTfE5661V845mzjnnE2cc84mzjlnv3NyzsnEb5xzNnHOOZs455xNnHPOJt4Qn0ycc84mzjlnE+ecs4lzztnEOedk4nfOOZs455xNnHNOXmvvnHM28Yb4ZOKcczZxzjn7nZNzzibOOWcT55yTiT8452zinHM2cc45mzjnnE28IT6ZOOecTZxzzibOOWcT55yziXPOycSfnHPyWvvknLOJc87ZxDnnbOIN8cnvnJxzNnHOOZs455xNnHPOJs455xK/nzjnbOKcczZxzjmbOOecTbwhPpk455xNnHPOJs45ZxPnnHPX2vuJc04mfuacs4lzztnEOefkd84z55xNvCE+mTjnnE2cc84mzjlnE+ecs4lzzsnEN845mzjnnE2cc84mzjlnE2+ITybOOWcT55yT19qNc84mzjlnE+eck4lfOOfkd84L55xNnHPOJs45ZxNviE8mzjlnE+ecs4lzztnEOeds4pxzMvHGOWcT55yziXPO2cQ552ziDfG5a23jnLOJc87ZxDnnbOKcc/Y7J+ecTPzKOWcT55yziXPO2cQ552ziDfHJxDnnbOKcczZxzjmbOOecTZxzTiZ+45yziXPO2cQ55+S19sY5ZxNviE8mzjlnE+ecs985Oeds4pxzNnHOOZn4nXPOJs45ZxPnnLOJc87ZxBvik4lzztnEOeds4pxzNnHOOZs455xM/ME5J6+1D845mzjnnE2cc84m3hCf/M7JOWcT55yziXPO2cQ552zinHMy8SfnnE2cc84mzjlnE+ecs4k3xCcT55yziXPO2cQ552zinHPyWvvknHOJP06cczZxzjmbOOec+875OHHO2cQb4pOJc87ZxDnnbOKcczZxzjmbOOecTPzMOWcT55yziXPO2cQ552ziDfHJxDnnbOKcc/Jae+acs4lzztnEOedk4hvnnPzOuXHO2cQ552zinHM28Yb4ZOKcczZxzjmbOOecTZxzzibOOScTv3DO2cQ552zinHM2cc45m3hDfO5ae+Gcs4lzztnEOefsP8c552zinHMy8cY5ZxPnnLOJc87ZxDnn5OuwNcQnE+ecs4lzztl/jnPO2cQ552zinHMy8SvnnE2cc84mzjknX4dXzjmbeEN8MnHOOZs455z9zsk5ZxPnnLOJc87JxG+cczZxzjmbOOecTZxzzibeEJ9MnHPOJs45ZxPnnNnE74/z5z/5cemJc86/QPzc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","brillig_names":["get_contract_instance_internal","get_public_keys_and_partial_address","decompose_hint","notify_created_note_oracle_wrapper","get_key_validation_request","random","lt_32_hint","lte_16_hint","build_msg_block","attach_len_to_msg_block","build_msg_block","emit_encrypted_note_log_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"verify_private_authwit","is_unconstrained":false,"custom_attributes":["private","noinitcheck","view"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"authwit::aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"databus"},"error_types":{"3469988399892582431":{"error_kind":"fmtstring","length":20,"item_types":[]}}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","pack_returns_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"lookup_validity","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"consumer","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"5Z3djiPHkYXfZa51kZEZ+edXWSwWsi0bAgTJsOQFFobefTlk82dETgaazml+kXljj6wq9vnG7HNOFSuC//701x/+/K+//8+PP//tl18//em//v3pp1/+8v1vP/7y8+Gf/v37d5/+/M8ff/rpx7//z+3//Cl8/g+Jx+N//cf3P3/+x19/+/6fv336k5Qevvv0w89/PfyxhnB4hb/9+NMPn/5U5ffv7g5uQd+ObTFeDpXWHhybY347Nufry0rOv//3d58k/eda8vn1W62GFk397Vgt7U6L/sdaeohvx3YphpYSzrpLLHda8n+uRc/H9pwsLe187O3LnrWUd2r5fE594pz2xDn9/efE8MQ58sQ58Ylz0hPn6BPn5CfOeeJ9EJ94H8SH74NUVd7OSfXmF/3hez/lcjm4yI1DpfDoN6Xlsy30Vm9+V0I86uksPSnA9AhMT4TpSTA9CtOTYXoKTE+F6YH5c4L5s8L8WWH+rDB/Vpg/K8yfFebPCvNnhfmzwvxZYf6cYf6cYf6cYf6cYf6cYf6cYf6cYf6cYf6cYf6cYf5cYP5cYP5cYP5cYP5cYP5cYP5cYP5cYP5cYP5cYP5cYf5cYf5cYf5cYf5cYf5cYf5cYf5cYf5cYf5cYf7cYP7cYP7cYP7cYP7cYP7cYP7cYP7cYP7cYP7cYP7cYf7cYf7cYf7cYf7cYf7cYf7cYf7cYf7cYf7cYf4sAWbQEmAOffgvmiCYR0uAmbQEmEtLgNm0BJhPS4AZtQSaUwvNqYXm1EJzaqE5tdCcWmhOLTSnFppTC82phebUkebUkebUkebUkebUkebUkebUkebUkebUtOFCoU0XCm28UGjzhUIbMBTahKHQRgyFNmMotCFDoU0ZCm3MUGhzhkIbNBTapKHQRg2FNmsotGFDoU0bCm3cUGjzhkIbOBTaxKHQRg6FNnMotKFDoU0dCm3sUGhzh0IbPBTa5KHQRg+FNnsotOFDoU0fCm38UGjzh0IbQBTaBKLQRhCFNoMotCFEoU0hCm0MUWhziEIbRBTaJKLQRhGFNosotGFEoU0jCm0cUWjziEIbSBTaRKLQRhKFNpMotKFEoU0lCm0sUWhziUIbTBTaZKLQRhOFNpsotOFEoU0nCm08UWjziUIbUBTahKLQRhTlw2cUJYRY3w6XoF2+kHR/fKzp/HUihz9ev0+kfpYfP3yicbJ88S0/+paffMtX3/IzXL7WkN4Oz6H269H50TcNJU3nr35JTb48+ohb9sKte+G2vXDprWEurtBbxmRceiuZjEtvMZNx6a1nMq7uhbtXq5K9WpXs1apkr1Yle7WquFerinu1qrhXq4p7taoP31jwYty9WlXcq1XFvVpV3KtVxb1aVdqrVaW9WlXaq1WlvVrVh28XeTHuXq0q7dWq0l6tKu3VqtJerUr3alW6V6vSvVqV7tWqPnwT0Itx92pVuler0r1ale7VqnSvVpX3alV5r1aV92pVea9W9eFbu16Mu1erynu1qrxXq8p7taq8V6sqe7WqslerKvRWlSWcXz2LhHsAek8yAdQ7AL3LfAlQ7wHo7cQEoPcNE4DeILLUK0B78DtA7wQWQKWnvAnA/3+gn1cn5BjLHUDDJ3Ev58Nzvz36DIBPYgsAn8QWAD6JLYCPT+IsegHI6UuAo6TKk9R4kjpOUg88ScKTFHmSEk+S8iRlniSee3eee3eee3ece6eAc+8UcO6dAs69U8C5dwo4904B594p4Nw7BZx7p4Bz7xR47i089xaeewvPvYXn3sJzb+G5t/DcW3juLTz3Fp57R557R557R557R557R557R557R557R557R557R557J557J557J557J557J557J557J557J557J557J557K8+9lefeynNv5bm38txbee6tPPdWnnsrz72V596Z596Z596Z596Z596Z596Z596Z596Z596Z596Z596F596F596F596F596F596F596F596F596F596F596V596V596V596V596V596V596V596V596V596V596N596N596N596N596N596N5968WcvEm7VMvFnLxJu1TLxZy8SbtUy8WcvEm7VMvFnLxJu1TLxZy8SbtUy8WcvEm7VU3qyl8mYtlTdrqbxZSw0491berKXyZi2VN2upvFlL5c1aKm/WUnmzlsqbtVTerKXyZi2VN2upvFlL5c1aKm/WUnmzlsqbtVTerKXyZi2VN2upvFlL5c1aKm/WUnmzlsqbtVTerKXyZi2VN2upvFlL5c1aKm/WUnmzlsqbtVTerKXyZi2VN2uprxhG036VVMq9pI//P67IVVKJ/V5Sx0maPmZVDEkp5nI+OtYrQD3JEZacyJKTPlpOuuwkT0nzjZz7Yw+3l87SD/dQ8h+lq1/p2a/0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","brillig_names":["lookup_validity"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"SchnorrAccount::entrypoint_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SchnorrAccount::entrypoint_parameters","fields":[{"name":"app_payload","type":{"kind":"struct","path":"authwit::entrypoint::app::AppPayload","fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"target_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}]}}},{"name":"nonce","type":{"kind":"field"}}]}},{"name":"fee_payload","type":{"kind":"struct","path":"authwit::entrypoint::fee::FeePayload","fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"target_address","type":{"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}]}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}]}},{"name":"cancellable","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"SchnorrAccount::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SchnorrAccount::constructor_parameters","fields":[{"name":"signing_pub_key_x","type":{"kind":"field"}},{"name":"signing_pub_key_y","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"SchnorrAccount::verify_private_authwit_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SchnorrAccount::verify_private_authwit_parameters","fields":[{"name":"inner_hash","type":{"kind":"field"}}]}},{"name":"return_type","type":{"kind":"field"}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"SchnorrAccount"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"signing_public_key","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000a74a8dc0"},{"kind":"string","value":"PublicKeyNote"},{"kind":"struct","fields":[{"name":"x","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"y","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"npk_m_hash","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]}]}},"file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n","path":"std/array/mod.nr"},"7":{"source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"24":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"29":{"source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"34":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"35":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE = 16;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeroes.\ntype MSG_BLOCK = [u8; BLOCK_SIZE];\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !crate::runtime::is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: MSG_BLOCK) -> INT_BLOCK {\n    let mut msg32: INT_BLOCK = [0; INT_BLOCK_SIZE];\n\n    for i in 0..INT_BLOCK_SIZE {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeroes.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeroes by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    for i in 0..BLOCK_SIZE {\n        if i >= msg_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..MSG_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[MSG_SIZE_PTR + i] = len_bytes[i];\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    for i in 0..MSG_SIZE_PTR {\n        let predicate = (i < msg_byte_ptr) as u8;\n        let expected_byte = predicate * last_block[i];\n        assert_eq(msg_block[i], expected_byte);\n    }\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let len = 8 * message_size;\n    let mut reconstructed_len: Field = 0;\n    for i in MSG_SIZE_PTR..BLOCK_SIZE {\n        reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n    }\n    assert_eq(reconstructed_len, len as Field);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n","path":"std/hash/sha256.nr"},"58":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"59":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"70":{"source":"use dep::aztec::prelude::{NoteHeader, NullifiableNote, PrivateContext};\nuse dep::aztec::{\n    note::utils::compute_note_hash_for_nullify, keys::getters::get_nsk_app,\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note\n};\n\n// Stores a public key composed of two fields\n// TODO: Do we need to include a nonce, in case we want to read/nullify/recreate with the same pubkey value?\n#[note]\npub struct PublicKeyNote {\n    x: Field,\n    y: Field,\n    // We store the npk_m_hash only to get the secret key to compute the nullifier\n    npk_m_hash: Field,\n}\n\nimpl NullifiableNote for PublicKeyNote {\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl PublicKeyNote {\n    pub fn new(x: Field, y: Field, npk_m_hash: Field) -> Self {\n        PublicKeyNote { x, y, npk_m_hash, header: NoteHeader::empty() }\n    }\n}","path":"/home/lima.linux/aztec/alpha-build2/phantom-gate/contracts/account/src/public_key_note.nr"},"71":{"source":"mod public_key_note;\n\n// Account contract that uses Schnorr signatures for authentication.\n// The signing key is stored in an immutable private note and should be different from the encryption/nullifying key.\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract SchnorrAccount {\n    use dep::std;\n\n    use dep::aztec::prelude::{AztecAddress, PrivateContext, PrivateImmutable};\n    use dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\n    use dep::authwit::{\n        entrypoint::{app::AppPayload, fee::FeePayload}, account::AccountActions,\n        auth_witness::get_auth_witness, auth::{compute_authwit_nullifier, compute_authwit_message_hash}\n    };\n    use dep::aztec::{hash::compute_siloed_nullifier, keys::getters::get_public_keys};\n    use dep::aztec::oracle::get_nullifier_membership_witness::get_low_nullifier_membership_witness;\n    use dep::aztec::macros::{storage::storage, functions::{private, initializer, view, noinitcheck}};\n\n    use crate::public_key_note::PublicKeyNote;\n\n    #[storage]\n    struct Storage<Context> {\n        signing_public_key: PrivateImmutable<PublicKeyNote, Context>,\n    }\n\n    // Constructs the contract\n    #[private]\n    #[initializer]\n    fn constructor(signing_pub_key_x: Field, signing_pub_key_y: Field) {\n        let this = context.this_address();\n        let this_keys = get_public_keys(this);\n        // Not emitting outgoing for msg_sender here to not have to register keys for the contract through which we\n        // deploy this (typically MultiCallEntrypoint). I think it's ok here as I feel the outgoing here is not that\n        // important.\n\n        let mut pub_key_note = PublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this_keys.npk_m.hash());\n        storage.signing_public_key.initialize(&mut pub_key_note).emit(encode_and_encrypt_note(&mut context, this_keys.ovpk_m, this_keys.ivpk_m, this));\n    }\n\n    // Note: If you globally change the entrypoint signature don't forget to update account_entrypoint.ts file\n    #[private]\n    #[noinitcheck]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload, cancellable);\n    }\n\n    #[private]\n    #[noinitcheck]\n    #[view]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    #[contract_library_method]\n    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {\n        // docs:start:is_valid_impl\n        // Load public key from storage\n        let storage = Storage::init(context);\n        let public_key = storage.signing_public_key.get_note();\n        // Load auth witness\n        let witness: [Field; 64] = unsafe {\n            get_auth_witness(outer_hash)\n        };\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n\n        // Verify signature of the payload bytes\n        std::schnorr::verify_signature(\n            public_key.x,\n            public_key.y,\n            signature,\n            outer_hash.to_be_bytes::<32>()\n        )\n        // docs:end:is_valid_impl\n    }\n\n    /**\n    * @notice Helper function to check validity of private authwitnesses\n    * @param consumer The address of the consumer of the message\n    * @param message_hash The message hash of the message to check the validity\n    * @return True if the message_hash can be consumed, false otherwise\n    */\n    unconstrained fn lookup_validity(consumer: AztecAddress, inner_hash: Field) -> pub bool {\n        let public_key = storage.signing_public_key.view_note();\n\n        let message_hash = compute_authwit_message_hash(consumer, context.chain_id(), context.version(), inner_hash);\n\n        let witness: [Field; 64] = get_auth_witness(message_hash);\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n        let valid_in_private = std::schnorr::verify_signature(\n            public_key.x,\n            public_key.y,\n            signature,\n            message_hash.to_be_bytes::<32>()\n        );\n\n        // Compute the nullifier and check if it is spent\n        // This will BLINDLY TRUST the oracle, but the oracle is us, and\n        // it is not as part of execution of the contract, so we are good.\n        let nullifier = compute_authwit_nullifier(context.this_address(), inner_hash);\n        let siloed_nullifier = compute_siloed_nullifier(consumer, nullifier);\n        let lower_wit = get_low_nullifier_membership_witness(context.block_number(), siloed_nullifier);\n        let is_spent = lower_wit.leaf_preimage.nullifier == siloed_nullifier;\n\n        !is_spent & valid_in_private\n    }\n}","path":"/home/lima.linux/aztec/alpha-build2/phantom-gate/contracts/account/src/main.nr"},"73":{"source":"#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n *\n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\npub unconstrained fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/authwit/src/auth_witness.nr"},"75":{"source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, CANONICAL_AUTH_REGISTRY_ADDRESS,\n    }, hash::poseidon2_hash_with_separator,\n};\nuse dep::aztec::{context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let result: Field = context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n            [on_behalf_of.to_field(), inner_hash].as_slice(),\n            GasOpts::default(),\n        )\n        .deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n            [message_hash, authorize as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context\n        .call_public_function(\n            CANONICAL_AUTH_REGISTRY_ADDRESS,\n            comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n            [context.this_address().to_field(), reject as Field].as_slice(),\n            GasOpts::default(),\n        )\n        .assert_empty();\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/authwit/src/auth.nr"},"78":{"source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize},\n};\n\nuse crate::entrypoint::function_call::FunctionCall;\n\n// FUNCTION_CALL_SIZE * ACCOUNT_MAX_CALLS + 1\nglobal APP_PAYLOAD_SIZE: u32 = 21;\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\npub struct AppPayload {\n    function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n    nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Serialize<APP_PAYLOAD_SIZE> for AppPayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; APP_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, APP_PAYLOAD_SIZE> = BoundedVec::new();\n        for call in self.function_calls {\n            fields.extend_from_array(call.serialize());\n        }\n        fields.push(self.nonce);\n        fields.storage\n    }\n}\n\nimpl Hash for AppPayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n    }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr"},"79":{"source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__FEE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize},\n};\nuse crate::entrypoint::function_call::FunctionCall;\n\n// 2 * 5 (FUNCTION_CALL_SIZE) + 2\nglobal FEE_PAYLOAD_SIZE: u32 = 12;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: u32 = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS: u32 = 2;\n\n// docs:start:fee-payload-struct\npub struct FeePayload {\n    function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n    nonce: Field,\n    is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Serialize<FEE_PAYLOAD_SIZE> for FeePayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; FEE_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, FEE_PAYLOAD_SIZE> = BoundedVec::new();\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            fields.extend_from_array(self.function_calls[i].serialize());\n        }\n        fields.push(self.nonce);\n        fields.push(self.is_fee_payer as Field);\n        fields.storage\n    }\n}\n\nimpl Hash for FeePayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__FEE_PAYLOAD)\n    }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage\n    }\n\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr"},"80":{"source":"use dep::aztec::{\n    context::PrivateContext,\n    protocol_types::constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\n    hash::poseidon2_hash_with_separator,\n};\n\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\nuse crate::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash};\n\npub struct AccountActions<Context> {\n    context: Context,\n    is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n *\n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /**\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     *\n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     *\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let valid_fn = self.is_valid_impl;\n\n        let combined_payload_hash = poseidon2_hash_with_separator(\n            [app_payload.hash(), fee_payload.hash()],\n            GENERATOR_INDEX__COMBINED_PAYLOAD,\n        );\n        assert(valid_fn(self.context, combined_payload_hash));\n\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n        app_payload.execute_calls(self.context);\n        if cancellable {\n            let tx_nullifier =\n                poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\n            self.context.push_nullifier(tx_nullifier);\n        }\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     *\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     *\n     * Will revert if the message is not authorized.\n     *\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can\n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash,\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/authwit/src/account.nr"},"98":{"source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission,\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(context: &mut PrivateContext, note: Note)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"99":{"source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note,\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr"},"100":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n    }, utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"102":{"source":"use dep::protocol_types::constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH,\n};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector,\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(context: PrivateContext, storage_slot: Field, note: Note)\nwhere\n    Note: NoteInterface<N>,\n{\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>,\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field =\n            extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()),\n            \"Mismatch return note field.\",\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>,\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n) -> (Note, Field)\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note = unsafe { get_note_internal(storage_slot) };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    let opt_notes = unsafe { get_notes_internal(storage_slot, options) };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n    ) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>)\nwhere\n    Note: NoteInterface<N> + NullifiableNote + Eq,\n{\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> =\n        BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note\nwhere\n    Note: NoteInterface<N>,\n{\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length,\n    )[0]\n        .expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>,\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]\nwhere\n    Note: NoteInterface<N>,\n{\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\npub unconstrained fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>,\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\nwhere\n    Note: NoteInterface<N>,\n{\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) =\n        flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length,\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>,\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values,\n        select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order,\n    )\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr"},"118":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice,\n};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator =\n        arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false,\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158,\n        236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159,\n    ];\n    assert_eq(key, key_from_typescript);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr"},"122":{"source":"use dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\nuse crate::{\n    oracle::{\n        keys::get_public_keys_and_partial_address,\n        key_validation_request::get_key_validation_request,\n    }, keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"123":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__FUNCTION_ARGS,\n    }, point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice},\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER,\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"130":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    note_emission::NoteEmission,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(self, note: &mut Note) -> NoteEmission<Note>\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    pub unconstrained fn view_note<let N: u32>(self) -> Note\n    where\n        Note: NoteInterface<N> + NullifiableNote,\n    {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr"},"145":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm,\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"147":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader,\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\npub unconstrained fn get_contract_instance_internal_avm(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"149":{"source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe { pack_returns_oracle_wrapper(returns) };\n}\n\npub unconstrained fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\npub unconstrained fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr"},"150":{"source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, utils::arr_copy_slice,\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: u32 = 24;\n\npub struct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH,\n            ),\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field,\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\npub unconstrained fn get_low_nullifier_membership_witness(\n    block_number: u32,\n    nullifier: Field,\n) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field,\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\npub unconstrained fn get_nullifier_membership_witness(\n    block_number: u32,\n    nullifier: Field,\n) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr"},"151":{"source":"use dep::protocol_types::abis::validation_requests::{\n    KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"153":{"source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr"},"154":{"source":"use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(\n            contract_address,\n            randomness,\n            encrypted_event,\n            counter,\n        )\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(\n    note_hash_counter: u32,\n    encrypted_note: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32,\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(\n    contract_address: AztecAddress,\n    message: T,\n    counter: u32,\n) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\npub unconstrained fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32,\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) -> Field {}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr"},"155":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"158":{"source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            serialized_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_created_note_oracle(\n        storage_slot,\n        note_type_id,\n        serialized_note,\n        note_hash,\n        counter,\n    );\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(\n    _nullifier: Field,\n    _note_hash: Field,\n    _counter: u32,\n) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S],\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S],\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N], // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S]\nwhere\n    Note: NoteInterface<N>,\n{\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"160":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress}, public_keys::{PublicKeys, NpkM, IvpkM, OvpkM, TpkM},\n    point::Point,\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"161":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"165":{"source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) -> Field {}\n\npub unconstrained fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"168":{"source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::getters::get_ovsk_app, encrypted_logs::payload::compute_encrypted_log,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, OvpkM, IvpkM}, hash::sha256_to_field,\n    abis::note_hash::NoteHash,\n};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] =\n        compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> (u32, [u8; 416 + N * 32], Field)\nwhere\n    Note: NoteInterface<N>,\n{\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        let ovsk_app: Field = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) =\n            compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> ()\nwhere\n    Note: NoteInterface<N>,\n{\n    |e: NoteEmission<Note>| {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) =\n            unsafe { compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient) };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress,\n) {\n    let ovsk_app: Field = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext,\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr"},"169":{"source":"use dep::protocol_types::{\n    address::AztecAddress, public_keys::{PublicKeys, IvpkM, ToPoint}, scalar::Scalar, point::Point,\n};\n\nuse crate::keys::point_to_symmetric_key::point_to_symmetric_key;\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48]\n    where\n        T: ToPoint,\n    {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n    };\n    let point = IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false,\n        },\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131,\n        160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171,\n        176, 218, 48, 209, 73, 89, 200, 209,\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr"},"170":{"source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, public_keys::{OvpkM, IvpkM},\n    constants::GENERATOR_INDEX__SYMMETRIC_KEY, hash::poseidon2_hash_with_separator,\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose,\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes,\n    encrypted_logs::header::EncryptedLogHeader,\n    keys::point_to_symmetric_key::point_to_symmetric_key,\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P],\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] =\n        compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe { random() };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(\n    plaintext: [u8; P],\n    eph_sk: Scalar,\n    ivpk: IvpkM,\n) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point,\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field,\n    )\n        .to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::encrypted_logs::payload::{\n        compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext,\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{\n        address::AztecAddress, public_keys::{OvpkM, IvpkM}, point::Point, scalar::Scalar,\n    };\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false,\n            },\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false,\n            },\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41,\n            2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239,\n            247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118,\n            183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183,\n            12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78,\n            101, 153, 0, 0, 16, 39,\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(\n            0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2,\n        );\n\n        let log: [u8; 448] = compute_encrypted_log(\n            contract_address,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            recipient,\n            plaintext,\n        );\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235,\n            86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79,\n            51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171,\n            62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203,\n            98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211,\n            49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205,\n            104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248,\n            193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110,\n            249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173,\n            151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4,\n            235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194,\n            90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219,\n            22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18,\n            204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167,\n            110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239,\n            95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25,\n            244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91,\n            68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76,\n            26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178,\n            143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189,\n            117, 147, 101, 230, 132,\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06,\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false,\n            },\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160,\n            190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157,\n            131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93,\n            46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130,\n            37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95,\n            115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234,\n            245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162,\n            25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185,\n            212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236,\n            23, 206, 229, 108,\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb,\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31,\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b,\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(\n            recipient,\n            recipient_ivpk,\n            sender_ovsk_app,\n            eph_sk,\n            eph_pk,\n        );\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238,\n            50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248,\n            43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31,\n            211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151,\n            152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58,\n            120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25,\n            173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224,\n            30, 168, 177, 26, 144, 5, 124, 128, 6,\n        ];\n\n        assert_eq(outgoing_body_ciphertext_from_typescript, ciphertext);\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr"},"175":{"source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"185":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n        key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n        call_private_function::call_private_function_internal, header::get_header_at,\n        logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext, function_selector::FunctionSelector,\n        max_block_number::MaxBlockNumber,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n        nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash},\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    }, header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"188":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{\n    execution::{get_chain_id, get_version, get_contract_address, get_block_number},\n    storage::storage_read,\n};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr"},"199":{"source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils,\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [pub_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        ))\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys_hash: PublicKeysHash,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys_hash, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"200":{"source":"use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"202":{"source":"use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"203":{"source":"use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    }, public_keys::PublicKeys, contract_class_id::ContractClassId,\n    constants::CONTRACT_INSTANCE_LENGTH, traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys.hash(),\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"210":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash}, note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    }, address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    }, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"229":{"source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"248":{"source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"265":{"source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash},\n};\n\npub struct NullifierLeafPreimage {\n    nullifier: Field,\n    next_nullifier: Field,\n    next_index: u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self { nullifier: 0, next_nullifier: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable<ScopedReadRequest> for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value =\n            compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(\n            self.nullifier,\n            siloed_value,\n            \"Value of the nullifier leaf does not match read request\",\n        );\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.next_nullifier == other.next_nullifier)\n            & (self.next_index == other.next_index)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr"},"297":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"309":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_IVPK_M_X,\n        DEFAULT_IVPK_M_Y, DEFAULT_OVPK_M_X, DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y,\n    }, hash::poseidon2_hash_with_separator, point::POINT_LENGTH,\n    traits::{Deserialize, Serialize, Hash},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"310":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"311":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"334":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n","path":"/home/lima.linux/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.60.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"}}}