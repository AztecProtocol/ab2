{"noir_version":"0.35.0+2a0d211b92d002fa75855d4ba27267f8892dd52c","hash":17714986211656897714,"abi":{"parameters":[{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"jwt","type":{"kind":"array","length":386,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"secret_key","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"header_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"payload_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"signature_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"5447761253536668537":{"error_kind":"fmtstring","length":53,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]}}},"bytecode":"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BHBcmwCOLyeAYzoBHNclgOP6GDjGwXNDQnhuTAjPVyLk2Q14bupmyfawgle6tWegu3+W2LRS/+zpn738s7d/lvlnuX9u5Z9b+2eFf27jn5X+WeWf2/rndv65vX/u4J87+udO/rmzf37OP3fxz139czf//Lx/7u6fe/jnnv7Zxz/38s++/rm3f+7jn/v6537+ub9/HuCfB/rnQf55sH8e4p+H+udh/nm4CZB/VvtnP/+s8c9a/+zvnwP8c6B/1vnnIP88wj+P9M+j/PNo/zzGP4+1hXacfx7vnyf452D/HOKfQ/3zRP88yT+H+edw/zzZP0/xzxH+eap/jvTPUf55mn+O9s8x/nm6f471z3H+eYZ/numfZ/nn2f453j/P8c9z/fM8/5zgnxP9s8E/J/nnZP+c4p+N/tnkn+f751T/nOaf0/1zhn/O9M9Z/jnbP+f451z/vMA/5/nnfP9c4J8L/XORf17on4v9c4l/XuSfS/1zmX9e7J+X+Oel/tnsn8v9c4V/XuafLf650j9X+efl/nmFf17pn1f559X+eY1/fsE/r/XP6/zzev+8wT9v9M8v+udN/nmzf97in7f6523+ebt/3uGfd/rnXf75Jf+82z/v8c97/fM+//yyf97vnw/451f886v++aB/fs0/H/LPh/3z6/75iH9+wz8f9c/H/PNx/3zCP5/0z6f882n/fMY/n/XP1f75nH+u8c/n/fMF/3zRP1/yz7X++bJ/pv1znX+u988N/rnRP1/xz03++ap/vuafr/vnG/75pn++5Z9v++c7/vmuf77nn+/75wf++aF/fuSfH/vnN/3zE//81D+/5Z/f9s/v+Od3/fN7/vl9//yBf/7QP//PP3/knz/2z5/45//zz5/658/88+f++Qv//KV//so/f+2fv/HP3/rn7/zz9/75B//8o3/+yT//7J9/8c+/+uff/PPv/vkP//ynf/7LP//tn//xz//65//80zT+bv7Z3T9L/LOHf5b6p/nhe/PD8uaH280Po5sfHjc/7G1+ONv8MLX54Wfzw8rmh4vNDwObH941P2xrfjjW/DCr+eFT88Oi5oc7zQ9jmh+eND/saH440fwwofnhP/PDen380/wwnPnhNfPDZuaHw8wPc5kfvjI/LGV+uMn8MJL54SHzwz7mh3PMD9OYH34xP6xiejjzwyDmhzfMD1uYH44wP8xg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","debug_symbols":"7L3brvS6kp35LvvaFzwET36VRqPhbh9QgGE3bPeVUe/eWvXPlDR3BpOZK0lFUBzYgJG1rH8q+DGTMUZIDP7vf/zH//R//3//5f/6l//2n//7//zHv/8//vc//ut//3/+w//6l//+37b/63//67/7x//9P/7lv/7Xf/kv/9f5P//D/PX/BGP/7R/8z//3P/y3v/7v//m//sP/+F//+PcU4r/7x3/6b//xH/8+eLf9gf/8L//1P/3j3yf/r//u6VKbbP651qZsj4stc3GM9ufaGN350v/z322hOD2heD2hkJ5Qgp5Qop5Qkp5Qsp5QippQrNETip7V1upZba2e1dbqWW2tntXW6lltrZ7V1upZba2e1dbpWW2dntXWXbraJpN+rk2mPIXi9YRCekIJekKJekJJekLJekIpakLxRk8oVk8oelZbr2e19XpWW69ntfV6VluvZ7X1elZbr2e1JT2rLelZbUnPakvXrrbZPULJ/ikU0hNK0BNK1BNK0hNK1hPKpattIfNzbUnmn0MJRk8oVk8oTk8oXk8ol6621qRHLNYaegomaAomagomaQomKwomXvpbstbTHgw9B3MtGWd3Ms7Zfw4mXUvGm8cftt4+Ccx07a/J+52Mj0+LXkqagsmagvlaxeSw/0CKya1fkyF7/Lbz6W8bdiWgsI/U0O/L/4o+m6mjt1NH76aO3k8dPU0dfZg6+jh19Gnq6PPU0U+da8vUubZMnWvL1Lm2TJ1ry9S5tkyda8vUubZMnWvL1Lm2zJxro5k510Yzc66NZuZcG83MuTaamXNtNDPn2mhmzrXRzJxro5k510Yzda61U+daO3WutVPnWjt1rv1+A5do9FPnWjt1rrVT51o7da61U+daN3WudVPnWjd1rnVT59rvt++JRj91rnVT51o3da51U+daN3Wu9VPnWj91rvVT51o/da79fvOmaPRT51o/da71U+daP3Wu9VPnWpo619LUuZamzrU0da79fuuuaPRT51qaOtfS1LmWps61NHWuDVPn2jB1rg1T59owda79fuO2aPRT59owda4NU+faMHWuDVPn2jh1ro1T59o4da6NU+faOHWujVPn2jh1ro1T59o4da6NU+faNHWuTVPn2jR1rk1T59o0da5NU+faNHWuTVPn2jR1rp26b1Scum9UnLpvVJy6b1Scum9UnLpvVJy6b1Scum9UnLpvVJy6b1Scum9UnLpvVJy6b1Scum9UnLpvVJy6b1Scum9UnLpvVJy6b1Scum9UnLpvVJq6b1Saum9UmrpvVJq6b1QyM+faNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g0dd+oNHXfqDR136g8dd+oPHXfqDx136g8dd+obGbOtXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5Reeq+UXnqvlF56r5RZeq+UWXqvlFl6r5RZeq+UcXMnGvL1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o8rUfaPK1H2jytR9o6yZunHUFv7M2XYLf+Z0u4U/c77dwp854W7hz5xxt/BnTrlb+DPn3C38mZPuFv7cWXfqFlJb+HNn3ambSG3hz511p24jtYU/d9adupHUFv7cWXfqVlJb+HNn3ambSW3hz511p24ntYU/d9aduqHUFv7cWXfqllJb+HNn3ambSm3hz511p24rtYU/d9adurHUFv7cWXfq1lJb+HNn3ambS23hz511p24vtYU/d9adusHUX39t7vDnzrpT95ja/tvcWXfqLlPbf5s7607dZ+qv/zZ3+HNn3albTW3hz511p242tYU/d9adut3UFv7cWXfqhlNb+HNn3albTm3hz511p246tYU/d9aduu3UFv7cWXfqxlNb+HNn3albT23hz511p24+tYU/d9aduv3UFv7cWXfqBlRb+HNn3albUG3hz511p25CtYU/d9adug3VFv7cWXfqRlTbX5g7607dimr7C3Nn3ambUW1/Ye6sO3U7qu0vzJ11p25Itf2FubPu1C2ptvDnzrpTN6Xawp87607dlmoLf+6sO3Vjqi38ubPu1K2ptvCnzrp27t5Udu7eVHbu3lR27t5U23+cO/yps66duzeVnbs3lZ27N5WduzeVnbs3lZ27N5WduzeVnbs3lZ27N5WduzeVnbs3lZ27N5WduzeVnbs3lZ27N5WduzeVnbs3lZ27N5WduzeVnbs3lZ27N5WduzeVnbs3lZ27N5WduzeVnbs3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9vH5FdnVWlx9xC4c9bsQnt8ZGNkP688N3Ogb+NE3oNE3+Pq3H/3j2u1jfrpB+voHEoPbb1D88w3Yb1HY/1Eo5vUNcor78pjN6WLDXbwtl4+LnYvni/9E41RF41VFQ6qiCaqiiaqiSaqiyaqiKZqiyUZVNKrW4qxqLc6q1uKsai3OqtbirGotzqrW4qxqLc6q1uKiai0uqtbiomotLqrW4qJqLS6q1uKiai0uqtbiomotLprWYms0rcXWaFqLrdG0FlujaS22RtNabI2mtdgaTWuxNZrWYms0rcXWqFqLraq12Kpai62qtdiqWoutqrXYqlqLraq12Kpai62qtdiqWoudqrXYqVqLnaq12Klai52qtdipWoudqrXYqVqLnaq12Klai72qtdirWou9qrXYq1qLvaq12Ktai72qtdirWou9qrXYq1qLSdVaTKrWYlK1FpOqtZhUrcWkai0mVWsxqVqLSdVaTKrW4qBqLQ6q1uKgai0OqtbioGotDqrW4qBqLQ6q1uKgai0OqtbiqGotjqrW4qhqLY6q1uKoai2OqtbiqGotjqrW4qhqLY6q1uKkai1Wte/Oqtp3Z1Xtu7Oq9t1ZVfvurKp9d1bVvjurat+dVbXvzqrad2dV7buzqvbdWVX77qyqfXdW1b47q2rfnVW1786q2ndnVe27s6r23VlV++6sqn13VtW+O6tq351Vte/Oqtp3Z1Xtu7Oq9t1ZVfvunKp9d07Vvjunat+dU7XvzhlNa7FTte/Oqdp351Ttu3Oq9t05VfvunKp9d07Vvjunat+dU7Xvzqnad+dU7btzqvbdOVX77pyqfXdO1b47p2rfnVO1786p2nfnVO27c6r23TlV++6cqn13TtW+O6dq351Tte/Oqdp351Ttu3Oq9t05VfvunKp9d07Vvjunat+dU7Xvzqnad+dU7btzqvbdOVX77pyqfXdO1b47p2rfnVO1786p2nfnVO27c6r23TlV++6cqn13TtW+O6dq351Tte/Oqdp351Ttu3Oq9t05VfvunKp9d07Vvjunat+dU7Xvzqnad+dU7btzqvbdOVX77pyqfXdO1b47p2rfnVO1786p2nfnVO27c6r23TlV++6cqn13TtW+O6dq351Tte/Oqdp351Ttu3Oq9t05VfvunKp9d07Vvjunat+dU7Xvzqnad+dU7btzqvbdOVX77pyqfXdO1b47p2rfnVO1786p2nfnVO27c6r23TlV++6cqn13TtW+O69q351Xte/Oq9p351Xtu/NG01rsVe2786r23XlV++68qn13XtW+O69q351Xte/Oq9p351Xtu/Oq9t15VfvuvKp9d17Vvjuvat+dV7Xvzqvad+dV7bvzqvbdeVX77ryqfXde1b47r2rfnVe1786r2nfnVe2786r23XlV++68qn13XtW+O69q351Xte/Oq9p351Xtu/Oq9t15VfvuvKp9d17Vvjuvat+dV7Xvzqvad+dV7bvzqvbdeVX77ryqfXde1b47r2rfnVe1786r2nfnVe2786r23XlV++68qn13XtW+O69q351Xte/Oq9p351Xtu/Oq9t15VfvuvKp9d17Vvjuvat+dV7Xvzqvad+dV7bvzqvbdeVX77ryqfXde1b47r2rfnVe1786r2nfnVe2786r23XlV++68qn13XtW+O69q351Xte/Oq9p351Xtu/Oq9t15VfvuvKp9d17Vvjuvat+dV7Xvzqvad+dV7bvzqvbdeVX77ryqfXde1b47r2rfnVe1745U7bsjVfvuSNW+O1K1746MprWYVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvjtSte+OVO27I1X77kjVvrugat9dULXvLqjadxdU7bsLRtNaHFTtuwuq9t0FVfvugqp9d0HVvrugat9dULXvLqjadxdU7bsLqvbdBVX77oKqfXdB1b67oGrfXVC17y6o2ncXVO27C6r23QVV++6Cqn13QdW+u6Bq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","file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    /// \n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    /// \n    /// example\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    /// \n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    /// \n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    /// \n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    /// \n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    /// \n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Ord + Eq {\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Eq {\n    /// Returns a new sorted array by sorting it with a custom comparison function. \n    /// The original array remains untouched. \n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    /// \n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    /// \n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]), \"Array has not been sorted correctly according to `ordering`.\"\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n","path":"std/array/mod.nr"},"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(s, quote { Eq }, signature, for_each_field, quote { & }, body)\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"13":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U where T: From<U> {\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n","path":"std/convert.nr"},"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"34":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"35":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\nglobal ZERO = 0;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n","path":"std/hash/sha256.nr"},"70":{"source":"pub global INVALID_VALUE: u8 = 255;\npub global MAX_MESSAGE_LENGTH: u32 = 256;\npub global MAX_MESSAGE_LENGTH_URL: u32 = 64;\npub global MAX_OUTPUT_LENGTH: u32 = ((MAX_MESSAGE_LENGTH * 3) / 4);\npub global MAX_OUTPUT_LENGTH_URL: u32 = ((MAX_MESSAGE_LENGTH_URL * 3) / 4);\n\nstruct Base64DecodeBE {\n    table: [u8; 256]\n}\n\nimpl Base64DecodeBE {\n    /// Creates a new decoder that uses the standard Base64 Alphabet (base64) specified in RFC 4648\n    /// https://datatracker.ietf.org/doc/html/rfc4648#section-4\n    fn new() -> Self {\n        Base64DecodeBE {\n            table: [\n                // 0-42\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                62,// 43\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,// 44-46\n                63,// 47\n                52, 53, 54, 55, 56, 57, 58, 59, 60, 61,// 48-57\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,// 58-64\n                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,// 65-90 (A-Z)\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,// 91-96\n                26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,// 97-122 (a-z)\n                // 123-255\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE\n            ]\n        }\n    }\n\n    fn get(self, idx: Field) -> u8 {\n        self.table[idx]\n    }\n}\n\nstruct Base64URLDecodeBE {\n    table: [u8; 256]\n}\n\nimpl Base64URLDecodeBE {\n    /// Creates a new decoder that uses the standard Base64 with URL and Filename safe (base64) specified in RFC 4648\n    /// https://datatracker.ietf.org/doc/html/rfc4648#page-7\n    fn new() -> Self {\n        Base64URLDecodeBE {\n            table: [\n                // 0-42\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,\n                INVALID_VALUE, INVALID_VALUE,\n                62,// 45\n                INVALID_VALUE, INVALID_VALUE,\n                52, 53, 54, 55, 56, 57, 58, 59, 60, 61,// 48-57\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,// 58-64\n                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,// 65-90 (A-Z)\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE,// 91-94\n                63,// 95\n                INVALID_VALUE,// 96\n                26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,// 97-122 (a-z)\n                // 123-255\n                INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE, INVALID_VALUE\n            ]\n        }\n    }\n\n    fn get(self, idx: Field) -> u8 {\n        self.table[idx]\n    }\n}\n\npub fn base64_decode_elements(input: [u8; MAX_MESSAGE_LENGTH], length: u32) -> [u8; MAX_MESSAGE_LENGTH] {\n    let mut Base64Decoder = Base64DecodeBE::new();\n\n    let mut result: [u8; MAX_MESSAGE_LENGTH] = [32; MAX_MESSAGE_LENGTH]; // Whitespace Pad\n\n    for i in 0..MAX_MESSAGE_LENGTH {\n        if (i < length) {\n            let input_byte = input[i];\n            result[i] = Base64Decoder.get(input_byte as Field);\n            assert(result[i] != INVALID_VALUE, f\"DecodeError: invalid symbol {input_byte}, offset {i}.\");\n        }\n    }\n    result\n}\n\npub fn base64_decode(input: [u8; MAX_MESSAGE_LENGTH], length: u32) -> [u8; MAX_OUTPUT_LENGTH] {\n    let decoded: [u8; MAX_MESSAGE_LENGTH] = base64_decode_elements(input, length);\n    let mut result: [u8; MAX_OUTPUT_LENGTH] = [32; MAX_OUTPUT_LENGTH];\n    let out_len = (length * 3) / 4;\n    let BASE64_ELEMENTS_PER_CHUNK: u32 = 40;\n    let BYTES_PER_CHUNK: u32 = 30;\n    let num_chunks = (length / BASE64_ELEMENTS_PER_CHUNK)\n        + (length % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        for i in 0..num_chunks - 1 {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                slice += decoded[i * BASE64_ELEMENTS_PER_CHUNK + j] as Field;\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        let base64_elements_in_final_chunk = length - ((num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK);\n\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            slice += decoded[(num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK + j] as Field;\n        }\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = out_len - ((num_chunks - 1) * BYTES_PER_CHUNK);\n        for i in 0..num_bytes_in_final_chunk {\n            result[(num_chunks - 1) * BYTES_PER_CHUNK + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\npub fn base64_url_decode_elements(\n    input: [u8; MAX_MESSAGE_LENGTH_URL],\n    length: u32\n) -> [u8; MAX_MESSAGE_LENGTH_URL] {\n    let mut Base64URLDecoder = Base64URLDecodeBE::new();\n\n    let mut result: [u8; MAX_MESSAGE_LENGTH_URL] = [0; MAX_MESSAGE_LENGTH_URL];\n\n    for i in 0..MAX_MESSAGE_LENGTH_URL {\n        if (i < length) {\n            let input_byte = input[i];\n            result[i] = Base64URLDecoder.get(input_byte as Field);\n            assert(result[i] != INVALID_VALUE, f\"DecodeError: invalid symbol {input_byte}, offset {i}.\");\n        }\n    }\n    result\n}\n\npub fn base64_url_decode(\n    input: [u8; MAX_MESSAGE_LENGTH_URL],\n    length: u32\n) -> [u8; MAX_OUTPUT_LENGTH_URL] {\n    let decoded: [u8; MAX_MESSAGE_LENGTH_URL] = base64_url_decode_elements(input, length);\n    let mut result: [u8; MAX_OUTPUT_LENGTH_URL] = [0; MAX_OUTPUT_LENGTH_URL];\n    let BASE64_ELEMENTS_PER_CHUNK: u32 = 40;\n    let BYTES_PER_CHUNK: u32 = 30;\n    let num_chunks = (MAX_MESSAGE_LENGTH_URL / BASE64_ELEMENTS_PER_CHUNK)\n        + (MAX_MESSAGE_LENGTH_URL % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    if num_chunks > 0 {\n        for i in 0..num_chunks - 1 {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                slice += decoded[i * BASE64_ELEMENTS_PER_CHUNK + j] as Field;\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        let base64_elements_in_final_chunk = MAX_MESSAGE_LENGTH_URL - ((num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK);\n\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            slice += decoded[(num_chunks - 1) * BASE64_ELEMENTS_PER_CHUNK + j] as Field;\n        }\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = MAX_OUTPUT_LENGTH_URL - ((num_chunks - 1) * BYTES_PER_CHUNK);\n        for i in 0..num_bytes_in_final_chunk {\n            result[(num_chunks - 1) * BYTES_PER_CHUNK + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n","path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/crates/kyc_age_verify/src/base64.nr"},"71":{"source":"use crate::base64::base64_url_decode;\nuse crate::hmac::hmac_sha256;\n\npub global MAX_HEADER_LENGTH: u32 = 64;\npub global MAX_PAYLOAD_LENGTH: u32 = 256;\npub global MAX_SIGNATURE_LENGTH: u32 = 64;\n\n// Header + . + Payload + . + Signature\npub type JWT = [u8; MAX_HEADER_LENGTH + 1 + MAX_PAYLOAD_LENGTH + 1 + MAX_SIGNATURE_LENGTH];\npub type Header = [u8; MAX_HEADER_LENGTH];\npub type Payload = [u8; MAX_PAYLOAD_LENGTH];\npub type Signature = [u8; MAX_SIGNATURE_LENGTH];\npub type SecretKey = [u8; 64];\n\npub fn split_jwt(\n    jwt: JWT,\n    header_length: u32,\n    payload_length: u32,\n    signature_length: u32\n) -> (Header, Payload, Signature) {\n    let mut header = [0; MAX_HEADER_LENGTH];\n    let mut payload = [32; MAX_PAYLOAD_LENGTH]; // Fill with Whitespaces\n    let mut signature = [0; MAX_SIGNATURE_LENGTH];\n\n    let header_start = 0;\n    let header_end = header_length;\n    let payload_start = MAX_HEADER_LENGTH + 1;\n    let payload_end = payload_start + payload_length;\n    let signature_start = MAX_HEADER_LENGTH + 1 + MAX_PAYLOAD_LENGTH + 1;\n    let signature_end = signature_start + signature_length;\n\n    for i in header_start..header_end {\n        header[i] = jwt[i];\n    }\n\n    for i in payload_start..payload_end {\n        payload[i - payload_start] = jwt[i];\n    }\n\n    for i in signature_start..signature_end {\n        signature[i - signature_start] = jwt[i];\n    }\n\n    (header, payload, signature)\n}\n\npub fn verify_jwt(\n    jwt: JWT,\n    secret_key: SecretKey,\n    header_length: u32,\n    payload_length: u32,\n    signature_length: u32\n) -> (bool, Payload) {\n    // Step 1: Split the JWT (header.payload.signature)\n    let (encoded_header,encoded_payload, encoded_signature): (Header,Payload,Signature) = split_jwt(jwt, header_length, payload_length, signature_length);\n\n    // Step 2: Base64 decode the Signature\n    let decoded_signature= base64_url_decode(encoded_signature, signature_length);\n\n    // Step 3: Create the signing input\n    let input_length: u32 = header_length + 1 + payload_length;\n    // header + . + payload\n    let mut signing_input: [u8; MAX_HEADER_LENGTH + 1 + MAX_PAYLOAD_LENGTH] = [0; MAX_HEADER_LENGTH + 1 + MAX_PAYLOAD_LENGTH];\n\n    for i in 0..header_length {\n        signing_input[i] = encoded_header[i];\n    }\n\n    signing_input[header_length] = 46; // ASCII value of .\n    for i in 0..payload_length {\n        signing_input[header_length + 1 + i] = encoded_payload[i];\n    }\n\n    // Step 4: Compute HMAC of the signing input and Secret Key\n    let hmac_signature: [u8; 32] = hmac_sha256(secret_key, signing_input, input_length as u64);\n\n    let  mut verified: bool = true;\n\n    for i in 0..32 {\n        if hmac_signature[i] != decoded_signature[i] {\n            verified = false;\n        }\n    }\n\n    (verified, encoded_payload)\n}\n","path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/crates/kyc_age_verify/src/jwt.nr"},"72":{"source":"use std::hash::sha256::{sha256_var, sha256};\n\npub fn xor_key(key: [u8; 64], pad_byte: u8) -> [u8; 64] {\n    let mut result: [u8; 64] = [0 as u8; 64];\n    for i in 0..64 {\n        result[i] = key[i] ^ pad_byte;\n    }\n    result\n}\n\npub fn hmac_sha256<let M: u32>(key: [u8; 64], message: [u8; M], length: u64) -> [u8; 32] {\n    let inner_key_pad: [u8; 64] = xor_key(key, 0x36);\n    let outer_key_pad: [u8; 64] = xor_key(key, 0x5C);\n\n    // Step 3: Perform the inner hash (SHA256(key XOR ipad || message))\n    let inner_input: [u8; M + 64] = inner_key_pad.concat(message);\n    let inner_hash: [u8; 32] = sha256_var(inner_input, length + 64);\n\n    // Step 4: Perform the outer hash (SHA256(key XOR opad || inner_hash))\n    let outer_input: [u8; 64 + 32] = outer_key_pad.concat(inner_hash);\n    let hmac_result: [u8; 32] = sha256(outer_input);\n\n    hmac_result\n}\n\ntrait ArrayExtentions {\n    fn concat<let N: u32>(self, other: [u8; N]) -> [u8; N + 64];\n}\n\nimpl ArrayExtentions for [u8; 64] {\n    fn concat<let N: u32>(self, other: [u8; N]) -> [u8; N + 64] {\n        let mut result: [u8; N + 64] = [0 as u8; N + 64];\n        for i in 0..64 {\n            result[i] = self[i];\n        }\n        for i in 0..N {\n            result[i + 64] = other[i];\n        }\n        result\n    }\n}\n","path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/crates/kyc_age_verify/src/hmac.nr"},"73":{"source":"pub mod jwt;\npub mod base64;\npub mod hmac;\nuse base64::base64_decode;\n\nuse jwt::{JWT, Payload, SecretKey, verify_jwt, split_jwt};\nuse json::JSON1kb::JSON;\n\npub global EIGHTEEN_YEARS_IN_SECONDS: u64 = 18 * 365 * 24 * 60 * 60;\n\nunconstrained pub fn main(\n    timestamp: pub u64,\n    jwt: JWT,\n    secret_key: SecretKey,\n    header_length: u32,\n    payload_length: u32,\n    signature_length: u32\n) -> pub bool {\n    let (verified, payload): (bool, Payload) = verify_jwt(jwt, secret_key, header_length, payload_length, signature_length);\n    let decoded = base64_decode(payload, payload_length);\n    assert(verified, \"JWT verification failed\");\n    let json: JSON = JSON::parse_json(decoded);\n    let birthdate = json.get_number_unchecked(\"birthdate\".as_bytes());\n    let is_above_eighteen = timestamp - EIGHTEEN_YEARS_IN_SECONDS > birthdate;\n    assert(is_above_eighteen, \"Not above 18 years old\");\n    true\n}\n\n#[test]\nfn test_valid_jwt() {\n    let header = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\".as_bytes();\n    let payload = \"eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJiaXJ0aGRhdGUiOjEwOTg2NDE2MDN9\".as_bytes();\n\n    let signature = \"MFLNcbOEVB4lFSvMIP-RKXXYCphJC22SmS07iX0RM6k\".as_bytes();\n\n    let mut padded_header = [0; 64];\n    let mut padded_payload = [0; 256];\n    let mut padded_signature = [0; 64];\n\n    let mut jwt = [0; 64 + 1 + 256 + 1 + 64];\n\n    for i in 0..header.len() {\n        padded_header[i] = header[i];\n    }\n    for i in 0..payload.len() {\n        padded_payload[i] = payload[i];\n    }\n    for i in 0..signature.len() {\n        padded_signature[i] = signature[i];\n    }\n\n    for i in 0..padded_header.len() {\n        jwt[i] = padded_header[i];\n    }\n\n    jwt[64] = 46;\n\n    for i in 0..padded_payload.len() {\n        jwt[64 + 1 + i] = padded_payload[i];\n    }\n\n    jwt[64 + 1 + 256] = 46;\n\n    for i in 0..padded_signature.len() {\n        jwt[64 + 1 + 256 + 1 + i] = padded_signature[i];\n    }\n\n    let mut secret_key = [0; 64];\n    let key = \"secret_key\".as_bytes();\n    for i in 0..key.len() {\n        secret_key[i] = key[i];\n    }\n\n    unsafe {\n        main(\n            1729793701,\n            jwt,\n            secret_key,\n            header.len(),\n            payload.len(),\n            signature.len()\n        )\n    };\n}\n","path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/crates/kyc_age_verify/src/main.nr"},"74":{"source":"mod _table_generation;\nmod enums;\nmod json;\nmod json_tables;\nmod keymap;\nmod json_entry;\nmod transcript_entry;\nmod _string_tools;\nmod _comparison_tools;\nmod token_flags;\nmod getters;\nmod keyhash;\nmod get_string;\nmod get_number;\nmod get_literal;\nmod get_object;\nmod get_array;\n\nuse crate::json::JSON;\nuse crate::json::JSONValue;\nuse crate::json_entry::JSONEntryPacked;\nuse crate::json_entry::JSONEntry;\nuse crate::_string_tools::slice_packed_field::slice_fields;\nuse crate::get_literal::JSONLiteral;\n\ntrait JSONParserTrait\n{\n    fn parse_json_from_string<let StringBytes: u32>(s: str<StringBytes>) -> Self;\n    fn parse_json<let StringBytes: u32>(s: [u8; StringBytes]) -> Self;\n    fn get_length(self) -> u32;\n    fn get_array<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<Self>;\n    fn get_array_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Self;\n    fn get_array_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<Self>;\n    fn get_array_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Self;\n    fn get_array_from_array(self, array_index: Field) -> Option<Self>;\n    fn get_array_from_array_unchecked(self, array_index: Field) -> Self;\n    fn map<U, let MaxElements: u32, let MaxElementBytes: u32>(self, f: fn(JSONValue<MaxElementBytes>) -> U) -> [U; MaxElements] where U: std::default::Default;\n    fn get_object<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<Self>;\n    fn get_object_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Self;\n    fn get_object_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<Self>;\n    fn get_object_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Self;\n    fn get_object_from_array(self, array_index: Field) -> Option<Self>;\n    fn get_object_from_array_unchecked(self, array_index: Field) -> Self;\n    fn get_literal<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<JSONLiteral>;\n    fn get_literal_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> JSONLiteral;\n    fn get_literal_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<JSONLiteral>;\n    fn get_literal_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> JSONLiteral;\n    fn get_literal_from_array(self, array_index: Field) -> Option<JSONLiteral>;\n    fn get_literal_from_array_unchecked(self, array_index: Field) -> JSONLiteral;\n    fn get_number<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<u64>;\n    fn get_number_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> u64;\n    fn get_number_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<u64>;\n    fn get_number_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> u64;\n    fn get_number_from_array(self, array_index: Field) -> Option<u64>;\n    fn get_number_from_array_unchecked(self, array_index: Field) -> u64;\n    fn get_string<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> Option<BoundedVec<u8, StringBytes>>;\n    fn get_string_unchecked<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> BoundedVec<u8, StringBytes>;\n    fn get_string_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<BoundedVec<u8, StringBytes>>;\n    fn get_string_unchecked_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> BoundedVec<u8, StringBytes>;\n    fn get_string_from_array<let StringBytes: u32>(self, array_index: Field) -> Option<BoundedVec<u8, StringBytes>>;\n    fn get_string_from_array_unchecked<let StringBytes: u32>(self, array_index: Field) -> BoundedVec<u8, StringBytes>;\n    fn get_string_from_path<let KeyBytes: u32, let StringBytes: u32, let PathDepth: u32>(self, keys: [BoundedVec<u8, KeyBytes>; PathDepth]) -> Option<BoundedVec<u8, StringBytes>>;\n    fn get_value<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> Option<JSONValue<StringBytes>>;\n    fn get_value_unchecked<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> JSONValue<StringBytes>;\n    fn get_value_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<JSONValue<StringBytes>>;\n    fn get_value_unchecked_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> JSONValue<StringBytes>;\n    fn get_value_from_array<let StringBytes: u32>(self, array_index: Field) -> Option<JSONValue<StringBytes>>;\n    fn get_value_from_array_unchecked<let StringBytes: u32>(self, array_index: Field) -> JSONValue<StringBytes>;\n    fn get_value_from_path<let KeyBytes: u32, let StringBytes: u32, let PathDepth: u32>(self,keys: [BoundedVec<u8, KeyBytes>; PathDepth]) -> Option<JSONValue<StringBytes>>;\n    fn key_exists<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> bool;\n    fn get_keys_at_root<let MaxNumKeys: u32, let MaxKeyBytes: u32>(self) -> BoundedVec<BoundedVec<u8, MaxKeyBytes>, MaxNumKeys>;\n}\n\nmod JSON512b {\n    struct JSON\n    {\n        inner: crate::json::JSON<512, 20, 64, 33, 2>\n    }\n\n    impl JSON {\n        fn convert(inner: Option<crate::json::JSON<512, 20, 64, 33, 2>>) -> Option<Self> {\n            Option { _is_some: inner._is_some, _value: JSON { inner: inner._value } }\n        }\n    }\n    impl crate::JSONParserTrait for JSON {\n        fn parse_json_from_string<let StringBytes: u32>(s: str<StringBytes>) -> Self {\n            JSON { inner: crate::json::JSON::parse_json_from_string(s) }\n        }\n\n        fn parse_json<let StringBytes: u32>(s: [u8; StringBytes]) -> Self {\n            JSON { inner: crate::json::JSON::parse_json(s) }\n        }\n        fn get_length(self) -> u32 {\n            self.inner.get_length()\n        }\n        fn get_array<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<Self> {\n            JSON::convert(self.inner.get_array(key))\n        }\n        fn get_array_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Self {\n            JSON { inner: self.inner.get_array_unchecked(key) }\n        }\n        fn get_array_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_array_var(key))\n            }\n        }\n        fn get_array_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Self {\n            JSON { inner: self.inner.get_array_unchecked_var(key) }\n        }\n        fn get_array_from_array(self, array_index: Field) -> Option<Self> {\n            JSON::convert(self.inner.get_array_from_array(array_index))\n        }\n        fn get_array_from_array_unchecked(self, array_index: Field) -> Self {\n            JSON { inner: self.inner.get_array_from_array_unchecked(array_index) }\n        }\n        fn map<U, let MaxElements: u32, let MaxElementBytes: u32>(\n            self,\n            f: fn(crate::JSONValue<MaxElementBytes>) -> U\n        ) -> [U; MaxElements] where U: std::default::Default {\n            self.inner.map(f)\n        }\n        fn get_object<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_object(key))\n            }\n        }\n        fn get_object_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Self {\n            JSON { inner: self.inner.get_object_unchecked(key) }\n        }\n        fn get_object_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_object_var(key))\n            }\n        }\n        fn get_object_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Self {\n            JSON { inner: self.inner.get_object_unchecked_var(key) }\n        }\n        fn get_object_from_array(self, array_index: Field) -> Option<Self> {\n            JSON::convert(self.inner.get_object_from_array(array_index))\n        }\n        fn get_object_from_array_unchecked(self, array_index: Field) -> Self {\n            JSON { inner: self.inner.get_object_from_array_unchecked(array_index) }\n        }\n        fn get_literal<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal(key)\n        }\n        fn get_literal_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> crate::JSONLiteral {\n            self.inner.get_literal_unchecked(key)\n        }\n        fn get_literal_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal_var(key)\n        }\n        fn get_literal_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> crate::JSONLiteral {\n            self.inner.get_literal_unchecked_var(key)\n        }\n        fn get_literal_from_array(self, array_index: Field) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal_from_array(array_index)\n        }\n        fn get_literal_from_array_unchecked(self, array_index: Field) -> crate::JSONLiteral {\n            self.inner.get_literal_from_array_unchecked(array_index)\n        }\n        fn get_number<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<u64> {\n            self.inner.get_number(key)\n        }\n        fn get_number_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> u64 {\n            self.inner.get_number_unchecked(key)\n        }\n        fn get_number_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<u64> {\n            self.inner.get_number_var(key)\n        }\n        fn get_number_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> u64 {\n            self.inner.get_number_unchecked_var(key)\n        }\n        fn get_number_from_array(self, array_index: Field) -> Option<u64> {\n            self.inner.get_number_from_array(array_index)\n        }\n        fn get_number_from_array_unchecked(self, array_index: Field) -> u64 {\n            self.inner.get_number_from_array_unchecked(array_index)\n        }\n\n        fn get_string<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string(key)\n        }\n        fn get_string_unchecked<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_unchecked(key)\n        }\n        fn get_string_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_var(key)\n        }\n        fn get_string_unchecked_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_unchecked_var(key)\n        }\n        fn get_string_from_array<let StringBytes: u32>(self, array_index: Field) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_from_array(array_index)\n        }\n        fn get_string_from_array_unchecked<let StringBytes: u32>(self, array_index: Field) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_from_array_unchecked(array_index)\n        }\n        fn get_string_from_path<let KeyBytes: u32, let StringBytes: u32, let PathDepth: u32>(\n            self,\n            keys: [BoundedVec<u8, KeyBytes>; PathDepth]\n        ) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_from_path(keys)\n        }\n        fn get_value<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value(key)\n        }\n        fn get_value_unchecked<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_unchecked(key)\n        }\n        fn get_value_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_var(key)\n        }\n        fn get_value_unchecked_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_unchecked_var(key)\n        }\n        fn get_value_from_array<let StringBytes: u32>(self, array_index: Field) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_from_array(array_index)\n        }\n        fn get_value_from_array_unchecked<let StringBytes: u32>(self, array_index: Field) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_from_array_unchecked(array_index)\n        }\n        fn get_value_from_path<let KeyBytes: u32, let StringBytes: u32, let PathDepth: u32>(\n            self,\n            keys: [BoundedVec<u8, KeyBytes>; PathDepth]\n        ) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_from_path(keys)\n        }\n\n        fn key_exists<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> bool {\n            self.inner.key_exists(key)\n        }\n        fn get_keys_at_root<let MaxNumKeys: u32, let MaxKeyBytes: u32>(self) -> BoundedVec<BoundedVec<u8, MaxKeyBytes>, MaxNumKeys> {\n            self.inner.get_keys_at_root()\n        }\n    }\n}\n\nmod JSON1kb {\n    struct JSON\n    {\n        inner: crate::json::JSON<1024, 37, 128, 65, 2>\n    }\n    impl JSON {\n        fn convert(inner: Option<crate::json::JSON<1024, 37, 128, 65, 2>>) -> Option<Self> {\n            Option { _is_some: inner._is_some, _value: JSON { inner: inner._value } }\n        }\n    }\n    impl crate::JSONParserTrait for JSON {\n        fn parse_json_from_string<let StringBytes: u32>(s: str<StringBytes>) -> Self {\n            JSON { inner: crate::json::JSON::parse_json_from_string(s) }\n        }\n\n        fn parse_json<let StringBytes: u32>(s: [u8; StringBytes]) -> Self {\n            JSON { inner: crate::json::JSON::parse_json(s) }\n        }\n        fn get_length(self) -> u32 {\n            self.inner.get_length()\n        }\n        fn get_array<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<Self> {\n            JSON::convert(self.inner.get_array(key))\n        }\n        fn get_array_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Self {\n            JSON { inner: self.inner.get_array_unchecked(key) }\n        }\n        fn get_array_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_array_var(key))\n            }\n        }\n        fn get_array_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Self {\n            JSON { inner: self.inner.get_array_unchecked_var(key) }\n        }\n        fn get_array_from_array(self, array_index: Field) -> Option<Self> {\n            JSON::convert(self.inner.get_array_from_array(array_index))\n        }\n        fn get_array_from_array_unchecked(self, array_index: Field) -> Self {\n            JSON { inner: self.inner.get_array_from_array_unchecked(array_index) }\n        }\n        fn map<U, let MaxElements: u32, let MaxElementBytes: u32>(\n            self,\n            f: fn(crate::JSONValue<MaxElementBytes>) -> U\n        ) -> [U; MaxElements] where U: std::default::Default {\n            self.inner.map(f)\n        }\n        fn get_object<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_object(key))\n            }\n        }\n        fn get_object_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Self {\n            JSON { inner: self.inner.get_object_unchecked(key) }\n        }\n        fn get_object_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_object_var(key))\n            }\n        }\n        fn get_object_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Self {\n            JSON { inner: self.inner.get_object_unchecked_var(key) }\n        }\n        fn get_object_from_array(self, array_index: Field) -> Option<Self> {\n            JSON::convert(self.inner.get_object_from_array(array_index))\n        }\n        fn get_object_from_array_unchecked(self, array_index: Field) -> Self {\n            JSON { inner: self.inner.get_object_from_array_unchecked(array_index) }\n        }\n        fn get_literal<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal(key)\n        }\n        fn get_literal_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> crate::JSONLiteral {\n            self.inner.get_literal_unchecked(key)\n        }\n        fn get_literal_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal_var(key)\n        }\n        fn get_literal_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> crate::JSONLiteral {\n            self.inner.get_literal_unchecked_var(key)\n        }\n        fn get_literal_from_array(self, array_index: Field) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal_from_array(array_index)\n        }\n        fn get_literal_from_array_unchecked(self, array_index: Field) -> crate::JSONLiteral {\n            self.inner.get_literal_from_array_unchecked(array_index)\n        }\n        fn get_number<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<u64> {\n            self.inner.get_number(key)\n        }\n        fn get_number_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> u64 {\n            self.inner.get_number_unchecked(key)\n        }\n        fn get_number_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<u64> {\n            self.inner.get_number_var(key)\n        }\n        fn get_number_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> u64 {\n            self.inner.get_number_unchecked_var(key)\n        }\n        fn get_number_from_array(self, array_index: Field) -> Option<u64> {\n            self.inner.get_number_from_array(array_index)\n        }\n        fn get_number_from_array_unchecked(self, array_index: Field) -> u64 {\n            self.inner.get_number_from_array_unchecked(array_index)\n        }\n        fn get_string<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string(key)\n        }\n        fn get_string_unchecked<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_unchecked(key)\n        }\n        fn get_string_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_var(key)\n        }\n        fn get_string_unchecked_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_unchecked_var(key)\n        }\n        fn get_string_from_array<let StringBytes: u32>(self, array_index: Field) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_from_array(array_index)\n        }\n        fn get_string_from_array_unchecked<let StringBytes: u32>(self, array_index: Field) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_from_array_unchecked(array_index)\n        }\n        fn get_string_from_path<let KeyBytes: u32, let StringBytes: u32, let PathDepth: u32>(\n            self,\n            keys: [BoundedVec<u8, KeyBytes>; PathDepth]\n        ) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_from_path(keys)\n        }\n        fn get_value<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value(key)\n        }\n        fn get_value_unchecked<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_unchecked(key)\n        }\n        fn get_value_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_var(key)\n        }\n        fn get_value_unchecked_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_unchecked_var(key)\n        }\n        fn get_value_from_array<let StringBytes: u32>(self, array_index: Field) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_from_array(array_index)\n        }\n        fn get_value_from_array_unchecked<let StringBytes: u32>(self, array_index: Field) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_from_array_unchecked(array_index)\n        }\n        fn get_value_from_path<let KeyBytes: u32, let StringBytes: u32, let PathDepth: u32>(\n            self,\n            keys: [BoundedVec<u8, KeyBytes>; PathDepth]\n        ) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_from_path(keys)\n        }\n        fn key_exists<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> bool {\n            self.inner.key_exists(key)\n        }\n        fn get_keys_at_root<let MaxNumKeys: u32, let MaxKeyBytes: u32>(self) -> BoundedVec<BoundedVec<u8, MaxKeyBytes>, MaxNumKeys> {\n            self.inner.get_keys_at_root()\n        }\n    }\n}\n\nmod JSON2kb {\n    struct JSON\n    {\n        inner: crate::json::JSON<2048, 70, 256, 129, 2>\n    }\n    impl JSON {\n        fn convert(inner: Option<crate::json::JSON<2048, 70, 256, 129, 2>>) -> Option<Self> {\n            Option { _is_some: inner._is_some, _value: JSON { inner: inner._value } }\n        }\n    }\n    impl crate::JSONParserTrait for JSON {\n        fn parse_json_from_string<let StringBytes: u32>(s: str<StringBytes>) -> Self {\n            JSON { inner: crate::json::JSON::parse_json_from_string(s) }\n        }\n\n        fn parse_json<let StringBytes: u32>(s: [u8; StringBytes]) -> Self {\n            JSON { inner: crate::json::JSON::parse_json(s) }\n        }\n        fn get_length(self) -> u32 {\n            self.inner.get_length()\n        }\n        fn get_array<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<Self> {\n            JSON::convert(self.inner.get_array(key))\n        }\n        fn get_array_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Self {\n            JSON { inner: self.inner.get_array_unchecked(key) }\n        }\n        fn get_array_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_array_var(key))\n            }\n        }\n        fn get_array_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Self {\n            JSON { inner: self.inner.get_array_unchecked_var(key) }\n        }\n        fn get_array_from_array(self, array_index: Field) -> Option<Self> {\n            JSON::convert(self.inner.get_array_from_array(array_index))\n        }\n        fn get_array_from_array_unchecked(self, array_index: Field) -> Self {\n            JSON { inner: self.inner.get_array_from_array_unchecked(array_index) }\n        }\n        fn map<U, let MaxElements: u32, let MaxElementBytes: u32>(\n            self,\n            f: fn(crate::JSONValue<MaxElementBytes>) -> U\n        ) -> [U; MaxElements] where U: std::default::Default {\n            self.inner.map(f)\n        }\n        fn get_object<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_object(key))\n            }\n        }\n        fn get_object_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Self {\n            JSON { inner: self.inner.get_object_unchecked(key) }\n        }\n        fn get_object_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_object_var(key))\n            }\n        }\n        fn get_object_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Self {\n            JSON { inner: self.inner.get_object_unchecked_var(key) }\n        }\n        fn get_object_from_array(self, array_index: Field) -> Option<Self> {\n            JSON::convert(self.inner.get_object_from_array(array_index))\n        }\n        fn get_object_from_array_unchecked(self, array_index: Field) -> Self {\n            JSON { inner: self.inner.get_object_from_array_unchecked(array_index) }\n        }\n        fn get_literal<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal(key)\n        }\n        fn get_literal_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> crate::JSONLiteral {\n            self.inner.get_literal_unchecked(key)\n        }\n        fn get_literal_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal_var(key)\n        }\n        fn get_literal_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> crate::JSONLiteral {\n            self.inner.get_literal_unchecked_var(key)\n        }\n        fn get_literal_from_array(self, array_index: Field) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal_from_array(array_index)\n        }\n        fn get_literal_from_array_unchecked(self, array_index: Field) -> crate::JSONLiteral {\n            self.inner.get_literal_from_array_unchecked(array_index)\n        }\n        fn get_number<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<u64> {\n            self.inner.get_number(key)\n        }\n        fn get_number_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> u64 {\n            self.inner.get_number_unchecked(key)\n        }\n        fn get_number_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<u64> {\n            self.inner.get_number_var(key)\n        }\n        fn get_number_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> u64 {\n            self.inner.get_number_unchecked_var(key)\n        }\n        fn get_number_from_array(self, array_index: Field) -> Option<u64> {\n            self.inner.get_number_from_array(array_index)\n        }\n        fn get_number_from_array_unchecked(self, array_index: Field) -> u64 {\n            self.inner.get_number_from_array_unchecked(array_index)\n        }\n        fn get_string<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string(key)\n        }\n        fn get_string_unchecked<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_unchecked(key)\n        }\n        fn get_string_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_var(key)\n        }\n        fn get_string_unchecked_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_unchecked_var(key)\n        }\n        fn get_string_from_array<let StringBytes: u32>(self, array_index: Field) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_from_array(array_index)\n        }\n        fn get_string_from_array_unchecked<let StringBytes: u32>(self, array_index: Field) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_from_array_unchecked(array_index)\n        }\n        fn get_string_from_path<let KeyBytes: u32, let StringBytes: u32, let PathDepth: u32>(\n            self,\n            keys: [BoundedVec<u8, KeyBytes>; PathDepth]\n        ) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_from_path(keys)\n        }\n        fn get_value<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value(key)\n        }\n        fn get_value_unchecked<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_unchecked(key)\n        }\n        fn get_value_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_var(key)\n        }\n        fn get_value_unchecked_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_unchecked_var(key)\n        }\n        fn get_value_from_array<let StringBytes: u32>(self, array_index: Field) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_from_array(array_index)\n        }\n        fn get_value_from_array_unchecked<let StringBytes: u32>(self, array_index: Field) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_from_array_unchecked(array_index)\n        }\n        fn get_value_from_path<let KeyBytes: u32, let StringBytes: u32, let PathDepth: u32>(\n            self,\n            keys: [BoundedVec<u8, KeyBytes>; PathDepth]\n        ) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_from_path(keys)\n        }\n        fn key_exists<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> bool {\n            self.inner.key_exists(key)\n        }\n        fn get_keys_at_root<let MaxNumKeys: u32, let MaxKeyBytes: u32>(self) -> BoundedVec<BoundedVec<u8, MaxKeyBytes>, MaxNumKeys> {\n            self.inner.get_keys_at_root()\n        }\n    }\n}\n\nmod JSON4kb {\n    struct JSON\n    {\n        inner: crate::json::JSON<4096, 136, 512, 257, 2>\n    }\n    impl JSON {\n        fn convert(inner: Option<crate::json::JSON<4096, 136, 512, 257, 2>>) -> Option<Self> {\n            Option { _is_some: inner._is_some, _value: JSON { inner: inner._value } }\n        }\n    }\n    impl crate::JSONParserTrait for JSON {\n        fn parse_json_from_string<let StringBytes: u32>(s: str<StringBytes>) -> Self {\n            JSON { inner: crate::json::JSON::parse_json_from_string(s) }\n        }\n\n        fn parse_json<let StringBytes: u32>(s: [u8; StringBytes]) -> Self {\n            JSON { inner: crate::json::JSON::parse_json(s) }\n        }\n        fn get_length(self) -> u32 {\n            self.inner.get_length()\n        }\n        fn get_array<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<Self> {\n            JSON::convert(self.inner.get_array(key))\n        }\n        fn get_array_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Self {\n            JSON { inner: self.inner.get_array_unchecked(key) }\n        }\n        fn get_array_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_array_var(key))\n            }\n        }\n        fn get_array_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Self {\n            JSON { inner: self.inner.get_array_unchecked_var(key) }\n        }\n        fn get_array_from_array(self, array_index: Field) -> Option<Self> {\n            JSON::convert(self.inner.get_array_from_array(array_index))\n        }\n        fn get_array_from_array_unchecked(self, array_index: Field) -> Self {\n            JSON { inner: self.inner.get_array_from_array_unchecked(array_index) }\n        }\n        fn map<U, let MaxElements: u32, let MaxElementBytes: u32>(\n            self,\n            f: fn(crate::JSONValue<MaxElementBytes>) -> U\n        ) -> [U; MaxElements] where U: std::default::Default {\n            self.inner.map(f)\n        }\n        fn get_object<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_object(key))\n            }\n        }\n        fn get_object_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Self {\n            JSON { inner: self.inner.get_object_unchecked(key) }\n        }\n        fn get_object_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_object_var(key))\n            }\n        }\n        fn get_object_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Self {\n            JSON { inner: self.inner.get_object_unchecked_var(key) }\n        }\n        fn get_object_from_array(self, array_index: Field) -> Option<Self> {\n            JSON::convert(self.inner.get_object_from_array(array_index))\n        }\n        fn get_object_from_array_unchecked(self, array_index: Field) -> Self {\n            JSON { inner: self.inner.get_object_from_array_unchecked(array_index) }\n        }\n        fn get_literal<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal(key)\n        }\n        fn get_literal_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> crate::JSONLiteral {\n            self.inner.get_literal_unchecked(key)\n        }\n        fn get_literal_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal_var(key)\n        }\n        fn get_literal_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> crate::JSONLiteral {\n            self.inner.get_literal_unchecked_var(key)\n        }\n        fn get_literal_from_array(self, array_index: Field) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal_from_array(array_index)\n        }\n        fn get_literal_from_array_unchecked(self, array_index: Field) -> crate::JSONLiteral {\n            self.inner.get_literal_from_array_unchecked(array_index)\n        }\n        fn get_number<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<u64> {\n            self.inner.get_number(key)\n        }\n        fn get_number_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> u64 {\n            self.inner.get_number_unchecked(key)\n        }\n        fn get_number_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<u64> {\n            self.inner.get_number_var(key)\n        }\n        fn get_number_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> u64 {\n            self.inner.get_number_unchecked_var(key)\n        }\n        fn get_number_from_array(self, array_index: Field) -> Option<u64> {\n            self.inner.get_number_from_array(array_index)\n        }\n        fn get_number_from_array_unchecked(self, array_index: Field) -> u64 {\n            self.inner.get_number_from_array_unchecked(array_index)\n        }\n        fn get_string<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string(key)\n        }\n        fn get_string_unchecked<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_unchecked(key)\n        }\n        fn get_string_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_var(key)\n        }\n        fn get_string_unchecked_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_unchecked_var(key)\n        }\n        fn get_string_from_array<let StringBytes: u32>(self, array_index: Field) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_from_array(array_index)\n        }\n        fn get_string_from_array_unchecked<let StringBytes: u32>(self, array_index: Field) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_from_array_unchecked(array_index)\n        }\n        fn get_string_from_path<let KeyBytes: u32, let StringBytes: u32, let PathDepth: u32>(\n            self,\n            keys: [BoundedVec<u8, KeyBytes>; PathDepth]\n        ) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_from_path(keys)\n        }\n        fn get_value<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value(key)\n        }\n        fn get_value_unchecked<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_unchecked(key)\n        }\n        fn get_value_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_var(key)\n        }\n        fn get_value_unchecked_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_unchecked_var(key)\n        }\n        fn get_value_from_array<let StringBytes: u32>(self, array_index: Field) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_from_array(array_index)\n        }\n        fn get_value_from_array_unchecked<let StringBytes: u32>(self, array_index: Field) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_from_array_unchecked(array_index)\n        }\n        fn get_value_from_path<let KeyBytes: u32, let StringBytes: u32, let PathDepth: u32>(\n            self,\n            keys: [BoundedVec<u8, KeyBytes>; PathDepth]\n        ) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_from_path(keys)\n        }\n        fn key_exists<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> bool {\n            self.inner.key_exists(key)\n        }\n        fn get_keys_at_root<let MaxNumKeys: u32, let MaxKeyBytes: u32>(self) -> BoundedVec<BoundedVec<u8, MaxKeyBytes>, MaxNumKeys> {\n            self.inner.get_keys_at_root()\n        }\n    }\n}\n\nmod JSON8kb {\n    struct JSON\n    {\n        inner: crate::json::JSON<8192, 268, 1024, 513, 2>\n    }\n    impl JSON {\n        fn convert(inner: Option<crate::json::JSON<8192, 268, 1024, 513, 2>>) -> Option<Self> {\n            Option { _is_some: inner._is_some, _value: JSON { inner: inner._value } }\n        }\n    }\n    impl crate::JSONParserTrait for JSON {\n        fn parse_json_from_string<let StringBytes: u32>(s: str<StringBytes>) -> Self {\n            JSON { inner: crate::json::JSON::parse_json_from_string(s) }\n        }\n\n        fn parse_json<let StringBytes: u32>(s: [u8; StringBytes]) -> Self {\n            JSON { inner: crate::json::JSON::parse_json(s) }\n        }\n        fn get_length(self) -> u32 {\n            self.inner.get_length()\n        }\n        fn get_array<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<Self> {\n            JSON::convert(self.inner.get_array(key))\n        }\n        fn get_array_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Self {\n            JSON { inner: self.inner.get_array_unchecked(key) }\n        }\n        fn get_array_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_array_var(key))\n            }\n        }\n        fn get_array_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Self {\n            JSON { inner: self.inner.get_array_unchecked_var(key) }\n        }\n        fn get_array_from_array(self, array_index: Field) -> Option<Self> {\n            JSON::convert(self.inner.get_array_from_array(array_index))\n        }\n        fn get_array_from_array_unchecked(self, array_index: Field) -> Self {\n            JSON { inner: self.inner.get_array_from_array_unchecked(array_index) }\n        }\n        fn map<U, let MaxElements: u32, let MaxElementBytes: u32>(\n            self,\n            f: fn(crate::JSONValue<MaxElementBytes>) -> U\n        ) -> [U; MaxElements] where U: std::default::Default {\n            self.inner.map(f)\n        }\n        fn get_object<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_object(key))\n            }\n        }\n        fn get_object_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Self {\n            JSON { inner: self.inner.get_object_unchecked(key) }\n        }\n        fn get_object_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_object_var(key))\n            }\n        }\n        fn get_object_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Self {\n            JSON { inner: self.inner.get_object_unchecked_var(key) }\n        }\n        fn get_object_from_array(self, array_index: Field) -> Option<Self> {\n            JSON::convert(self.inner.get_object_from_array(array_index))\n        }\n        fn get_object_from_array_unchecked(self, array_index: Field) -> Self {\n            JSON { inner: self.inner.get_object_from_array_unchecked(array_index) }\n        }\n        fn get_literal<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal(key)\n        }\n        fn get_literal_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> crate::JSONLiteral {\n            self.inner.get_literal_unchecked(key)\n        }\n        fn get_literal_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal_var(key)\n        }\n        fn get_literal_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> crate::JSONLiteral {\n            self.inner.get_literal_unchecked_var(key)\n        }\n        fn get_literal_from_array(self, array_index: Field) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal_from_array(array_index)\n        }\n        fn get_literal_from_array_unchecked(self, array_index: Field) -> crate::JSONLiteral {\n            self.inner.get_literal_from_array_unchecked(array_index)\n        }\n        fn get_number<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<u64> {\n            self.inner.get_number(key)\n        }\n        fn get_number_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> u64 {\n            self.inner.get_number_unchecked(key)\n        }\n        fn get_number_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<u64> {\n            self.inner.get_number_var(key)\n        }\n        fn get_number_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> u64 {\n            self.inner.get_number_unchecked_var(key)\n        }\n        fn get_number_from_array(self, array_index: Field) -> Option<u64> {\n            self.inner.get_number_from_array(array_index)\n        }\n        fn get_number_from_array_unchecked(self, array_index: Field) -> u64 {\n            self.inner.get_number_from_array_unchecked(array_index)\n        }\n        fn get_string<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string(key)\n        }\n        fn get_string_unchecked<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_unchecked(key)\n        }\n        fn get_string_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_var(key)\n        }\n        fn get_string_unchecked_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_unchecked_var(key)\n        }\n        fn get_string_from_array<let StringBytes: u32>(self, array_index: Field) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_from_array(array_index)\n        }\n        fn get_string_from_array_unchecked<let StringBytes: u32>(self, array_index: Field) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_from_array_unchecked(array_index)\n        }\n        fn get_string_from_path<let KeyBytes: u32, let StringBytes: u32, let PathDepth: u32>(\n            self,\n            keys: [BoundedVec<u8, KeyBytes>; PathDepth]\n        ) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_from_path(keys)\n        }\n        fn get_value<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value(key)\n        }\n        fn get_value_unchecked<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_unchecked(key)\n        }\n        fn get_value_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_var(key)\n        }\n        fn get_value_unchecked_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_unchecked_var(key)\n        }\n        fn get_value_from_array<let StringBytes: u32>(self, array_index: Field) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_from_array(array_index)\n        }\n        fn get_value_from_array_unchecked<let StringBytes: u32>(self, array_index: Field) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_from_array_unchecked(array_index)\n        }\n        fn get_value_from_path<let KeyBytes: u32, let StringBytes: u32, let PathDepth: u32>(\n            self,\n            keys: [BoundedVec<u8, KeyBytes>; PathDepth]\n        ) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_from_path(keys)\n        }\n        fn key_exists<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> bool {\n            self.inner.key_exists(key)\n        }\n        fn get_keys_at_root<let MaxNumKeys: u32, let MaxKeyBytes: u32>(self) -> BoundedVec<BoundedVec<u8, MaxKeyBytes>, MaxNumKeys> {\n            self.inner.get_keys_at_root()\n        }\n    }\n}\n\nmod JSON16kb {\n    struct JSON\n    {\n        inner: crate::json::JSON<16384, 532, 2048, 1025, 2>\n    }\n    impl JSON {\n        fn convert(inner: Option<crate::json::JSON<16384, 532, 2048, 1025, 2>>) -> Option<Self> {\n            Option { _is_some: inner._is_some, _value: JSON { inner: inner._value } }\n        }\n    }\n    impl crate::JSONParserTrait for JSON {\n        fn parse_json_from_string<let StringBytes: u32>(s: str<StringBytes>) -> Self {\n            JSON { inner: crate::json::JSON::parse_json_from_string(s) }\n        }\n\n        fn parse_json<let StringBytes: u32>(s: [u8; StringBytes]) -> Self {\n            JSON { inner: crate::json::JSON::parse_json(s) }\n        }\n        fn get_length(self) -> u32 {\n            self.inner.get_length()\n        }\n        fn get_array<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<Self> {\n            JSON::convert(self.inner.get_array(key))\n        }\n        fn get_array_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Self {\n            JSON { inner: self.inner.get_array_unchecked(key) }\n        }\n        fn get_array_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_array_var(key))\n            }\n        }\n        fn get_array_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Self {\n            JSON { inner: self.inner.get_array_unchecked_var(key) }\n        }\n        fn get_array_from_array(self, array_index: Field) -> Option<Self> {\n            JSON::convert(self.inner.get_array_from_array(array_index))\n        }\n        fn get_array_from_array_unchecked(self, array_index: Field) -> Self {\n            JSON { inner: self.inner.get_array_from_array_unchecked(array_index) }\n        }\n        fn map<U, let MaxElements: u32, let MaxElementBytes: u32>(\n            self,\n            f: fn(crate::JSONValue<MaxElementBytes>) -> U\n        ) -> [U; MaxElements] where U: std::default::Default {\n            self.inner.map(f)\n        }\n        fn get_object<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_object(key))\n            }\n        }\n        fn get_object_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Self {\n            JSON { inner: self.inner.get_object_unchecked(key) }\n        }\n        fn get_object_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<Self> {\n            {\n                JSON::convert(self.inner.get_object_var(key))\n            }\n        }\n        fn get_object_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Self {\n            JSON { inner: self.inner.get_object_unchecked_var(key) }\n        }\n        fn get_object_from_array(self, array_index: Field) -> Option<Self> {\n            JSON::convert(self.inner.get_object_from_array(array_index))\n        }\n        fn get_object_from_array_unchecked(self, array_index: Field) -> Self {\n            JSON { inner: self.inner.get_object_from_array_unchecked(array_index) }\n        }\n        fn get_literal<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal(key)\n        }\n        fn get_literal_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> crate::JSONLiteral {\n            self.inner.get_literal_unchecked(key)\n        }\n        fn get_literal_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal_var(key)\n        }\n        fn get_literal_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> crate::JSONLiteral {\n            self.inner.get_literal_unchecked_var(key)\n        }\n        fn get_literal_from_array(self, array_index: Field) -> Option<crate::JSONLiteral> {\n            self.inner.get_literal_from_array(array_index)\n        }\n        fn get_literal_from_array_unchecked(self, array_index: Field) -> crate::JSONLiteral {\n            self.inner.get_literal_from_array_unchecked(array_index)\n        }\n        fn get_number<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<u64> {\n            self.inner.get_number(key)\n        }\n        fn get_number_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> u64 {\n            self.inner.get_number_unchecked(key)\n        }\n        fn get_number_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<u64> {\n            self.inner.get_number_var(key)\n        }\n        fn get_number_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> u64 {\n            self.inner.get_number_unchecked_var(key)\n        }\n        fn get_number_from_array(self, array_index: Field) -> Option<u64> {\n            self.inner.get_number_from_array(array_index)\n        }\n        fn get_number_from_array_unchecked(self, array_index: Field) -> u64 {\n            self.inner.get_number_from_array_unchecked(array_index)\n        }\n        fn get_string<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string(key)\n        }\n        fn get_string_unchecked<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_unchecked(key)\n        }\n        fn get_string_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_var(key)\n        }\n        fn get_string_unchecked_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_unchecked_var(key)\n        }\n        fn get_string_from_array<let StringBytes: u32>(self, array_index: Field) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_from_array(array_index)\n        }\n        fn get_string_from_array_unchecked<let StringBytes: u32>(self, array_index: Field) -> BoundedVec<u8, StringBytes> {\n            self.inner.get_string_from_array_unchecked(array_index)\n        }\n        fn get_string_from_path<let KeyBytes: u32, let StringBytes: u32, let PathDepth: u32>(\n            self,\n            keys: [BoundedVec<u8, KeyBytes>; PathDepth]\n        ) -> Option<BoundedVec<u8, StringBytes>> {\n            self.inner.get_string_from_path(keys)\n        }\n        fn get_value<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value(key)\n        }\n        fn get_value_unchecked<let KeyBytes: u32, let StringBytes: u32>(self, key: [u8; KeyBytes]) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_unchecked(key)\n        }\n        fn get_value_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_var(key)\n        }\n        fn get_value_unchecked_var<let KeyBytes: u32, let StringBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_unchecked_var(key)\n        }\n        fn get_value_from_array<let StringBytes: u32>(self, array_index: Field) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_from_array(array_index)\n        }\n        fn get_value_from_array_unchecked<let StringBytes: u32>(self, array_index: Field) -> crate::JSONValue<StringBytes> {\n            self.inner.get_value_from_array_unchecked(array_index)\n        }\n        fn get_value_from_path<let KeyBytes: u32, let StringBytes: u32, let PathDepth: u32>(\n            self,\n            keys: [BoundedVec<u8, KeyBytes>; PathDepth]\n        ) -> Option<crate::JSONValue<StringBytes>> {\n            self.inner.get_value_from_path(keys)\n        }\n        fn key_exists<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> bool {\n            self.inner.key_exists(key)\n        }\n        fn get_keys_at_root<let MaxNumKeys: u32, let MaxKeyBytes: u32>(self) -> BoundedVec<BoundedVec<u8, MaxKeyBytes>, MaxNumKeys> {\n            self.inner.get_keys_at_root()\n        }\n    }\n}\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/lib.nr"},"76":{"source":"use crate::json_tables::ASCII_TO_TOKEN_TABLE;\n\nstruct ValidationFlags\n{\n    push_layer: Field,\n    push_layer_type_of_root: Field,\n    pop_layer: Field\n}\n\nimpl ValidationFlags {\n    fn to_field(self) -> Field {\n        self.push_layer + self.push_layer_type_of_root * 0x100 + self.pop_layer * 0x10000\n    }\n\n    unconstrained fn __from_field(f: Field) -> Self {\n        let bytes: [u8; 4] = f.to_be_bytes();\n        let mut push_layer= bytes[3] as Field;\n        let push_layer_type_of_root = bytes[2] as Field;\n        let pop_layer = bytes[1] as Field;\n        let error = bytes[0] as Field;\n\n        assert(error == 0, \"ValidationFlags: grammar error\");\n        // we are doing something very degenerate here.\n        // in `validate_tokens` update a `depth` parameter via `depth = depth + push_layer - pop_layer`\n        // we index a size-32 array `parent_layer_stack` using the `depth_parameter` immediately after updating `depth`\n        // i.e. we implicitly validate `push_layer < 32`\n        // If the Prover incorrectly generates the `push_layer` witness via encoding any other flag data within it,\n        // an out of bounds error will be triggered\n        // n.b. reason for doing this is that by only having 3 flags stored in our lookup table,\n        // we can extract them all with 1 add gate. combined with 2 bool checks = 3 gates instead of 5/6 gates if we had 4 flags\n        push_layer = push_layer + error * 0x1000000;\n        ValidationFlags { push_layer, push_layer_type_of_root, pop_layer }\n    }\n\n    // 3 gates\n    fn from_field(f: Field) -> Self {\n        let r = ValidationFlags::__from_field(f);\n        assert(r.pop_layer * r.pop_layer == r.pop_layer);\n        assert(r.push_layer_type_of_root * r.push_layer_type_of_root == r.push_layer_type_of_root);\n        assert(r.pop_layer * 0x10000 + r.push_layer_type_of_root * 0x100 + r.push_layer == f);\n        r\n    }\n}\n\nstruct RawTranscriptEntry {\n    encoded_ascii: Field,\n    index: Field,\n    length: Field,\n}\n\nimpl RawTranscriptEntry {\n    fn new() -> Self {\n        RawTranscriptEntry { encoded_ascii: 0, index: 0, length: 0 }\n    }\n    fn to_field(self) -> Field {\n        self.encoded_ascii + self.index * 0x10000 + self.length * (0x100000000)\n    }\n\n    unconstrained fn __from_field(felt: Field) -> Self {\n        let slices: [u8; 6] = felt.to_be_bytes(); // 2 gates + 1.25 + 2 = 5.25\n        let length = slices[1] as Field + slices[0] as Field * 0x100;\n        let index = slices[3] as Field + slices[2] as Field * 0x100;\n        let encoded_ascii = slices[5] as Field + slices[4] as Field * 0x100;\n        Self { encoded_ascii, index, length }\n    }\n    // 2 gates to add bytes into sum\n    // 1.25 gates for range checks\n    // 2 gates to get u16s\n    // 5.25 gates total\n    fn from_field(felt: Field) -> Self {\n        let result = RawTranscriptEntry::__from_field(felt);\n        result.length.assert_max_bit_size(16);\n        result.index.assert_max_bit_size(16);\n        result.encoded_ascii.assert_max_bit_size(14);\n\n        assert(result.encoded_ascii + result.index * 0x10000 + result.length * 0x100000000 == felt);\n        result\n    }\n\n    unconstrained fn __extract_ascii(f: Field) -> (Field, Field) {\n        let r = RawTranscriptEntry::__from_field(f);\n        let ascii = r.encoded_ascii;\n        let remainder = r.index + r.length * 0x10000;\n        (ascii, remainder)\n    }\n    fn extract_ascii(f: Field) -> (Field, Field) {\n        let (ascii, remainder) = RawTranscriptEntry::__extract_ascii(f);\n        ascii.assert_max_bit_size(14);\n        remainder.assert_max_bit_size(32);\n        assert(ascii + remainder * 0x10000 == f);\n        (ascii, remainder)\n    }\n}\n\nstruct TranscriptEntry {\n    token: Field,\n    index: Field,\n    length: Field\n}\n\nstruct ScanData {\n    scan_token: Field,\n    push_transcript: Field,\n    increase_length: Field,\n    is_potential_escape_sequence: Field,\n}\n\nimpl ScanData {\n    unconstrained fn __from_field(f: Field) -> Self {\n        let bytes : [u8; 6]= f.to_le_bytes();\n\n        let mut scan_token = bytes[0] as Field;\n        let push_transcript = bytes[1] as Field;\n        let increase_length = bytes[2] as Field;\n        let is_potential_escape_sequence = bytes[3] as Field;\n        let error = bytes[4] as Field * 0x100 + bytes[5] as Field;\n        assert(error == 0, \"ScanData: Invalid token\");\n        // TODO document this\n        scan_token = scan_token + error * 0x100000000;\n        ScanData { scan_token, push_transcript, increase_length, is_potential_escape_sequence }\n    }\n    fn from_field(f: Field) -> Self {\n        let result = ScanData::__from_field(f);\n\n        assert(result.increase_length * result.increase_length == result.increase_length);\n        assert(result.push_transcript * result.push_transcript == result.push_transcript);\n        assert(\n            result.is_potential_escape_sequence * result.is_potential_escape_sequence\n            == result.is_potential_escape_sequence\n        );\n        assert(\n            result.scan_token\n            + result.push_transcript * 0x100\n            + result.increase_length * 0x10000\n            + result.is_potential_escape_sequence * 0x1000000\n            == f\n        );\n        result\n    }\n}\n\nstruct PostProcessScanData {\n    token: Field,\n    new_grammar: Field,\n    scan_token: Field,\n}\nimpl PostProcessScanData {\n    fn from_field(f: Field) -> Self {\n        let bytes: [u8; 3] = f.to_be_bytes();\n        let token = bytes[2] as Field;\n        let new_grammar = bytes[1] as Field;\n        let scan_token = bytes[0] as Field;\n        PostProcessScanData { token, new_grammar, scan_token }\n    }\n}\nimpl TranscriptEntry {\n    fn new() -> Self {\n        TranscriptEntry { token: 0, index: 0, length: 0 }\n    }\n    fn to_field(self) -> Field {\n        self.token + self.index * 0x100 + self.length * (0x1000000)\n    }\n    unconstrained fn __from_field(felt: Field) -> Self {\n        let slices: [u8; 5] = felt.to_be_bytes(); // 2 gates + 1.25 + 2 = 5.25\n        let length = slices[1] as Field + slices[0] as Field * 256;\n        let index = slices[3] as Field + slices[2] as Field * 256;\n        let token = slices[4] as Field;\n        Self { token, index, length }\n    }\n    unconstrained fn __get_token(f: Field) -> (Field, Field) {\n        let r = TranscriptEntry::__from_field(f);\n        (r.token, (r.index + r.length * 0x10000))\n    }\n    // 4 gates\n    fn get_token(f: Field) -> Field {\n        let (token, remainder) = TranscriptEntry::__get_token(f);\n        remainder.assert_max_bit_size(32);\n        token.assert_max_bit_size(8);\n        assert(token + remainder * 0x100 == f);\n        token\n    }\n    // 5.25 gates\n    fn from_field(felt: Field) -> Self {\n        let result = TranscriptEntry::__from_field(felt);\n        result.length.assert_max_bit_size(16);\n        result.index.assert_max_bit_size(16);\n        result.token.assert_max_bit_size(8);\n        assert(result.token + result.index * 0x100 + result.length * 0x1000000 == felt);\n        result\n    }\n\n    fn get_token_and_index_length_combined(f: Field) -> (Field, Field) {\n        let (token, remainder) = TranscriptEntry::__get_token(f);\n        remainder.assert_max_bit_size(32);\n        token.assert_max_bit_size(8);\n        assert(token + remainder * 0x100 == f);\n        (token, remainder)\n    }\n\n    // 5.75 gates\n    fn from_raw(raw_encoded: Field) -> Field {\n        let (ascii, remainder) = RawTranscriptEntry::__extract_ascii(raw_encoded);\n        remainder.assert_max_bit_size(32);\n        assert(ascii + remainder * 0x10000 == raw_encoded);\n        // this lookup enforces an implicit 10 bit range check on ascii\n        let token = ASCII_TO_TOKEN_TABLE[ascii];\n        token + remainder * 0x100\n    }\n}\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/transcript_entry.nr"},"77":{"source":"mod ScanMode {\n    global GRAMMAR_SCAN = 0;\n    global STRING_SCAN = 1;\n    global NUMERIC_SCAN = 2;\n    global LITERAL_SCAN: Field = 3;\n}\n\nmod Token {\n    global NO_TOKEN = 0;\n    global BEGIN_OBJECT_TOKEN = 1;\n    global END_OBJECT_TOKEN = 2;\n    global BEGIN_ARRAY_TOKEN = 3;\n    global END_ARRAY_TOKEN: Field = 4;\n    global KEY_SEPARATOR_TOKEN = 5;\n    global VALUE_SEPARATOR_TOKEN = 6;\n    global STRING_TOKEN = 7;\n    global NUMERIC_TOKEN = 8;\n    global LITERAL_TOKEN  =9;\n    global KEY_TOKEN = 10;\n    global NUM_TOKENS = 11;\n    global NUM_TOKENS_MUL_2 = 22;\n}\n\nmod Layer {\n    global OBJECT_LAYER = 0;\n    global ARRAY_LAYER = 1;\n    global SINGLE_VALUE_LAYER = 2;\n}\n\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/enums.nr"},"78":{"source":"use crate::transcript_entry::TranscriptEntry;\nuse crate::json_entry::JSONEntry;\nuse crate::json::JSON;\nuse crate::_comparison_tools::lt::{lt_field_16_bit, assert_lt_240_bit, assert_gt_240_bit};\nuse crate::enums::Token::{NUMERIC_TOKEN, LITERAL_TOKEN, STRING_TOKEN};\nuse crate::enums::Layer::{OBJECT_LAYER, ARRAY_LAYER};\nuse crate::keyhash::ByteHasher;\nuse crate::keymap::KeyIndexData;\nuse crate::_string_tools::string_chopper::StringChopper;\nuse crate::_string_tools::slice_packed_field::slice_fields;\nuse crate::json::JSONValue;\n/**\n * @brief records data used to reason about whether a key exists in a json blob\n **/\nstruct KeySearchResult {\n    found: bool, // does the key exist?\n    target_lt_smallest_entry: bool, // is the target keyhash smaller than the smallest keyhash in self.key_hashes?\n    target_gt_largest_entry: bool, // is the target keyhash larger than the largest keyhash in self.key_hashes?\n    lhs_index: Field, // either the index of the key being searched for, or the index of the keyhash in self.key_hashes that is closest to keyhash (hash > lhs_index_hash)\n    rhs_index: Field, // either the index of the key being searched for, or the index of the keyhash in self.key_hashes that is closest to keyhash (hash < rhs_index_hash)\n}\n\n/**\n * @brief helper methods for extracting data out of a processed JSON object\n **/\nimpl<let NumBytes: u32, let NumPackedFields: u32, let MaxNumTokens: u32, let MaxNumValues: u32, let MaxKeyFields: u32> JSON<NumBytes,NumPackedFields, MaxNumTokens, MaxNumValues, MaxKeyFields> {\n\n    /**\n     * @brief If the root JSON is an object, extract a JSONEntry that describes an array, object or value that maps to a given key\n     * @description returns an Option<JSONEntry> which will be null if the entry does not exist\n     **/\n    fn get_json_entry<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> (bool, JSONEntry) {\n        // let key_index = self.find_key_in_map(keyhash);\n        // assert(self.key_hashes[key_index] == keyhash);\n        assert(self.layer_type_of_root != ARRAY_LAYER, \"cannot extract array elements via a key\");\n\n        let (exists, key_index) = self.key_exists_impl(key);\n        let entry: JSONEntry = self.json_entries_packed[key_index].into();\n        (exists, entry)\n    }\n\n    /**\n     * @brief If the root JSON is an object, extract a JSONEntry that describes an array, object or value that maps to a given key\n     * @note will revert if the key does not exist\n     **/\n    fn get_json_entry_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> JSONEntry {\n        assert(self.layer_type_of_root != ARRAY_LAYER, \"cannot extract array elements via a key\");\n\n        let hasher: ByteHasher<MaxKeyFields> = ByteHasher {};\n        let keyhash = hasher.get_keyhash_var(key, 0, KeyBytes);\n        let two_pow_216 = 0x100000000000000000000000000000000000000000000000000000000;\n\n        let keyhash = keyhash + self.root_id * two_pow_216;\n\n        let key_index = self.find_key_in_map(keyhash);\n\n        assert(self.key_hashes[key_index] == keyhash, \"get_json_entry_unchecked: key not found\");\n        let entry: JSONEntry = self.json_entries_packed[key_index].into();\n\n        entry\n    }\n\n    /**\n     * @brief same as `get_json_entry` but the key length may be less than KeyBytes\n     **/\n    fn get_json_entry_var<let KeyBytes: u32>(\n        self,\n        key: BoundedVec<u8, KeyBytes>\n    ) -> (bool, JSONEntry) {\n        // let key_index = self.find_key_in_map(keyhash);\n        // assert(self.key_hashes[key_index] == keyhash);\n        assert(self.layer_type_of_root != ARRAY_LAYER, \"cannot extract array elements via a key\");\n\n        let (exists, key_index) = self.key_exists_impl_var(key);\n        let entry: JSONEntry = self.json_entries_packed[key_index].into();\n        (exists, entry)\n    }\n\n    /**\n     * @brief same as `get_json_entry_unchecked` but the key length may be less than KeyBytes\n     **/\n    fn get_json_entry_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> JSONEntry {\n        assert(self.layer_type_of_root != ARRAY_LAYER, \"cannot extract array elements via a key\");\n\n        let hasher: ByteHasher<MaxKeyFields> = ByteHasher {};\n        let keyhash = hasher.get_keyhash_var(key.storage, 0, key.len as u32);\n        let two_pow_216 = 0x100000000000000000000000000000000000000000000000000000000;\n\n        let keyhash = keyhash + self.root_id * two_pow_216;\n\n        let key_index = self.find_key_in_map(keyhash);\n\n        assert(self.key_hashes[key_index] == keyhash, \"get_json_entry_unchecked: key not found\");\n        let entry: JSONEntry = self.json_entries_packed[key_index].into();\n\n        entry\n    }\n\n    /**\n     * @brief same as `get_json_entry_unchecked_var` but also returns the position of the JSONEntry in `self.json_entries_packed`\n     **/\n    fn get_json_entry_unchecked_with_key_index<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> (JSONEntry, Field) {\n        assert(self.layer_type_of_root != ARRAY_LAYER, \"cannot extract array elements via a key\");\n\n        let hasher: ByteHasher<MaxKeyFields> = ByteHasher {};\n        let keyhash = hasher.get_keyhash_var(key, 0, KeyBytes);\n        let two_pow_216 = 0x100000000000000000000000000000000000000000000000000000000;\n\n        let keyhash = keyhash + self.root_id * two_pow_216;\n\n        let key_index = self.find_key_in_map(keyhash);\n\n        assert(self.key_hashes[key_index] == keyhash, \"get_json_entry_unchecked: key not found\");\n        let entry: JSONEntry = self.json_entries_packed[key_index].into();\n\n        (entry, key_index)\n    }\n    /**\n     * @brief same as `get_json_entry_unchecked_var` but also returns the position of the JSONEntry in `self.json_entries_packed`\n     **/\n    fn get_json_entry_unchecked_with_key_index_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> (JSONEntry, Field) {\n        assert(self.layer_type_of_root != ARRAY_LAYER, \"cannot extract array elements via a key\");\n\n        let hasher: ByteHasher<MaxKeyFields> = ByteHasher {};\n        let keyhash = hasher.get_keyhash_var(key.storage, 0, key.len as u32);\n        let two_pow_216 = 0x100000000000000000000000000000000000000000000000000000000;\n\n        let keyhash = keyhash + self.root_id * two_pow_216;\n\n        let key_index = self.find_key_in_map(keyhash);\n\n        assert(self.key_hashes[key_index] == keyhash, \"get_json_entry_unchecked: key not found\");\n        let entry: JSONEntry = self.json_entries_packed[key_index].into();\n\n        (entry, key_index)\n    }\n\n    /**\n     * @brief helper method that will extract an array of bytes that describes the value associated with a JSONEntry object\n     * @description e.g. if the JSONEntry describes \"foo\" : \"bar\" in the JSON, `extract_string_entry` will return \"foo\"\n     **/\n    fn extract_string_entry<let StringBytes: u32>(self, entry: JSONEntry) -> [u8; StringBytes] {\n        // todo can we make this faster? witness gen for this method is slow\n        // TODO: document that StringBytes parameter includes non-escaped characters\n        assert(\n            lt_field_16_bit(entry.json_length, StringBytes as Field + 1), \"get_string, string size is larger than StringBytes\"\n        );\n\n        let mut result: [u8; StringBytes] = [0; StringBytes];\n        if (StringBytes <= 31)\n        {\n            let s: StringChopper<1> = StringChopper{};\n            result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n        }\n        else if (StringBytes <= 62)\n        {\n            let s: StringChopper<2> = StringChopper{};\n            result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n        }\n        else if (StringBytes <= 93)\n        {\n            let s: StringChopper<3> = StringChopper{};\n            result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n        }\n        else if (StringBytes <= 124)\n        {\n            let s: StringChopper<4> = StringChopper{};\n            result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n        }\n        else if (StringBytes <= 155)\n        {\n            let s: StringChopper<5> = StringChopper{};\n            result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n        }\n        else if (StringBytes <= 186)\n        {\n            let s: StringChopper<6> = StringChopper{};\n            result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n        }\n        else if (StringBytes <= 217)\n        {\n            let s: StringChopper<7> = StringChopper{};\n            result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n        }\n        else if (StringBytes <= 248) // 8\n        {\n            let s: StringChopper<8> = StringChopper{};\n            result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n        }\n        else if (StringBytes <= 496) // 16\n        {\n            let s: StringChopper<16> = StringChopper{};\n            result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n        }\n        else if (StringBytes <= 992) // 32\n        {\n            let s: StringChopper<32> = StringChopper{};\n            result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n        }\n        else if (StringBytes <= 1984)\n        {\n            let s: StringChopper<64> = StringChopper{};\n            result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n        }\n        else if (StringBytes <= 3968)\n        {\n            let s: StringChopper<128> = StringChopper{};\n            result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n        }\n        else if (StringBytes <= 7936)\n        {\n            let s: StringChopper<256> = StringChopper{};\n            result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n        }\n        else if (StringBytes <= 15872)\n        {\n            let s: StringChopper<512> = StringChopper{};\n            result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n        }\n        else if (StringBytes <= 31774)\n        {\n            let s: StringChopper<1024> = StringChopper{};\n        result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n        }\n        else\n        {\n            // max 16 bits = 65535 = 2115 31-byte slices\n            let s: StringChopper<2115> = StringChopper{};\n            result = s.slice_string(self.json_packed, entry.json_pointer, entry.json_length);\n\n        }\n        result\n    }\n\n    unconstrained fn find_key_in_map(self, target: Field) -> Field {\n        let mut found_index: Field = 0;\n        let mut found: bool = false;\n        for i in 0..MaxNumValues {\n            let key_hash= self.key_hashes[i];\n            if (key_hash == target) {\n                found_index = i as Field;\n                found = true;\n                break;\n            }\n        }\n        assert(found, \"find_key_in_map, key not found\");\n        found_index\n    }\n\n    /**\n     * @brief figures out if `target` exists as a key in `self.key_hashes`\n     * @details if `target` does not exist, we return the two indicies of adjacent\n     *          entries in `self.key_hashes`, lhs_index, rhs_index, where\n     *          lhs_index < key_hash < rhs_index\n     **/\n    unconstrained fn search_for_key_in_map(self, target: Field) -> KeySearchResult {\n        let mut found_index: Field = 0;\n        let mut found: bool = false;\n\n        let mut lhs_maximum: Field = 0;\n        let mut rhs_minimum: Field = -1;\n        let mut lhs_maximum_index: Field = 0;\n        let mut rhs_minimum_index: Field = 0;\n        for i in 0..MaxNumValues {\n            let key_hash= self.key_hashes[i];\n            if (key_hash == target) {\n                found_index = i as Field;\n                found = true;\n                break;\n            } else {\n                if key_hash.lt(target) & (lhs_maximum.lt(key_hash)) {\n                    lhs_maximum = key_hash;\n                    lhs_maximum_index = i as Field;\n                }\n                if (target.lt(key_hash)) & (key_hash.lt(rhs_minimum)) {\n                    rhs_minimum = key_hash;\n                    rhs_minimum_index = i as Field;\n                }\n            }\n        }\n        let target_lt_smallest_entry = target.lt(self.key_hashes[0]);\n        let target_gt_largest_entry = self.key_hashes[MaxNumValues - 1].lt(target);\n\n        let result_not_first_or_last = !target_lt_smallest_entry & !target_gt_largest_entry & !found;\n\n        let mut lhs_index = result_not_first_or_last as Field * lhs_maximum_index;\n        let mut rhs_index = result_not_first_or_last as Field * rhs_minimum_index;\n\n        // if target_lt_smallest_entry, rhs_index = 0\n        // if target_gt_largest_entry, lhs_index = TranscriptEntries - 1\n        rhs_index = rhs_index * (1 - target_lt_smallest_entry as Field);\n\n        // we rely here on the fact that target_gt_largest_entry and result_not_first_or_last are mutually exclusive\n        lhs_index = lhs_index  + target_gt_largest_entry as Field * (MaxNumValues as Field - 1);\n\n        // If target is FOUND, we want the following:\n        // keyhash[target_index] - 1 < hash < keyhash[target_index] + 1\n        lhs_index = lhs_index  + found as Field * found_index;\n        rhs_index = rhs_index  + found as Field * found_index;\n\n        KeySearchResult { found, target_lt_smallest_entry, target_gt_largest_entry, lhs_index, rhs_index }\n    }\n\n    /**\n     * @brief returns a bool that describes whether a given key exists at the root of the JSON\n     **/\n    fn key_exists<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> bool {\n        self.key_exists_impl_var(key).0\n    }\n\n    /**\n     * @brief implementation of `key_exists`. returns both a boolean and also the position in `self.json_entries_packed` of the key\n     * @description algorithm is O(1) because of the preprocessing we have done\n     *              Method computes a key hash and checks whether key hash exists in the list of sorted preprocessed key hashes\n     *              If it does *not* exist, we can find two adjacent entries in `key_hashes` where `key_hashes[i]` < target_key_hash < `key_hashes[i+1]`\n     **/\n    fn key_exists_impl<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> (bool, Field) {\n        /*\n            Option A: key exists\n            Option B: key does NOT exist\n\n            If key does NOT exist. 3 cases\n            case 1: keyhash < first entry\n            case 2: keyhash > last entry\n            case 3: entry A > keyhash > entryB\n\n        */\n        let hasher: ByteHasher<MaxKeyFields> = ByteHasher {};\n        let keyhash = hasher.get_keyhash_var(key, 0, KeyBytes);\n\n        let HASH_MAXIMUM = 0x1000000000000000000000000000000000000000000000000000000000000 - 1;\n        let two_pow_216 = 0x100000000000000000000000000000000000000000000000000000000;\n\n        let keyhash = keyhash + self.root_id * two_pow_216;\n\n        let search_result = self.search_for_key_in_map(keyhash);\n        let found = search_result.found as Field;\n\n        let target_lt_smallest_entry = search_result.target_lt_smallest_entry as Field;\n        let target_gt_largest_entry = search_result.target_gt_largest_entry as Field;\n\n        assert(((search_result.lhs_index - search_result.rhs_index) * found) == 0);\n\n        // only one of \"found\", \"target_lt_smallest_entry\", \"target_gt_largest_entry\" can be true\n        let exclusion_test = found + target_gt_largest_entry + target_lt_smallest_entry;\n        assert(exclusion_test * exclusion_test == exclusion_test);\n\n        let mut lhs = self.key_hashes[search_result.lhs_index];\n        let mut rhs = self.key_hashes[search_result.rhs_index];\n\n        // case where hash < self.key_hashes[0]\n        // 0 < hash < hashes[0]\n        lhs = lhs * (1 - target_lt_smallest_entry);\n\n        // case where hash > self.key_hashes[last]\n        // largest < x < -1\n        rhs = rhs * (1 - target_gt_largest_entry) + target_gt_largest_entry * HASH_MAXIMUM;\n\n        // case where hash == self.key_hashes[found_index]\n        lhs = lhs - found;\n        rhs = rhs + found;\n\n        assert_gt_240_bit(keyhash, lhs);\n        assert_lt_240_bit(keyhash, rhs);\n\n        (search_result.found, search_result.lhs_index)\n    }\n\n    /**\n     * @brief implementation of `key_exists`. returns both a boolean and also the position in `self.json_entries_packed` of the key\n     * @description algorithm is O(1) because of the preprocessing we have done\n     *              Method computes a key hash and checks whether key hash exists in the list of sorted preprocessed key hashes\n     *              If it does *not* exist, we can find two adjacent entries in `key_hashes` where `key_hashes[i]` < target_key_hash < `key_hashes[i+1]`\n     **/\n    fn key_exists_impl_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> (bool, Field) {\n        /*\n            Option A: key exists\n            Option B: key does NOT exist\n\n            If key does NOT exist. 3 cases\n            case 1: keyhash < first entry\n            case 2: keyhash > last entry\n            case 3: entry A > keyhash > entryB\n\n        */\n        let hasher: ByteHasher<MaxKeyFields> = ByteHasher {};\n        let keyhash = hasher.get_keyhash_var(key.storage, 0, key.len as u32);\n\n        let HASH_MAXIMUM = 0x1000000000000000000000000000000000000000000000000000000000000 - 1;\n        let two_pow_216 = 0x100000000000000000000000000000000000000000000000000000000;\n\n        let keyhash = keyhash + self.root_id * two_pow_216;\n\n        let search_result = self.search_for_key_in_map(keyhash);\n        let found = search_result.found as Field;\n\n        let target_lt_smallest_entry = search_result.target_lt_smallest_entry as Field;\n        let target_gt_largest_entry = search_result.target_gt_largest_entry as Field;\n\n        assert(((search_result.lhs_index - search_result.rhs_index) * found) == 0);\n\n        // only one of \"found\", \"target_lt_smallest_entry\", \"target_gt_largest_entry\" can be true\n        let exclusion_test = found + target_gt_largest_entry + target_lt_smallest_entry;\n        assert(exclusion_test * exclusion_test == exclusion_test);\n\n        let mut lhs = self.key_hashes[search_result.lhs_index];\n        let mut rhs = self.key_hashes[search_result.rhs_index];\n\n        // case where hash < self.key_hashes[0]\n        // 0 < hash < hashes[0]\n        lhs = lhs * (1 - target_lt_smallest_entry);\n\n        // case where hash > self.key_hashes[last]\n        // largest < x < -1\n        rhs = rhs * (1 - target_gt_largest_entry) + target_gt_largest_entry * HASH_MAXIMUM;\n\n        // case where hash == self.key_hashes[found_index]\n        lhs = lhs - found;\n        rhs = rhs + found;\n\n        assert_gt_240_bit(keyhash, lhs);\n        assert_lt_240_bit(keyhash, rhs);\n\n        (search_result.found, search_result.lhs_index)\n    }\n\n    unconstrained fn __get_keys_at_root<let MaxNumKeys: u32>(self) -> BoundedVec<Field, MaxNumKeys> {\n        let mut result: BoundedVec<Field, MaxNumKeys> = BoundedVec { len: 0, storage: [0; MaxNumKeys] };\n\n        let root_object: JSONEntry = JSONEntry::from(self.json_entries_packed[self.root_index_in_transcript]);\n\n        let mut result_ptr = 0;\n        for i in 0..MaxNumValues {\n            let target_entry: JSONEntry = JSONEntry::from(self.unsorted_json_entries_packed[i]);\n            if (target_entry.parent_index == self.root_id) {\n                result.storage[result_ptr] = i as Field;\n                result_ptr += 1;\n            }\n        }\n        assert(result_ptr == root_object.num_children);\n        result.len = result_ptr as u32;\n        result\n    }\n    fn get_keys_at_root<let MaxNumKeys: u32, let MaxKeyBytes: u32>(self) -> BoundedVec<BoundedVec<u8, MaxKeyBytes>, MaxNumKeys> {\n        let root_object: JSONEntry = JSONEntry::from(self.json_entries_packed[self.root_index_in_transcript]);\n        let key_indices: BoundedVec<Field, MaxNumKeys> = self.__get_keys_at_root();\n\n        assert(key_indices.len as Field == root_object.num_children);\n\n        let mut result: BoundedVec<BoundedVec<u8, MaxKeyBytes>, MaxNumKeys> = BoundedVec { len: 0, storage: [BoundedVec { len: 0, storage: [0; MaxKeyBytes] }; MaxNumKeys] };\n        for i in 0..MaxNumKeys {\n            let key = KeyIndexData::from_field(self.key_data[key_indices.storage[i]]);\n            // just a workaround to the interface for `extract_string_entry`\n            let mut fake_entry = JSONEntry::new();\n            fake_entry.json_pointer = key.json_index;\n            fake_entry.json_length = key.json_length;\n            result.storage[i].storage = self.extract_string_entry(fake_entry);\n            result.storage[i].len = key.json_length as u32;\n        }\n        result.len = key_indices.len;\n        result\n    }\n}\n\n#[test]\nfn test_get_keys_at_root() {\n    let s = \"{ \\\"A\\\": 1, \\\"foo\\\": false, \\\"bar\\\": { \\\"one\\\" : \\\"A\\\", \\\"two\\\" : \\\"B\\\"}, \\\"baz\\\": \\\"12345\\\"  }\";\n\n    let json: JSON<77, 6, 30, 30, 2> = JSON::parse_json_from_string(s);\n\n    let keys: BoundedVec<BoundedVec<u8, 5>, 5> = json.get_keys_at_root();\n\n    assert(keys.len == 4);\n    assert(keys.storage[0] == BoundedVec::from_array(\"A\".as_bytes()));\n    assert(keys.storage[1] == BoundedVec::from_array(\"foo\".as_bytes()));\n    assert(keys.storage[2] == BoundedVec::from_array(\"bar\".as_bytes()));\n    assert(keys.storage[3] == BoundedVec::from_array(\"baz\".as_bytes()));\n}\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/getters.nr"},"79":{"source":"struct TokenFlags {\n    create_json_entry: Field,\n    is_end_of_object_or_array: Field,\n    is_start_of_object_or_array: Field,\n    new_context: Field,\n    is_key_token: Field,\n    is_value_token: Field,\n    preserve_num_entries: Field,\n}\n\nimpl TokenFlags {\n\n    unconstrained fn __from_field(f: Field) -> Self {\n        let bytes: [u8; 7] = f.to_be_bytes();\n        let create_json_entry = bytes[0] as Field;\n        let is_end_of_object_or_array = bytes[1] as Field;\n        let is_start_of_object_or_array = bytes[2] as Field;\n        let new_context = bytes[3] as Field;\n        let is_key_token = bytes[4] as Field;\n        let is_value_token = bytes[5] as Field;\n        let preserve_num_entries = bytes[6] as Field;\n\n        TokenFlags {\n            create_json_entry,\n            is_end_of_object_or_array,\n            is_start_of_object_or_array,\n            new_context,\n            is_key_token,\n            is_value_token,\n            preserve_num_entries\n        }\n    }\n\n    fn from_field(f: Field) -> Self {\n        // 10 gates\n        let r = TokenFlags::__from_field(f);\n\n        assert(r.create_json_entry * r.create_json_entry == r.create_json_entry);\n        assert(r.is_end_of_object_or_array * r.is_end_of_object_or_array == r.is_end_of_object_or_array);\n        assert(\n            r.is_start_of_object_or_array * r.is_start_of_object_or_array\n            == r.is_start_of_object_or_array\n        );\n        assert(r.new_context * r.new_context == r.new_context);\n        assert(r.is_key_token * r.is_key_token == r.is_key_token);\n        assert(r.is_value_token * r.is_value_token == r.is_value_token);\n        assert(r.preserve_num_entries * r.preserve_num_entries == r.preserve_num_entries);\n\n        assert(r.to_field() == f);\n        r\n    }\n\n    // 4 gates\n    fn to_field(self) -> Field {\n        self.preserve_num_entries\n            + self.is_value_token * 0x100\n            + self.is_key_token * 0x10000\n            + self.new_context * 0x1000000\n            + self.is_start_of_object_or_array * 0x100000000\n            + self.is_end_of_object_or_array * 0x10000000000\n            + self.create_json_entry * 0x1000000000000\n    }\n\n    fn default() -> Self {\n        TokenFlags {\n            create_json_entry: 0,\n            is_end_of_object_or_array: 0,\n            is_start_of_object_or_array: 0,\n            new_context: 0,\n            is_key_token: 0,\n            preserve_num_entries: 0,\n            is_value_token: 0\n        }\n    }\n}\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/token_flags.nr"},"80":{"source":"use crate::json::JSON;\nuse crate::json_entry::{JSONEntryPacked, JSONEntry};\nuse crate::_comparison_tools::lt::lt_field_16_bit;\nuse crate::_comparison_tools::lt::lte_field_240_bit;\nuse crate::_comparison_tools::lt::assert_lte_240_bit;\nuse crate::json_tables::TOKEN_ENDS_OBJECT_OR_ARRAY;\nuse crate::_string_tools::slice_packed_field::slice_fields;\nuse crate::keyhash::FieldHasher;\n\nuse dep::noir_sort;\n\nuse dep::std::hash::poseidon2;\nstruct KeyIndexData {\n    json_index: Field,\n    json_length: Field,\n    parent_id: Field,\n    array_index: Field,\n}\n\nimpl KeyIndexData {\n    fn to_field(self) -> Field {\n        self.parent_id\n            + self.json_index as Field * 0x10000\n            + self.json_length as Field * 0x100000000\n            + self.array_index * 0x1000000000000\n    }\n\n    unconstrained fn __from_field(packed: Field) -> Self {\n        let unpacked: [u8; 8] = packed.to_be_bytes();\n        let array_index: Field = unpacked[1] as Field + unpacked[0] as Field * 0x100;\n        let json_length: Field = unpacked[3] as Field + unpacked[2] as Field * 0x100;\n        let json_index: Field = unpacked[5] as Field + unpacked[4] as Field * 0x100;\n        let parent_id: Field = unpacked[7] as Field + unpacked[6] as Field * 0x100;\n        KeyIndexData { json_index, json_length, parent_id, array_index }\n    }\n\n    fn from_field(packed: Field) -> Self {\n        let result = KeyIndexData::__from_field(packed);\n        result.array_index.assert_max_bit_size(16);\n        result.json_length.assert_max_bit_size(16);\n        result.json_index.assert_max_bit_size(16);\n        result.parent_id.assert_max_bit_size(16);\n        assert(result.to_field() == packed);\n        result\n    }\n}\n\nimpl<let NumBytes: u32, let NumPackedFields: u32, let MaxNumTokens: u32, let MaxNumValues: u32, let MaxKeyFields: u32> JSON<NumBytes, NumPackedFields, MaxNumTokens, MaxNumValues, MaxKeyFields> {\n    fn compute_keyhash_and_sort_json_entries(&mut self) {\n        let hasher: FieldHasher<MaxKeyFields> = FieldHasher {};\n\n        let mut hashlist: [Field; MaxNumValues] = [0; MaxNumValues];\n\n        let two_pow_200 = 0x10000000000000000000000000000000000000000000000000000;\n        let two_pow_216 = 0x100000000000000000000000000000000000000000000000000000000;\n        for i in 0..MaxNumValues {\n            let KeyIndexData{ json_index, json_length, parent_id, array_index } = KeyIndexData::from_field(self.key_data[i]);\n            let hash = hasher.get_keyhash(self.json_packed, json_index, json_length);\n            hashlist[i] = hash + array_index * two_pow_200 + parent_id * two_pow_216;\n        }\n\n        hashlist[MaxNumValues - 1] = 0; // we always ensure the last (unused hopefully!) entry goes first.\n\n        self.json_entries_packed[MaxNumValues - 1] = JSONEntryPacked::default();\n        // when updating identity_to_json_map we are relying on the fact that we can update sorted entry 0? maybe? oof document better\n        let sort_result = noir_sort::sort_advanced(hashlist, lte_field_240_bit, assert_lte_240_bit);\n\n        let mut sorted_entries: [JSONEntryPacked; MaxNumValues] = [JSONEntryPacked::default(); MaxNumValues];\n        for i in 0..MaxNumValues {\n            sorted_entries[sort_result.sort_indices[i]] = self.json_entries_packed[i];\n        }\n\n        let mut ids: [Field; MaxNumValues] = [0; MaxNumValues];\n        let mut parent_indices: [Field; MaxNumValues] = [0; MaxNumValues];\n        let mut entry_types: [Field; MaxNumValues] = [0; MaxNumValues];\n\n        for i in 0..MaxNumValues {\n            // 11.75 + 3.5 = 15.25 gates per iteration\n            let (id, parent_index, entry_type) = JSONEntry::extract_entry_type_id_and_parent_index_from_field(sorted_entries[i].value);\n            ids[i] = id;\n            parent_indices[i] = parent_index;\n            entry_types[i] = entry_type;\n        }\n\n        let mut identity_to_json_map: [Field; MaxNumValues] = [0; MaxNumValues];\n        // 6.5 gates per iteration\n        for i in 0..MaxNumValues {\n            let id = ids[i];\n            let entry_type = entry_types[i];\n            // 2 gates\n            let update = TOKEN_ENDS_OBJECT_OR_ARRAY[entry_type];\n            // NOTE THIS RELIES ON MaxNumValues ACTUALLY DESCRIBING NUMMaxNumValues + 1\n            // 1 gate\n            let index = (id - (MaxNumValues as Field - 1)) * update + (MaxNumValues as Field - 1);\n            // 3.5 gates\n            identity_to_json_map[index] = i as Field;\n        }\n\n        // 13.5 gates per iteration\n        let mut parent_identity_pre = parent_indices[0];\n        for i in 1..MaxNumValues {\n            let parent_identity_post = parent_indices[i];\n            // if the parent identity changes,\n\n            // 3.5 gate\n            // the list is sorted according to parent_ideneity,\n            // n.b. parent_identity_post - parent_identity_pre is not neccessarily 0 or 1 (can be larger)\n            //      due to empty objects and arrays increasing identity value without creating associated child json entries\n            let new_parent = lt_field_16_bit(parent_identity_pre, parent_identity_post) as Field;\n            // let new_parent = (parent_identity_post as u32 > parent_identity_pre as u32) as Field;\n            // 3.5 gates\n            let index_of_parent = identity_to_json_map[parent_identity_post];\n            // 1 gate + 3.5 gates\n            let updated = JSONEntry::add_child_pointer_into_field(sorted_entries[index_of_parent].value, i as Field);\n\n            // RELIES ON THE SMALLEST ENTRY IN THE SORTED LIST BEING EMPTY\n            // 1 gate\n            let index = (index_of_parent * new_parent);\n            // 3.5 gates\n            sorted_entries[index] = JSONEntryPacked{ value: updated };\n\n            parent_identity_pre = parent_identity_post;\n        }\n        sorted_entries[0] = JSONEntryPacked::default(); // TODO document why we want to always make 0 a dead entry\n\n        self.unsorted_json_entries_packed = self.json_entries_packed;\n        self.json_entries_packed = sorted_entries;\n        self.key_hashes = sort_result.sorted;\n        self.set_root_entry();\n    }\n\n    unconstrained fn __find_root_entry(self) -> Field {\n        let mut found_index = 0;\n        for i in 0..MaxNumValues {\n            let entry : JSONEntry = self.json_entries_packed[i].into();\n            if (entry.parent_index == 0) & (self.json_entries_packed[i].value != 0) {\n                found_index = i as Field;\n                break;\n            }\n        }\n        found_index\n    }\n\n    fn set_root_entry(&mut self) {\n        let root_index = self.__find_root_entry();\n\n        let packed_entry = self.json_entries_packed[root_index];\n        let entry: JSONEntry = packed_entry.into();\n\n        assert(packed_entry.value != 0);\n        assert(entry.parent_index == 0);\n        self.root_index_in_transcript = root_index;\n    }\n}\n\n// 68002\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/keymap.nr"},"81":{"source":"use crate::json_entry::JSONEntry;\nuse crate::json::JSON;\nuse crate::_comparison_tools::lt::lt_field_16_bit;\nuse crate::json_tables::ASCII_TO_NUMBER;\nuse crate::enums::Token::NUMERIC_TOKEN;\nuse crate::enums::Layer::{OBJECT_LAYER, ARRAY_LAYER};\nuse crate::getters::JSONValue;\n\nglobal U64_LENGTH_AS_BASE10_STRING = 20;\nglobal NUMBER_OFFSET_SHIFT: [Field; 21] = [\n    100000000000000000000,10000000000000000000,1000000000000000000,100000000000000000,10000000000000000,1000000000000000,100000000000000,10000000000000, 1000000000000, 100000000000, 10000000000, 1000000000, 100000000,10000000,1000000,100000,10000,1000,100,10,1\n];\n\nfn extract_number_from_array(arr: [u8; U64_LENGTH_AS_BASE10_STRING], json_length: Field) -> u64 {\n    let mut parsed_number: Field = 0;\n    for i in 0..U64_LENGTH_AS_BASE10_STRING {\n        parsed_number *= 10;\n\n        let value = ASCII_TO_NUMBER[arr[i]] as Field;\n        parsed_number += value;\n    }\n    parsed_number /= NUMBER_OFFSET_SHIFT[json_length];\n    parsed_number as u64\n}\n\n/**\n * @brief getter methods for extracting numeric values out of a JSON struct\n * @note numeric values must fit into a `u64` type.\n *       decimal values and scientific notation are not yet supported\n **/\nimpl<let NumBytes: u32, let NumPackedFields: u32, let MaxNumTokens: u32, let MaxNumValues: u32, let MaxKeyFields: u32> JSON<NumBytes,NumPackedFields, MaxNumTokens, MaxNumValues, MaxKeyFields> {\n\n    /**\n     * @brief if the root JSON is an object, extract a numeric value given by `key`\n     * @description returns an Option<u64> which will be null if the key does not exist\n     **/\n    fn get_number<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> Option<u64> {\n        let (exists, entry) = self.get_json_entry(key);\n        assert(\n            (entry.entry_type - NUMERIC_TOKEN) * exists as Field == 0, \"get_number: entry exists but is not a number!\"\n        );\n        let mut parsed_string: [u8; U64_LENGTH_AS_BASE10_STRING] = self.extract_string_entry(entry);\n\n        Option { _is_some: exists, _value: extract_number_from_array(parsed_string, entry.json_length) }\n    }\n\n    /**\n     * @brief if the root JSON is an object, extract a u64 value given by `key`\n     * @description will revert if the number does not exist\n     **/\n    fn get_number_unchecked<let KeyBytes: u32>(self, key: [u8; KeyBytes]) -> u64 {\n        let  entry = self.get_json_entry_unchecked(key);\n        assert(entry.entry_type == NUMERIC_TOKEN, \"get_number_unchecked: entry exists but is not a number!\");\n        let mut parsed_string: [u8; U64_LENGTH_AS_BASE10_STRING] = self.extract_string_entry(entry);\n\n        extract_number_from_array(parsed_string, entry.json_length)\n    }\n\n    /**\n     * @brief same as `get_number` for where the key length may be less than KeyBytes\n     **/\n    fn get_number_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> Option<u64> {\n        let (exists, entry) = self.get_json_entry_var(key);\n        assert(\n            (entry.entry_type - NUMERIC_TOKEN) * exists as Field == 0, \"get_number: entry exists but is not a number!\"\n        );\n        let mut parsed_string: [u8; U64_LENGTH_AS_BASE10_STRING] = self.extract_string_entry(entry);\n\n        Option { _is_some: exists, _value: extract_number_from_array(parsed_string, entry.json_length) }\n    }\n\n    /**\n     * @brief same as `get_number_unchecked` for where the key length may be less than KeyBytes\n     **/\n    fn get_number_unchecked_var<let KeyBytes: u32>(self, key: BoundedVec<u8, KeyBytes>) -> u64 {\n        let  entry = self.get_json_entry_unchecked_var(key);\n        assert(entry.entry_type == NUMERIC_TOKEN, \"get_number_unchecked: entry exists but is not a number!\");\n        let mut parsed_string: [u8; U64_LENGTH_AS_BASE10_STRING] = self.extract_string_entry(entry);\n\n        extract_number_from_array(parsed_string, entry.json_length)\n    }\n\n    /**\n     * @brief if the root JSON is an array, extract a numeric value given by the position of the target in the source array\n     * @description returns an Option<u64> which will be null if the number does not exist\n     **/\n    fn get_number_from_array(self, array_index: Field) -> Option<u64> {\n        assert(self.layer_type_of_root == ARRAY_LAYER, \"can only acceess array elements from array\");\n\n        let parent_entry : JSONEntry = self.json_entries_packed[self.root_index_in_transcript].into();\n\n        let valid = lt_field_16_bit(array_index, parent_entry.num_children);\n        let entry_index = (parent_entry.child_pointer + array_index) * valid as Field;\n\n        let entry : JSONEntry = self.json_entries_packed[entry_index].into();\n\n        assert(\n            (entry.entry_type - NUMERIC_TOKEN) * valid as Field == 0, \"get_number: entry exists but is not a number!\"\n        );\n\n        let mut parsed_string: [u8; U64_LENGTH_AS_BASE10_STRING] = self.extract_string_entry(entry);\n        let result = extract_number_from_array(parsed_string, entry.json_length);\n\n        Option { _is_some: valid, _value: result }\n    }\n\n    /**\n     * @brief if the root JSON is an array, extract a numeric value given by the position of the target in the source array\n     * @description will revert if the number does not exist\n     **/\n    fn get_number_from_array_unchecked(self, array_index: Field) -> u64 {\n        assert(self.layer_type_of_root == ARRAY_LAYER, \"can only acceess array elements from array\");\n\n        let parent_entry : JSONEntry = self.json_entries_packed[self.root_index_in_transcript].into();\n\n        let valid = lt_field_16_bit(array_index, parent_entry.num_children);\n        assert(valid, \"array overflow\");\n        let entry_index = (parent_entry.child_pointer + array_index);\n\n        let entry : JSONEntry = self.json_entries_packed[entry_index].into();\n\n        assert(entry.entry_type == NUMERIC_TOKEN, \"get_number: entry exists but is not a number!\");\n\n        let mut parsed_string: [u8; U64_LENGTH_AS_BASE10_STRING] = self.extract_string_entry(entry);\n        extract_number_from_array(parsed_string, entry.json_length)\n    }\n}\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/get_number.nr"},"82":{"source":"\n\n/*\n\nwhen iterating from 0 to N, validate i < M efficiently\nwe have an array of flags that describe whether entry is valid\nflags start at 1 and at 0 more or less\n\nwe check:\n1. flag starts at 0 or 1\n2. flag transition cannot be 0 -> 1 i.e. new_flag * (1 - old_flag) == 0\n3. flag ends at 0 or 1\n\nthe above validates that only one transition point occurs\nwe still need to test the transition point\n\ntransition happens when we get 1 -> 0 i.e. tx = i * (old_flag * (1 - new_flag))\nin this case, i == M\n\n// o * (1 - n) = o - on\n// n * (1 - o) = n - on\n// i*(o - on) * (1/i) - o + n\n*/\n\n/**\n * @brief helper method that provides an array of Field elements `flags`, where `flags[i] = i < boundary`\n * @description this method is cheaper than querying `i < boundary` for `u16` and `u32` types\n *              cost = 3 gates + 2 gates per iteration \n **/\npub fn get_validity_flags<let N: u32>(boundary: u32) -> [Field; N] {\n    let flags: [Field; N] = __get_validity_flags(boundary);\n    get_validity_flags_inner(boundary, flags)\n}\n\nunconstrained fn __get_validity_flags<let N: u32>(boundary: u32) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        if i < boundary {\n            result[i] = 1;\n        }\n    }\n    result\n}\n\n/**\n * @brief implementation of `get_validity_flags`\n * @description Given an array of `flags`, we apply the following checks to build an inductive proof about the validity of the flags array:\n *              1. the first element `flags[0]` is in the range [0,1]\n *              2. the last element `flags[N-1]` is in the range [0,1]\n *              3. for any two flags `old, new` where `old = flags[i-1], new = flags[i]` and `i>0, i <N`, we validate the following:\n *                  a. if `old` is 0, `new` *cannot* equal 1\n *                  b. if `old` is 1 and `new` is 0, set `transition_index = i`\n *  The value of `transition_index` will equal the value `i` where `i = boundary` (or `N` if `boundary > N`)\n *              4. we finally validate `transition_index == boundary` to prove the location where `flags[i-1] = 1` and `flags[i] = 0`\n *                 aligns with what is expected from testing `i < boundary`\n *  N.B. this method will revert if `boundary > N`\n **/\nfn get_validity_flags_inner<let N: u32>(boundary: u32, flags: [Field; N]) -> [Field; N] {\n    let initial_flag = flags[0];\n    let final_flag = flags[N - 1];\n\n    // check first and last flags are in the range [0, 1]\n    assert(initial_flag * initial_flag == initial_flag);\n    assert(final_flag * final_flag == final_flag);\n\n    let mut transition_index = 0;\n\n    for i in 1..N {\n        let old_flag = flags[i - 1];\n        let new_flag = flags[i];\n        assert(new_flag == old_flag * new_flag);\n\n        // old = a, new = b\n        let idx = (old_flag * (1 - new_flag)) * (i as Field);\n        transition_index = transition_index + idx;\n        std::as_witness(transition_index);\n    }\n\n    assert(transition_index == boundary as Field);\n    flags\n}\n\n#[test]\nfn test_get_validity_flags() {\n    for i in 0..32 {\n        let flags: [Field; 32] = get_validity_flags(i);\n        for j in 0..32 {\n            assert(flags[j] == (j < i) as Field);\n        }\n    }\n}\n\n#[test(should_fail)]\nfn test_get_validity_flags_fail() {\n    let _ = get_validity_flags(33);\n}\n\n#[test(should_fail)]\nfn test_get_validity_flags_bad_index_fail_a() {\n    let bad_flags: [Field; 10] = [1, 1, 1, 0, 0, 0, 1, 0, 0, 0];\n    let _ = get_validity_flags_inner(3, bad_flags);\n}\n#[test(should_fail)]\nfn test_get_validity_flags_bad_index_fail_b() {\n    let bad_flags: [Field; 10] = [1, 1, 1, 1, 0, 0, 0, 0, 0, 0];\n    let _ = get_validity_flags_inner(3, bad_flags);\n}\n\n#[test(should_fail)]\nfn test_get_validity_flags_bad_index_fail_c() {\n    let bad_flags: [Field; 10] = [1, 1, 0, 0, 0, 0, 0, 0, 0, 0];\n    let _ = get_validity_flags_inner(3, bad_flags);\n}\n\n#[test]\nfn test_get_validity_flags_good_index_d() {\n    let bad_flags: [Field; 10] = [1, 1, 1, 0, 0, 0, 0, 0, 0, 0];\n    let _ = get_validity_flags_inner(3, bad_flags);\n}\n\n#[test(should_fail)]\nfn test_get_validity_flags_bad_index_fail_e() {\n    let bad_flags: [Field; 10] = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\n    let _ = get_validity_flags_inner(11, bad_flags);\n}\n\n// this test uses bad flags but manipulates transition_index to be satisfiable\n// nevertheless test will fail because our transition test (old * new = new) will fail\n#[test(should_fail)]\nfn test_get_validity_flags_bad_index_fail_f() {\n    let mut bad_flags: [Field; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n    let fake_index_a = 2;\n    let fake_value_a = 100;\n\n    let fake_index_b = 4;\n    // 4 * Y = -2 * X\n    let fake_value_b = (-fake_value_a * fake_index_a) / fake_index_b;\n\n    bad_flags[fake_index_a] = fake_value_a;\n    bad_flags[fake_index_b] = fake_value_b;\n    let _ = get_validity_flags_inner(0, bad_flags);\n}\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/_comparison_tools/bounds_checker.nr"},"83":{"source":"/**\n * @file helper methods that evaluate comparison operations on Field elements that are known to be of a fixed size (e.g. <2^16)\n **/\nunconstrained pub fn get_lt_predicate_f(x: Field, y: Field) -> bool {\n    let a = x as u32;\n    let b = y as u32;\n    let r = a < b;\n    r\n}\n\nunconstrained pub fn get_lte_predicate_large(x: Field, y: Field) -> bool {\n    let r = x.lt(y) | (x == y);\n    r\n}\n\npub fn lte_field_240_bit(x: Field, y: Field) -> bool {\n    let predicate = get_lte_predicate_large(x, y);\n    let delta = y as Field - x as Field;\n\n    // (x - y) * predicate \n    // if true, y - x >= 0\n    // if false, x <= y is wrong therefore x > y => x - y > 0 => x - y + 1 >= 0\n    // (y - x) * p + (1 - p) * (x - y + 1)\n    // (y - x) * p + x - y + 1 + p * (y - x)\n    let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta + 1;\n    lt_parameter.assert_max_bit_size(240);\n\n    predicate\n}\n\npub fn assert_lte_240_bit(x: Field, y: Field) {\n    let delta = y as Field - x as Field;\n\n    // (x - y) * predicate \n    // if true, y - x >= 0\n    // if false, x <= y is wrong therefore x > y => x - y > 0 => x - y + 1 >= 0\n    // (y - x) * p + (1 - p) * (x - y + 1)\n    // (y - x) * p + x - y + 1 + p * (y - x)\n    delta.assert_max_bit_size(240);\n}\n\npub fn lt_field_16_bit(x: Field, y: Field) -> bool {\n    let predicate = get_lt_predicate_f(x, y);\n    let delta = y as Field - x as Field;\n    let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n    lt_parameter.assert_max_bit_size(16);\n\n    predicate\n}\n\npub fn lt_field_8_bit(x: Field, y: Field) -> bool {\n    let predicate = get_lt_predicate_f(x, y);\n    let delta = y as Field - x as Field;\n    let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n    lt_parameter.assert_max_bit_size(8);\n\n    predicate\n}\n\npub fn assert_gt_240_bit(lhs: Field, rhs: Field) {\n    // lhs > rhs\n    // -> lhs - rhs > 0\n    // -> lhs - rhs - 1 >= 0\n    let diff = lhs - rhs - 1;\n    diff.assert_max_bit_size(240);\n}\n\npub fn assert_lt_240_bit(lhs: Field, rhs: Field) {\n    // lhs < rhs\n    // -> rhs - lhs > 0\n    // -> rhs - lhs - 1 >= 0\n    let diff = rhs - lhs - 1;\n    diff.assert_max_bit_size(240);\n}\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/_comparison_tools/lt.nr"},"87":{"source":"use crate::_string_tools::slice_packed_field::slice_fields;\nuse crate::_string_tools::slice_field::slice_200_bits_from_field;\n\n/**\n * @brief utility struct that computes a 200-bit Poseidon hash of some bytes,\n *        when the bytes are represented as packed 31 byte Field elements\n * @note we wrap `get_keyhash` in a struct so that the KeyFields parameter can be defined ahead of time\n **/\nstruct FieldHasher<let KeyFields: u32>\n{}\n\nimpl<let KeyFields: u32> FieldHasher<KeyFields> {\n\n    fn get_keyhash<let NumPackedFields: u32>(\n        _: Self,\n        packed_fields: [Field; NumPackedFields],\n        body_index: Field,\n        key_length: Field\n    ) -> Field {\n        let key_fields: [Field; KeyFields] = slice_fields(packed_fields, body_index, key_length);\n        let hashed = dep::std::hash::poseidon2::Poseidon2::hash(key_fields, KeyFields as u32);\n        slice_200_bits_from_field(hashed)\n    }\n}\n\n/**\n * @brief utility struct that computes a 200-bit Poseidon hash of some bytes,\n *        when the bytes are represented as a substring in a byte array\n * @note we wrap `get_keyhash` in a struct so that the KeyFields parameter can be defined ahead of time\n * @note produces identical hash outputs when compared w. FieldHasher\n **/\nstruct ByteHasher<let KeyFields: u32>\n{}\n\nimpl<let KeyFields: u32> ByteHasher<KeyFields> {\n\n    fn get_keyhash_var<let N: u32>(\n        _: Self,\n        body_text: [u8; N],\n        body_index: u32,\n        key_length: u32\n    ) -> Field {\n        assert(key_length < KeyFields * 31, \"key too large\");\n\n        let mut key_fields: [Field; KeyFields] = [0; KeyFields];\n\n        let mut key_idx: u32 = 0;\n        let mut limb = 0;\n\n        for j in 0..KeyFields {\n            limb = 0;\n\n            for _ in 0..31 {\n                let valid = (key_idx < key_length) as Field;\n                limb *= 0x100;\n                let byte_index = (body_index as Field + key_idx as Field) * valid;\n                let byte = body_text[byte_index] as Field;\n                limb += byte * valid;\n                key_idx += 1;\n            }\n            key_fields[j] = limb;\n        }\n\n        let hashed_full = dep::std::hash::poseidon2::Poseidon2::hash(key_fields, KeyFields as u32);\n\n        let mut r = slice_200_bits_from_field(hashed_full);\n        r\n    }\n}\n\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/keyhash.nr"},"88":{"source":"/**\n * @brief contains data we need to keep track when, in `create_json_entries`, we enter or exist from an object or array\n **/\nstruct JSONContextStackEntry {\n    num_entries: Field,\n    context: Field,\n    current_key_index_and_length: Field,\n    json_index: Field,\n    current_identity: Field\n}\nimpl JSONContextStackEntry {\n    unconstrained fn __from_field(f: Field) -> Self {\n        let bytes: [u8; 11] = f.to_be_bytes();\n        let context = bytes[0] as Field;\n        let num_entries = bytes[1] as Field * 0x100 + bytes[2] as Field;\n        let current_key_length = bytes[3] as Field * 0x100 + bytes[4] as Field;\n        let current_key_index = bytes[5] as Field * 0x100 + bytes[6] as Field;\n        let json_index = bytes[7] as Field * 0x100 + bytes[8] as Field;\n        let current_identity = bytes[9] as Field * 0x100 + bytes[10] as Field;\n        let current_key_index_and_length = current_key_index + current_key_length * 0x10000;\n        JSONContextStackEntry { num_entries, context, current_key_index_and_length, json_index, current_identity }\n    }\n\n    /**\n     * @brief we pack multiple values into a Field element in order to reduce the number of array read/write queries we need\n     *        (each query will be 3.5 gates as we read and write from/to unknown locations)\n     * @note method cost = 9.5 gates\n     **/\n    fn from_field(f: Field) -> Self {\n        let result = JSONContextStackEntry::__from_field(f);\n\n        result.context.assert_max_bit_size(8); // 1.25\n        result.num_entries.assert_max_bit_size(16); // 1.5\n        result.current_key_index_and_length.assert_max_bit_size(32); // 1.75\n        result.json_index.assert_max_bit_size(16); // 1.5\n        result.current_identity.assert_max_bit_size(16); // 1.5\n        assert(result.to_field() == f); // 2\n        result\n    }\n\n    /**\n     * @brief we pack multiple values into a Field element in order to reduce the number of array read/write queries we need\n     *        (each query will be 3.5 gates as we read and write from/to unknown locations)\n     * @note method cost = 2 gates\n     **/\n    fn to_field(self) -> Field {\n        self.current_identity\n            + self.json_index * 0x10000\n            + self.current_key_index_and_length * 0x100000000\n            + self.num_entries * 0x10000000000000000\n            + self.context * 0x100000000000000000000\n    }\n}\n\n/**\n * @brief describes a single array, object or value within our JSON\n **/\nstruct JSONEntry {\n    entry_type: Field, // is this an OBJECT_TOKEN, ARRAY_TOKEN, STRING_TOKEN, NUMERIC_TOKEN or LITERAL_TOKEN?\n    id: Field, // if this is an object or array, describes the unique identifier assigned to this item\n    parent_index: Field, // if parent is an object or array, describes the unique identifier assigned to our parent\n    array_pointer: Field, // if parent is an array, where in the array are we?\n    child_pointer: Field, // if this is an object or array, points to the location in `json_entries_packed` of this item's first child\n    num_children: Field, // if this is an object or array, how many child elements do we contain?\n    json_pointer: Field, // points to the json that describes the first byte of this entry\n    json_length: Field, // how many bytes in the json describes this item? (only for strings, numbers or literals)\n}\nimpl JSONEntry {\n    fn new() -> Self {\n        JSONEntry {\n            array_pointer: 0,\n            entry_type: 0,\n            child_pointer: 0,\n            num_children: 0,\n            json_pointer: 0,\n            json_length: 0,\n            parent_index: 0,\n            id: 0\n        }\n    }\n\n    unconstrained fn __extract_parent_index_from_field(f: Field) -> (Field, Field, Field) {\n        let entry = JSONEntry::from_field(f);\n        let low = entry.id;\n        let mid = entry.parent_index;\n        let hi = (f - low - mid * 0x10000) / 0x100000000;\n        (low, mid, hi)\n    }\n\n    fn add_child_pointer_into_field(f: Field, child_pointer: Field) -> Field {\n        f + child_pointer * 0x100000000000000000000\n    }\n    unconstrained fn __extract_entry_type_and_id_from_field(f: Field) -> (Field, Field, Field) {\n        let entry = JSONEntry::from_field(f);\n        let id = entry.id;\n        let entry_type = entry.entry_type;\n        let mid = (f - id - entry_type * 0x100000000000000000000000000000000000000) / 0x10000;\n        (id, mid, entry_type)\n    }\n    unconstrained fn __extract_entry_type_id_and_parent_index_from_field(f: Field) -> (Field, Field, Field, Field) {\n        let entry = JSONEntry::from_field(f);\n        let id = entry.id;\n        let entry_type = entry.entry_type;\n        let parent_index = entry.parent_index;\n        let mid = (f - id - parent_index * 0x10000 - entry_type * 0x100000000000000000000000000000000000000)\n            / 0x100000000;\n        (id, parent_index, mid, entry_type)\n    }\n\n    // 11.75 gates\n    fn extract_entry_type_id_and_parent_index_from_field(f: Field) -> (Field, Field, Field) {\n        let (id, parent_index, mid, entry_type) = JSONEntry::__extract_entry_type_id_and_parent_index_from_field(f);\n        id.assert_max_bit_size(8); // 1.25\n        parent_index.assert_max_bit_size(16); // 1.5\n        entry_type.assert_max_bit_size(16); // 1.5\n        mid.assert_max_bit_size(136); // 5.5\n\n        assert(\n            id\n            + parent_index * 0x10000\n            + mid * 0x100000000\n            + entry_type * 0x100000000000000000000000000000000000000\n            == f\n        );\n\n        (id, parent_index, entry_type)\n    }\n    fn extract_entry_type_and_id_from_field(f: Field) -> (Field, Field) {\n        let (id, mid, entry_type) = JSONEntry::__extract_entry_type_and_id_from_field(f);\n        id.assert_max_bit_size(8); // 1.25\n        entry_type.assert_max_bit_size(16); // 1.5\n        mid.assert_max_bit_size(136); // 5.5\n\n        assert(id + mid * 0x10000 + entry_type * 0x100000000000000000000000000000000000000 == f);\n        (id, entry_type)\n    }\n    fn extract_parent_index_from_field(f: Field) -> Field {\n        let (low, parent_index, hi) = JSONEntry::__extract_parent_index_from_field(f);\n\n        low.assert_max_bit_size(16); // 1.75\n        hi.assert_max_bit_size(128); // 5.5\n        parent_index.assert_max_bit_size(16); // 1.75\n        assert(low + parent_index * 0x10000 + hi * 0x100000000 == f); // 1\n        // 10 gates?\n        parent_index\n    }\n    unconstrained fn __from_field(f: Field) -> Self {\n        let bytes: [u8; 20] = f.to_be_bytes(); // 10.5 gates\n\n        let entry_type = bytes[0] as Field;\n\n        let json_length = bytes[2] as Field * 0x100 + bytes[3] as Field;\n        let json_pointer = bytes[4] as Field * 0x100 + bytes[5] as Field;\n        let num_children = bytes[6] as Field * 0x100 + bytes[7] as Field;\n        let child_pointer = bytes[8] as Field * 0x100 + bytes[9] as Field;\n        let array_pointer = bytes[10] as Field * 0x100 + bytes[11] as Field;\n        let parent_index = bytes[16] as Field * 0x100 + bytes[17] as Field; // 6 gates\n        let id = bytes[18] as Field * 0x100 + bytes[19] as Field; // 6 gates\n\n        JSONEntry { array_pointer, child_pointer, num_children, json_pointer, json_length, entry_type, parent_index, id }\n    }\n\n    fn to_field(self) -> Field {\n        self.id +\n        self.parent_index *    0x10000\n        + self.array_pointer * 0x10000000000000000                          // 2 bytes\n        + self.child_pointer * 0x100000000000000000000                      // 2 bytes\n        + self.num_children *  0x1000000000000000000000000                  // 2 bytes\n        + self.json_pointer *  0x10000000000000000000000000000              // 2 bytes\n        + self.json_length *   0x100000000000000000000000000000000          // 2 bytes\n        + self.entry_type *    0x100000000000000000000000000000000000000 // 1 byte\n        // 4 gates. oof\n    }\n    fn from_field(f: Field) -> Self {\n        let result = JSONEntry::__from_field(f);\n        result.entry_type.assert_max_bit_size(8);\n        result.json_length.assert_max_bit_size(16);\n        result.json_pointer.assert_max_bit_size(16);\n        result.num_children.assert_max_bit_size(16);\n        result.child_pointer.assert_max_bit_size(16);\n        result.array_pointer.assert_max_bit_size(16);\n        result.parent_index.assert_max_bit_size(16);\n        result.id.assert_max_bit_size(16);\n        assert(result.to_field() == f);\n        result\n    }\n}\n\nimpl std::convert::From<JSONEntryPacked> for JSONEntry {\n    fn from(JSONEntryPacked{ value: f }: JSONEntryPacked) -> Self {\n        let result = JSONEntry::__from_field(f);\n        result.entry_type.assert_max_bit_size(8);\n        result.json_length.assert_max_bit_size(16);\n        result.json_pointer.assert_max_bit_size(16);\n        result.num_children.assert_max_bit_size(16);\n        result.child_pointer.assert_max_bit_size(16);\n        result.array_pointer.assert_max_bit_size(16);\n        result.parent_index.assert_max_bit_size(16);\n        result.id.assert_max_bit_size(16);\n        assert(result.to_field() == f);\n        result\n    }\n}\n\nimpl std::cmp::Eq for JSONEntry {\n    // N.B. used for testing\n    fn eq(self, other: Self) -> bool {\n        let array_ptr = (self.array_pointer == other.array_pointer);\n        let entry = self.entry_type == other.entry_type;\n        let child = (self.child_pointer == other.child_pointer);\n        let num_children = (self.num_children == other.num_children);\n        let json_pointer = (self.json_pointer == other.json_pointer);\n        let json_length = (self.json_length == other.json_length);\n        array_ptr | entry | child | num_children | json_pointer | json_length\n    }\n}\n\n/**\n * @brief describes a JSONEntry object's data, but packed into a single field element.\n * @description We do this to minimize the number of array lookups we perform\n **/\nstruct JSONEntryPacked {\n    value: Field\n}\n\nimpl std::cmp::Eq for JSONEntryPacked {\n    fn eq(self, other: Self) -> bool {\n        self.value == other.value\n    }\n}\n\nimpl std::default::Default for JSONEntryPacked {\n    fn default() -> Self {\n        JSONEntryPacked { value: 0 }\n    }\n}\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/json_entry.nr"},"89":{"source":"use crate::_comparison_tools::bounds_checker;\nuse crate::_comparison_tools::bounds_checker::get_validity_flags;\nuse crate::enums::Layer::{OBJECT_LAYER, ARRAY_LAYER, SINGLE_VALUE_LAYER};\nuse crate::enums::Token::{\n    BEGIN_OBJECT_TOKEN, END_OBJECT_TOKEN, BEGIN_ARRAY_TOKEN, END_ARRAY_TOKEN, KEY_SEPARATOR_TOKEN,\n    VALUE_SEPARATOR_TOKEN, STRING_TOKEN, NUMERIC_TOKEN, LITERAL_TOKEN, KEY_TOKEN, NUM_TOKENS\n};\nuse crate::enums::ScanMode::{GRAMMAR_SCAN, STRING_SCAN, NUMERIC_SCAN, LITERAL_SCAN};\nuse crate::get_literal::JSONLiteral;\nuse crate::json_entry::{JSONContextStackEntry, JSONEntry, JSONEntryPacked};\nuse crate::json_tables::{\n    TOKEN_VALIDATION_TABLE, PROCESS_RAW_TRANSCRIPT_TABLE, JSON_CAPTURE_TABLE, TOKEN_FLAGS_TABLE,\n    TOKEN_IS_ARRAY_OBJECT_OR_VALUE\n};\nuse crate::token_flags::TokenFlags;\nuse crate::transcript_entry::{ValidationFlags, TranscriptEntry, RawTranscriptEntry, ScanData, PostProcessScanData};\n\n/**\n * @brief records a value in a json blob\n **/\nstruct JSONValue<let MaxLength: u32> {\n    value: BoundedVec<u8, MaxLength>, // raw bytes that constitute the json value entry\n    value_type: Field // either STRING_TOKEN, NUMERIC_TOKEN or LITERAL_TOKEN\n}\n\nimpl<let MaxLength: u32> JSONValue<MaxLength> {\n    fn is_string(self) -> bool {\n        self.value_type == STRING_TOKEN\n    }\n    fn is_number(self) -> bool {\n        self.value_type == NUMERIC_TOKEN\n    }\n    fn is_literal(self) -> bool {\n        self.value_type == LITERAL_TOKEN\n    }\n}\n\n/**\n * @brief It's a JSON struct! Contains the raw and processed information required to extract data from a json blob\n * @description The \"root\" of the JSON refers to the parent object or array (or a value if the json is just a single value e.g. text = \"\\\"foo\\\": \\\"bar\\\"\")\n * @note text that describes just a single JSON value is not yet fully supported. Only use this library for processing objects or arrays for now\n **/\nstruct JSON<let NumBytes: u32, let NumPackedFields: u32, let MaxNumTokens: u32, let MaxNumValues: u32, let MaxKeyFields: u32> {\n    json: [u8; NumBytes], // the raw json bytes\n    json_packed: [Field; NumPackedFields], // raw bytes, but packed into 31-byte Field elements\n    raw_transcript: [Field; MaxNumTokens], // transcript of json tokens after basic processing\n    transcript: [Field; MaxNumTokens], // complete transcript of json tokens\n    transcript_length: u32, // how big is the transcript?\n    key_data: [Field; MaxNumValues], // description of each key, packed into a Field element\n    key_hashes: [Field; MaxNumValues], // a sorted list of key hashes\n    unsorted_json_entries_packed: [JSONEntryPacked; MaxNumValues], // a list of all the processed json values (objects, arrays, numerics, literals, strings)\n    json_entries_packed: [JSONEntryPacked; MaxNumValues], // a sorted list of all the processed json values (objects, arrays, numerics, literals, strings)\n    layer_type_of_root: Field, // is the root an OBJECT_LAYER, ARRAY_LAYER or SINGLE_VALUE_LAYER?\n    root_id: Field, // the unique identifier of the root (if an object or array)\n    root_index_in_transcript: Field // location in json_entries_packed of the root\n}\n\n/**\n * @brief are two JSON objects equal?\n * @note VERY EXPENSIVE! Currently only used in tests\n **/\nimpl<let NumBytes: u32, let NumPackedFields: u32, let MaxNumTokens: u32, let MaxNumValues: u32, let MaxKeyFields: u32> std::cmp::Eq for JSON<NumBytes, NumPackedFields, MaxNumTokens, MaxNumValues, MaxKeyFields> {\n    fn eq(self, other: Self) -> bool {\n        (self.json == other.json)\n            & (self.raw_transcript == other.raw_transcript)\n            & (self.transcript == other.transcript)\n            & (self.transcript_length == other.transcript_length)\n            & (self.key_data == other.key_data)\n            & (self.key_hashes == other.key_hashes)\n            & (self.layer_type_of_root == other.layer_type_of_root)\n            & (self.root_id == other.root_id)\n            & (self.root_index_in_transcript\n                                            == other.root_index_in_transcript)\n            & (self.json_entries_packed == other.json_entries_packed)\n            & (self.json_packed == other.json_packed)\n    }\n}\n\n// TODO: casting entry_ptr to u16 is kind of expensive when generating witnesses, can we fix?\nunconstrained fn __check_entry_ptr_bounds(entry_ptr: Field, max: u32) {\n    // n.b. even though this assert is in an unconstrained function, an out of bounds error will be triggered when writing into self.key_data[entry_ptr]\n    assert(entry_ptr as u32 < max - 1, \"create_json_entries: MaxNumValues limit exceeded!\");\n}\n\nimpl<let NumBytes: u32, let NumPackedFields: u32, let MaxNumTokens: u32, let MaxNumValues: u32, let MaxKeyFields: u32> JSON<NumBytes, NumPackedFields, MaxNumTokens, MaxNumValues, MaxKeyFields> {\n\n    /**\n     * @brief pack the json bytes into Field elements, where each Field element represents 31 bytes\n     * @description we do this because we need to extract substrings from the json bytes, where the position and length of the substring are witness values.\n     *              Doing this on packed Field elements using `slice_string` is cheaper than the direct method of iterating byte-by-byte.\n     *              Also, by extracting data at unknown locations exclusively from the packed json, we do not need to represent the raw bytes `self.json` as a ROM table\n     *              (which would have an expensive initialization cost of 2*NumBytes gates)\n     **/\n    fn compute_json_packed(&mut self) {\n        let NumWholeLimbs = NumBytes / 31;\n        for i in 0..NumWholeLimbs {\n            let mut limb: Field = 0;\n            for j in 0..31 {\n                limb *= 0x100;\n                limb += self.json[i * 31 + j] as Field;\n            }\n            std::as_witness(limb);\n            self.json_packed[i] = limb;\n        }\n        let NumRemainingBytes = NumBytes - NumWholeLimbs * 31;\n        let mut limb: Field = 0;\n        for j in 0..NumRemainingBytes {\n            limb *= 0x100;\n            limb += self.json[NumWholeLimbs * 31 + j] as Field;\n        }\n        for _ in NumRemainingBytes..31 {\n            limb *= 0x100;\n        }\n        std::as_witness(limb);\n        self.json_packed[NumWholeLimbs + (NumRemainingBytes == 0) as u32] = limb;\n    }\n\n    // TODO: when impl is more mature, merge this into create_json_entries\n    fn keyswap(&mut self) {\n        // TODO: this won't work if 1st entry is a key!\n        let mut current= TranscriptEntry::from_field(self.transcript[0]);\n        let mut next: TranscriptEntry = TranscriptEntry::new();\n\n        for i in 0..MaxNumTokens - 1 {\n            next = TranscriptEntry::from_field(self.transcript[i + 1]);\n\n            let next_is_key = (next.token == KEY_SEPARATOR_TOKEN) as Field;\n\n            let valid_token = TOKEN_IS_ARRAY_OBJECT_OR_VALUE[current.token];\n            assert(\n                (valid_token * next_is_key) + (1 - next_is_key) == 1, \"Cannot find key/value straddling KEY_DELIMITER_TOKEN\"\n            );\n\n            let old_transcript = self.transcript[i];\n            let new_transcript = TranscriptEntry::to_field(TranscriptEntry { token: KEY_TOKEN, index: current.index, length: current.length });\n            let updated_transcript = (new_transcript - old_transcript) * next_is_key + old_transcript;\n            self.transcript[i] = updated_transcript;\n\n            current = next;\n        }\n    }\n\n    /**\n     * @brief Once we have processed the json into a transcript of tokens, validate these tokens represent valid JSON!\n     * @description To avoid a lot of painful if/else statements, we construct a state transition function out of the lookup table TOKEN_VALIDATION_TABLE\n     *              The inputs to TOKEN_VALIDATION_TABLE are:\n     *                  1. The current token (at some position `i` i.e. `self.transcript[i])\n     *                  2. The previous token (`self.transcript[i-1]`)\n     *                  3. The context of the previous token (i.e. is it within an object or an array?)\n     *              The lookup table maps these inputs into the following outputs:\n     *                  1. Are we moving into a new context? i.e. is current token a `{` or `[` character?\n     *                  2. If so, what context are we moving into? (`OBJECT_LAYER` or `ARRAY_LAYER`)\n     *                  3. Are we exiting from the current context? i.e. is the current token a `}` or `]` character?\n     *                  4. Have we entered an error state? e.g. a `[` token followed by a `,` token would be invalid JSON\n     * \n     * @note To shave some gates, we represent the error state in a nonstandard way.\n     *       If we have entered an error state, the value of `push_layer` will be 0x1000000\n     *       This will then update `depth` to a value that exceeds the size of `parent_layer_stack` (32),\n     *       which will trigger an out-of-bounds array access, which creates unsatisfiable constraints\n     **/\n    fn validate_tokens(self, tokens: [Field; MaxNumTokens]) {\n        let mut current_layer = self.layer_type_of_root;\n        let mut parent_layer_stack: [Field; 32] = [0; 32];\n        let mut depth = 0;\n        let mut previous_token = tokens[0];\n        let NN = NUM_TOKENS * NUM_TOKENS;\n\n        let is_object = previous_token == BEGIN_OBJECT_TOKEN;\n        let is_array = previous_token == BEGIN_ARRAY_TOKEN;\n\n        depth = is_object as Field + is_array as Field;\n\n        // todo is this correct?\n        parent_layer_stack[0] = is_object as Field * OBJECT_LAYER + is_array as Field * ARRAY_LAYER;\n        assert(\n            TOKEN_IS_ARRAY_OBJECT_OR_VALUE[previous_token] == 1, \"first json token does not describe an object, array or key\"\n        );\n\n        // 17 gates per iteration?\n        for i in 1..MaxNumTokens {\n            // 0 gates\n            let current_token = tokens[i];\n\n            // 1 gate\n            let index = current_layer * (NN as Field) + previous_token * (NUM_TOKENS as Field) + current_token;\n\n            // 5 gates\n            let  ValidationFlags{push_layer, push_layer_type_of_root, pop_layer} = ValidationFlags::from_field(TOKEN_VALIDATION_TABLE[index]);\n\n            // 3.5 gates\n            parent_layer_stack[depth] = current_layer;\n\n            // 1 gate\n            // we encode an error flag into `push_layer` by making its value such that `depth` will exceed the size of `parent_layer_stack`\n            depth = depth + push_layer - pop_layer;\n            std::as_witness(depth);\n\n            // 6.5 gates\n            let parent_layer = parent_layer_stack[depth];\n            let mut updated_layer = (1 - pop_layer - push_layer);\n            std::as_witness(updated_layer);\n            updated_layer = updated_layer * current_layer + push_layer_type_of_root;\n            std::as_witness(updated_layer);\n            updated_layer = updated_layer + parent_layer * pop_layer;\n            std::as_witness(updated_layer);\n            current_layer = updated_layer;\n\n            previous_token = current_token;\n        }\n        assert(depth == 0, \"validate_tokens: unclosed objects or arrays\");\n    }\n\n    /**\n     * @brief given a processed transcript of json tokens, compute a list of json entries that describes the values within the JSON blob\n     * @details a 'value' here is either an Object, Array, String, Numeric or Literal.\n     *          e.g. \"[ 1, 2, 3 ]\" contains 4 values (3 Numeric types and the Array that contains them)\n     *\n     *          To avoid branches and if statements, we construct a state transition function out of the lookup table TOKEN_FLAGS_TABLE\n     *          This table takes as an input the following:\n     *              1. The token value of an element in the transcript\n     *              2. The layer type the previous token is located in (i.e. are we in an array or an object?)\n     *          The table outputs the following data:\n     *              1. Should we create a new json entry? (i.e. is the token a STRING_TOKEN, LITERAL_TOKEN, NUMERIC_TOKEN, END_ARRAY_TOKEN, END_OBJECT_TOKEN)\n     *              2. Is the token `}` or `]`?\n     *              3. Is the token `{` or `[`?\n     *              4. Given the current layer type and the token being queried, what should the new layer type be?\n     *              5. Is the token `KEY_TOKEN`?\n     *              6. Is the token a `STRING_TOKEN`, `NUMERIC_TOKEN` OR `VALUE_TOKEN`?\n     *              7. Is the token one that we should skip over? `,` or `:`\n     **/\n    fn create_json_entries(&mut self) {\n        let mut entry_ptr = 0;\n        let mut depth: Field = 1;\n        let mut num_entries_at_current_depth: Field = 0;\n        let mut next_identity_value: Field = 1;\n        let mut current_identity_value: Field = 0;\n        let mut context = OBJECT_LAYER;\n\n        let mut current_key_index_and_length: Field = 0;\n\n        let mut parent_context_stack: [Field; 32] = [0; 32];\n        let mut tokens: [Field; MaxNumTokens] = [0; MaxNumTokens];\n        //  maybe 71.75 gates per iteration\n        for i in 0..MaxNumTokens {\n            __check_entry_ptr_bounds(entry_ptr, MaxNumValues);\n            // 5.25 gates\n            let TranscriptEntry{token, index, length} = TranscriptEntry::from_field(self.transcript[i]);\n\n            tokens[i] = token;\n            // 13 gates\n            let TokenFlags{\n                create_json_entry,\n                is_end_of_object_or_array,\n                is_start_of_object_or_array,\n                new_context,\n                is_key_token: update_key,\n                is_value_token,\n                preserve_num_entries\n            } = TokenFlags::from_field(TOKEN_FLAGS_TABLE[token + context * (NUM_TOKENS as Field)]);\n\n            // 2 gates\n            let diff = (index + length * 0x10000) - current_key_index_and_length;\n            std::as_witness(diff);\n            current_key_index_and_length = diff * update_key + current_key_index_and_length;\n            std::as_witness(current_key_index_and_length);\n\n            // 2 gates\n            let new_context_stack_entry = JSONContextStackEntry::to_field(\n                JSONContextStackEntry {\n                num_entries: num_entries_at_current_depth,\n                context,\n                current_key_index_and_length,\n                json_index: index,\n                current_identity: current_identity_value\n            }\n            );\n            // subtotal 22.25\n\n            // 1 gate\n            let depth_index: Field = (depth - 1);\n            // 3.5 gates\n            let previous_stack_entry_packed = parent_context_stack[depth_index];\n\n            // 9.5 gates\n            let previous_stack_entry = JSONContextStackEntry::from_field(previous_stack_entry_packed);\n\n            let object_or_array_entry: JSONEntry = JSONEntry {\n                array_pointer: previous_stack_entry.num_entries,\n                entry_type: token,\n                child_pointer: 0,\n                num_children: num_entries_at_current_depth,\n                json_pointer: previous_stack_entry.json_index,\n                json_length: length,\n                parent_index: previous_stack_entry.current_identity,\n                id: current_identity_value\n            };\n            // 0\n            let value_entry: JSONEntry = JSONEntry {\n                array_pointer: num_entries_at_current_depth,\n                entry_type: token,\n                child_pointer: 0,\n                num_children: 0,\n                json_pointer: index,\n                json_length: length,\n                parent_index: current_identity_value,\n                id: 0\n            };\n\n            // 3 gates\n            let object_or_array_entry_packed = object_or_array_entry.to_field();\n            // 2 gates\n            let value_entry_packed = value_entry.to_field();\n\n            // 2 gates\n            let diff = object_or_array_entry_packed - value_entry_packed;\n            std::as_witness(diff);\n            let new_entry = diff * is_end_of_object_or_array + value_entry_packed;\n            std::as_witness(new_entry);\n\n            // 3 gates\n            // subtotal 24 + 22.25 = 46.25\n            let old = current_identity_value;\n            current_identity_value = (next_identity_value * is_start_of_object_or_array);\n            std::as_witness(current_identity_value);\n            current_identity_value = current_identity_value + (previous_stack_entry.current_identity * is_end_of_object_or_array);\n            std::as_witness(current_identity_value);\n            current_identity_value = current_identity_value + old * preserve_num_entries;\n            std::as_witness(current_identity_value);\n\n            // 2 gates\n            num_entries_at_current_depth = num_entries_at_current_depth * preserve_num_entries + is_value_token;\n            std::as_witness(num_entries_at_current_depth);\n            num_entries_at_current_depth = num_entries_at_current_depth +\n            (previous_stack_entry.num_entries + 1) * is_end_of_object_or_array;\n            std::as_witness(num_entries_at_current_depth);\n\n            // 1 gate\n            // if `is_end_of_object_or_array == 1`, `new_context = 0` so we can do something cheaper than a conditional select:\n            context = previous_stack_entry.context * is_end_of_object_or_array + new_context;\n            std::as_witness(context);\n            // 3 gates\n            let common_term = current_identity_value + context * (num_entries_at_current_depth - 1) * 0x1000000000000;\n            std::as_witness(common_term);\n            let mut new_key_data = current_key_index_and_length * is_value_token * 0x10000 + common_term;\n            std::as_witness(new_key_data);\n            new_key_data = new_key_data + previous_stack_entry.current_key_index_and_length * is_end_of_object_or_array * 0x10000;\n            std::as_witness(new_key_data);\n\n            // 3.5 gates\n            self.key_data[entry_ptr] = new_key_data * create_json_entry;\n\n            // 3.5 gates\n            parent_context_stack[depth] = new_context_stack_entry;\n\n            // 4.5 gates\n            self.json_entries_packed[entry_ptr] = JSONEntryPacked{ value: new_entry * create_json_entry };\n\n            // 1 gate\n            next_identity_value = next_identity_value + is_start_of_object_or_array;\n            std::as_witness(next_identity_value);\n\n            // 1 gate\n            depth = depth + is_start_of_object_or_array - is_end_of_object_or_array;\n\n            // 1 gate\n            // 2105 + 46.25\n            // subtotal 66.75?\n            entry_ptr += create_json_entry;\n            std::as_witness(entry_ptr);\n        }\n        self.validate_tokens(tokens);\n    }\n\n    /**\n     * @brief Perform the 1st transcript processing step as an unconstrained function\n     *        We will validate this transcript is correct via a constrained function\n     *        This is a bit cheaper than doing everything in a constrained function,\n     *        because we can use ROM arrays instead of RAM arrays\n     *        (i.e. we're only reading from our arrays, we don't write to them in constrained functions)\n     **/\n    unconstrained fn __build_transcript(self) -> [Field; MaxNumTokens] {\n        let mut raw_transcript: [Field; MaxNumTokens] = [0; MaxNumTokens];\n        let mut transcript_ptr: u32 = 0;\n        let mut scan_mode = GRAMMAR_SCAN as Field;\n        let mut length: Field = 0;\n        let mut previous_was_potential_escape_sequence = 0;\n        for i in 0..NumBytes {\n            // while this assert is in an unconstrained function, the out of bounds accesss `raw_transcript[transcript_ptr]` in build_transcript also generates failing constraints\n            assert(transcript_ptr < MaxNumTokens, \"build_transcript: MaxNumTokens limit exceeded!\");\n            let ascii = self.json[i];\n\n            let encoded_ascii = previous_was_potential_escape_sequence * 1024 + scan_mode * 256 + ascii as Field;\n            let ScanData{ scan_token, push_transcript, increase_length, is_potential_escape_sequence } = ScanData::from_field(JSON_CAPTURE_TABLE[encoded_ascii]);\n            let mut push_transcript = push_transcript;\n            let mut scan_token = scan_token;\n            let mut increase_length = increase_length;\n\n            let new_entry = RawTranscriptEntry::to_field(RawTranscriptEntry { encoded_ascii, index: i as Field - length, length });\n\n            raw_transcript[transcript_ptr] = new_entry;\n            length = length * (1 - push_transcript) + increase_length;\n            transcript_ptr += (push_transcript as bool) as u32;\n\n            previous_was_potential_escape_sequence = is_potential_escape_sequence;\n\n            scan_mode = scan_token;\n        }\n\n        // ensure an error isn't hiding in the last scanned token\n        scan_mode.assert_max_bit_size(2);\n        raw_transcript\n    }\n\n    /**\n     * @brief Construct a token transcript by iterating through self.json and using a lookup table `JSON_CAPTURE_TABLE` to define a state transition function\n     * @details JSON_CAPTURE_TABLE takes the following as input:\n     *          1. the ascii byte at the current location in the json\n     *          2. the current scan mode (are we searching for grammar, strings, numbers or literals?)\n     *          3. could this byte potentially be an escape sequence? (i.e. the previous byte was a backslash character \"\\\" and scan_mode == STRING_SCAN)\n     *          The table outputs the following flags:\n     *          1. what token have we scanned? (listed in enums::Token)\n     *          2. should we push this token to the transcript (no push if token == NO_TOKEN)\n     *          3. should we increase the length of the current entry we're evaluating?\n     *              (i.e. if token == STRING_TOKEN and scan_mode == STRING_SCAN, then increase the length because we're in the process of scanning a string)\n     *          4. is this scanned ascii character a potential escape sequence? i.e. scan_mode == STRING_SCAN and ascii = \"\\\"\n     *          5. have we entered an error state? (i.e. invalid grammar e.g. \":\" is followed by \"}\")\n     *\n     * NOTE: we represent error states in a nonstandard way to reduce gate count. Instead of handling an error flag,\n     *       an error state will increase the value of `scan_token` by 0x100000000. This will cause the next access into `JSON_CAPTURE_TABLE` to trigger an out of bounds error\n     *\n     * NOTE: the scanned transcript will be missing some edge cases that are caught via `swap_keys` and `capture_missing_tokens`:\n     *          1. If the scan mode is NUMERIC_SCAN or LITERAL_SCAN and the next character is a \",\" or \"}\" or \"]\",\n     *             we will push a NUMERIC_TOKEN or LITERAL_TOKEN into the transcript but we will MISS the VALUE_SEPARATOR_TOKEN, END_OBJECT_TOKEN or END_ARRAY_TOKEN\n     *             (accomodating this edge case requires conditionally pushing two transcript entries per iteration, so we do this in a separate step where we iterate over the transcript and not the json bytes)\n     *          2. We can't yet tell if an entry is a KEY_TOKEN or a STRING_TOKEN. All keys are represented as STRING_TOKEN. This gets fixed after `swap_keys` is evaluated\n     **/\n    fn build_transcript(self) -> Self {\n        let mut raw_transcript: [Field; MaxNumTokens] = [0; MaxNumTokens];\n        let mut transcript_ptr: Field = 0;\n        let mut scan_mode = GRAMMAR_SCAN;\n        let mut length: Field = 0;\n\n        let raw_transcript = self.__build_transcript();\n\n        // 14 gates per iteration, plus fixed cost for initing 2,048 size lookup table (4,096 gates)\n        let mut previous_was_potential_escape_sequence = 0;\n        for i in 0..NumBytes {\n            let ascii = self.json[i];\n\n            // 1 gate\n            let encoded_ascii = previous_was_potential_escape_sequence * 1024 + scan_mode * 256 + ascii as Field;\n            std::as_witness(encoded_ascii);\n\n            // 2 gates\n            let capture_flags = JSON_CAPTURE_TABLE[encoded_ascii];\n            // 5 gates\n            let ScanData{ scan_token, push_transcript, increase_length, is_potential_escape_sequence } = ScanData::from_field(capture_flags);\n\n            // 2 gates\n            let raw = raw_transcript[transcript_ptr];\n\n            // 1 gate\n            let diff = raw\n                - RawTranscriptEntry::to_field(RawTranscriptEntry { encoded_ascii, index: i as Field - length, length });\n            std::as_witness(diff);\n            // 1 gate\n            assert(diff * push_transcript == 0);\n\n            // 1 gate\n            length = length * (1 - push_transcript) + increase_length;\n            std::as_witness(length);\n\n            // 1 gate\n            transcript_ptr += push_transcript;\n\n            previous_was_potential_escape_sequence = is_potential_escape_sequence;\n            scan_mode = scan_token;\n        }\n\n        // we encode error flag into the scan_token value, which must be less than 4\n        // the lookup into JSON_CAPTURE_TABLE applies an implicit 2-bit range check on `scan_token`\n        // however this does not get triggered if the final byte scanned produces an error state\n        length.assert_max_bit_size(2);\n\n        JSON {\n            json: self.json,\n            raw_transcript,\n            transcript: self.transcript,\n            transcript_length: transcript_ptr as u32,\n            key_data: self.key_data,\n            key_hashes: self.key_hashes,\n            layer_type_of_root: self.layer_type_of_root,\n            root_id: 1,\n            root_index_in_transcript: 0,\n            json_entries_packed: self.json_entries_packed,\n            unsorted_json_entries_packed: self.unsorted_json_entries_packed,\n            json_packed: self.json_packed\n        }\n    }\n\n    /**\n     * @brief We compute the output of `capture_missing_tokens` via an unconstrained function, then validate the result is correct.\n     *        Saves some gates for same reason as in __build_transcript\n     **/\n    unconstrained fn __capture_missing_tokens(self) -> [Field; MaxNumTokens] {\n        let mut updated_transcript: [Field; MaxNumTokens] = [0; MaxNumTokens];\n        let mut transcript_ptr: u32 = 0;\n        // TODO: do we need a null transcript value?!?!\n\n        for i in 0..MaxNumTokens {\n            let RawTranscriptEntry{ encoded_ascii, index, length} = RawTranscriptEntry::from_field(self.raw_transcript[i]);\n\n            let PostProcessScanData{ token, new_grammar, scan_token } = PostProcessScanData::from_field(PROCESS_RAW_TRANSCRIPT_TABLE[encoded_ascii]);\n\n            let entry = TranscriptEntry::to_field(TranscriptEntry { token, index, length });\n            updated_transcript[transcript_ptr] = entry;\n\n            let index_valid: u32 = (i < self.transcript_length) as u32;\n            transcript_ptr += index_valid;\n\n            let index_of_possible_grammar = (index + length);\n            let new_entry = TranscriptEntry { token: scan_token, index: index_of_possible_grammar, length: 0 };\n\n            let update = new_grammar * index_valid as Field;\n            let new_transcript = TranscriptEntry::to_field(new_entry);\n            assert(transcript_ptr < MaxNumTokens, \"capture_missing_tokens: MaxNumTokens limit exceeded!\");\n            updated_transcript[transcript_ptr] = new_transcript;\n            transcript_ptr += update as bool as u32;\n        }\n        updated_transcript\n    }\n\n    /**\n     * @brief Check for missing tokens that we could have missed in `build_transcript`\n     * @details If we had a json string where a NUMERIC_TOKEN or LITERAL_TOKEN is directly succeeded by a VALUE_SEPARATOR_TOKEN, END_OBJECT_TOKEN, END_ARRAY_TOKEN,\n     *          we will have missed the latter token.\n     *          We pick these up via the lookup table PROCESS_RAW_TRANSCRIPT_TABLE\n     **/\n    fn capture_missing_tokens(&mut self) {\n        let mut transcript_ptr: Field = 0;\n        // hmm probably need a null transcript value?!?!\n        let updated_transcript = self.__capture_missing_tokens();\n        // 26? gates per iteration\n        let range_valid: [Field; MaxNumTokens] = get_validity_flags(self.transcript_length);\n        for i in 0..MaxNumTokens {\n            // 5.25 gates\n            let RawTranscriptEntry{ encoded_ascii, index, length} = RawTranscriptEntry::from_field(self.raw_transcript[i]);\n            // 6.75 gates\n            let PostProcessScanData{ token, new_grammar, scan_token } = PostProcessScanData::from_field(PROCESS_RAW_TRANSCRIPT_TABLE[encoded_ascii]);\n            // 2 gates\n            let index_valid: Field = range_valid[i];\n            // 1 gate\n            let entry = TranscriptEntry::to_field(TranscriptEntry { token, index, length });\n            // 2 gates\n            let diff = updated_transcript[transcript_ptr] - entry;\n            std::as_witness(diff);\n            assert(diff * index_valid == 0);\n            // 1 gate\n            transcript_ptr += index_valid;\n            // 0 gate (merged into TranscriptEntry::to_field)\n            let index_of_possible_grammar = (index + length);\n            // 0 gates\n            let new_entry = TranscriptEntry { token: scan_token, index: index_of_possible_grammar, length: 0 };\n            // 2 gates\n            let update = new_grammar as Field * index_valid;\n            std::as_witness(update);\n            // 1 gate\n            let new_transcript = TranscriptEntry::to_field(new_entry);\n            // 4 gates\n            let diff = updated_transcript[transcript_ptr] - new_transcript;\n            std::as_witness(diff);\n            assert(diff * update == 0);\n            // 1 gate\n            transcript_ptr += update;\n        }\n        self.transcript = updated_transcript;\n\n        // TODO we could make this more efficient...probably not a big deal though\n        let first = TranscriptEntry::from_field(self.transcript[0]);\n        if (first.token == BEGIN_OBJECT_TOKEN) {\n            self.layer_type_of_root = OBJECT_LAYER;\n        } else if (first.token == BEGIN_ARRAY_TOKEN) {\n            self.layer_type_of_root = ARRAY_LAYER;\n        } else if (first.token == STRING_TOKEN) {\n            self.layer_type_of_root = SINGLE_VALUE_LAYER as Field;\n        }\n    }\n\n    fn parse_json<let StringBytes: u32>(stringbytes: [u8; StringBytes]) -> Self {\n        assert(StringBytes <= NumBytes, \"json length exceeds NumBytes!\");\n        let mut text: [u8; NumBytes] = [0; NumBytes];\n        for i in 0..StringBytes {\n            text[i] = stringbytes[i];\n        }\n        for i in StringBytes..NumBytes {\n            text[i] = 32; // whitespace character\n        }\n        let mut json = JSON {\n            json: text,\n            raw_transcript: [0; MaxNumTokens],\n            transcript: [0; MaxNumTokens],\n            transcript_length: 0,\n            key_data: [0; MaxNumValues],\n            key_hashes: [0; MaxNumValues],\n            layer_type_of_root: 0,\n            root_id: 1,\n            root_index_in_transcript: 0,\n            json_entries_packed: [JSONEntryPacked::default(); MaxNumValues],\n            unsorted_json_entries_packed: [JSONEntryPacked::default(); MaxNumValues],\n            json_packed: [0; NumPackedFields]\n        };\n\n        json = json.build_transcript();\n        json.capture_missing_tokens();\n        json.keyswap();\n        json.compute_json_packed();\n        json.create_json_entries();\n\n        json.compute_keyhash_and_sort_json_entries();\n\n        json\n    }\n\n    fn parse_json_from_string<let StringBytes: u32>(s: str<StringBytes>) -> Self {\n        JSON::parse_json(s.as_bytes())\n    }\n}\n\n// TODO: our capture tables are not correctly set up to process a JSON blob that does not begin with an object or array\n// #[test]\n// fn test_single_value() {\n//     let text = \"100\";\n//     let mut json: JSON<3, 10, 20, 20> = JSON::parse_json_from_string(text);\n//\n//     assert(json.get_length() == 0);\n//     assert(json.get_array_element_as_number(0) == 100);\n// }\n\n#[test]\nfn test_numbers() {\n    let text = \"{ \\\"a\\\": 9, \\\"b\\\": 99, \\\"c\\\": 999, \\\"d\\\": 9999, \\\"e\\\": 99999, \\\"f\\\": 999999, \\\"g\\\": 9999999, \\\"h\\\": 99999999, \\\"i\\\": 999999999, \\\"j\\\": 9999999999, \\\"k\\\": 99999999999, \\\"l\\\": 999999999999, \\\"m\\\": 9999999999999, \\\"n\\\": 99999999999999, \\\"o\\\": 999999999999999, \\\"p\\\": 999999999999999,\\\"q\\\": 9999999999999999, \\\"r\\\": 99999999999999999, \\\"s\\\": 999999999999999999, \\\"t\\\": 9999999999999999999, \\\"u\\\": 18446744073709551615}\";\n    let mut json: JSON<372, 16, 100, 24, 2> = JSON::parse_json_from_string(text);\n\n    let a = json.get_number_unchecked(\"a\".as_bytes());\n    let b = json.get_number_unchecked(\"b\".as_bytes());\n    let c = json.get_number_unchecked(\"c\".as_bytes());\n    let d = json.get_number_unchecked(\"d\".as_bytes());\n    let e = json.get_number_unchecked(\"e\".as_bytes());\n    let f = json.get_number_unchecked_var(BoundedVec { storage: \"ftrololol\".as_bytes(), len: 1 });\n    let g = json.get_number(\"g\".as_bytes()).unwrap();\n    let h = json.get_number_var(BoundedVec { storage: \"h\".as_bytes(), len: 1 }).unwrap();\n    let i = json.get_number_unchecked(\"i\".as_bytes());\n    let j = json.get_number_unchecked(\"j\".as_bytes());\n    let k = json.get_number_unchecked(\"k\".as_bytes());\n    let l = json.get_number_unchecked(\"l\".as_bytes());\n    let m = json.get_number_unchecked(\"m\".as_bytes());\n    let n = json.get_number_unchecked(\"n\".as_bytes());\n    let o = json.get_number_unchecked(\"o\".as_bytes());\n    let p = json.get_number_unchecked(\"p\".as_bytes());\n    let q = json.get_number_unchecked(\"q\".as_bytes());\n    let r = json.get_number_unchecked(\"r\".as_bytes());\n    let s = json.get_number_unchecked(\"s\".as_bytes());\n    let t = json.get_number_unchecked(\"t\".as_bytes());\n    let u = json.get_number_unchecked(\"u\".as_bytes());\n\n    assert(a == 9);\n    assert(b == 99);\n    assert(c == 999);\n    assert(d == 9999);\n    assert(e == 99999);\n    assert(f == 999999);\n    assert(g == 9999999);\n    assert(h == 99999999);\n    assert(i == 999999999);\n    assert(j == 9999999999);\n    assert(k == 99999999999);\n    assert(l == 999999999999);\n    assert(m == 9999999999999);\n    assert(n == 99999999999999);\n    assert(o == 999999999999999);\n    assert(p == 999999999999999);\n    assert(q == 9999999999999999);\n    assert(r == 99999999999999999);\n    assert(s == 999999999999999999);\n    assert(t == 9999999999999999999);\n    assert(u == 18446744073709551615);\n}\n\n#[test]\nfn test_parent_array() {\n    let text = \"[0,10,21,32,44]\";\n    let mut json: JSON<15, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n    assert(json.get_length() == 5);\n    assert(json.get_number_from_array_unchecked(0) == 0);\n    assert(json.get_number_from_array_unchecked(1) == 10);\n    assert(json.get_number_from_array_unchecked(2) == 21);\n    assert(json.get_number_from_array_unchecked(3) == 32);\n    assert(json.get_number_from_array_unchecked(4) == 44);\n}\n\n#[test]\nfn test_escaped_strings() {\n    let text = \"{   \\\"name\\\": \\\"\\\\\\\"Ade\\\\nel Solangi\\\\\\\"\\\", \\\"testA\\\": false, \\\"testB\\\": true, \\\"testC\\\": null }                                                                   \";\n    let mut json: JSON<148, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n    let result: BoundedVec<u8,19>  = json.get_string_unchecked(\"name\".as_bytes());\n    assert(result.storage == BoundedVec::from_array(\"\\\"Ade\\nel Solangi\\\"\".as_bytes()).storage);\n    assert(result.len == 16);\n}\n\n#[test]\nfn test_parse_json() {\n    let text= \"{ \\\"foo\\\": 1234, \\\"bar\\\": { \\\"foo\\\": 9876, \\\"bar\\\": true }, \\\"baz\\\": \\\"hello\\\" }\";\n    let mut json: JSON<68, 7, 30, 30, 2> = JSON::parse_json_from_string(text);\n\n    let result = json.get_string_unchecked(\"baz\".as_bytes());\n    assert(result.storage == \"hello\".as_bytes());\n\n    let result: Option<BoundedVec<u8, 5>> = json.get_string(\"baz\".as_bytes());\n    assert(result.is_some());\n    assert(result.unwrap().storage == \"hello\".as_bytes());\n\n    let result: Option<BoundedVec<u8, 1>> = json.get_string(\"wibble\".as_bytes());\n    assert(result.is_some() == false);\n\n    let result: u64 = json.get_number_unchecked(\"foo\".as_bytes());\n    assert(result == 1234);\n\n    let result: Option<u64> = json.get_number(\"foo\".as_bytes());\n    assert(result.is_some());\n    assert(result.unwrap() == 1234);\n\n    let result: Option<u64> = json.get_number(\"fooo\".as_bytes());\n    assert(result.is_some() == false);\n\n    let mut nested_json = json.get_object(\"bar\".as_bytes()).unwrap();\n    let result: Option<u64> = nested_json.get_number_var(BoundedVec { storage: \"foounusedkeybyteslolol\".as_bytes(), len: 3 });\n    assert(result.is_some() == true);\n    assert(result.unwrap() == 9876);\n\n    let key0: BoundedVec<u8, 3> = BoundedVec::from_array(\"bar\".as_bytes());\n    let key1: BoundedVec<u8, 3> = BoundedVec::from_array(\"baz\".as_bytes());\n\n    let result: Option<BoundedVec<u8, 10>> = json.get_string_from_path([key0, key1]);\n    assert(result.is_some() == false);\n}\n\n#[test]\nfn test_literal() {\n    let text = \"{   \\\"name\\\": \\\"Adeel Solangi\\\", \\\"testA\\\": false, \\\"testB\\\": true, \\\"testC\\\": null }                                                                   \";\n    let mut json: JSON<142, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n\n    let result: JSONLiteral = json.get_literal_unchecked(\"testA\".as_bytes());\n    assert(result.is_false() == true);\n    assert(result.is_true() == false);\n    assert(result.is_null() == false);\n    assert(result.to_bool() == false);\n\n    let result_option: Option<JSONLiteral> = json.get_literal(\"testA\".as_bytes());\n    assert(result_option.is_some());\n    assert(result_option.unwrap().value == result.value);\n}\n\n#[test]\nfn test_arrays() {\n    let text = \"{   \\\"name\\\": \\\"Adeel Solangi\\\", \\\"age\\\": 62, \\\"portfolio\\\": { \\\"vibe_ratings\\\": [1,2],\\\"elemental_lorem\\\": false }}                                                 \";\n    let mut json: JSON<153, 10, 60, 60, 2> = JSON::parse_json_from_string(text);\n\n    assert(json.key_exists(BoundedVec { storage: \"foo\".as_bytes(), len: 3 }) == false);\n    assert(json.key_exists(BoundedVec { storage: \"name\".as_bytes(), len: 4 }));\n    assert(json.key_exists(BoundedVec { storage: \"age\".as_bytes(), len: 3 }));\n    assert(json.key_exists(BoundedVec { storage: \"portfolio\".as_bytes(), len: 9 }));\n}\n\n#[test(should_fail_with = \"build_transcript: MaxNumTokens limit exceeded!\")]\nfn test_json_not_enough_tokens_fails() {\n    let text = \"{ \\\"hello \\\": \\\"world\\\" }\";\n    let _: JSON<26, 10, 2, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"capture_missing_tokens: MaxNumTokens limit exceeded!\")]\nfn test_json_not_enough_tokens_fails_2() {\n    // we should exceed the limit of 8 tokens here, when capturing the `,` token missed by build_transcript\n    let text = \"{ \\\"hello \\\": false,\\\"world\\\": true }\";\n    let _: JSON<33, 10, 8, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"create_json_entries: MaxNumValues limit exceeded!\")]\nfn test_json_not_enough_values_fails() {\n    let text = \"{ \\\"hello \\\": false,\\\"world\\\": true }\";\n    let _: JSON<33, 10, 10, 4, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"ValidationFlags: grammar error\")]\nfn test_json_object_without_key_fails() {\n    let text = \"{ \\\"hello \\\": \\\"world\\\", 100 }\";\n    let _: JSON<26, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"ValidationFlags: grammar error\")]\nfn test_json_array_with_key_fails() {\n    let text = \"[ \\\"hello \\\": \\\"world\\\" ]\";\n    let _: JSON<26, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"ValidationFlags: grammar error\")]\nfn test_json_unclosed_object_fails() {\n    let text = \"{ \\\"hello \\\": \\\"world\\\" \";\n    let _: JSON<26, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"ValidationFlags: grammar error\")]\nfn test_json_object_closed_with_array_fails() {\n    let text = \"{ \\\"hello \\\": \\\"world\\\" ]\";\n    let _: JSON<26, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"ValidationFlags: grammar error\")]\nfn test_json_object_with_trailing_comma_fails() {\n    let text = \"{ \\\"hello \\\" : \\\"world\\\", }\";\n    let _: JSON<26, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"ValidationFlags: grammar error\")]\nfn test_json_unclosed_array_fails() {\n    let text = \"[ \\\"hello \\\", \\\"world\\\"\";\n    let _: JSON<19, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"validate_tokens: unclosed objects or arrays\")]\nfn test_json_unclosed_array_fails_2() {\n    let text = \"[ \\\"hello \\\", \\\"world\\\", [1,2,3,4] \";\n    let _: JSON<31, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"ValidationFlags: grammar error\")]\nfn test_json_array_with_trailing_comma_fails() {\n    let text = \"[ \\\"hello \\\", \\\"world\\\", ]\";\n    let _: JSON<26, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"ValidationFlags: grammar error\")]\nfn test_json_array_closed_with_object_fails() {\n    let text = \"[ \\\"hello \\\": \\\"world\\\" }\";\n    let _: JSON<26, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"ScanData: Invalid token\")]\nfn test_json_key_not_wrapped_in_quotes_fails() {\n    let text = \"{ false: \\\"world\\\" }\";\n    let _: JSON<26, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"ScanData: Invalid token\")]\nfn test_json_string_not_wrapped_in_quotes_fails() {\n    let text = \"{ \\\"hello \\\": world }\";\n    let _: JSON<26, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"ScanData: Invalid token\")]\nfn test_json_char_outside_of_string_fails() {\n    let text = \"{ \\\"hello \\\", \\\"world\\\" a}\";\n    let _: JSON<26, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"ValidationFlags: grammar error\")]\nfn test_json_char_outside_of_string_fails_2() {\n    // n could be the start of the literal \"null\", so this passes the ScanData check but fails ValidationFlags\n    let text = \"{ \\\"hello \\\", \\\"world\\\" n}\";\n    let _: JSON<26, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"ValidationFlags: grammar error\")]\nfn test_json_array_with_invalid_tokens_fails() {\n    // n could be the start of the literal \"null\", so this passes the ScanData check but fails ValidationFlags\n    let text = \"[,,,]\";\n    let _: JSON<26, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test(should_fail_with = \"Cannot find key/value straddling KEY_DELIMITER_TOKEN\")]\nfn test_json_object_with_invalid_tokens_fails() {\n    // n could be the start of the literal \"null\", so this passes the ScanData check but fails ValidationFlags\n    let text = \"{:::}\";\n    let _: JSON<26, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test]\nfn test_json_empty_object_passes() {\n    // n could be the start of the literal \"null\", so this passes the ScanData check but fails ValidationFlags\n    let text = \"{}\";\n    let _: JSON<26, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n#[test]\nfn test_json_empty_array_passes() {\n    // n could be the start of the literal \"null\", so this passes the ScanData check but fails ValidationFlags\n    let text = \"[]\";\n    let _: JSON<26, 10, 20, 20, 2> = JSON::parse_json_from_string(text);\n}\n\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/json.nr"},"91":{"source":"use crate::_string_tools::slice_packed_field::slice_fields;\n\nstruct StringChopper<let NeedlePackedFields: u32> {}\n\nimpl<let NeedlePackedFields: u32> StringChopper<NeedlePackedFields> {\n    fn slice_string<let StringBytes: u32, let HaystackPackedFields: u32>(\n        _: Self,\n        haystack: [Field; HaystackPackedFields],\n        start_bytes: Field,\n        num_bytes: Field\n    ) -> [u8; StringBytes] {\n        let mut parsed_string: [u8; StringBytes] = [0; StringBytes];\n\n        let sliced: [Field; NeedlePackedFields] = slice_fields(haystack, start_bytes, num_bytes);\n\n        let sliced_bytes = sliced.map(|x: Field| { let r: [u8; 31] = x.to_be_bytes(); r });\n\n        let num_slices = StringBytes / 31;\n        let overflow = StringBytes % 31;\n        for i in 0..num_slices {\n            for j in 0..31 {\n                parsed_string[i * 31 + j] = sliced_bytes[i][j];\n            }\n        }\n        for j in 0..overflow {\n            parsed_string[num_slices * 31 + j] = sliced_bytes[num_slices][j];\n        }\n        parsed_string\n    }\n}\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/_string_tools/string_chopper.nr"},"92":{"source":"global PLO: Field = 0x2833E84879B9709143E1F593F0000001;\nglobal PHI: Field = 0x30644E72E131A029B85045B68181585D;\n\nglobal PLO_200_felt: Field = 0x29B85045B68181585D2833E84879B9709143E1F593F0000001;\nglobal PHI_54_felt: Field = 0x30644E72E131A0;\nglobal TWO_POW_200 = 0x100000000000000000000000000000000000000000000000000;\nstruct Slice200 {\n    hihi: u64, // 7 bytes\n    hilo: u64, // 7 bytes\n    lohi: u64, // 7 bytes\n    lolo: u32 // 4 bytes\n}\nglobal PHI_54: u64 = 0x30644E72E131A0;\nglobal PLO_200: Slice200 = Slice200 {\n    hihi: 0x29B85045B68181,\n    hilo: 0x585D2833E84879,\n    lohi: 0xB9709143E1F593,\n    lolo: 0xF0000001,\n};\n\nunconstrained fn __slice_200_bits_from_field(f: Field) -> (Field, Field, bool) {\n    let b: [u8; 32] = f.to_be_bytes();\n\n    let mut res200: Slice200 = Slice200 { hihi: 0, hilo: 0, lohi: 0, lolo: 0 };\n    let mut res54: u64 = 0;\n    for i in 0..7 {\n        res200.hihi <<= 8;\n        res200.hilo <<= 8;\n        res200.lohi <<= 8;\n        res200.hihi += b[i + 7] as u64;\n        res200.hilo += b[i + 14] as u64;\n        res200.lohi += b[i + 21] as u64;\n    }\n    for i in 0..4 {\n        res200.lolo <<= 8;\n        res200.lolo += b[28 + i] as u32;\n    }\n    for i in 0..7 {\n        res54 <<= 8;\n        res54 += b[i] as u64;\n    }\n\n    let mut lo: Field = res200.hihi as Field; // 56 bits\n    lo *= 0x100000000000000; // 56 + 56 bits\n    lo += res200.hilo as Field; // 56 + 56 bits\n    lo *= 0x100000000000000; // 56 + 56 + 56 bits\n    lo += res200.lohi as Field; // 56 + 56 + 56 bits = 168 bits\n    lo *= 0x100000000; // 56 + 56 + 56 + 32 bits = 200 bits?\n    lo += res200.lolo as Field;\n\n    let mut hi = res54 as Field;\n\n    let mut PLO = PLO_200;\n    let mut borrow: bool = false;\n    // p - x\n    borrow = PLO.lolo < res200.lolo;\n    PLO.lohi -= borrow as u64;\n    borrow = PLO.lohi < res200.lohi;\n    PLO.hilo -= borrow as u64;\n    borrow = PLO.hilo < res200.hilo;\n    PLO.hihi -= borrow as u64;\n    borrow = PLO.hihi < res200.hihi;\n    (lo, hi, borrow)\n}\n\npub fn slice_200_bits_from_field(f: Field) -> Field {\n    let (lo, hi, borrow) = __slice_200_bits_from_field(f);\n    assert(hi * TWO_POW_200 + lo == f);\n    lo.assert_max_bit_size(200);\n    hi.assert_max_bit_size(56);\n    let lo_diff = PLO_200_felt - lo + (borrow as Field * TWO_POW_200);\n    let hi_diff = PHI_54_felt - hi - borrow as Field;\n    lo_diff.assert_max_bit_size(200);\n    hi_diff.assert_max_bit_size(56);\n    lo\n}\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/_string_tools/slice_field.nr"},"94":{"source":"/**\n * @file methods to extract data efficiently from Field elements that represent 31 bytes of packed data\n **/\n\n// #############################################################\n// ### GLOBAL VARIABLES AND LOOKUP TABLES\n// #############################################################\nglobal two_pow_128 = 0x100000000000000000000000000000000;\nglobal two_pow_64 = 0x10000000000000000;\nglobal two_pow_32 = 0x100000000;\nglobal two_pow_16 = 0x10000;\n\nglobal path_multipliers_chunk4: [Field; 32] = [\n    /* 0  (00000) */ 0,\n    /* 1  (00001) */ 0,\n    /* 2  (00010) */ 0,\n    /* 3  (00011) */ 0,\n    /* 4  (00100) */ 0,\n    /* 5  (00101) */ 0,\n    /* 6  (00110) */ 0,\n    /* 7  (00111) */ 0,\n    /* 8  (01000) */ 0,\n    /* 9  (01001) */ 0,\n    /* 10 (01010) */ 0,\n    /* 11 (01011) */ 0,\n    /* 12 (01100) */ 0,\n    /* 13 (01101) */ 0,\n    /* 14 (01110) */ 0,\n    /* 15 (01111) */ 0,\n    /* 16 (10000) */ 1,\n    /* 17 (10001) */ 1,\n    /* 18 (10010) */ 1,\n    /* 19 (10011) */ 1,\n    /* 20 (10100) */ 1,\n    /* 21 (10101) */ 1,\n    /* 22 (10110) */ 1,\n    /* 23 (10111) */ 1,\n    /* 24 (11000) */ 1,\n    /* 25 (11001) */ 1,\n    /* 26 (11010) */ 1,\n    /* 27 (11011) */ 1,\n    /* 28 (11100) */ 1,\n    /* 29 (11101) */ 1,\n    /* 30 (11110) */ 1,\n    /* 31 (11111) */ 1\n];\n\n// this represents an 8 byte chunk. what do we multiply by?\nglobal path_multipliers_chunk3: [Field; 32] = [\n    /* 0  (00000) */ 0,\n    /* 1  (00001) */ 0,\n    /* 2  (00010) */ 0,\n    /* 3  (00011) */ 0,\n    /* 4  (00100) */ 0,\n    /* 5  (00101) */ 0,\n    /* 6  (00110) */ 0,\n    /* 7  (00111) */ 0,\n    /* 8  (01000) */ 1,\n    /* 9  (01001) */ 1,\n    /* 10 (01010) */ 1,\n    /* 11 (01011) */ 1,\n    /* 12 (01100) */ 1,\n    /* 13 (01101) */ 1,\n    /* 14 (01110) */ 1,\n    /* 15 (01111) */ 1,\n    /* 16 (10000) */ 0,\n    /* 17 (10001) */ 0,\n    /* 18 (10010) */ 0,\n    /* 19 (10011) */ 0,\n    /* 20 (10100) */ 0,\n    /* 21 (10101) */ 0,\n    /* 22 (10110) */ 0,\n    /* 23 (10111) */ 0,\n    /* 24 (11000) */ two_pow_128,\n    /* 25 (11001) */ two_pow_128,\n    /* 26 (11010) */ two_pow_128,\n    /* 27 (11011) */ two_pow_128,\n    /* 28 (11100) */ two_pow_128,\n    /* 29 (11101) */ two_pow_128,\n    /* 30 (11110) */ two_pow_128,\n    /* 31 (11111) */ two_pow_128\n];\n\n// what do we multiply 4 byte chunk by\nglobal path_multipliers_chunk2: [Field; 32] = [\n    /* 0  (00000) */ 0,\n    /* 1  (00001) */ 0,\n    /* 2  (00010) */ 0,\n    /* 3  (00011) */ 0,\n    /* 4  (00100) */ 1,\n    /* 5  (00101) */ 1,\n    /* 6  (00110) */ 1,\n    /* 7  (00111) */ 1,\n    /* 8  (01000) */ 0,\n    /* 9  (01001) */ 0,\n    /* 10 (01010) */ 0,\n    /* 11 (01011) */ 0,\n    /* 12 (01100) */ two_pow_64,\n    /* 13 (01101) */ two_pow_64,\n    /* 14 (01110) */ two_pow_64,\n    /* 15 (01111) */ two_pow_64,\n    /* 16 (10000) */ 0,\n    /* 17 (10001) */ 0,\n    /* 18 (10010) */ 0,\n    /* 19 (10011) */ 0,\n    /* 20 (10100) */ two_pow_128,\n    /* 21 (10101) */ two_pow_128,\n    /* 22 (10110) */ two_pow_128,\n    /* 23 (10111) */ two_pow_128,\n    /* 24 (11000) */ 0,\n    /* 25 (11001) */ 0,\n    /* 26 (11010) */ 0,\n    /* 27 (11011) */ 0,\n    /* 28 (11100) */ two_pow_128 * two_pow_64,\n    /* 29 (11101) */ two_pow_128 * two_pow_64,\n    /* 30 (11110) */ two_pow_128 * two_pow_64,\n    /* 31 (11111) */ two_pow_128 * two_pow_64\n];\n\n// what do we multiply 2 byte chunk by\nglobal path_multipliers_chunk1: [Field; 32] = [\n    /* 0  (00000) */ 0,\n    /* 1  (00001) */ 0,\n    /* 2  (00010) */ 1,\n    /* 3  (00011) */ 1,\n    /* 4  (00100) */ 0,\n    /* 5  (00101) */ 0,\n    /* 6  (00110) */ two_pow_32,\n    /* 7  (00111) */ two_pow_32,\n    /* 8  (01000) */ 0,\n    /* 9  (01001) */ 0,\n    /* 10 (01010) */ two_pow_64,\n    /* 11 (01011) */ two_pow_64,\n    /* 12 (01100) */ 0,\n    /* 13 (01101) */ 0,\n    /* 14 (01110) */ two_pow_64 * two_pow_32,\n    /* 15 (01111) */ two_pow_64 * two_pow_32,\n    /* 16 (10000) */ 0,\n    /* 17 (10001) */ 0,\n    /* 18 (10010) */ two_pow_128,\n    /* 19 (10011) */ two_pow_128,\n    /* 20 (10100) */ 0,\n    /* 21 (10101) */ 0,\n    /* 22 (10110) */ two_pow_128 * two_pow_32,\n    /* 23 (10111) */ two_pow_128 * two_pow_32,\n    /* 24 (11000) */ 0,\n    /* 25 (11001) */ 0,\n    /* 26 (11010) */ two_pow_128 * two_pow_64,\n    /* 27 (11011) */ two_pow_128 * two_pow_64,\n    /* 28 (11100) */ 0,\n    /* 29 (11101) */ 0,\n    /* 30 (11110) */ two_pow_128 * two_pow_64 * two_pow_32,\n    /* 31 (11111) */ two_pow_128 * two_pow_64 * two_pow_32\n];\n\n// what do we multiply 1 byte chunk by\nglobal path_multipliers_chunk0: [Field; 32] = [\n    /* 0  (00000) */ 0,\n    /* 1  (00001) */ 1,\n    /* 2  (00010) */ 0,\n    /* 3  (00011) */ two_pow_16,\n    /* 4  (00100) */ 0,\n    /* 5  (00101) */ two_pow_32,\n    /* 6  (00110) */ 0,\n    /* 7  (00111) */ two_pow_16 * two_pow_32,\n    /* 8  (01000) */ 0,\n    /* 9  (01001) */ two_pow_64,\n    /* 10 (01010) */ 0,\n    /* 11 (01011) */ two_pow_64 * two_pow_16,\n    /* 12 (01100) */ 0,\n    /* 13 (01101) */ two_pow_64 * two_pow_32,\n    /* 14 (01110) */ 0,\n    /* 15 (01111) */ two_pow_64 * two_pow_32 * two_pow_16,\n    /* 16 (10000) */ 0,\n    /* 17 (10001) */ two_pow_128,\n    /* 18 (10010) */ 0,\n    /* 19 (10011) */ two_pow_128 * two_pow_16,\n    /* 20 (10100) */ 0,\n    /* 21 (10101) */ two_pow_128 * two_pow_32,\n    /* 22 (10110) */ 0,\n    /* 23 (10111) */ two_pow_128 * two_pow_32 * two_pow_16,\n    /* 24 (11000) */ 0,\n    /* 25 (11001) */ two_pow_128 * two_pow_64,\n    /* 26 (11010) */ 0,\n    /* 27 (11011) */ two_pow_128 * two_pow_64 * two_pow_16,\n    /* 28 (11100) */ 0,\n    /* 29 (11101) */ two_pow_128 * two_pow_64 * two_pow_32,\n    /* 30 (11110) */ 0,\n    /* 31 (11111) */ two_pow_128 * two_pow_64 * two_pow_32 * two_pow_16\n];\n\n// these are `head_path_multipliers` but in reverse order\nglobal tail_path_multipliers_chunk3: [Field; 32] = [0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];\nglobal tail_path_multipliers_chunk2: [Field; 32] = [0x01000000000000000000000000000000000000000000000000, 0x01000000000000000000000000000000000000000000000000, 0x01000000000000000000000000000000000000000000000000, 0x01000000000000000000000000000000000000000000000000, 0x00, 0x00, 0x00, 0x00, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x00, 0x00, 0x00, 0x00, 0x010000000000000000, 0x010000000000000000, 0x010000000000000000, 0x010000000000000000, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00];\nglobal tail_path_multipliers_chunk1: [Field; 32] = [0x0100000000000000000000000000000000000000000000000000000000, 0x0100000000000000000000000000000000000000000000000000000000, 0x00, 0x00, 0x01000000000000000000000000000000000000000000000000, 0x01000000000000000000000000000000000000000000000000, 0x00, 0x00, 0x010000000000000000000000000000000000000000, 0x010000000000000000000000000000000000000000, 0x00, 0x00, 0x0100000000000000000000000000000000, 0x0100000000000000000000000000000000, 0x00, 0x00, 0x01000000000000000000000000, 0x01000000000000000000000000, 0x00, 0x00, 0x010000000000000000, 0x010000000000000000, 0x00, 0x00, 0x0100000000, 0x0100000000, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00];\nglobal tail_path_multipliers_chunk0: [Field; 32] = [0x01000000000000000000000000000000000000000000000000000000000000, 0x00, 0x0100000000000000000000000000000000000000000000000000000000, 0x00, 0x010000000000000000000000000000000000000000000000000000, 0x00, 0x01000000000000000000000000000000000000000000000000, 0x00, 0x0100000000000000000000000000000000000000000000, 0x00, 0x010000000000000000000000000000000000000000, 0x00, 0x01000000000000000000000000000000000000, 0x00, 0x0100000000000000000000000000000000, 0x00, 0x010000000000000000000000000000, 0x00, 0x01000000000000000000000000, 0x00, 0x0100000000000000000000, 0x00, 0x010000000000000000, 0x00, 0x01000000000000, 0x00, 0x0100000000, 0x00, 0x010000, 0x00, 0x01, 0x00];\n\nglobal LIMB_VALID_PATH: [Field; 35] = [\n0x000000000, // 0 0 0 0 0 0 0 0 0\n0x000000001, // 0 0 0 0 0 0 0 0 1\n0x000000003, // 0 0 0 0 0 0 0 1 1\n0x000000007, // 0 0 0 0 0 0 1 1 1\n0x000000008, // 0 0 0 0 0 1 1 1 1\n0x000000010, // 0 0 0 0 1 0 0 0 0\n0x000000020, // 0 0 0 1 0 0 0 0 0\n0x000000040, // 0 0 1 0 0 0 0 0 0\n0x000000080, // 0 1 0 0 0 0 0 0 0\n0x000000100, // 1 0 0 0 0 0 0 0 0\n0x000000200, // 0 0 0 0 0 0 0 1 0\n0x000000400, // 0 0 0 0 0 0 1 0 0\n0x000000800, // 0 0 0 0 0 1 0 0 0\n0x000001000, // 0 0 0 0 1 0 0 0 0\n0x000002000, // 0 0 0 1 0 0 0 0 0\n0x000004000, // 0 0 1 0 0 0 0 0 0\n0x000008000, // 0 1 0 0 0 0 0 0 0\n0x000010000, // 0 0 0 0 0 0 0 0 1\n0x000020000, // 0 0 0 0 0 0 0 1 0\n0x000040000, // 0 0 0 0 0 0 1 0 0\n0x000080000, // 0 0 0 0 0 1 0 0 0\n0x000100000, // 0 0 0 0 1 0 0 0 0\n0x000200000, // 0 0 0 1 0 0 0 0 0\n0x000400000, // 0 0 1 0 0 0 0 0 0\n0x000800000, // 0 1 0 0 0 0 0 0 0\n0x001000000, // 0 0 0 0 0 0 0 0 1\n0x002000000, // 0 0 0 0 0 0 0 1 0\n0x004000000, // 0 0 0 0 0 0 1 0 0\n0x008000000, // 0 0 0 0 0 1 0 0 0\n0x010000000, // 0 0 0 0 1 0 0 0 0\n0x020000000, // 0 0 0 1 0 0 0 0 0\n0x040000000, // 0 0 1 0 0 0 0 0 0\n0x080000000, // 0 1 0 0 0 0 0 0 0\n0x100000000,\n0x200000000\n];\n\n// these path variables describe the location of a limb in an array\n// e.g. LAST_LIMB_PATH[5] produces 2^{5-1},\n// which is decomposed into 1 0 0 0 0, and the decompositions turned into an array M\n// M[4] = 1 i.e. the limbs[4] should contain the last limb\n// array extends to 0x200000000 which is 2^33 => 33 31 byte limbs = 1,023 bytes\n// this puts a hard limit on the max size of a key that this program supports.\nglobal LAST_LIMB_PATH: [Field; 36] = [\n0x000000000, // 0 0 0 0 0 0 0 0 0 <-- edge case because sometimes array index is -1, so we offset by 1 TODO explain better\n0x000000000, // 0 0 0 0 0 0 0 0 1\n0x000000001, // 0 0 0 0 0 0 0 1 0\n0x000000003, // 0 0 0 0 0 0 1 0 0\n0x000000007, // 0 0 0 0 0 1 0 0 0\n0x00000000f, // 0 0 0 0 1 0 0 0 0\n0x00000001f, // 0 0 0 1 0 0 0 0 0\n0x00000003f, // 0 0 1 0 0 0 0 0 0\n0x00000007f, // 0 1 0 0 0 0 0 0 0\n0x0000000ff, // 1 0 0 0 0 0 0 0 0\n0x0000001ff, // 0 0 0 0 0 0 0 1 0\n0x0000003ff, // 0 0 0 0 0 0 1 0 0\n0x0000007ff, // 0 0 0 0 0 1 0 0 0\n0x000000fff, // 0 0 0 0 1 0 0 0 0\n0x000001fff, // 0 0 0 1 0 0 0 0 0\n0x000003fff, // 0 0 1 0 0 0 0 0 0\n0x000007fff, // 0 1 0 0 0 0 0 0 0\n0x00000ffff, // 0 0 0 0 0 0 0 0 1\n0x00001ffff, // 0 0 0 0 0 0 0 1 0\n0x00003ffff, // 0 0 0 0 0 0 1 0 0\n0x00007ffff, // 0 0 0 0 0 1 0 0 0\n0x0000fffff, // 0 0 0 0 1 0 0 0 0\n0x0001fffff, // 0 0 0 1 0 0 0 0 0\n0x0003fffff, // 0 0 1 0 0 0 0 0 0\n0x0007fffff, // 0 1 0 0 0 0 0 0 0\n0x000ffffff, // 0 0 0 0 0 0 0 0 1\n0x001ffffff, // 0 0 0 0 0 0 0 1 0\n0x003ffffff, // 0 0 0 0 0 0 1 0 0\n0x007ffffff, // 0 0 0 0 0 1 0 0 0\n0x00fffffff, // 0 0 0 0 1 0 0 0 0\n0x01fffffff, // 0 0 0 1 0 0 0 0 0\n0x03fffffff, // 0 0 1 0 0 0 0 0 0\n0x07fffffff, // 0 1 0 0 0 0 0 0 0\n0x0ffffffff,\n0x1ffffffff,\n0x3ffffffff\n];\n\nglobal INTEGER_UP_TO_62_IS_GREATER_THAN_31: [Field; 63] = [\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n];\nglobal NUM_BYTES_MOD_31_IS_ZERO: [Field; 31] = [\n    1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n];\nglobal BYTE_SHIFT: [Field; 32] = [\n        1,\n        0x1000000000000000000000000000000000000000000000000000000000000,\n        0x10000000000000000000000000000000000000000000000000000000000,\n        0x100000000000000000000000000000000000000000000000000000000,\n        0x1000000000000000000000000000000000000000000000000000000,\n        0x10000000000000000000000000000000000000000000000000000,\n        0x100000000000000000000000000000000000000000000000000,\n        0x1000000000000000000000000000000000000000000000000,\n        0x10000000000000000000000000000000000000000000000,\n        0x100000000000000000000000000000000000000000000,\n        0x1000000000000000000000000000000000000000000,\n        0x10000000000000000000000000000000000000000,\n        0x100000000000000000000000000000000000000,\n        0x1000000000000000000000000000000000000,\n        0x10000000000000000000000000000000000,\n        0x100000000000000000000000000000000,\n        0x1000000000000000000000000000000,\n        0x10000000000000000000000000000,\n        0x100000000000000000000000000,\n        0x1000000000000000000000000,\n        0x10000000000000000000000,\n        0x100000000000000000000,\n        0x1000000000000000000,\n        0x10000000000000000,\n        0x100000000000000,\n        0x1000000000000,\n        0x10000000000,\n        0x100000000,\n        0x1000000,\n        0x10000,\n        0x100,\n        1\n    ];\n\nglobal PATH_LOOKUP: [[bool; 5]; 32] = [\n        [false, false, false, false, false],\n        [true, false, false, false, false],\n        [false, true, false, false, false],\n        [true, true, false, false, false],\n        [false, false, true, false, false],\n        [true, false, true, false, false],\n        [false, true, true, false, false],\n        [true, true, true, false, false],\n        [false, false, false, true, false],\n        [true, false, false, true, false],\n        [false, true, false, true, false],\n        [true, true, false, true, false],\n        [false, false, true, true, false],\n        [true, false, true, true, false],\n        [false, true, true, true, false],\n        [true, true, true, true, false],\n        [false, false, false, false, true],\n        [true, false, false, false, true],\n        [false, true, false, false, true],\n        [true, true, false, false, true],\n        [false, false, true, false, true],\n        [true, false, true, false, true],\n        [false, true, true, false, true],\n        [true, true, true, false, true],\n        [false, false, false, true, true],\n        [true, false, false, true, true],\n        [false, true, false, true, true],\n        [true, true, false, true, true],\n        [false, false, true, true, true],\n        [true, false, true, true, true],\n        [false, true, true, true, true],\n        [true, true, true, true, true]\n    ];\n\n// #############################################################\n// ### METHODS\n// #############################################################\n\n/**\n * slice a field that represents bytes [0, ..., 31] into 5 chunks where:\n * chunk[0] = 1 byte\n * chunk[1] = 2 bytes\n * chunk[2] = 4 bytes\n * chunk[3] = 8 bytes\n * chunk[4] = 16 bytes\n *\n * some of the chunks will describe the bytes [0, ..., num_bytes - 1]\n * some of the chunks will describe the bytes [num_bytes, ..., 31]\n **/\nunconstrained fn __slice_field(f: Field, num_bytes: Field) -> [Field; 5] {\n    let head_path = PATH_LOOKUP[num_bytes];\n    let bytes: [u8; 32] = f.to_be_bytes();\n    let bytes = bytes.map(|b: u8| b as Field);\n\n    let mut chunks: [Field; 5] = [0; 5];\n    let mut head_ptr = 1;\n    let mut tail_ptr = num_bytes + 1;\n    if head_path[0] {\n        chunks[0] = bytes[head_ptr] as Field;\n        head_ptr += 1;\n    } else {\n        chunks[0] = bytes[tail_ptr] as Field;\n        tail_ptr += 1;\n    }\n    if head_path[1] {\n        chunks[1] = bytes[head_ptr] * 0x100 + bytes[head_ptr + 1];\n        head_ptr += 2;\n    } else {\n        chunks[1] = bytes[tail_ptr] * 0x100 + bytes[tail_ptr + 1];\n        tail_ptr += 2;\n    }\n    if head_path[2] {\n        chunks[2] = bytes[head_ptr] * 0x1000000 + bytes[head_ptr + 1] * 0x10000\n        + bytes[head_ptr + 2] * 0x100 + bytes[head_ptr + 3];\n        head_ptr += 4;\n    } else {\n        chunks[2] = bytes[tail_ptr] * 0x1000000 + bytes[tail_ptr + 1] * 0x10000\n        + bytes[tail_ptr + 2] * 0x100 + bytes[tail_ptr + 3];\n        tail_ptr += 4;\n    }\n    if head_path[3] {\n        chunks[3] =\n        bytes[head_ptr] * 0x100000000000000 + bytes[head_ptr + 1] * 0x1000000000000\n        + bytes[head_ptr + 2] * 0x10000000000 + bytes[head_ptr + 3] * 0x100000000\n        + bytes[head_ptr + 4] * 0x1000000 + bytes[head_ptr + 5] * 0x10000\n        + bytes[head_ptr + 6] * 0x100 + bytes[head_ptr + 7];\n        head_ptr += 8;\n    } else {\n        chunks[3] =\n        bytes[tail_ptr] * 0x100000000000000 + bytes[tail_ptr + 1] * 0x1000000000000\n        + bytes[tail_ptr + 2] * 0x10000000000 + bytes[tail_ptr + 3] * 0x100000000\n        + bytes[tail_ptr + 4] * 0x1000000 + bytes[tail_ptr + 5] * 0x10000\n        + bytes[tail_ptr + 6] * 0x100 + bytes[tail_ptr + 7];\n        tail_ptr += 8;\n    }\n    if head_path[4] {\n        chunks[4] =\n        bytes[head_ptr] *       0x1000000000000000000000000000000 + bytes[head_ptr + 1] * 0x10000000000000000000000000000\n        + bytes[head_ptr + 2] * 0x100000000000000000000000000 + bytes[head_ptr + 3] *      0x1000000000000000000000000\n        + bytes[head_ptr + 4] * 0x10000000000000000000000 + bytes[head_ptr + 5] * 0x100000000000000000000\n        + bytes[head_ptr + 6] * 0x1000000000000000000 + bytes[head_ptr + 7] * 0x10000000000000000\n        + bytes[head_ptr + 8] * 0x100000000000000 + bytes[head_ptr + 9] * 0x1000000000000\n        + bytes[head_ptr + 10] * 0x10000000000 + bytes[head_ptr + 11] * 0x100000000\n        + bytes[head_ptr + 12] * 0x1000000 + bytes[head_ptr + 13] * 0x10000\n        + bytes[head_ptr + 14] * 0x100 + bytes[head_ptr + 15];\n    } else {\n        chunks[4] =\n        bytes[tail_ptr] * 0x1000000000000000000000000000000 + bytes[tail_ptr + 1] * 0x10000000000000000000000000000\n        + bytes[tail_ptr + 2] * 0x100000000000000000000000000 + bytes[tail_ptr + 3] * 0x1000000000000000000000000\n        + bytes[tail_ptr + 4] * 0x10000000000000000000000 + bytes[tail_ptr + 5] * 0x100000000000000000000\n        + bytes[tail_ptr + 6] * 0x1000000000000000000 + bytes[tail_ptr + 7] * 0x10000000000000000\n        + bytes[tail_ptr + 8] * 0x100000000000000 + bytes[tail_ptr + 9] * 0x1000000000000\n        + bytes[tail_ptr + 10] * 0x10000000000 + bytes[tail_ptr + 11] * 0x100000000\n        + bytes[tail_ptr + 12] * 0x1000000 + bytes[tail_ptr + 13] * 0x10000\n        + bytes[tail_ptr + 14] * 0x100 + bytes[tail_ptr + 15];\n    }\n\n    chunks\n}\n\nunconstrained fn __divmod(numerator: Field, denominator: Field) -> (Field, Field) {\n    let quotient = numerator as u32 / denominator as u32;\n    let remainder = numerator as u32 % denominator as u32;\n    (quotient as Field, remainder as Field)\n}\n\n/**\n * @brief cheeky divmod method for dividing a u16 by 31\n *        we know the quotient will fit into a 14 bit range check which will save us some fractional gates\n **/\nfn divmod_31(numerator: Field) -> (Field, Field) {\n    let (quotient, remainder) = __divmod(numerator, 31);\n\n    let qf = quotient as Field;\n    let rf = remainder as Field;\n\n    // note: these range checks are because we know the denominator is 31\n    // TODO: need more checks, atm remainder could equal 31\n    qf.assert_max_bit_size(14);\n    rf.assert_max_bit_size(5);\n\n    // n / d = q\n    // d * q + r = n\n    assert(qf * 31 as Field + rf == numerator as Field);\n    (quotient, remainder)\n}\n\n/**\n * @brief converts a 16 bit value into 16 fake bools (Field elements that are 0 or 1)\n **/\nunconstrained fn decompose(val: Field) -> [Field; 16] {\n    let mut r: [Field; 16] = [0; 16];\n\n    let mut it = val as u32;\n    for i in 0..16 {\n        r[i] = (it & 1) as Field;\n        it >>= 1;\n    }\n    r\n}\n\n// 5 gates?\npub fn get_last_limb_path<let OutputFields: u32>(last_limb_index: Field) -> [Field; OutputFields] {\n    // TODO we offset by 1 explain why (0 byte length produces 0 - 1 which = invalid array index. we just add 1 and increase array length by 1 to compensate)\n    let path = LAST_LIMB_PATH[last_limb_index + 1]; // 2\n\n    let path_valid_bits = decompose(path);\n    let mut path_valid_sum: Field = 0;\n    let mut path_valid_output: [Field; OutputFields] = [0; OutputFields];\n    for i in 0..OutputFields {\n        assert(path_valid_bits[i] * path_valid_bits[i] - path_valid_bits[i] == 0);\n        path_valid_sum += (path_valid_bits[i] * (1 << i as u8) as Field);\n        path_valid_output[i] = path_valid_bits[i];\n    }\n    assert(path_valid_sum == path);\n    path_valid_output\n}\n\n/**\n * @brief slice a Field `f`, that represents 31-bytes, into two outputs `head, tail`\n *        where `head = f.slice(0, num_bytes)`, `tail = f.slice(num_bytes, 31)`\n * @details cost 46 gates\n **/\npub fn slice_field(f: Field, num_bytes: Field) -> (Field, Field) {\n    let chunks = __slice_field(f, num_bytes);\n    chunks[0].assert_max_bit_size(8); // 1.25 gates\n    chunks[1].assert_max_bit_size(16); // 1.5 gates\n    chunks[2].assert_max_bit_size(32); // 1.75 gates\n    chunks[3].assert_max_bit_size(64); // 3.25 gates\n    chunks[4].assert_max_bit_size(128); // 7.5 gates\n\n    let mut head: Field = 0;\n    let mut tail: Field = 0;\n\n    // 15 gates\n    let temp = path_multipliers_chunk4[num_bytes];\n    head = chunks[4] * temp;\n    std::as_witness(head);\n    head += chunks[3] * path_multipliers_chunk3[num_bytes];\n    std::as_witness(head);\n    head += chunks[2] * path_multipliers_chunk2[num_bytes];\n    std::as_witness(head);\n    head += chunks[1] * path_multipliers_chunk1[num_bytes];\n    std::as_witness(head);\n    head += chunks[0] * path_multipliers_chunk0[num_bytes];\n\n    // 13 gates\n    tail = chunks[4] * (1 - temp);\n    std::as_witness(tail);\n    tail += chunks[3] * tail_path_multipliers_chunk3[num_bytes];\n    std::as_witness(tail);\n    tail += chunks[2] * tail_path_multipliers_chunk2[num_bytes];\n    std::as_witness(tail);\n    tail += chunks[1] * tail_path_multipliers_chunk1[num_bytes];\n    std::as_witness(tail);\n    tail += chunks[0] * tail_path_multipliers_chunk0[num_bytes];\n    std::as_witness(tail);\n\n    // 3 gates\n    let total = tail + head * BYTE_SHIFT[num_bytes];\n    assert(total == f);\n\n    // total 46.25 gates\n    (head, tail)\n}\n\n/**\n * @brief Given an array of fields that pack 31 bytes, return an array that slices the packed byte array at a given index for a given number of bytes\n * @description Some serious dark black magic nonsense going on here. TODO: document\n **/\npub fn slice_fields<let InputFields: u32, let OutputFields: u32>(\n    data: [Field; InputFields],\n    start_byte: Field,\n    num_bytes: Field\n) -> [Field; OutputFields] {\n    // 3.5\n    let (start_index, start_mod_31) = divmod_31(start_byte);\n    let num_underflow_bytes = start_mod_31;\n    // 3.5, 7\n    let (num_bytes_div_31, num_bytes_mod_31) = divmod_31(num_bytes);\n\n    // 2, 9\n    let num_bytes_mod_31_is_0 = NUM_BYTES_MOD_31_IS_ZERO[num_bytes_mod_31];\n    // 2, 11\n    let num_bytes_div_31_is_0 = NUM_BYTES_MOD_31_IS_ZERO[num_bytes_div_31];\n\n    // 1, 12\n    let lookup = (-num_bytes_div_31_is_0 * num_bytes) - start_mod_31 + 62;\n    std::as_witness(lookup);\n    // 3, 15\n    let bytes_fit_into_limb = INTEGER_UP_TO_62_IS_GREATER_THAN_31[lookup] * num_bytes_div_31_is_0;\n    std::as_witness(bytes_fit_into_limb);\n\n    // 2, 17\n    let num_unused_bytes_in_start_limb = (num_bytes + start_mod_31 - 31) * bytes_fit_into_limb + (31 - start_mod_31);\n    std::as_witness(num_unused_bytes_in_start_limb);\n    let num_remaining_bytes = num_bytes - num_unused_bytes_in_start_limb;\n\n    // 4.5, 21.5\n    let mut (num_whole_limbs, num_overflow_bytes) = divmod_31(num_remaining_bytes);\n    // 44, 65.5\n    let (_, tail) = slice_field(data[start_index], num_underflow_bytes);\n\n    let mut previous = tail;\n\n    let mut result = [0; OutputFields];\n\n    // 4, 69.5\n    let extra_head_section = INTEGER_UP_TO_62_IS_GREATER_THAN_31[num_overflow_bytes - start_mod_31 + 31]\n        * (1 - bytes_fit_into_limb);\n\n    // 1, 70.5\n    let index_of_output_limb: Field = (num_bytes_div_31 - num_bytes_mod_31_is_0);\n    // 5, 75.5\n    let path_valid_output: [Field; OutputFields] = get_last_limb_path(index_of_output_limb);\n\n    // 2, 77.5\n    let tail_shift = BYTE_SHIFT[num_unused_bytes_in_start_limb];\n\n    // 51, 128.5\n    for i in 0..(OutputFields - 1) {\n        // 0\n        let slice_valid = path_valid_output[i];\n        // 1\n        let data_index = (start_index + 1 + i as Field);\n        // 2, 3\n        let input_slice = data[data_index];\n        // 44, 47\n        let (head, tail) = slice_field(input_slice, num_underflow_bytes);\n        // 1, 48\n        let combined = previous * tail_shift + head;\n        // 1, 49\n        result[i] = combined * slice_valid;\n        // 2, 51\n        previous = (tail - previous) * slice_valid + previous;\n    }\n\n    // 2, 130.5\n    let slice_size = (num_bytes + start_mod_31) * bytes_fit_into_limb + num_overflow_bytes;\n\n    // 1, 131.5\n    let use_previous_for_last_limb: Field = extra_head_section + bytes_fit_into_limb;\n\n    // 1, 132.5\n    let mut index_of_overflow_limb = start_index + num_whole_limbs + 1;\n    // 2, 134.5\n    let last_limb_from_data = data[index_of_overflow_limb];\n    // 2, 136.5\n    let slice_source = (previous - last_limb_from_data) * use_previous_for_last_limb + last_limb_from_data;\n\n    // 44, 180.5\n    let (head, _) = slice_field(slice_source, slice_size);\n\n    // 3, 183.5\n    let previous_shift = BYTE_SHIFT[31 - num_overflow_bytes]; // could save 1 gate by making different shift table\n    // 2, 185.5\n    let last_limb_shift = BYTE_SHIFT[num_bytes_mod_31];\n    // 1, 186.5\n    let mut last_limb = (previous * previous_shift);\n    std::as_witness(last_limb);\n    // 1, 187.5\n    last_limb = last_limb * (-use_previous_for_last_limb) + last_limb + head;\n    std::as_witness(last_limb);\n    // 1, 188.5\n    last_limb = last_limb * last_limb_shift;\n    std::as_witness(last_limb);\n\n    let mut path: [Field; OutputFields] = [0; OutputFields];\n    // 2, 190.5\n    for i in 1..OutputFields {\n        path[i] = path_valid_output[i] * -path_valid_output[i-1] + path_valid_output[i-1];\n    }\n    // 1, 191.5\n    path[0] = (1 - path_valid_output[0]);\n\n    // 4, 195.5\n    // actual valud = 182, missing gates?\n    for i in 0..OutputFields {\n        // 2\n        result[i] = (last_limb - result[i]) * path[i] + result[i];\n        // std::as_witness(result[i]);\n    }\n    // actual value = 182?\n    result\n}\n\nmod test {\n    use crate::_string_tools::slice_packed_field::slice_field;\n    use crate::_string_tools::slice_packed_field::slice_fields;\n\n    unconstrained fn build_slices_for_test<let N: u32>(\n        bytes: [u8; N],\n        start: u32,\n        num_bytes: u32\n    ) -> [Field; 3] {\n        let mut slices: [Field; 3] = [0; 3];\n        for i in 0..3 {\n            for k in 0..31 {\n                let mut idx = i * 31 + k;\n                slices[i] *= 0x100;\n                if (idx < num_bytes) {\n                    slices[i] += bytes[idx + start] as Field;\n                }\n            }\n        }\n        slices\n    }\n\n    #[test]\nfn test_slice_fields_nolength() {\n        let text: [u8; 1405] = \"Charlie is genius, right. He's made from a million pieces of old bubble gum. Imagine that! In the summer of 1976, on his way home from an Alice Cooper concert, Charlie started to melt onto the pavement. It was too hot in L.A., and he melted like a pink bitch. Luckily though, there was Eric Phillips, a local crocodile who dabbled in black magic. He took pity on Charlie and scraped him off the floor with a pair of fish slicers. He poured him into an antique soup ladle, and boarded his magic carpet. Destination: Alaska! Eric Phillips decided to refreeze Charlie, but in his cold-blooded reptilian haste, he refroze him into to the shape of a Hoover. Charlie wasn't fazed though, he just zoomed about the place, sucking up Inuits. Ha ha! Oh. The Inuits didn't mind; they loved it in Charlie's pink, tight warm belly pouch, and they refused to come out. Charlie said, \\\"I'm cool with that,\\\" and set fire to a posh hammer to make it official. he downside was that the Inuits suffocated immediately. It was air-tight in there. Charlie panicked and fired the tiny Inuit bullets into Eric's crocodile peepers. The green shape was frozen. After a quick drink, Charlie stole Eric Phillips's magic carpet and left for Seattle. Charlie was racked with guilt: he'd killed 50 Inuits, noone needs that. He decided to spend the rest of his life putting small hairstyles onto boots, monkey nuts, trumpets and spanners.\".as_bytes();\n        println(f\"text = {text}\");\n        let mut slices: [Field; 46 + 3] = [0; 46 + 3];\n        for i in 0..46 {\n            for j in 0..31 {\n                let mut idx = i * 31 + j;\n                slices[i] *= 0x100;\n                if (idx < 1405) {\n                    slices[i] += text[idx] as Field;\n                }\n            }\n        }\n        // let start_byte = 26;\n\n        let num_bytes = 0;\n        let start_byte: u32 = 0;\n        let mut expected_slices: [Field; 3] = build_slices_for_test(text, start_byte, num_bytes);\n        let result_slices: [Field; 3] = slice_fields(slices, start_byte as Field, num_bytes as Field);\n        assert(result_slices == expected_slices);\n    }\n\n    #[test]\nfn test_slice_fields() {\n        let text: [u8; 1405] = \"Charlie is genius, right. He's made from a million pieces of old bubble gum. Imagine that! In the summer of 1976, on his way home from an Alice Cooper concert, Charlie started to melt onto the pavement. It was too hot in L.A., and he melted like a pink bitch. Luckily though, there was Eric Phillips, a local crocodile who dabbled in black magic. He took pity on Charlie and scraped him off the floor with a pair of fish slicers. He poured him into an antique soup ladle, and boarded his magic carpet. Destination: Alaska! Eric Phillips decided to refreeze Charlie, but in his cold-blooded reptilian haste, he refroze him into to the shape of a Hoover. Charlie wasn't fazed though, he just zoomed about the place, sucking up Inuits. Ha ha! Oh. The Inuits didn't mind; they loved it in Charlie's pink, tight warm belly pouch, and they refused to come out. Charlie said, \\\"I'm cool with that,\\\" and set fire to a posh hammer to make it official. he downside was that the Inuits suffocated immediately. It was air-tight in there. Charlie panicked and fired the tiny Inuit bullets into Eric's crocodile peepers. The green shape was frozen. After a quick drink, Charlie stole Eric Phillips's magic carpet and left for Seattle. Charlie was racked with guilt: he'd killed 50 Inuits, noone needs that. He decided to spend the rest of his life putting small hairstyles onto boots, monkey nuts, trumpets and spanners.\".as_bytes();\n        println(f\"text = {text}\");\n        let mut slices: [Field; 46 + 3] = [0; 46 + 3];\n        for i in 0..46 {\n            for j in 0..31 {\n                let mut idx = i * 31 + j;\n                slices[i] *= 0x100;\n                if (idx < 1405) {\n                    slices[i] += text[idx] as Field;\n                }\n            }\n        }\n        // let start_byte = 26;\n\n        let byte_sizes: [u32; 10] = [\n            0,\n            1,\n            5,\n            30,\n            31,\n            32,\n            47,\n            61,\n            62,\n            90\n        ];\n\n        let byte_positions: [u32; 18] = [\n            0,\n            1,\n            14,\n            15,\n            16,\n            20,\n            28,\n            29,\n            30,\n            31,\n            32,\n            33,\n            38,\n            40,\n            55,\n            60,\n            61,\n            62\n        ];\n\n        for i in 0..10 {\n            let num_bytes = byte_sizes[i];\n            for j in 0..18 {\n                let start_byte: u32 = byte_positions[j];\n                let mut expected_slices: [Field; 3] = build_slices_for_test(text, start_byte, num_bytes);\n                let result_slices: [Field; 3] = slice_fields(slices, start_byte as Field, num_bytes as Field);\n                assert(result_slices == expected_slices);\n            }\n\n            for j in 0..18 {\n                let start_byte: u32 = text.len() - num_bytes - byte_positions[j];\n                let mut expected_slices: [Field; 3] = build_slices_for_test(text, start_byte, num_bytes);\n                let result_slices: [Field; 3] = slice_fields(slices, start_byte as Field, num_bytes as Field);\n                assert(result_slices == expected_slices);\n            }\n        }\n    }\n\n    #[test]\nfn test_slice_field() {\n        let input = 0xffeebbccbbaa99887766554433221100112233445566778899aabbccddeeff;\n\n        let input_bytes: [u8; 32] = input.to_be_bytes();\n\n        for i in 0..32 {\n            println(f\"i = {i}\");\n            let num_bytes = i as Field;\n            let (head, tail) = slice_field(input, num_bytes);\n            let mut expected_head: Field = 0;\n            let mut expected_tail: Field = 0;\n            for j in 0..num_bytes as u32 {\n                expected_head *= 0x100;\n                expected_head += input_bytes[j + 1] as Field;\n            }\n            for j in 0..(31 - num_bytes as u32) {\n                expected_tail *= 0x100;\n                expected_tail += input_bytes[j as Field + num_bytes + 1] as Field;\n            }\n            assert(expected_head == head);\n            assert(expected_tail == tail);\n        }\n        let (head, tail) = slice_field(input, 11);\n        let head_expected = 0xffeebbccbbaa9988776655;\n        let tail_expected = 0x4433221100112233445566778899aabbccddeeff;\n        assert(head_expected == head);\n        assert(tail_expected == tail);\n    }\n}\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/_string_tools/slice_packed_field.nr"},"95":{"source":"use crate::enums::Token::NUM_TOKENS_MUL_2;\n\nglobal TOKEN_ENDS_OBJECT_OR_ARRAY : [Field; 11] = [0,0,1,0,1,0,0,0,0,0,0];\nglobal TOKEN_IS_ARRAY_OBJECT_OR_VALUE: [Field; 11] = [0,1,0,1,0,0,0,1,1,1,0];\nglobal TOKEN_FLAGS_TABLE: [Field; NUM_TOKENS_MUL_2] = [0x01, 0x0100000000, 0x01010000000000, 0x0101000000, 0x01010000000000, 0x01, 0x01, 0x01000000000101, 0x01000000000101, 0x01000000000101, 0x010001, 0x01000001, 0x0100000000, 0x01010000000000, 0x0101000000, 0x01010000000000, 0x01000001, 0x01000001, 0x01000001000101, 0x01000001000101, 0x01000001000101, 0x01010001];\nglobal PROCESS_RAW_TRANSCRIPT_TABLE: [Field; 1024] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x060006, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x050005, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x030003, 0x00, 0x040004, 0x00, 0x00, 0x00, 0x090009, 0x00, 0x00, 0x00, 0x090009, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x090009, 0x00, 0x090009, 0x00, 0x00, 0x00, 0x090009, 0x090009, 0x090009, 0x090009, 0x00, 0x00, 0x00, 0x00, 0x00, 0x010001, 0x00, 0x020002, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x060000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x050000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x030000, 0x00, 0x040000, 0x00, 0x00, 0x00, 0x090000, 0x00, 0x00, 0x00, 0x090000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x090000, 0x00, 0x090000, 0x00, 0x00, 0x00, 0x090000, 0x090000, 0x090000, 0x090000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x010000, 0x00, 0x020000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x060108, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x050000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x030000, 0x00, 0x040108, 0x00, 0x00, 0x00, 0x090000, 0x00, 0x00, 0x00, 0x090000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x090000, 0x00, 0x090000, 0x00, 0x00, 0x00, 0x090000, 0x090000, 0x090000, 0x090000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x010000, 0x00, 0x020108, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x060109, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x050000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x030000, 0x00, 0x040109, 0x00, 0x00, 0x00, 0x090000, 0x00, 0x00, 0x00, 0x090000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x090000, 0x00, 0x090000, 0x00, 0x00, 0x00, 0x090000, 0x090000, 0x090000, 0x090000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x010000, 0x00, 0x020109, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];\nglobal ASCII_TO_TOKEN_TABLE: [Field; 1024] = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x09, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x09, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];\nglobal JSON_CAPTURE_TABLE: [Field; 2048] = [0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x00, 0x00, 0x0100000004, 0x0100000004, 0x00, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x00, 0x0100000004, 0x01, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100010004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100010004, 0x010003, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100010004, 0x0100000004, 0x010003, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100010004, 0x010003, 0x0100010004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x01, 0x01, 0x0100000004, 0x0100000004, 0x01, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x010001, 0x010001, 0x0100, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x01010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x0100000004, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000104, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000104, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x010003, 0x0100000004, 0x0100000004, 0x0100000004, 0x010003, 0x0100010003, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x010003, 0x0100000004, 0x0100010003, 0x0100000004, 0x0100000004, 0x0100000004, 0x010003, 0x010003, 0x0100010004, 0x010003, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x00, 0x00, 0x0100000004, 0x0100000004, 0x00, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x00, 0x0100000004, 0x010001, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100010004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100010004, 0x010003, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100010004, 0x0100000004, 0x010003, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100010004, 0x010003, 0x0100010004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x01, 0x01, 0x0100000004, 0x0100000004, 0x01, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x01010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x010001, 0x0100000004, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x010001, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x010002, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x010001, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000004, 0x010003, 0x0100000004, 0x0100000004, 0x0100000004, 0x010003, 0x0100010003, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x010003, 0x0100000004, 0x0100010003, 0x0100000004, 0x0100000004, 0x0100000004, 0x010003, 0x010003, 0x0100010004, 0x010003, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100000004, 0x0100, 0x0100000004, 0x0100000004, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000, 0x0100000000];\nglobal TOKEN_VALIDATION_TABLE: [Field; 363] = [0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x010000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x00, 0x01000000, 0x010000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x010000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01, 0x01000000, 0x0101, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x00, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x010000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x010000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x010000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x010000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01, 0x01000000, 0x0101, 0x010000, 0x01000000, 0x01000000, 0x00, 0x00, 0x00, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x010000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01, 0x01000000, 0x0101, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x00, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x010000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x010000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x010000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01, 0x01000000, 0x0101, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x00, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x00, 0x01000000, 0x01000000, 0x01000000, 0x01000000, 0x01000000];\nglobal ASCII_TO_NUMBER: [u8; 128] = [\n        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n        /*   */ 0,\n        /*\"!\"*/ 0,\n        /* \" */ 0,\n        /*\"#\"*/ 0,\n        /*\"$\"*/ 0,\n        /*\"%\"*/ 0,\n        /*\"&\"*/ 0,\n        /*\"'\"*/ 0,\n        /*\"(\"*/ 0,\n        /*\")\"*/ 0,\n        /*\"*\"*/ 0,\n        /*\"+\"*/ 0,\n        /*\",\"*/ 0,\n        /*\"-\"*/ 0,\n        /*\".\"*/ 0,\n        /*\"/\"*/ 0,\n        /*\"0\"*/ 0,   // numeric value\n        /*\"1\"*/ 1,   // numeric value\n        /*\"2\"*/ 2,   // numeric value\n        /*\"3\"*/ 3,   // numeric value\n        /*\"4\"*/ 4,   // numeric value\n        /*\"5\"*/ 5,   // numeric value\n        /*\"6\"*/ 6,   // numeric value\n        /*\"7\"*/ 7,   // numeric value\n        /*\"8\"*/ 8,   // numeric value\n        /*\"9\"*/ 9,   // numeric value\n        /*\":\"*/ 0,\n        /*\";\"*/ 0,\n        /*\"<\"*/ 0,\n        /*\"=\"*/ 0,\n        /*\">\"*/ 0,\n        /*\"?\"*/ 0,\n        /*\"@\"*/ 0,\n        /*\"A\"*/ 0,\n        /*\"B\"*/ 0,\n        /*\"C\"*/ 0,\n        /*\"D\"*/ 0,\n        /*\"E\"*/ 0,\n        /*\"F\"*/ 0,\n        /*\"G\"*/ 0,\n        /*\"H\"*/ 0,\n        /*\"I\"*/ 0,\n        /*\"J\"*/ 0,\n        /*\"K\"*/ 0,\n        /*\"L\"*/ 0,\n        /*\"M\"*/ 0,\n        /*\"N\"*/ 0,\n        /*\"O\"*/ 0,\n        /*\"P\"*/ 0,\n        /*\"Q\"*/ 0,\n        /*\"R\"*/ 0,\n        /*\"S\"*/ 0,\n        /*\"T\"*/ 0,\n        /*\"U\"*/ 0,\n        /*\"V\"*/ 0,\n        /*\"W\"*/ 0,\n        /*\"X\"*/ 0,\n        /*\"Y\"*/ 0,\n        /*\"Z\"*/ 0,\n        /*\"[\"*/ 0,   // an array\n        /*\"\\\"*/ 0,\n        /*\"]\"*/ 0,\n        /*\"^\"*/ 0,\n        /*\"_\"*/ 0,\n        /*\"`\"*/ 0,\n        /*\"a\"*/ 0,\n        /*\"b\"*/ 0,\n        /*\"c\"*/ 0,\n        /*\"d\"*/ 0,\n        /*\"e\"*/ 0,\n        /*\"f\"*/ 0,   // \"0\"\n        /*\"g\"*/ 0,\n        /*\"h\"*/ 0,\n        /*\"i\"*/ 0,\n        /*\"j\"*/ 0,\n        /*\"k\"*/ 0,\n        /*\"l\"*/ 0,\n        /*\"m\"*/ 0,\n        /*\"n\"*/ 0,\n        /*\"o\"*/ 0,\n        /*\"p\"*/ 0,\n        /*\"q\"*/ 0,\n        /*\"r\"*/ 0,\n        /*\"s\"*/ 0,\n        /*\"t\"*/ 0,   // \"0\"\n        /*\"u\"*/ 0,\n        /*\"v\"*/ 0,\n        /*\"w\"*/ 0,\n        /*\"x\"*/ 0,\n        /*\"y\"*/ 0,\n        /*\"z\"*/ 0,\n        /*\"{\"*/ 0,   // an object\n        /*\"|\"*/ 0,\n        /*\"}\"*/ 0,\n        /*\"~\"*/ 0,\n        /*DEL*/ 0,\n    ];\n\nglobal ESCAPE_SEQUENCE_END_CHARS: [bool; 128] = [\n        /* NULL */ false,\n        /* SOH */ false,\n        /* TXT */ false,\n        /* ETX */ false,\n        /* EOT */ false,\n        /* ENQ */ false,\n        /* ACK */ false,\n        /* BEL */ false,\n        /* BS */ false,\n        /* TAB */ false,\n        /* NL */ false,\n        /* VT */ false,\n        /* FF */ false,\n        /* CR */ false,\n        /* SI */ false,\n        /* SO */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /* SPACE */ false,\n        /*\"!\"*/ false,\n        /* \" */ true,   // replace \\\" with double quote\n        /*\"#\"*/ false,\n        /*\"$\"*/ false,\n        /*\"%\"*/ false,\n        /*\"&\"*/ false,\n        /*\"'\"*/ false,\n        /*\"(\"*/ false,\n        /*\")\"*/ false,\n        /*\"*\"*/ false,\n        /*\"+\"*/ false,\n        /*\",\"*/ false,\n        /*\"-\"*/ false,\n        /*\".\"*/ false,\n        /*\"/\"*/ false,\n        /*\"0\"*/ false,\n        /*\"1\"*/ false,\n        /*\"2\"*/ false,\n        /*\"3\"*/ false,\n        /*\"4\"*/ false,\n        /*\"5\"*/ false,\n        /*\"6\"*/ false,\n        /*\"7\"*/ false,\n        /*\"8\"*/ false,\n        /*\"9\"*/ false,\n        /*\":\"*/ false,\n        /*\";\"*/ false,\n        /*\"<\"*/ false,\n        /*\"=\"*/ false,\n        /*\">\"*/ false,\n        /*\"?\"*/ false,\n        /*\"@\"*/ false,\n        /*\"A\"*/ false,\n        /*\"B\"*/ false,\n        /*\"C\"*/ false,\n        /*\"D\"*/ false,\n        /*\"E\"*/ false,\n        /*\"F\"*/ false,\n        /*\"G\"*/ false,\n        /*\"H\"*/ false,\n        /*\"I\"*/ false,\n        /*\"J\"*/ false,\n        /*\"K\"*/ false,\n        /*\"L\"*/ false,\n        /*\"M\"*/ false,\n        /*\"N\"*/ false,\n        /*\"O\"*/ false,\n        /*\"P\"*/ false,\n        /*\"Q\"*/ false,\n        /*\"R\"*/ false,\n        /*\"S\"*/ false,\n        /*\"T\"*/ false,\n        /*\"U\"*/ false,\n        /*\"V\"*/ false,\n        /*\"W\"*/ false,\n        /*\"X\"*/ false,\n        /*\"Y\"*/ false,\n        /*\"Z\"*/ false,\n        /*\"[\"*/ false,\n        /*\"\\\"*/ true, // replace \\\\ with \\\n        /*\"]\"*/ false,\n        /*\"^\"*/ false,\n        /*\"_\"*/ false,\n        /*\"`\"*/ false,\n        /*\"a\"*/ false,\n        /*\"b\"*/ true,  // replace \\b with backspace\n        /*\"c\"*/ false,\n        /*\"d\"*/ false,\n        /*\"e\"*/ false,\n        /*\"f\"*/ true, // replace \\f with form feed\n        /*\"g\"*/ false,\n        /*\"h\"*/ false,\n        /*\"i\"*/ false,\n        /*\"j\"*/ false,\n        /*\"k\"*/ false,\n        /*\"l\"*/ false,\n        /*\"m\"*/ false,\n        /*\"n\"*/ true, // replace \\n with line feed\n        /*\"o\"*/ false,\n        /*\"p\"*/ false,\n        /*\"q\"*/ false,\n        /*\"r\"*/ true, // replace \\r with carriage return\n        /*\"s\"*/ false,\n        /*\"t\"*/ true,  // replace \\t with tab\n        /*\"u\"*/ false,\n        /*\"v\"*/ false,\n        /*\"w\"*/ false,\n        /*\"x\"*/ false,\n        /*\"y\"*/ false,\n        /*\"z\"*/ false,\n        /*\"{\"*/ false,\n        /*\"|\"*/ false,\n        /*\"}\"*/ false,\n        /*\"~\"*/ false,\n        /*DEL*/ false,\n    ];\n\nglobal ESCAPE_SEQUENCE_START_CHARS: [bool; 128] = [\n        /* NULL */ false,\n        /* SOH */ false,\n        /* TXT */ false,\n        /* ETX */ false,\n        /* EOT */ false,\n        /* ENQ */ false,\n        /* ACK */ false,\n        /* BEL */ false,\n        /* BS */ false,\n        /* TAB */ false,\n        /* NL */ false,\n        /* VT */ false,\n        /* FF */ false,\n        /* CR */ false,\n        /* SI */ false,\n        /* SO */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /*  */ false,\n        /* SPACE */ false,\n        /*\"!\"*/ false,\n        /* \" */ false,\n        /*\"#\"*/ false,\n        /*\"$\"*/ false,\n        /*\"%\"*/ false,\n        /*\"&\"*/ false,\n        /*\"'\"*/ false,\n        /*\"(\"*/ false,\n        /*\")\"*/ false,\n        /*\"*\"*/ false,\n        /*\"+\"*/ false,\n        /*\",\"*/ false,\n        /*\"-\"*/ false,\n        /*\".\"*/ false,\n        /*\"/\"*/ false,\n        /*\"0\"*/ false,\n        /*\"1\"*/ false,\n        /*\"2\"*/ false,\n        /*\"3\"*/ false,\n        /*\"4\"*/ false,\n        /*\"5\"*/ false,\n        /*\"6\"*/ false,\n        /*\"7\"*/ false,\n        /*\"8\"*/ false,\n        /*\"9\"*/ false,\n        /*\":\"*/ false,\n        /*\";\"*/ false,\n        /*\"<\"*/ false,\n        /*\"=\"*/ false,\n        /*\">\"*/ false,\n        /*\"?\"*/ false,\n        /*\"@\"*/ false,\n        /*\"A\"*/ false,\n        /*\"B\"*/ false,\n        /*\"C\"*/ false,\n        /*\"D\"*/ false,\n        /*\"E\"*/ false,\n        /*\"F\"*/ false,\n        /*\"G\"*/ false,\n        /*\"H\"*/ false,\n        /*\"I\"*/ false,\n        /*\"J\"*/ false,\n        /*\"K\"*/ false,\n        /*\"L\"*/ false,\n        /*\"M\"*/ false,\n        /*\"N\"*/ false,\n        /*\"O\"*/ false,\n        /*\"P\"*/ false,\n        /*\"Q\"*/ false,\n        /*\"R\"*/ false,\n        /*\"S\"*/ false,\n        /*\"T\"*/ false,\n        /*\"U\"*/ false,\n        /*\"V\"*/ false,\n        /*\"W\"*/ false,\n        /*\"X\"*/ false,\n        /*\"Y\"*/ false,\n        /*\"Z\"*/ false,\n        /*\"[\"*/ false,\n        /*\"\\\"*/ true, // replace \\\\ with \\\n        /*\"]\"*/ false,\n        /*\"^\"*/ false,\n        /*\"_\"*/ false,\n        /*\"`\"*/ false,\n        /*\"a\"*/ false,\n        /*\"b\"*/ false, \n        /*\"c\"*/ false,\n        /*\"d\"*/ false,\n        /*\"e\"*/ false,\n        /*\"f\"*/ false,\n        /*\"g\"*/ false,\n        /*\"h\"*/ false,\n        /*\"i\"*/ false,\n        /*\"j\"*/ false,\n        /*\"k\"*/ false,\n        /*\"l\"*/ false,\n        /*\"m\"*/ false,\n        /*\"n\"*/ false,\n        /*\"o\"*/ false,\n        /*\"p\"*/ false,\n        /*\"q\"*/ false,\n        /*\"r\"*/ false,\n        /*\"s\"*/ false,\n        /*\"t\"*/ false,\n        /*\"u\"*/ false,\n        /*\"v\"*/ false,\n        /*\"w\"*/ false,\n        /*\"x\"*/ false,\n        /*\"y\"*/ false,\n        /*\"z\"*/ false,\n        /*\"{\"*/ false,\n        /*\"|\"*/ false,\n        /*\"}\"*/ false,\n        /*\"~\"*/ false,\n        /*DEL*/ false,\n    ];\n\nglobal ESCAPE_SEQUENCE_REPLACEMENT: [u8; 128] = [\n        /* NULL */ 0,\n        /* SOH */ 0,\n        /* TXT */ 0,\n        /* ETX */ 0,\n        /* EOT */ 0,\n        /* ENQ */ 0,\n        /* ACK */ 0,\n        /* BEL */ 0,\n        /* BS */ 0,\n        /* TAB */ 0,\n        /* NL */ 0,\n        /* VT */ 0,\n        /* FF */ 0,\n        /* CR */ 0,\n        /* SI */ 0,\n        /* SO */ 0,\n        /*  */ 0,\n        /*  */ 0,\n        /*  */ 0,\n        /*  */ 0,\n        /*  */ 0,\n        /*  */ 0,\n        /*  */ 0,\n        /*  */ 0,\n        /*  */ 0,\n        /*  */ 0,\n        /*  */ 0,\n        /*  */ 0,\n        /*  */ 0,\n        /*  */ 0,\n        /*  */ 0,\n        /*  */ 0,\n        /* SPACE */ 0,\n        /*\"!\"*/ 0,\n        /* \" */ 34,   // replace \\\" with double quote\n        /*\"#\"*/ 0,\n        /*\"$\"*/ 0,\n        /*\"%\"*/ 0,\n        /*\"&\"*/ 0,\n        /*\"'\"*/ 0,\n        /*\"(\"*/ 0,\n        /*\")\"*/ 0,\n        /*\"*\"*/ 0,\n        /*\"+\"*/ 0,\n        /*\",\"*/ 0,\n        /*\"-\"*/ 0,\n        /*\".\"*/ 0,\n        /*\"/\"*/ 0,\n        /*\"0\"*/ 0,\n        /*\"1\"*/ 0,\n        /*\"2\"*/ 0,\n        /*\"3\"*/ 0,\n        /*\"4\"*/ 0,\n        /*\"5\"*/ 0,\n        /*\"6\"*/ 0,\n        /*\"7\"*/ 0,\n        /*\"8\"*/ 0,\n        /*\"9\"*/ 0,\n        /*\":\"*/ 0,\n        /*\";\"*/ 0,\n        /*\"<\"*/ 0,\n        /*\"=\"*/ 0,\n        /*\">\"*/ 0,\n        /*\"?\"*/ 0,\n        /*\"@\"*/ 0,\n        /*\"A\"*/ 0,\n        /*\"B\"*/ 0,\n        /*\"C\"*/ 0,\n        /*\"D\"*/ 0,\n        /*\"E\"*/ 0,\n        /*\"F\"*/ 0,\n        /*\"G\"*/ 0,\n        /*\"H\"*/ 0,\n        /*\"I\"*/ 0,\n        /*\"J\"*/ 0,\n        /*\"K\"*/ 0,\n        /*\"L\"*/ 0,\n        /*\"M\"*/ 0,\n        /*\"N\"*/ 0,\n        /*\"O\"*/ 0,\n        /*\"P\"*/ 0,\n        /*\"Q\"*/ 0,\n        /*\"R\"*/ 0,\n        /*\"S\"*/ 0,\n        /*\"T\"*/ 0,\n        /*\"U\"*/ 0,\n        /*\"V\"*/ 0,\n        /*\"W\"*/ 0,\n        /*\"X\"*/ 0,\n        /*\"Y\"*/ 0,\n        /*\"Z\"*/ 0,\n        /*\"[\"*/ 0,\n        /*\"\\\"*/ 92, // replace \\\\ with \\\n        /*\"]\"*/ 0,\n        /*\"^\"*/ 0,\n        /*\"_\"*/ 0,\n        /*\"`\"*/ 0,\n        /*\"a\"*/ 0,\n        /*\"b\"*/ 8,  // replace \\b with backspace\n        /*\"c\"*/ 0,\n        /*\"d\"*/ 0,\n        /*\"e\"*/ 0,\n        /*\"f\"*/ 12, // replace \\f with form feed\n        /*\"g\"*/ 0,\n        /*\"h\"*/ 0,\n        /*\"i\"*/ 0,\n        /*\"j\"*/ 0,\n        /*\"k\"*/ 0,\n        /*\"l\"*/ 0,\n        /*\"m\"*/ 0,\n        /*\"n\"*/ 10, // replace \\n with line feed\n        /*\"o\"*/ 0,\n        /*\"p\"*/ 0,\n        /*\"q\"*/ 0,\n        /*\"r\"*/ 13, // replace \\r with carriage return\n        /*\"s\"*/ 0,\n        /*\"t\"*/ 9,  // replace \\t with tab\n        /*\"u\"*/ 0,\n        /*\"v\"*/ 0,\n        /*\"w\"*/ 0,\n        /*\"x\"*/ 0,\n        /*\"y\"*/ 0,\n        /*\"z\"*/ 0,\n        /*\"{\"*/ 0,\n        /*\"|\"*/ 0,\n        /*\"}\"*/ 0,\n        /*\"~\"*/ 0,\n        /*DEL*/ 0,\n    ];\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_json_parserv0.2.0/src/json_tables.nr"},"100":{"source":"mod quicksort;\nuse crate::quicksort::quicksort::quicksort as quicksort;\nuse crate::quicksort::quicksort_explicit::quicksort as quicksort_explicit;\nuse dep::check_shuffle::{check_shuffle, get_shuffle_indices};\n\n/**\n * Given an input array of type T, return a sorted array.\n * Type `T` must satisfy the Ord and Eq trait\n * The Eq function is used within an unconstrained function so its constraint-efficiently is not relevant\n * Note: sort_extended is likely more efficient as constraining `x < y` can typically be described\n *       more efficiently than returning a boolean that describes whether `x < y`\n **/\npub fn sort<T, let N: u32>(input: [T; N]) -> [T; N] where T: std::cmp::Ord + std::cmp::Eq {\n    let sorted = quicksort(input);\n\n    for i in 0..N - 1 {\n        assert(sorted[i] <= sorted[i + 1]);\n    }\n    check_shuffle(input, sorted);\n    sorted\n}\n\n/**\n * Given an input array of type T, return a sorted array.\n * Type `T` must satisfy the Eq trait\n * The Eq function is used within an unconstrained function so its constraint-efficiently is not relevant\n *\n * The `sortfn` parameter is a function that descibes whether, given two elements `a, b` of type T, `a <= b`\n * Note: sort_extended is likely more efficient as constraining `x < y` can typically be described\n *       more efficiently than returning a boolean that describes whether `x < y`\n **/\npub fn sort_via<T, let N: u32>(input: [T; N], sortfn: fn(T, T) -> bool) -> [T; N] where T: std::cmp::Eq {\n    let sorted = quicksort_explicit(input, sortfn);\n\n    for i in 0..N - 1 {\n        assert(sortfn(sorted[i], sorted[i + 1]));\n    }\n    check_shuffle(input, sorted);\n    sorted\n}\n\n/**\n * Given an input array of type T, return a sorted array.\n * Type `T` must satisfy the Eq trait\n * The Eq function is used within an unconstrained function so its constraint-efficiently is not relevant\n *\n * The `sortfn` parameter is a function that descibes whether, given two elements `a, b` of type T, `a <= b`\n * The `sortfn_assert` parameter is a function that *asserts* that `a <= b`\n *\n * `sortfn` is used in unconstrained functions only\n * `sortfn_assert` is used in constrained functions\n\n * Note: This is likely the most efficient sort function as constraining `x < y` can typically be described\n *       more efficiently than returning a boolean that describes whether `x < y`\n **/\npub fn sort_extended<T, let N: u32>(\n    input: [T; N],\n    sortfn: fn(T, T) -> bool,\n    sortfn_assert: fn(T, T) -> ()\n) -> [T; N] where T: std::cmp::Eq {\n    let sorted = quicksort_explicit(input, sortfn);\n\n    for i in 0..N - 1 {\n        sortfn_assert(sorted[i], sorted[i + 1]);\n    }\n    check_shuffle(input, sorted);\n    sorted\n}\n\nstruct SortResult<T, let N: u32>{\n    sorted: [T; N],\n    sort_indices: [Field; N]\n}\npub fn sort_advanced<T, let N: u32>(\n    input: [T; N],\n    sortfn: fn(T, T) -> bool,\n    sortfn_assert: fn(T, T) -> ()\n) -> SortResult<T, N> where T: std::cmp::Eq {\n    let sorted = quicksort_explicit(input, sortfn);\n\n    let sort_indices = get_shuffle_indices(input, sorted);\n\n    for i in 0..N - 1 {\n        sortfn_assert(sorted[i], sorted[i + 1]);\n    }\n    SortResult { sorted, sort_indices }\n}\n\nmod test {\n    use crate::sort;\n    use crate::sort_via;\n    use crate::sort_extended;\n\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    // unconditional_lt will cost fewer constraints than the `<=` operator\n    // as we do not need to constrain the case where `a > b`, and assign a boolean variable to the result\n    fn unconditional_lt(_a: u32, _b: u32) {\n        let a = _a as Field;\n        let b = _b as Field;\n\n        let diff = b - a;\n        diff.assert_max_bit_size(32);\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = sort(arr);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = sort_via(arr, sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_extended() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = sort_extended(arr, sort_u32, unconditional_lt);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n}\n\nfn sort_u32(a: u32, b: u32) -> bool {\n    a <= b\n}\n\nfn lt_u32(a: u32, b: u32) -> bool {\n    a < b\n}\n// unconditional_lt will cost fewer constraints than the `<=` operator\n// as we do not need to constrain the case where `a > b`, and assign a boolean variable to the result\nfn unconditional_lt(_a: u32, _b: u32) {\n    let a = _a as Field;\n    let b = _b as Field;\n\n    let diff = b - a;\n    diff.assert_max_bit_size(32);\n}\n\nstruct TestStruct {\n    a: bool,\n    b: u32,\n    c: Field\n}\n\nimpl std::cmp::Eq for TestStruct {\n    fn eq(self, other: Self) -> bool {\n        \n        (self.a == other.a)\n        & (self.b == other.b)\n        & (self.c == other.c)\n    }\n}\n\nunconstrained pub fn get_lt_predicate_f(x: Field, y: Field) -> bool {\n    let a = x as u32;\n    let b = y as u32;\n    let r = a < b;\n    r\n}\n\npub fn lt_f(x: Field, y: Field) -> bool {\n    let predicate = get_lt_predicate_f(x, y);\n    let delta = y as Field - x as Field;\n    let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n    lt_parameter.assert_max_bit_size(32);\n\n    predicate\n}\n\nfn less_than_for_test_struct(lhs: TestStruct, rhs: TestStruct) -> bool {\n    let a_lt = lhs.a < rhs.a;\n    let b_lt = lhs.b < rhs.b;\n    let c_lt = lt_f(lhs.c, rhs.c);\n\n    let a_eq = lhs.a == rhs.a;\n    let b_eq = lhs.b == rhs.b;\n\n    let b_flag = a_eq;\n\n    let c_flag = a_eq & b_eq;\n    let result = a_lt | (b_flag & b_lt) | (c_flag & c_lt);\n\n    result\n}\n\nfn unconditional_lte(lhs: TestStruct, rhs: TestStruct) {\n    // lhs < rhs implies:\n    // a == false, b == false\n    // a == false, b == true\n    // a == true, b == true\n    // i.e. a == true, b == false is not allowed\n    assert(lhs.a as Field * (1 - rhs.a as Field) == 0);\n\n    // a < b as u32 implies\n    // b - a > 0\n    let diff = lhs.b as Field - rhs.b as Field;\n    diff.assert_max_bit_size(32);\n\n    // a < b as Field (32 bit condition)\n    let diff = lhs.c as Field - rhs.c as Field;\n    diff.assert_max_bit_size(32);\n}\n\nglobal Num: u32 = 100;\n\n// // size 100: 7,638\n// // size 1,000: 51,738\n// // diff = 49\n// fn main2(x: [TestStruct; Num]) {\n//     let sorted = sort_extended(x, less_than_for_test_struct, unconditional_lte);\n//     println(f\"{sorted}\");\n// }\n\n// // size 100: 9,321\n// // size 1,000: 68,721\n// // diff = 59,400 = 66 per\n// fn main3(x: [TestStruct; Num]) {\n//     let sorted = sort_via(x, less_than_for_test_struct);\n//     println(f\"{sorted}\");\n// }\n\nfn unconditional_lt_f(a: Field, b: Field) {\n    let diff = b - a;\n    diff.assert_max_bit_size(32);\n}\n\n// 5,089\nfn main20(x: [Field; Num]) {\n    let sorted = sort_via(x, lt_f);\n    println(f\"{sorted}\");\n}\n\n// 4,891\nfn main000(x: [Field; Num]) {\n    let sorted = sort_extended(x, lt_f, unconditional_lt_f);\n    println(f\"{sorted}\");\n}\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_sortv0.1.0/src/lib.nr"},"102":{"source":"trait Swap {\n    fn swap(&mut self, i: u32, j: u32);\n}\n\nimpl<T, let N: u32> Swap for [T; N] {\n    fn swap(&mut self, i: u32, j: u32) {\n        let temp = self[i];\n        self[i] = self[j];\n        self[j] = temp;\n    }\n}\n\nunconstrained fn partition<T, let N: u32>(arr: &mut [T; N], low: u32, high: u32) -> u32 where T: std::cmp::Ord {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (arr[j] < arr[pivot]) {\n            arr.swap(i, j);\n            i += 1;\n        }\n    }\n    arr.swap(i, pivot);\n    i\n}\n\nunconstrained fn quicksort_recursive<T, let N: u32>(arr: &mut [T; N], low: u32, high: u32) where T: std::cmp::Ord {\n    if low < high {\n        let pivot_index = partition(arr, low, high);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high);\n    }\n}\n\nunconstrained pub fn quicksort<T, let N: u32>(_arr: [T; N]) -> [T; N] where T: std::cmp::Ord {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1);\n    }\n    arr\n}\n\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_sortv0.1.0/src/quicksort/quicksort.nr"},"103":{"source":"trait Swap {\n    fn swap(&mut self, i: u32, j: u32);\n}\n\nimpl<T, let N: u32> Swap for [T; N] {\n    fn swap(&mut self, i: u32, j: u32) {\n        let temp = self[i];\n        self[i] = self[j];\n        self[j] = temp;\n    }\n}\n\nunconstrained fn partition<T, let N: u32>(arr: &mut [T; N], low: u32, high: u32, sortfn: fn(T, T) -> bool) -> u32 {\n    let pivot = high;\n    let mut i = low;\n    for j in low..high {\n        if (sortfn(arr[j], arr[pivot])) {\n            arr.swap(i, j);\n            i += 1;\n        }\n    }\n    arr.swap(i, pivot);\n    i\n}\n\nunconstrained fn quicksort_recursive<T, let N: u32>(\n    arr: &mut [T; N],\n    low: u32,\n    high: u32,\n    sortfn: fn(T, T) -> bool\n) {\n    if low < high {\n        let pivot_index = partition(arr, low, high, sortfn);\n        if pivot_index > 0 {\n            quicksort_recursive(arr, low, pivot_index - 1, sortfn);\n        }\n        quicksort_recursive(arr, pivot_index + 1, high, sortfn);\n    }\n}\n\nunconstrained pub fn quicksort<T, let N: u32>(_arr: [T; N], sortfn: fn(T, T) -> bool) -> [T; N] {\n    let mut arr: [T; N] = _arr;\n    if arr.len() <= 1 {} else {\n        quicksort_recursive(&mut arr, 0, arr.len() - 1, sortfn);\n    }\n    arr\n}\n\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_sortv0.1.0/src/quicksort/quicksort_explicit.nr"},"104":{"source":"unconstrained fn __get_shuffle_indices<T, let N: u32>(\n    lhs: [T; N],\n    rhs: [T; N]\n) -> [Field; N] where T: std::cmp::Eq {\n    let mut shuffle_indices: [Field;N ] = [0; N];\n\n    let mut shuffle_mask: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut found = false;\n        for j in 0..N {\n            if ((shuffle_mask[j] == false) & (!found)) {\n                if (lhs[i] == rhs[j]) {\n                    found = true;\n                    shuffle_indices[i] = j as Field;\n                    shuffle_mask[j] = true;\n                }\n            }\n            if (found) {\n                continue;\n            }\n        }\n        assert(found == true, \"check_shuffle, lhs and rhs arrays do not contain equivalent values\");\n    }\n\n    shuffle_indices\n}\n\nunconstrained fn __get_index<let N: u32>(indices: [Field; N], idx: Field) -> Field {\n    let mut result = 0;\n    for i in 0..N {\n        if (indices[i] == idx) {\n            result = i as Field;\n            break;\n        }\n    }\n    result\n}\n\npub fn check_shuffle<T, let N: u32>(lhs: [T; N], rhs: [T; N]) where T: std::cmp::Eq {\n    let shuffle_indices = __get_shuffle_indices(lhs, rhs);\n\n    for i in 0..N {\n        let idx = __get_index(shuffle_indices, i as Field);\n        assert_eq(shuffle_indices[idx], i as Field);\n    }\n    for i in 0..N {\n        let idx = shuffle_indices[i];\n        let expected = rhs[idx];\n        let result = lhs[i];\n        assert_eq(expected, result);\n    }\n}\n\npub fn get_shuffle_indices<T, let N: u32>(lhs: [T; N], rhs: [T; N]) -> [Field; N] where T: std::cmp::Eq {\n    let shuffle_indices = __get_shuffle_indices(lhs, rhs);\n    for i in 0..N {\n        let idx = __get_index(shuffle_indices, i as Field);\n        assert_eq(shuffle_indices[idx], i as Field);\n    }\n    for i in 0..N {\n        let idx = shuffle_indices[i];\n        let expected = rhs[idx];\n        let result = lhs[i];\n        assert_eq(expected, result);\n    }\n    shuffle_indices\n}\n\nmod test {\n    struct CompoundStruct {\n        a: bool,\n        b: Field,\n        c: u64\n    }\n    impl std::cmp::Eq for CompoundStruct {\n        fn eq(self, other: Self) -> bool {\n            (self.a == other.a) & (self.b == other.b) & (self.c == other.c)\n        }\n    }\n\n    use crate::check_shuffle;\n    #[test]\n    fn test_shuffle() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [2, 0, 3, 1, 4];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test]\n    fn test_shuffle_identity() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [0, 1, 2, 3, 4];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test(should_fail_with = \"check_shuffle, lhs and rhs arrays do not contain equivalent values\")]\n    fn test_shuffle_fail() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [0, 1, 2, 3, 5];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test(should_fail_with = \"check_shuffle, lhs and rhs arrays do not contain equivalent values\")]\n    fn test_shuffle_duplicates() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [0, 1, 2, 3, 3];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test]\n    fn test_shuffle_compound_struct() {\n        let lhs: [CompoundStruct; 5] = [\n            CompoundStruct { a: false, b: 0, c: 12345 },\n            CompoundStruct { a: false, b: -100, c: 54321 },\n            CompoundStruct { a: true, b: 5, c: 0xffffffffffffffff },\n            CompoundStruct { a: true, b: 9814, c: 0xeeffee0011001133 },\n            CompoundStruct { a: false, b: 0x155, c: 0 }\n        ];\n        let rhs: [CompoundStruct; 5] = [\n            CompoundStruct { a: false, b: 0x155, c: 0 },\n            CompoundStruct { a: false, b: 0, c: 12345 },\n            CompoundStruct { a: false, b: -100, c: 54321 },\n            CompoundStruct { a: true, b: 9814, c: 0xeeffee0011001133 },\n            CompoundStruct { a: true, b: 5, c: 0xffffffffffffffff }\n        ];\n        check_shuffle(lhs, rhs);\n    }\n}\n","path":"/Users/envoy1084/nargo/github.com/noir-lang/noir_check_shufflev0.1.0/src/lib.nr"}},"names":["main"],"brillig_names":["main"]}