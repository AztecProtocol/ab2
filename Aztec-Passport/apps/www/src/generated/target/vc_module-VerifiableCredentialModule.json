{"transpiled":true,"noir_version":"0.35.0+b848cc128d2dc2b461581f21a35509a1af9065a7-aarch64","name":"VerifiableCredentialModule","functions":[{"name":"verify","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"content","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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nrki+jNXRH/miujPXBH9mSuif/uKWP/RP53A3TOl3MRuTl8/R1tNmB/f9u1T9m2s81PC90+J3z8lff+U3esnb5uH57Y8nJK/f0r5/in1+6fssl+W23ukpYZfTvmHbxz78fH9pR+/b1hd9/HhtR8fX/vx6bUfL6/9+Pzajy+v/fj62o9/7V9teu1frbz2r1Ze+1crr/2rldf+1cpr/2rltX+18tq/WnntX6289q82//GVk2vdlMKdZ9nb58df0PubqCpLefj4+tqPb6/9+P7Sjy+vpbb8+U1he1peYnr4+Pzajy+v/fj62o+/4MLs28fLw8f3l358XV778eG1Hx9f+/HptR8vr/34/NJbWn3tclJfu5zU1y4n9bXLSVte+/HhtR8fX/vx6bUfL6/9+Nf+1bZX/tX+x8crfB+HHvz8dv3An6eG9Vnw3feE45FbO6k9c1L/9kkf0MKn27r/l91u6qzVO7sxnFin56eE758Sv39K+v4p8v1Tdq/onm+n9Bp/OWXnd+7lRkyq98vc3rsYUW7HxlJ/OfbvR5bse0qpdkppdkrpF5bS0u8fv283X/fx4bUfv/sX3vv2294lLMrnnzZ/32++8PPlxZ+fX/n5HytA/FwB9l8B2PIu2918HkL78dLF90+p3z+lff+U/u1T9lezk1M+GpecqoL1n//vP/7vf/rH//LP//3f1pM+/tf/8y//9d//6V//5ec///3/+18//pf14P8f","brillig_names":["get_public_storage_hints","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","get_public_storage_hints","build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","get_l1_to_l2_membership_witness","pack_arguments_oracle_wrapper","call_private_function_internal","unpack_returns","pack_arguments_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"get_jwt_registry","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_jwt_registry"],"assert_messages":{"253":"Array index out of bounds","218":"Array index out of bounds","247":"attempt to add with overflow","285":"attempt to add with overflow","14":"Not initialized","162":"call to assert_max_bit_size","194":"Array index out of bounds","226":"Array index out of bounds","345":"Array index out of bounds","374":"attempt to add with overflow","19":"Function get_jwt_registry can only be called statically","205":"attempt to add with overflow","170":"call to assert_max_bit_size","234":"Array index out of bounds","333":"attempt to add with overflow","353":"Array index out of bounds","271":"Array index out of bounds","361":"Array index out of bounds"}},{"name":"set_admin","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"new_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAAQIRAAAJAAEAQQkAAQABR8AAAAABQAAAAQAAAhDKwAIQwADIgAAAAg5AAAACEQAAAAAHgAAAAUeAAAABjAAAAAABQAAAAYAAAAHJAACAQUKAAIHBQYhAAAPAAY6AQAAKgAABSQABAIHAAAEAAcAJAEEAQUAAAQFAgcqAAcGJAAHAAgqAggGKgEFBwAABAcCByoCBwUqAAAHAAAEAAIAKgIFByQABAAFJAAHAQgkAAQBBioABQQgACIKAAQEBQkhAABKAAkgACUqAQcJAAAECQIKAAAECgULKgELBx4AAgAJCgAHBwkKIQAALQAKOgEAACoABQQgAC8KAAQEBQchAAAzAAcgADIjHAAHBAcAAAcIBwkqAAAHJAAEAgoAAAQACgAkAQQBBwAABAcCCioACgsqAgMLJAAEAQsMAAQECwwhAABAAAw6AQAAAAAEBwIMAAAEDAQLKgELCi0AAAAACgAAAAkAAAQEBgkOAAQECQohAABIAAo6AQAAKgAJBCAALyoBBwkcAAcECgAABwgKCywAAAAACwAAAAokAAQBDAwABAQMDSEAAFIADToBAAArAAAJCAMlAAQAAggEIgAAAGArAAgFAAsAAAQLAg0AAAQNBAwqAgoMAAAEBAYJDgAEBAkKIQAAXQAKOgEAACoCCwcqAAkEIAAiKwEIAwgGCwAECAYAAggHIQAAZAgHIABmKwAIAwgFIAB0KwAAAAgFAQAEAAAIBAAAJQAEAAAICQ0ABAgJCAQIChcACAoICiEAAHIICgEABAgDCAkICysBCAsICAEABAgFCAkICysCCAgICwEABAgJAAIICSAAaSUBBAABCAUgAHQjKwAYyhjK","debug_symbols":"1Zthb+IwDIb/Sz/zIXYSx+avnE4TbDBVQjABO+mE+O/X7mja63qppo3J/oIovHWepm7fxkkv1dNm/fr8UO+3h1O1/HGpdofH1bk+7Juty3VRrY/1blc/Pwx/rlz7wW/y08tq326dzqvjuVpCwrCoNvun9qsPTYBtvdtUy+Sui3di8emmlZiyFKKf0AYEuYkDIme14ISYGPxNTIwyFP9cVPJpcHCQxW4gvjs6uM93eurii8x1OmDoxIAiZXKG2FEwDELfyOELyZtO/xe9bQDv3YC/dwPh3g3EqQYEYpcQ3s/lfeIuftNAHz/RhDoKdXkfRVw5e2Ly0ImTx3H2kFnyZJaczZKLVXJ0ZsnBLDmaJfdmyYNZcrMeimY9FM16KJr1UK/6Co2cyeN4jORVZ0sKmZzdmPy7syUP2Mi5WCYHJ9SH7sXe0Ru6mEUPzi769EOXl4myyiR68IxdacLPJS8JZXJJ48suzD1GkRuytHv4D+8RPrzH5M2gqd9QP06OM6cXCXMRhHnm9JKHrqhF3s+UTKiJ3YkBxyWTCLrZE2R2hjE76maPVGD3utk5FwhBxrYdg2H2aJidDLMrv0cW2dkwu9hlJ2eYXbmvFtmV+2qR3bCvkmFfJcO+SoZ9lZT7asCe3ZfFzZi1n6pnHh+ochP+74G27MpNuMSelJtwkV25CRfZg9XaaNI8e8GQ69GM40F5Uj17kat0U+Sq69HZwBpynDGBplrYMYf07jBVT3WUyu5J9XKBEjmrXi5QJFe9XKBIrnq5QJFc9XKBIrlqwy2Sq14uUCRXbbhFcrMTwGzWQ9msh4pZDxWzHipmPVSMeui12fq1Otar9W5ze7Nj+7p/HLzocf798vefRvwH","brillig_names":["set_admin"],"assert_messages":{"81":"Array index out of bounds","63":"Array index out of bounds","92":"attempt to add with overflow","44":"Aztec Passport: Unauthorized Admin Change","71":"attempt to add with overflow","14":"Not initialized"}},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"error_types":{},"parameters":[{"name":"_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"],"assert_messages":{"128":"attempt to add with overflow","448":"Array index out of bounds","698":"Array index out of bounds","110":"Array index out of bounds","366":"Array index out of bounds","616":"Array index out of bounds","430":"Array index out of bounds","415":"attempt to add with overflow","598":"Array index out of bounds","592":"attempt to add with overflow","394":"Array index out of bounds","522":"Array index out of bounds","510":"attempt to add with overflow","571":"Array index out of bounds","117":"Array index out of bounds","690":"Array index out of bounds","678":"attempt to add with overflow","538":"Array index out of bounds","340":"Initializer address is not the contract deployer","334":"Initialization hash does not match","462":"attempt to add with overflow","72":"attempt to add with overflow","386":"Array index out of bounds","706":"Array index out of bounds","374":"attempt to add with overflow","563":"Array index out of bounds","630":"attempt to add with overflow","106":"attempt to add with overflow","551":"attempt to add with overflow","344":"Aztec Passport: Invalid Address","402":"Array index out of bounds","530":"Array index out of bounds","719":"attempt to add with overflow","579":"Array index out of bounds"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"12265343917440897559":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":6,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"7b3RrvQ4dqX5LnntC5HaoiS/ymDQKHe7GwUUyg27eoCBke/ekSf+UOhYLNLHYlBL5HdjVLmUkdzfOhFca5Mi//23//HP//R//td/+/Nf/+e//Ntv//j//Ptvf/mX//6nv/35X/76+G///vs//PZP//rnv/zlz//rv+3/378Nf/wfG7+e/7f//ae//vFf/+1vf/rXv/32j6P9w2///Nf/8fgP6+Of/p9//ss///aP8/D7//sPv5n97Hk3LT/9B9Yf/gPB/+Af+IfDg7P/9eA8bw9O6/OTx499sn3sk6ePfXL42CfPH/vk5WOfvH7qk+fhY5/sPvbJH/sOzh/7Ds4f+w7OH/sOzh/7Ds4f+w7OH/sOzh/7Di4f+w4uH/sOLh/7Di4f+w4uH/sOLh/7Di4f+w4uH/sOLh/7Di4f+w6uH/sOrh/7Dq4f+w6uH/sOrh/7Dq4f+w6uH/sOrh/7Dq4f+w6un/oO+mH42Ce7j32y/9gnjx/7ZPvYJ08f++TwsU+eP/bJy8c++WPfQfex76D72HfQfew76D72HXQf+w66j30H3ce+g+5j30H3se+g+9h30H/sO+g/9h30H/sO+o99B/3HvoP+Y99B/7HvoP/Yd9B/7DvoP/YdHD/2HRw/9h0cP/YdHD/2HRw/9h0cP/YdHD/2HRw/9h2czikYhu3RMMzh/fAceXhcwvT63GV5D8XbcyimM5RJZyhBZyizzlAWmaEEV28o0zz/enZa3p/r1+U5kopfoDAM27PhOJJJZiRBZiSzzEjOfnncbiRzZiTr6y92Htz26Dj+GsmqMpKT690lR+JkRuJlRjLKjMRkRjLJjCTIjGT+1Ei+Pn356Kevn/z0Zfjop7uPfrr/6KePH/10++inTx/99PDRT//od3X56Hd1+eh3df3od3U9+11dxu3TH4byTHRavc5QRp2hmM5QJp2hBJ2hzDpDOfkz596h0k25UPl3rdfxWRv862Eb/vhXbxE01p6cw69nl2H36BT7XL++PtZ8+tGHTMuvZ/262vvhEGusDO6lyTSMbv/wF+YVzJ/HPJ7c6APm/yRmB+YamD2Ya2AewVwDs3WGeVs0tXncP/oFYwLGG0YAxhvG3BeMx6/G9qPhDzA6SydpGJ1liCQM15nTn/zr0cnPBxid+fE0jM5ccxpGZz5jsleza7IjjM5mkzC9zHuY3QFGZ7NJEoZXnU3c9IpU5la3h/E1bNXffWdzatiqv9BuXFPDVu0TZIZt9xx2bwn5mq6M7y17X4S5s1R/FWZWM6tgZjWzBuaR1cwqmHtbzUy1n8fe1hyTMHpbGUzCMNrPbxi99dWSMDrLEGkYva3fpdrPY2/rd0kYva3fpWBYb6s0qYUJ62w2SfbirbPZJA1DdTZJL0yY6u9+emHCVH+h063ySXb1Kj1s2dWr9LDZlVujKzOxK7cKZgNzDcysZlbBzGpmFcysZlbB3NtqZqr9PPW25piCEXpbGUzC6G33c6r9HHrrqyVhdJYh0jCM9vMbRm/rd0kYva3fJWH0tkqTWpiYO5tNkr34ubPZJA1DdTZJL0zMqr/76YWJWfUXOt0qn2VXr9LDll29Sg+bXbk1ujILu3KrYOaMoSqYWc2sgpnVzCqYDcw1MHN60TsJLZxetIPR28pgEganF+1gcHrRG8ba2+lFSRicXrSDwelFOxi9rd8lYfS2SpNamOjtPO1UL956O/U6DUN2V3lqYcJkz3pOLkyY7NnJyVa5DXbPYcuuXqWHLTpzPRYxX7b0sebzH6/GMNWTeHPDFk2duWGLzuiZYaueQ5sbtugsmRu26CyZG7boLJkbtugsmRu26CyZG/Y9Z0l3z1lS9Szg3LDvOUuqnq+bG/Y9Z0nV83Vzw77nLKl6vm5u2PecJVXPq80N+56zpOp5qrlh33OWVD3vMzfse86Sqidd5oZ9z1lS9fTI3LDvOUuqnsiYG7bqLLm418Pjst8O92vYqrNkZtiqs2R62HZ2llxenx68ufSw3WqvVUk/uPdN26Oz2NODm19rfG7wbvz2/NfY3Y3H7m889vHGY7cbj3268djDjcc+33jsy43Hvt537NON59VJeF71bn2PffS55517bXtzLrxf0xh/FSo8CZctVHjGLluoNVOora9Pf/zH+VCosBcoW6iwcShbqLDL+GGh4f14sHAoVNiSlC1U2L8ULTQIm52yhbbjjDKFtuOMMoW244xCWLZCl+VQqPVSaDvOKFNoO84oU2hDzihdaEPOKF1oQ84oWejckDNKF9qQM0oX2pAzSheqPI/uO5jL9Pt/7GDOwj+k4/ge+7h7F/e/8vxXrcK/pT+sdZ62v995PjRIFuHf0rKFCv+Wli3Umil02Y6uccvunc0x9vAyvlrYy67EFxNhs/tBJo8P3CajYXIHKu38oP+ISnq1Y2nnp78glbWdeaIklXYmlZJUhN38hVSEm6IXUjGoRKgIx8QLqQj3ZotR+Sq0B7v6VWgzDtQPw3Z27aNldCi0GVOZLnQamvGJuUJPWj8/D69Cx93ByNFCvdvOOvZ+yne3MnsRp7MneV069vHGY7cbj3268djDjcc+33jsy43Hvt537GdP/Lp07DeeV53wvFpyR/jkhCfhsoUKz9hlCxWe3kvuCJ+csBcoW6iwcShbqLDLKLmtdnLClqRooV7Yv5QtVNjslC20HWeUKbQdZ5Qp1NopNLVlb/LtOKNMoe04o0yh7TijTKENOaN0oQ05o2ShY0POKF1oQ84oXWhDzihdaEPOKF2o8jya3uM/jcI/pIX3+E8m/Ftackf4ZMK/pWULFf4tLVuocCa5aI//ZMJm97I9/pO184NebifhNLXz01+SSjvzREkq7UwqJakIu/kLqRhUIlT6dCs5KsIx8UIqwr3Zklvfp6kHu/pVaDMONLMjPDRjKnOFNuMTc4V+7Cf669Pnj3768tFPXz/56fPw0U93H/10/9FPP2m7bXj9VAezIf3Vc9OwzdTT7uH4lRiPCe11b8oUfO7NncHeTYs5M44fXfP96HD/etj2H+zXyMPz/NpWtgy7R6fY5/rt9vCdKNFH/Tpvvynr+jY4PsSoDdvP2zTsLxIJT7kNuXuSe0LunuQOyN2T3DNy9yT3gtw9yb0i9yVyb80nm8f9o3+IcvZ0Q0T5hCgOUfRE8YhyhSiPWWWbVPxBFLo9gqIYouiJQufkGlH869HJzwdR6G8IikIXQk+UlZxyjSj2QjHZURTc1yWihOk13jC7gyiGKHqi4L7Sorjp1To0t9sh9RDlCx8+KYPP5hQ+HE0G37im8LFOcQofff8T+MKA871kPr9mlSwM9P67kptVha7kJjF3Jbchd09yk/K7kpuuxDVyJ7ZphIFeh6AodFAERaEvc4koqW0awdHtERSFnoygKHROrhElsU0jOPobgqIYouiJQk65RpTEhqbgcV+XiJLaOxM87ktQFNxXWpTkhqbg8UkZfKkNTeHs1SqdbynxrFOcwkff/xQ+nO8l8/lFq2Se3n9XcrOq0JPcI4m5K7nJ4l3JTcrvSm66EtfIndqmMRqi6IlCB0VQFPoyl4iS3KYx0u0RFIWejKAodE6uESW1TcPobwiKQhdCUBRDlEtESW1oMtzXJaIk984Y7ktQFNxXWpT0hqYJn5TBl9zQNOFoMviSW0om1ilO4aPvfwqfge+K+fyiVbKJ3n9XcrOq0JXcJOau5CaLdyU3Kb8nuQNdiWvkTm3TCPQ6BEWhgyIoCn2ZS0RJbtMIhih6otCTERSFzsk1oqS2aQT6G4Ki0IXQE2Ump1wjSmpD02yIcoUoyb0zM+5LUBTcV1qU9IamGZ+UwZfc0DTjaDL4kltKZtYpzuBb6PufwofzTY5inO01inFedh7VnvjopZ/CR9f7FD4D3xl8ZJlT+Egdp/CROk7hI3WcwkfqOINvJXWcwkfqOIWP1HEKH6njFD4D3xl8pI5T+Egdp/CROk7hI3WcwkfqOIFvHkgdp/CROk7hI3WcwkfqOIXPwHcGH6njFD5Sxyl8pI5T+Egdp/CROs7gc6SOU/hIHafwkTrS+Bb3enhc9sci/MJH6jiFz8B3Bl8jqcNt55Q4t34bx1eVjYSDTJWNuCg/vsbh/GyZh1d7vaHjB7e8x+Es+i1z87h9zbwbvz3/B0PfiJW6lGEjfupSho2YqksZNuKsLmVoMDzNsBGPdSnDRhzcpQwb6fFeyrCRRu+lDMkppxm2ctX7Jxl6t74Zjj73vHNblS68hzL+Ak6oqQycBFQZOHGpNHBbX5/++I/zAbgBvC5wglhl4KS20sDD+/Fg4QCciFcZOHmwMnDCY13grVy6fR/gJM3KwEmaxYGHbaNCWJYDcJJmZeAG8LrASZqVgZM0KwMnaVYGTtKsDJykWRf4RNKsDJykWRm4ATwLfL/zYZm+Pf/FEOORZTiOb4bj7t6W/8rzX8zxHqWZz9P2uzLPh4WzVq5Gvg3wVi4nvg9weoClgS/b9bVu2d0jMcYeXsYXkWWH+qUNzZQrtXl84Ptd0Mkd1MEAXapOehddK7dHNqoOvkpYnRkTpqwO3SJlddjEoKwOaUdZHUMdYXXYS1FPnS/gxP/KwEn0hYH7YVi2T/dH4IT0ysDJ3XWBt3LtbYvt9Vbu1L1te30Yts92R3VwP8rqYJWU1cFXXatOcuGwlRtl21SnlQtrG1WHxQ9ldUg7yuqQd5TVMdQRVofFD2V16BVcq860IRnC4W2bVm5SblQdegXK6tAr0FVnaeWa6UbVoVegrA69AmV16BXI5J2IOoY6sml0aeUG8UbVoVegrA69AmV16BUoq0OvQFidVi6Hb1QdegXK6tArUFaHXoGyOoY6wurQK1BWhzSqrA5pVFkd0qiwOp40qqwOjjqvjnu/ATXuX4FyvxgaDE8zxJ2eZ8h603mG+PDzDHHL5xniaU8zHHGe5xmyWnGeIWsK5xmSU84zNBieZkhOOc+QnHKeITnlPENyynmG5JQsQ7+GN8NhzT2fPBt3MUJNaeDeb9cW+X3z/RdwElBl4MSlysDJVpWBG8BLAw9uG8pynDRxy6WB2/txW49/4VjrysDx4XWBc3V5ceDhffF2sHAAjg+vDBwfXhk4PrwycAN4XeCsnlQGzlJLZeAkzcrASZqVgZM06wIPJM3KwEmalYGTNCsDJ2lWBm4ALw08bO+1heVwbmEgaVYGTtKsDJykWRk4SbMycJJmXeAztrA0cNvubHbmvy0iHx9OXSG8zMyvV2qTOUZhZjJWVoeZ+1J10jvaZ6Z5YXUWus/K6tCqVlaHvrayOqQdZXUMdYTVob2urA69AmV16BUoq0OvQFkdegX11PkD+Er8rwycRF8ZOCG9MnByd2XgBvC6wEnHxYHbdkK+TYftlSuBtzJwMmxl4MTSysBJmlWBrwNJszJwkmZl4CTNysBJmpWBG8DrAidpVgZO0qwMnKRZGThJszjw1EmC60DSrAvckTQrAyf4nAL+xZAsc56hwfA0QxLHeYZYrOITUKH3bFcuk7/4Tc7hfeGQO6jjcRLK6uBRlNUx1LlUndQ76qvHVymrQ9tXWR16xMrqkHaU1SHvCKsz0qpWVocdVMrq0Cu4Vp1pQzKE5aAOvQJldQx1hNWhV6CsDr0CZXXoFSirQ69AWR16BTJ556iO0SsQTqNGr0BZHXoFyurQK1BWx1BHWB16Bcrq0CtQVodegbI69AqU1aFXIKzORK9AWR16BcrqkEaV1THUEVaHNKqsDmlUWJ2g6wqCnzd11jX30WFTZ1q/SflVpW4nvmSVur+DP6nSO3v9xXrvp9zDbtwenubsN83N2zE1g3fjt+e/GOr+Wt2HoW6H6z4MdftQ92Go2y26DcNZt6dzH4ZteKxrGbbh4K5lqNtjug9Dg+FphuSU8wzJKfmuilvfDEefez55SeA6E2oqAycBVQZOXCoNPH2C6UK2qgycIFYZOKmtNPDwfjzY4Zz1hYhXGbgBvC5wwmNl4CTNysBJmpWBkzSLAw/bppOwHF4qXkiadYGvJM3KwEmalYGTNCsDJ2lWBm4ArwucpFkZOEmzMnCSZlXgf9ylAfEs8f3Wh2X69vwTItYjC3Ec3xBHO/f8E7oBvTD0edp+WuZ5Pv5W4D9qE8eA1CZOJ7A08WXe3hFb1m/v+x0fTl1a6AbhG3Z7ECf95uZDHmzQpfIkd9M95DHkUZYHdyUtD1ZMWh46R9LysKNBWh5Sj7I8niattDzsragnz5M4jYDaxMn2hYn7YTs0yw8+QtwgXpk4Cbw2cWLBlcYm3W0XvjO7j277MGyf7Y7yCF/8izx//KuRR1keQ55L5UkvJQrf/Ys8j/+VxRBpeVgMkZaH1CMtD7lHWR7hC4CR5yEPiyHS8tA1uFae1NXzD3noGkjLY8ijLA9dA2l56BpIy0PXQFoeugbS8tA1kMk9EXmErwImlv7x/0IeZXnoGkjLQ9dAWh5DHmV56BpIy0PXQFoeugbS8tA1kJaHroGyPIGugbQ8dA2k5SGWSstjyKMsD7FUWh5iqbQ8GOu8PO79itS4f0fqdcTujP0tABGTWgAiC1AFIOLHC0A0IJ6HiLctABEHWgAiyxcFILLIUAAiieU8xIXEUgAiiaUARBJLAYgklgIQDYjnIZJYshD9Gt4QhzX3fOZU3YV4U5q499vdR37fjn8RJwvVJk5wqk2clFWZ+EokK048uI34cpw5uQm9OHF7P25r5G/cIF6ZOH68NnH8eGni4X2Vd7BwJI4fr00cP16bOH68LnE34MdrE2c9pTZxFl9qEydz1iZuEK9MnMxZmziZszZxMmdt4mTO2sTJnJWJOzJnceJhe/8tLMuROJmzNnEyZ23iZM7axA3ilYmTOWsTxx2WJm7bLdDO/LeV5ePDyTuJnWeSvVKczKkLzjMjS8tjyHOlPOkd784z10vLQzNaWh4619Ly0OaWlofUoyzPSANdWh667dLy0DWQloeugbQ8hjzK8tA1qCfPkziNgNrEyfa1iRPXaxMngVcmboTq2sTJycWJ23bGvk3HnZdG9K1NnDRbm7hBvDJxMmdt4mTO2sTJnLWJkzlrEydzViY+kTlrEydz1iZO5qxNnMxZm7hBvDTx5PmDbiJz1iZO5qxNnAR0ivgTIqHmPMRATikAkehRAKIBsfQsVOx9XC6pv1QcNwzve4tcRB78hLQ8OBVleWY80LXypN9mn3FX0vLQBZaWh5axtDyGPMrykHuk5aFzLS0PW6uk5aFrcK0804ZkCMcDCme6BsryLHQNpOWhayAtD10DaXnoGkjLY8ijLA9dA5ncE5OHroFyLF3oGkjLQ9dAWh66BsryrHQNpOWhayAtD10DaXnoGkjLY8ijLA9dA2l56BpIy0PXQFoeYqmwPH4glkrLQyyVlodYKi1PG8bahfdHB+/3Dz/LbKMx75ZtyI9uaW4cq73+rB4/kkv2r9DN22kvg3fjt+efENvwKddCdG24iYshtjHnXwyxjZn5YohttHUvhmhAPA+xESd3LcQ2GpkXQ2yj3XgxRBJLAYgklnzzwa1viKPPPZ++ic974k1t4mSh2sQJTqWJp88E9Z6UVZu4QbwycfJbaeLh/XiwcCRO2KtNnGRYmzgxsjZxMmdl4iOZszZxMmdx4mHbpxGW5UiczFmbOJmzNnGDeGXiZM7axMmctYmTOWsTJ3PWJk7mrEzcyJy1iePH88T3GyKW6dvzT4jYjyzEcXxDHG0+9fwTOg6kNPR52n5a5vm4lmY4kNrEcSCViTdyw7gS8WV+IXHL+u1duePDyTsBfSMXNd9VnNxbj43c6nxbeTIb7CYMk7Q8uCtpebBiyvI0cqt4s/KwtUFaHlKPtDw0aaXlMeSpJs+TOI2A2sTJ9oWJ+2E7cMo/FvWOxInrtYmTwGsTbyRUr+5NfHHph396jF32dfy5keh7LcRGAuq1EBuJkddCbCTsXQvRgHgeYiMp61qIjQSnayE2koWuhdhIvLkWIonlPMRGLrL/KMSyhys1cjf9nYiThWoTJziVJp45XKmRS+HvRJxIVps4+a008cwxKI3cxn4n4iTD2sSJkZWJN3IN+p2IkzlrEydzFieefn2+kfvH70TcIF6ZOJmzNnEyZ23iZM7axMmctYmTOesSHxu54/xOxMmctYkbxLPEMweIjQP2Iwux9AFiYyu3lwtBTx+uNLZy1fl9iLdyL/qNiNMRLE282AFiYysXEd9UnMwBYmMrVxzfVZ70BruxlcuTW5UHd6UsTyt3OLcqD50jaXnY2iAtD6lHWh5DHmV52GFRT54ncRoBtYmT7QsTzxyuNLZySfWNiJPAKxNv5QLfJrvtrdz1e9tu+zBsn+0i8uCBpOXBMEnLg7u6Vp70UmIrd7c2Kk8rF722Kg+LIdLykHqk5SH3SMtjyKMsD4sh0vLQNbhWnmlDMoTj6zit3Ireqjx0DaTloWugLM9E10BaHroG0vLQNZCWh66BTO6JyWPIIxxLJ7oG0vLQNZCWh66BtDx0DaTloWugLE+gayAtD10DaXnoGkjLQ9dAWh5DHmV56BpIy0MslZaHWCotD7FUWZ6ZWCotD8Y6L497vyI17t+Reh2xOxsQz0PEpBaAyAJUAYj48QIQcc0FIOJtz0NccKAFILJ8UQAiiwwFIJJYCkA0IJ6HSGIpAJHEUgAiiaUARBJLAYgklixEv4Y3xGHNPZ85VXcl3pQm7v1295Hft+NfxMlCtYkTnGoTJ2XVJm4QL008uI34Epk5cc2lidv7cVsjf+NY7NrE8eN1iRu3oRcnHt5XeQcLR+L48drE8eO1iePHaxM3iFcmznpKbeIsvtQmTuasTZzMWZs4mbMycUfmrE2czFmbOJmzNnEyZ23iBvHSxMP2/ltYliNxMmdt4mTO2sTJnLWJkzlrEydzVibucYelidt2C/QD77eV5ePDyTuJzTPJXilO5tSFxz+PPMryMH1fKk96x7t55npleUaa0dLy0LmWloc2t7Q8pB5peQx5lOWh2y4tD10DaXnoGkjLQ9dAWh66BvXk+SJuNAJqEyfb1yZOXK9NnARem7hBvDJxcnJx4radsW/TceelEX1rEyfN1iZOQK1NnMxZmfhE5qxNnMxZmziZszZxMmdt4gbxysTJnLWJkzlrEydz1iZO5ixOPH3+4ETmrEw8kDlrEycBnSL+hEioKQDRgHgeItGjAEScVvFZqNj7uFxSf6k4bhje9xa5ozwzfkJaHpyKtDyGPJfKk36bfcZdSctDF1haHlrG0vKQeqTlIfcoy7PQuZaWh61V0vLQNbhWnmlDMoTjAYULXQNpeQx5lOWhayAtD10DaXnoGkjLQ9dAWh66BjK5JyLPStdAOZaudA2k5aFrIC0PXQNpeQx5lOWhayAtD10DaXnoGkjLQ9dAWh66BsLyTANdA2l56BpIy0MslZbHkEdZHmKptDzEUml5GjHWy/iWZ8iNY7UXbz+4JSvPOI5veSwr5zK/kLhldWl5km+WTq4RW31TcTLvxk2uEd/WqjyGPMryNOLbbitP2hi4Rnxbq/I0spzQqjyNLCe0Kg+pR1keT+6RlqeR5YRW5WlkE2Kr8tA1uFae5PsJkzfkUZaHroG0PHQNpOWhayAtD10DaXnoGijLM9I1kMk9MXnoGijH0pGugbQ8dA2k5THkUZaHroG0PHQNpOWhayAtD10DaXnoGijLY3QNpOWhayAtD10DaXkMeZTlIZZKy0MslZaHWKosz4Sxzsvj3q9Ije77i79PiNjfAhAxqQUgsgBVAKIB8TxEXHMBiHjbAhBxoAUgsnxRACKLDOchBhJLAYgklgIQSSwFIJJYCkA0IJ6HSGIpAJHEkoX4w4MEnduqdMF+/48d3EC8KU3c+/X1uN+341/EyUK1iROcKhOfSVm1iRPJihMPbiO+HGfO2SBemLi9H7c18jeOxa5NHD9emzh+vDTx4LaZM1g4EseP1yaOH69MfMGP1yaOH69NnPWU2sRZfKlN3CBemTiZszZxMmdt4mTO2sTJnLWJkzkrE1/JnLWJkzmLEw/b+29hOZ53uJI5axMnc9YmbhCvTJzMWZs4mbMu8TDgDksT/8mV0ck7icPAJHulOJlTF8LAjCwtD9P3pfKkd7yHgbleWh6a0dLy0LmWloc2t7I8jtQjLQ8NdGl56LZLy0PXQFoeQx5leegaSMtD16CePE/iNAJqEyfb1yZOXK9M3JPAaxMnVNcmTk4uTty2M/ZtCkfiRN/axA3ilYkTUGsTJ3PWJk7mrE2czFmbOJmzMvGRzFmbOJmzNnEyZ23iZM7axA3ilYmTOYsTT54/GEYyZ23iZM7axElAp4h/QTRCTQGI5JQCEIkeBSDitIrPQsXex+WS+otf+Bze9xa5iDz4CWV5uKReWx480LXypN9mn3BX0vLQBZaWx5BHWR5Sj7Q85B5peehcS8vD1ippeegaXCvPtCEZwvGAwkDXQFoeugbS8tA1kJaHroG0PIY8yvLQNZCWh66BTO6JyUPXQDmWBroG0vLQNVCWZ6ZrIC0PXQNpeegaSMtD10BaHkMeZXnoGkjLQ9dAWh66BtLy0DVQlmchlkrLQyyVlodYKi0PsVRZnrXq3BO280Sm1WXkGd+DWN6jePyDsWEsL4Czje9no/hsW5+cnPv27BOIA8h3IB4g34GMAPkOxADyHcgEkO9AQm9AJrd5i2nJPOvc27Z8PfHrae/dL3wz+M7gW8B3Bl/NTQ1hcK/BzPOYwecGN2+0B+/Gb875j8HPw3Dnwbs7D97fefDjnQdvdx78dOfBhzsPfr7z4Jc7D/7OM6wTnmG9W9+DH/23wcecUPKWydkJT8eFKxWeuwtXKjzR/7DS9Lmqc9Ubhq+tVNhCFK5U2G/8sNLwfjxYOFYqbE4KVyrsZApXKmx7ylbq2/FIuUrb8Ui5StvxSCFsa8RhWY6VtuORcpVaN5W245FylTbkkTKVNuSRMpU25JEylTbkkdKVjg15pEylDXmkTKXK8+m+sblMvx8am6Pwz+k4vgc/2pyTKfn8s1jhX9QfFjtP6/vTjz2TUfgXtWylJvyLWrhS4YTyw0qX+TUUt6zf9useH07eSzKbsPH9IJTMjufZ2vlZ/xGWzEKItTMBFMXSzmxREsvUztRSFIuws78Si3Cr9EosfbqWLBYDSwyLcMe2GJZnpT0Y12elzXhRP2wvJfpHE+lYaTP2MltpM44xV+ncpzdOp+6lU2ecvkdwXjr1OjksBpYYlh68zs9bVwsdvSiWTjt6OSyddvRyWDrt6GWwrL36lgyWTjt6OSyddvRyWHp1uck7P+aqB4TcCEuvLjeDpVeXm8HSq8vNYOnV5Waw9Opyk1gW5eNAavmWGBZcbsTOLcpHmFyJpVeXm8FiYIlhoZcbxUIvN4qFXm4UC73cKBZ6uTEsykfyXIkFlxvFgsuNYjGwxLBg56JYsHNRLNi5GBbl82BG996aM7rvl1E8B688jWYHrzzZZQev3HjJDl55Ps0OXnnWyw5eeW7KDl55BskOXjm2ZwevHK5zg1c+TSQ/+DvPsOOdZ9jxzjOs8mkr+cHfeYYdlc8Y+9nlcum3EBflQ3F+WKn325ki3uZjpcpnjJWtVPmMsaKVKp+IU7hS5TPGflhp2D7dL8dfJBOe9X56sWfytO/FlM/sLFtpO/NprtJ25tP0ecmL8gFDhSttZz7NVKp8DFDhStuZT3OVKp9rXrZS5XPNy1Zq3VTajkfKVdqOR8pV2o1HUj4lp3Cl3Xik0I1HCg15pOS55ktoyCNlKm3II2UqtW4qbcgjZSptyCOlK53bmWVsO3XOmf/WMTs+nDyLbZnb+fH6CZTc7sO5nV+6olgaaq//BEtmxXduqBdfEks7obQolnYSbFEs7cTdkliUD0u9Eks7QboolnZSd1EsnbrcHBYDSwwLLjeKpQeX+6y0B+P6rLQHL/qstAd7+VWp8jG1hSvtwQQ+K23I19n2TrFNxxUy5fNhC1dq3VTakKHKVNqQR8pU2pBHylTakEfKVNqQR0pWuiofclq40oY8UqbSXjzSqny6aOFKrZtKe3lzaVU+1rNwpQ15pEylN3UOX4NXPgsyP/ibzu/Pwd90yn4Ovs9lguR+slX5kL+PbpxK3ta4uk43N2SwKB/ydyWWTjc3pHcfrsoHE16JhS28USwGlhiWTjc35LD06lsyWDrdwpvD0ukW3hyWXl1u8ka1VfmgzSux9OpyM1h6dbkZLL263AwWA0sMS68uN4MFlxvFgsuN2bmGjnctiqVXl5vG0tDBsUWx0MuNYqGXG8VCLzeKxcASw0IvN4oFlxvFgsuNYsHlxrA0dG5xUSzYuSgW7FwUC3YuiqXmBD0NW0ts2j0cxzJNywviFLzLfPRg7zLnzDjCOv96dh5cZhSP+l4P2/6D/Rp5eJ5fOi7D7tEpVp29UEy7+1Aejz5VmVHlElXC69FpDkdVFlQRVGVFFT1Vqp4jjSr/WVUcqgiq4lFFUJURVQRVMVS5WJVlOqoyoYqgKmT7i1TZsv0aUYVsf40q05JShWyvqArZXlCVmWx/iSrBb9z8clSFbK+oCtleURWyvaIqhiqXqOJsU2U9qkK2V1SFbK+oCtleURWyvaIqZHtBVRayvaIqZPurVRmPeWUh2yuqQra/SJVx4xZRxVDlElU2FFFVyPaKqpDtFVUh21+jyrYWGWZ3VIVsr6gK2V5QlZVsr6gK2V5RFbK9oirklUtUSb+tupJXrlEl+abESl5RVIW8oqgKeUVOFT8M5BVFVcgriqqQVxRVYS3yalUO70U+VDFUEVSFbH+RKn//bdWHKmT7a1RJvIH3UIVsr6gK2V5RFbL9Jaqk3vXygyPbK6pCtldUhWyvqArZ/hpVEm9KPFQxVBFUhWyvqArZXlEVsr2iKmR7RVXI9oKqeLL91aqMx7ziyfaKqpDtL1Ll77+t+lCFbH+NKok38B6qGKoIqkK2V1SFbH+NKon3Vx6qkO0VVSHbK6pCthdUZSTbK6pCtldUxVDlClVSb6s+VCGvXKNK8k2JkbyiqAp5RVEV8oqiKuQVQVWMvKKoCnlFURXWIq9WJfJepLEWqaiKoco1qqTeVjWy/TWqJN/AM7K9oipke0VVyPaXqJJ+18vI9oKqTGR7RVXI9oqqkO2vUSX5psREtldUxVBFUBWyvaIqZHtFVcj2iqqQ7RVVIdtfrUrkvchAtldUhWx/kSqpt1UD2f4aVZJv4AWyvaIqhiqCqpDtr1El+f5KINsrqkK2V1SFbK+oCtleUJWZbK+oCnnlElXSb6vOhiqXqJJ8U2ImryiqQl5RVIW8oqgKeUVRFfKKoCoLeUVRFdYir1Yl8l7kwlqkoipk+4tUSb2tuhiqXKJK8g28hWyvqArZXlEVsv0lqqTf9VrI9oqqkO0FVVnJ9oqqkO2vUSX5psRKtldUhWyvqIqhiqAqZHtFVcj2iqqQ7RVVIdtfrUrkvciVbK+nihvI9hepknhb1Q1k+2tUSb2B5wayvaIqZHtFVQxVLlEl9f6KG8j2iqqQ7RVVIdsrqkK2V1SFbC+oijuZV/w8bJ0D82kaj3/bK9B6P73f0RydRUGP47iRHi37/DK//kDcsu5oxx5extffx7Ir8fHoE8rYJZRHo2fYPttFsASwxLDMYIlhWTrFMr7nh8kdsaxgiWDxA1hiWBxYYlj6dC1ZLL36lgwWA0sMywSWGJZeXe60ReYhLEcsvbrcDJZeXW4GS68uN41l7NXlZrD06nIzWHp1uRksuNwoFgNLxM6NuNwoll5dbgZLry43g4VebhQLvdwYFqOXG8VCLzeKhV5uFAsuN4rFwBLDgsuNYsHORbFg56JYsHMxLBN2LopFeYJ27605435vjnsNXnkazQ5eebLLDl658ZIdvPJ8mh288qyXHbzy3JQbfFCeQbKDV47t2cErh+vs4O88w569IPXawd95hg13nmHDnWfYcOcZNgjPsH4N78EPa+5557YF9Mfv0CG5zMLT8Q8r9X59Pe738e9VqfDcXbhS4Ym+cKXCrqBwpdZOpcFtlS6RXyThWe+Hldr7cVsjmgpPkYUrbWc+zVS6tDOfBrf9IgULx0rbmU9zlbYzn+YqbWc+zVXaznyaq1Q4vxeuVDjsF660HY+Uq7Qdj5SrtB2PlKl07cYjrd14pLUbj7R245HO3regVGnY9m+E5fi+zNqQR8pU2pBHylTakEfKVNqQR8pU2pBHSlbqh3ZmGRu2Ss1/65gdH06exeaHdn68fgIls/vQDw11zEtiaai9/hMs6RVfPzTUiy+IxbUTSotiaSfBFsXSTtwtiqVP15LFYmCJYWkndRfF0qnLzWHp1OXmsOByo1h6cLlflSqfllu40h686LPSHuzls9IeHOOzUuum0oZ8nW3vFNsUjpU2ZNUylTbkvjKVNmSoMpU25JHSlSqftVq40oY8UqbShjxSptKGPFKmUuum0m48kvLpooUr7cYjKZ8BWvR9Hq98rGfZSpVP6ixc6U2dw3PwNzUDz8HbnQd/0yn7Ofg+lwnS+8mUD/n76Map5G2Nfup0c0MOS6ebG3JYbvqbfhpLeveh8sGEV2JhC28UC1t4o1g63dyQw9Krb0ljUT5a8kosnW7hzWHp1eUmb1TzygdtXonFwBLD0qvLzWDp1eVmsPTqcjNYenW5GSy43BiWhk5sLWnnGjretSiWXl1uBkuvLjeDxcASw0IvN4qFXm4UC73cKBZ6uVEsuNwYlobOUS6KBZcbxYKdi2IxsMSwYOeiWLBzUSwnJ2i3zC8s3lwai1vtVacf3JLF8sErT9M7584e4XtTKLm9UGfPhm0Vi4ElhmXqFEv6B/fsEbWtYpnBEsOygCWGpU/XksEyDr36lgwWB5YYFg+WGJZeXW5yv8I4GFhiWHp1uRksvbrcDJZeXW4GS68uN4OlV5ebxuJwuVEsuNyYnXO43CiWXl1uBouBJYaFXm4UC73cKBZ6uVEs9HKjWOjlxrB4XG4UCy43igWXG8ViYIlhwc5FsWDnoliwczEso/IE7d5bc0Z3PDBvHJWn0ezglSe77OCVGy/ZwSvPp9nBK8962cErz03ZwSvPINnBK8f27OCVw3Vu8HbnGdbuPMPanWdYu/MMe/YM6WsHf+cZ1oRn2B++IJS+PfKRk5qp1Pv19bi3+Vip8NxduFLhib5spZOwKyhcqbCF+GmlwW2VLsdfpLOnbAtVmr6dY5yEp8jClbYzn+YqbWc+DW77RQoWjpW2M5/mKm1nPs1UGtqZT3OVtjOf5ioVzu+FKxUO+4UrtW4qbccj5SptxyPlKu3GI4VuPFLoxiPN3XikuSGPFLb9G2E5vi8zN+SRMpU25JEylVo3lTbkkTKVNuSR0pUu7cwyxW4xHZd2frwKnts3Lu380hXF0lB7/SdYMiu+S0O9+JJY2gmlRbG0k2CLYmkn7pbEonxY6pVY2gnSRbG0k7qLYunU5eawGFhiWHC5USw9uNxnpT0Y12elPXjRZ6U92Ms/KjXlY2oLV9qDCXxW2pCvs+2dYpvCsdKGrFqmUuum0oYMVabShjxSptKGPFKm0oY8UqbShjxSulLlQ04LV9qQR8pU2o1HUj5dtHCl1k2lvby5ZMrHehautCGPlKn0ps7ha/DKZ0HmB3/T+f05+JtO2c/B97lMkNxPZsqH/H1041TytkbznW5uyGBRPuTvSiydbm5I7z405YMJr8TCFt4oFgNLDEunmxtyWHr1LRksnW7hzWHpdAtvDkuvLjd5o5opH7R5JZZeXW4GS68uN4OlV5ebwWJgiWHp1eVmsOByo1hwuTE719DxrkWx9Opy01gaOji2KBZ6uVEs9HKjWOjlRrEYWGJY6OVGseByo1hwuVEsuNwYlobOLS6KBTsXxYKdi2LBzkWxnJ2gt0eD222ljmIJ6wvhPOxGMi6RZ23wr4dt+ONf/etpv0YenucXv2XYPTpFHp3s1ZWbdveQPB590pg7oxFej05zONJYoLGjsULjTeP0OcFt0XDQ2NHw0NjRGKGxo2Hd0limI40JGjsavXnRsHnRNUKjNy86LSkavXnRNI3evGiSxtKZFw3eb62I5UijMy+aodGZF83Q6MyLZmhYZzTcNl6/Hml05kUzNDrzohkanXnRDI3OvGiGRmdeNE1j7c2Lpmn05kXfNMaj31h786JpGr15Ufc6dCpYhIZ1RmOYUjR686JpGr150TSN3rzo1vsKszvS6M2Lpmn05kVTNKahNy+aptGbF03T6M2Lpmn0tg6b2gU3Dd2twyZ2LEwDewL3NNgTuKfBnsAdDceewD0N9gTuabAncE+j3z2Bx31f0+mT5dui0d2ewMQuuMn15kVTO50mx57APQ32BO5p9Nb7Su3tmTx7Avc02BO4p8GewD2N7tZhEzsWJm/Q2NFgT+CeBnsC9zTYE7inwZ7APQ32BO5ojP3uCTzu+5pG9gTuaXS3JzCxC24ae/OiqZ1O0+lrU9qiwZ7APY3evGhy/8bInsA9DfYE7mmwJ3BHw9gTuKfBnsA9DWMX3I5Gv2ezRHYsGHsC9zTYE7inwZ7APQ32BO5oTOwJ3NNgT+CeRr97AiP7vib2BO5pGLvgdjR686LJnU4TewL3NNgTuKfRW+8rubdnYk/gjkZgT+CeBnsC9zT6PZslsmMhsCdwT8OgsaPBnsA9DfYE7mmwJ3BPgz2Bexr97gmM7Pvq7f6UDI3u9gSmdsH1dn9KeqdTb/enZGgYNHY0evOiyf0bvd2fkqHBnsA9DfYE7mmwJ3BHo7v7U9I0eluHTe6C6+2OjPSOhd7uyMjQYE/gngZ7Avc02BO4p8GewB2N3u7IyNDod09gZN9Xb3dkZGh0tycwtQuutzsy0judersjI0ODPYF7Gr31vpJ7e7q7IyNNgz2Bbxqhuzsy0jT6PZvluGMhdHdHRpoGewL3NAwaOxrsCdzTYE/gngZ7Avc0+t0TOEb8BnsCdzR6uz8luQsu9HZ/SnKnU+jt/pQMDfYE7mkY+zd2NNgTuKfBnsA9DfYE7mmwJ3BPgz2BOxpn78gY3jSGOUNjml8FTssuMa3Lr6GM9YbySCRbeLPIUExnKJPOUILOUGadoSw6Q1llhnL2LPyfDWXYng2RoTidoXidoYw6QzGdoUw6Qwk6Q5l1hrLoDGWVGYrp/Nqazq+t6fzams6vren82prOr61V/F0Zl23747gsu3dx7NdYVp2xTIPQWJzQWLzQWEahsQSZfsKkMz8Hnfk56MzPQWd+PnsQ2uB2Q5nTQ7HtRUyz9+eOo/s1FNMZyqQzlKAzlFlnKIvOUFaZoZw9c6nkUJzOUPynhvL8+PGzH2+f/fjpsx8fPvvx82c/fvnsx68f/fhl+OzHu89+/Ge/tctnv7XLZ7+1y2e/tWfPPRiWbd/bsC6nfrzPHjpQciiLzlBWmaGcfde95FCczlC8zlAqbiX8+0Opt+3D/LqNwacf9ev82iLi13W3mBtiTZdh2807DaPbP/zkbHCuwnmCcxXOAc5VOM9wrsJ5gXMVzmtnnOfXC+c2j/tH/6Ax13z9/gY0HDR2NHxfNB6/HNsPhz/S6CynZGgYNHY0OvP8k98OTfPzkUZnzjxDozP/nKbhOvMbycOdZ9fZnJJ85Wmu+RrtDWiozilueuUrc6vb03iOW/XX39mcHLfq77Qb1+S4VfsGuXGr5vDMuH1vifmaPs3se8viV3HuLOVfxpl1zjqcDc5VOLPOWYdzb+ucyZ607201Mk2jtzXDNI3OVvbSPemxt05bmkZnaSJDo7eVvWRPeuxtZS9Nw6Cxo9Hb6k1yvcI6m1PSHXrrbE7J0FCdUzLrFab6659ZrzDV3+lM/9xk17Uy45Zd18qMm/27Vfo0xv7dOpx72797EeeJdc46nFnnrMOZdc46nHtb50z2pCeDxo5Gb2uGaRq97ZNO9qSn3jptaRqdpYkMjd5W9pI96dDbyl6aRm8re2kaxnrFjkZnc0q6Qx86m1MyNGT3n6fXK2bVX//MesWs+jud6Z/PsutamXHLrmtlxt3ZDHZVn2Zm/24dzpxTVIcz65x1OLPOWYcz65xVOC+cgLRLRQsnIO1p9LZmmKbBCUh7GgaNHY3eTkBK0+AEpD0NTkDa0+htZS9JY+1t9Sa5XtHbGd3pDn1vJ2lnaMjuP0+vV8ieH51Zr5A9jznTP5c93zg97kX2JOLcuEVnsHG2l0Ud5+OFoIvq6b7ZcYum0Oy47abjFp2Fs+MWnS+z4xadL7PjFp0vs+MWnS9z41Y9STc77pvOl+6m86XqGcPZcd90vlQ9tzc77pvOl6rn9mbHfdP5UvXc3ty4Vc/tzY77pvOl6rmy2XHfdL5UPfc0O+6bzpeq53Jmx33T+VL1rMvsuG86X6qeH5kd903nS9UzGceHw36NYdnvn3uNW3W+zI1bdb7MjfvsfLm8Pj54c+lxu9Veq5d+cO97vkdnsacHN7+WAt3g3fjt+efgw50HP9958MudB7/eePCnD828dPDuzoP3dx78eOfB250Hf+cZ1oRnWO/W9+BHn3veuZdrci683/IYX5UKT8eFKxWeuwtXKjzR/7BSW1+f/viP86HSSdgVFK5U2EIUrlTYb/yw0vB+PFg4VipsTgpXat1UKmx7ClfajkfKVdqOR8pV2o5HCmHZKl2WY6XteKRMpaEdj5SrtB2PlKu0IY+UqbQhj5Sp1LqptCGPlKm0IY+UqbQhj5SudFaeT/eNzWX6/dDYnIV/TsfxPfhx917vf+X5Z7HCv6g/LHaetj/heT72TGbhX9TClQr/ohauVDih/LDSZTsRxy27lz/H2MPL+OptL7sSX1AWYeP7QSiPD9zmpGFyRyzt/Kz/CEtmIeT06UKNYmlntiiKpZ2ppSgWYWd/JRbhVumVWPp0LTksq3BovBKLcMe2GJZnpT0Y12elzXhRPwzbCbmPJtKxUuum0mYcY7bSkybQz8Or0nF3AnO0Uu+2Q5W9n/INr+y2xbOnhF07+OXOg1/vO/j17KFh1w7e3Xnw/s6DH+88eLvz4Kc7D/7GM+w6CM+wRTeRr4PwdFy4UuG5u2ylTniiL7qJfHXCrqBwpcIWonClwn6j6Dbc9eypbTeqVNjJFK5U2PYUrrQdj5SrtB2PlKu0HY+U3t63+nY8Uq7SdjxSrtJ2PFKu0oY8UqZS66bShjxSptKGPFKm0oY8UqbShjxSutJReT7NvBiwjsI/p6VfDFhH4V/UopvI11H4F7VwpcK/qGUrNeGEctWLAasJG9/rXgxYrZ2f9YL7DldrZwIoiqWd2aIolnamlqJYhJ39lViEW6UXYpn6dC1ZLMKh8Uoswh3botvl16kH4/qs1FqpNLOJfJ2asZfZSptxjLlKw8d+qJ8f7z/78eNnP94++/HTZz8+fPbj589+/EkbbsPrVzuYDemvoHPvLVp+d61G/BKOaVpel7VMwede+xns3cmYM+P40dXjj+b36+H9B/s18vA8v+pbht2jU+xz/Xaj+U6V6KN+nbfflnV9ux0fYtSG7WduGvZXl4Rfeq/o3ZPeZ8+bQu+b6e3Quyu9PXp3pfeI3l3pbeh9id5bN8rmcf/oU5UJVQRVCagiqMqMKleo8phZtonFH1Wh76OoCt0ZQVUWeijXqOJfj05+PqpCp0NRFfoRiqqQV65RZRvDZBFV8GCXqBKm13jD7I6q4MEEVVnxYGlV3PTqI5rbbZ96qPLkh1vK8LM5yQ9fk+E3rkl+rFuc42fwO8UPB3zJrH7VutnKWkBferPK0JfeZOe+9CaVd6T3OAzk/b70pj9xjd6JvRsPVeh6KKpCL0VRFUOVK1RJ7d14qELfR1EVujOKqtBDuUaVxN6Nhyp0OhRVoR8hqIojr1yjSmKf00MVPNglqqR21DxUwYMpqoIHS6uS3Of04IdbyvBL7XN68MPXZPil9pmMg2fd4hw/1gHO8cMBXzKrX7Vu5lkL6EtvQ++u9CY796U3qbwvvcn7felNf+IavZN7NzxdD0FVRnopiqrQoblElfTejZG+j6IqdGcUVTFUuUSV5N6NkU6Hoir0IxRVIa9co0pyn5PhwS5RJb2jxvBgiqoYqiRVyexzMtxShl96n5PhazL80vtMjHWLc/xYBzjHDwd8yax+1brZxFpAX3qzytCX3mTnvvQmlfelt6F3V3rTn7hG7+TejYmuh6Iq9FIUVaFDc4kq6b0bE30fQVUC3RlFVeihXKNKcu9GoNOhqAr9CEVVyCvXqJLc5xTwYJeokt5RM+PBFFXBg6VVyexzmnFLGX7pfU4zvibDL73PZDb4neLHOsA5fjjg5CjG2V6jGOdl51XtFz966+f40QU/x4+sdIrfQqo5x4/8cY4f+eMcP/LHOX4Gv1P8yB/n+JE/zvEjf5zjR/44x4/8cYrfSv44x4/8cY4f+eMcP/LHOX4Gv1P8yB/n+JE/zvEjf5zjR/44x4/8cYafG8gf5/iRP87xI3+c40f+OMfP4HeKH/njHD/yxzl+5I80v8W99u+Oy27MGz/yxzl+5I9T/Fwj+cNtZ5s8/i3fxvEss5GYkCvT2ijTj3776NkyD6/2Gocf3PIeh7PoF83N4/ZN82789vwTYiOW6lqIjfiqayE2Yq6uhdiIw7oWYiM261KIvhGvdS3ERpzctRAb6fpeC7GR1u+1EA2I5yGSWLIQvVvfEEefe/6RAregHd5DGV/EiTe1iZOFahMnOJUmbu8qbZ2PxElZlYm3cgX5jYiT30oTD+/Hg4UjccJebeIkw9rEDeKViZM5axMnc9YmTuYsTjxsGxjCshyJkzlrEydzViZuZM7axMmctYmTOWsTJ3PWJm4Qr0yczFmbOJmzNnH8eJ74fkPEMn17/gtiK7dNfxLiOL4hjrtbYP4rzz+h40BKQ5+n7adlno9raa1cunwj4jiQ2sTpCJYmvmz34rpldyXFGHt4GV97hJYd6pc4rdxAeVNxHh/4fmt0ckd5sEGXypPZYNfKnZStymPIoywPVkxaHjpH0vKwtUFaHlKPtDw0aZXlaeWq5FvI8yROI6A2cbJ9YeJ+GJbt032EOHG9NnGDeGXixIIrjU26297KXb237bYPw/bZ7ihPK1extioPhklaHtzVtfKklxJbuae2VXlYDJGWh8UQaXlIPdLykHuk5WExRFmeVm44blUeugbXyjNtS4lDOL6O08r9zK3KQ9dAWh5DHmV56BpIy0PXQFoeugbS8tA1kMk9MXnoGgjHUt/KveStykPXQFoeugbS8tA1kJbHkEdZHroG0vLQNZCWh66BtDx0DaTloWugLI+jayAtD7FUWh5iqbQ8hjzK8hBLpeXBWOflce9XpMb9O1LuBRH7ex6ix6QWgMgCVAGI+PECEHHNBSAaEM9DxIEWgMjyRQGILDIUgEhiKQCRxHIe4khiKQCRxFIAIomlAEQSSwGIBsQcRP8e9jAOa+759Km6fiTelCb+sEfbUPbt+BdxslBt4gSn2sRJWbWJE8mKEw9uG8pynDm5Db04cXs/buvxb5zb0KsTN4hXJo4fL008vK/yDhaOxPHjtYnjx2sTx4/XJo4fr0x8Yj2lNnEWX2oTJ3PWJk7mrE3cIF6ZOJmzNnEyZ23iZM7axMmctYmTOYsTD9v7b2E5nHfoA5mzNnEyZ23iZM7axMmctYkbxCsTxx2WJm7bLdDO/LeV5ePDyTuJ/cwke6U4uVMXZmZkaXmYvi+VJ7PjfTbkUZaHZrS0PHSupeWhzS0tD6lHWh4a6MryLHTbpeWhayAtD10DaXnoGkjLY8hTTZ4ncRoBtYmT7WsTJ67XJk4Cr02cUF2Z+EpOLk7ctjP2bTruvFyJvrWJk2ZrEyeg1iZuEK9MnMxZmziZszZxMmdt4mTO2sTJnHWJjwOZszZxMmdt4mTO2sTJnMWJJ88fHAeDeGXiZM7axElAp4g/IRJqCkAkp5yH6IgeBSDitIrPQqXexx25pP7iFz6H971FLiIPfkJaHpyKtDx4oGvlSb7NPnrclbQ8dIGl5aFlLC0PqUdaHkMeZXnoXEvLw9YqaXnoGlwrz7S98DmE5SgPXQNpeegaKMsz0jWQloeugbQ8dA2k5aFrIC2PIY9K7onJQ9dAOZaOdA2k5aFrIC0PXQNpeegaKMtjdA2k5aFrIC0PXQNpeegaSMtjyKMsD10DaXnoGkjLQyyVlodYqizPRCyVlodYKi2PrjUIft7kWdfMRz+efn30tH7T8lmmbmO+ZJnCN97/pEzv7PVH672fcg+7cXt4mrNfNjdvh9oM3o3fnn9C1P3FuhFE3XbXjSDqNqVuBNGAeB6iboPnRhDb8FoXQ2zDyV0MUbfjdCOIun2h+0CcSSwFIJJY8j0Wt74hjj73fPrCwXEm3tQmThaqTdwgXph45ujTmZRVmziRrDZx8ltp4uH9eLDjMe0zYa82cZJhZeILMbI2cTJnbeJkztrEyZzFiYdtO0pYjq8fLwbxysTJnLWJkzlrEydz1iZO5qxNnMxZmfhK5qxNnMxZmziZszZx/Hie+H5DxDJ9e/4JEfuRhTiOb4ijnXv+CR0HUhr6PG0/LfN8WEsz4Wu9WyWOA6lN3CBemPgyby+RLeu3VwKPDyevPjThu3p7ECfzcqcJ3wLchTzpDXYmfL8w8owmfHMx8jzkwYpJy0PnSFoetjZIy2PIoywPTVppedhhUU+eJ3EaAbWJk+0LE/fDdq6WH3yEOHG9MnHh2+1bJU4suNLYpLvtwhdu99FtH4bts11EHjyQtDwYJml5cFfXypNeShS+Mhh5HvKwGCItD4sh0vKQeqTlMeRRlofFEGl5WAyRloeuwbXyJK+rN+Erg5HnIQ9dA2V5hK8MRp6HPHQNpOWhayAtD10DaXkMeVRyT0weugbKsVT4ymDkechD10BaHroG0vLQNVCWR/hGZ+R5yEPXQFoeugbS8tA1kJbHkEdZHroG0vLQNZCWh1gqLQ+xVFmeQCyVlodYKi2PIU9WHvd+RWrcvyPlXhCxvwUgYlILQGQBqgBE/HgBiLjm8xBnvG0BiDjQAhBZvigAkUWGAhANiOchklgKQCSxFIBIYikAkcRSACKJ5TzEhcSShejfwx7GYc09nzlVdyHelCbu/Xb3kd+341/EyUK1iROcahM3iFcmTiQrTjy4rcolMnPimksTt/fjtkb+xrHYlYlzG3p14vjx0sTD+yrvYOFIHD9emzh+vDZxg3hl4vjx2sRZT6lNnMWX2sTJnLWJkznrEp8GMmdt4mTO2sTJnLWJkzlrEzeIVyZO5ixOPGzvv4VlORInc9YmTuasTZzMWZs4mbMycUfmrE3cIF6YuG23QDvz31aWjw8n7ySeHJPsleJkTl2YHDOytDxM35fKk97xPnnmeml5aEZLy0PnWloe2tzS8hjyKMtDA11aHrrt0vLQNZCWh66BtDx0DZTlGeka1JPnSZxGQG3iZPvaxInrtYkbxCsTJ1TXJk5OLk7ctjP2bTruvByJvrWJk2ZrEyegViZuZM7axMmctYmTOWsTJ3PWJm4Qr0yczFmbOJmzNnEyZ23iZM7axMmcxYknzx+cJjJnbeJkztrESUCniD8hGhDPQySnFIBI9CgAEadVfBYq9j4ul9RfKo4bhve9RS4iD35CWh5DHmV58EDXypN+mz3grqTloQssLQ8tY2l5SD3K8szkHml56FxLy8PWKml56BpcK8+0vfA5hOMBhbMhj7I8dA2k5aFrIC0PXQNpeegaSMtD10BZnoWugUzuiclD10A5li50DaTloWsgLY8hj7I8dA2k5aFrIC0PXQNpeegaSMtD10BZnpWugbQ8dA2k5aFrIC2PIY+yPMRSaXmIpdLyEEuF5QlDG8bahWFbdQze7x9+ltlGY94t25DdOuTGsdprHH5wS/av0M3baS+Dd+O3558QDYjnIbbhJi6G2MacfzHENmbmiyG20da9GGIbzddrIbpGnNy1ENtoZF4MsY1248UQSSwFIBoQs80Ht74hjj73fPomvuCIN7WJk4VqEyc4lSaePhM0OFJWbeJEssrEPfmtNPHwfjxYOBIn7NUmTjKsTZwYWZu4QbwycTJnbeJkzuLEw7ZPIyzLkTiZszZxMmdt4mTOysRHMmdt4mTO2sTJnLWJkzlrEzeIVyZO5qxNHD+eJ77fELFM357/gmjYjyzEcXxDHG0+9fwTOg6kNPR52n5a5vm4lmY4kNrEDeKVidMRLE18mV9I3LJ+e1fu+HDyTsDQyEXNdxUn99ZjI7c631aezAa7CcMkLQ/uSloeQx5leegcScvD1gZpeUg90vLQpJWWhx0W9eT5Ih5oBNQmTrYvTNwP24FT/rGodyROXK9NnARem7i1QXx1b+KLSz/802Pssq/jh0ai77UQGwmo10JsJEZeC7GRsHctxEYi2aUQ50ZS1rUQGwlO10JsJAtdC7GReHMtRAPieYgklizEsocrNXI3/Z2Ik4VqEyc4lSaeOVypkUvhb0S8kXve70Sc/FaaeOYYlEZuY78TcZJhbeIG8crEyZy1iZM5axMncxYnnn59vpH7x+9EnMxZmXgjt4TfiTiZszZxMmdt4mTO2sQN4pWJkzlrEydz1iaOH88TzxwgNg/YjyzE0geIza3cXi4EPX240jwYxCsTx4HUJk5HsDTxYgeIza1cRHxTcTIHiM2tXHF8V3nSG+zmVi5PblUeQx5lebBi0vLQOZKWh60N0vKQeqTloUmrLE8rl1TfQp4ncRoBtYmT7QsTzxyuNLdySfWNiBvEKxMnFlxpbNLd9lbu+r1tt30Yts92R3lauTS1VXkwTNLy4K6ulSe9lNjK3a2tysNiiLQ8LIZIy0PqkZaH3CMtD4shyvIYiyHS8tA1uFaeaVtKHMJylIeugbQ8dA2k5THkUZaHroG0PHQNpOWhayAtD10DmdwTk4eugXIsnegaSMtD10BaHroG0vLQNZCWx5BHWR66BtLy0DWQloeugbQ8dA2k5aFroCxPoGsgLQ+xVFoeYqm0PIY8yvIQS6XlwVjn5XHvV6TG/TtSryN2A/b3PMQZk1oAIgtQBSDixwtAxDUXgGhAPA8RB1oAIssXBSCyyFAAIomlAEQSy3mIC4mlAEQSSwGIJJYCEEksBSAaEHMQ/XvYwzisueczp+ouxJvSxL3f7j7y+3b8izhZqDZxglNt4qSs2sSJZMWJB7dVuRxnTm5DL07c3o/bevwb5zb06sQN4pWJ48dLEw/vq7yDhSNx/Hht4vjx2sTx47WJ48frEl8G1lNqE2fxpTZxMmdt4mTO2sQN4pWJkzlrEydz1iZO5qxNnMxZmziZszjxsL3/FpbDeYeLI3PWJk7mrE2czFmbOJmzNnGDeGXiuMPSxG27BdqZ/7ayfHw4eSfx4plkrxQnc+rC4pmRpeVh+r5UnvSO98Ub8ijLQzNaWh4619Ly0OaWlofUIy0PDXRleUa67dLy0DWQloeugbQ8dA2k5THkqSbPkziNgNrEyfa1iRPXaxMngdcmTqiuTNzIycWJ23bGvk3HnZdG9K1NnDRbmzgBtTZxg3hl4mTO2sTJnLWJkzlrEydz1iZO5qxMfCJz1iZO5qxNnMxZmziZszjx5PmDy2QQr0yczFmbOAnoFPEnREJNAYjklPMQA9GjAEScVvFZqNj7uFxSf6k4bhje9xa5iDz4CWl5cCrS8uCBrpUn/Tb7jLuSlocusLQ8tIyl5SH1SMtjyKMsD51raXnYWiUtD12Da+WZthc+h3A8oHCmayAtD10DZXkWugbS8tA1kJaHroG0PHQNpOUx5FHJPTF56Boox9KFroG0PHQNpOWhayAtD10DZXlWugbS8tA1kJaHroG0PHQNpOUx5FGWh66BtDx0DaTlIZZKy0MsFZZnHYil0vIQS6XlsTbkWca3PENuHKu9xuEHt2TlGcfxLY9l5VzmFxL3aMqk5Um+WboOjdjqm4qTeTduHRrxba3K04hva1Qe14hvu608aWPgGvFtrcrTyHJCq/I0spzQqjyGPMrykHuk5WlkOaFVeRrZhNiqPHQNrpUn+X7C6ugaKMvj6RpIy0PXQFoeugbS8tA1kJbHkEdZHroGMrknJg9dA+VY6ukaSMtD10BaHroGyvKMdA2k5aFrIC0PXQNpeegaSMtjyKMsD10DaXnoGkjLQ9dAWh5iqbI8RiyVlodYKi0PsVRaHox1Xh73fkVqdN9f/H1CxP4WgIhJLQCRBagCEPHj5yFOuOYCEPG2BSDiQAtAZPmiAEQD4nmIJJYCEEksBSCSWApAJLEUgEhiOQ8xkFgKQCSxZCH+8CBB57YXKlyw3/9jBzcQb0oT937dqty341/EyUK1iRvEKxMnZdUmTiQrTjy4rcolMnPimksTt/fjth7/xmcsdm3i+PHaxPHjpYkHt82cwcKROH68NnGDeGXi+PHaxPHjtYmznlKbOIsvtYmTOSsTX8ictYmTOWsTJ3PWJk7mrE3cIF6ZOJmzNnEyZ3HiYXv/LSzH8w4XMmdt4mTO2sTJnJWJr2TO2sTJnLWJ4w5LE//JldHpO4lXJtkrxcmdurAyI+vKY8PA9H2pPMkd7w95mOul5aEZLS0PnWtpeQx5lOUh9UjLQwNdWh667dLy0DWQloeugbI8jq6BtDx0DerJ8yROI6A2cbJ9beIG8crESeC1iROqaxMnJxcnbtsZ+zaFI3Gib23ipNnKxD0BtTZxMmdt4mTO2sTJnLWJG8QrEydz1iZO5qxNnMxZmziZszZxMmdl4iOZszjx1PmDD+JkztrEyZy1iRvEzxB/QiTUFIBITikAkehxHiLX1Mu+j/sQB1N2pThuGN73FrmIPIY8yvLgVKTlwQNdK0/6bXbDXUnLQxdYWh5axsryTKQeaXnIPdLy0LmWloetVdLyGPJcKs+0vfA5hOUoD10DaXnoGkjLQ9dAWh66BtLy0DVQlifQNZCWh66BTO6JyUPXQDmWBroG0vIY8ijLQ9dAWh66BtLy0DWQloeugbQ8dA2U5ZnpGkjLQ9dAWh66BtLy0DWQlodYKi0PsVRaHmKptDzEUmV5lppzj582hn7xGXnG9yCW9yjctMaGsbwAzja+n43is219cnLu27NPIAEg34HMAPkOZAHIdyArQL4BqXpF/C2AuN6ATG7zFtOSedY9ZubXiL+e+PW09+4XPg++M/hG8J3BZzXxrX7ztvuLnqL43ODm7YS6wbvxm3N+Dn668+DDnQc/33nwy50Hv9538G4Y7jx4d+fB+zsPfrzz4G88w7pBeIb1bn0PfvTfBh9zQslbJt0gPB0XrlR47i5cqfBE/8NK0+equkHYFZSt1AlbiMKVCvuNH1Ya3o8HC8dKhc1J4UqFnUzhSq2bStvxSLlK2/FIuUrb8UghbGvEYVmOlbbjkXKVtuORMpX6djxSrtKGPFKm0oY8UqbShjxSplLrptKGPFKm0oY8UqZS5fl039hcpt8Pjc1R+Od0HN+DH23OyZR8/lms8C/qD4udp+1PeJ6PPZNR+Be1cKXCv6iFKxVOKD+sdJm3T1/Wb/t1jw8n7yVxJmx8Pwgls+PZWTs/6z/CklkIsXYmgKJY2pktimJpZ2opikXY2V+JRbhVeiWWPl1LFotwaLwQyyTcsS2G5VlpD8b1WWkzXtQP20uJ/tFEOlbajL3MVmq9VDr36Y3TqXvu1Bmn7xF0c6deJ4elU6+TwbL04HV+3rpa6OhFsXTa0cth6bSjl8NiYIlh6dW3ZLB02tHLYem0o5fD0qvLTd754ZZeXW4ay9qry81g6dXlZrD06nIzWHp1uRksBpYYFlxuFAsuN2bnlI8wuRJLry43g6VXl5vE4pUPdLkSC73cKBZ6uVEs9HKjWAwsMSy43CgWXG4UCy43igU7F8OifLjOlViwc1Es2LkoFuUJ2r235ozu+2UUz8ErT6PZwStPdtnBKzdesoNXnk9zg1c+LiU/eOW5KTt45RkkO3jl2J4dvN158HeeYZUPCMkP/s4zrL/zDKt82kp28OOdZ9hR+Yyxn10ul34L0SsfivPDSh/fl9fj3uZjpcpnjJWt1LqpVPmMsbKVKp8x9sNKg9sqXSK/SMpnjP3wYs/kad/elM/sLFtpO/NprtJ25tP0ecle+YChwpW2M5/mKm1nPs1V2s58mqtU+VzzspUqn2tettJ2PFKmUuVTcgpX2o5HylXajUdSPiWncKXWTaXdeKSpIY+UPNfcTw15pEylDXmkTKUNeaR0paEhj5SptCGPlKm0nVnGtlPnnPlvHbPjw8mz2Hxo58frJ1Byuw9DQx3zgljmhtrrP8GSWfGdG+rFl8TSTigtiqWdBFsUi4ElhqVP15LF0k6QLoqlndRdFEunLjeHpVOXm8GifLTulVh6cLnPSnswrs9Ke/Ciz0qtm0p7cIzPSnswgc9KG/J1tr1TbNNxhUz5fNjClTbkvtKVKp/iWrjShjxSptKGPFKm0oY8UqZS66bShjxSptKGPFKm0m48kvLpooUr7cUjjcpngBZ9n2dUPtazcKUNeaRMpXbPSp+Dv6kZeA7+pvP7c/A3nbK/Bq98zN9V+8lG5UP+PrpxKnlb4+PfAJYYlk43N+SwdLq5Ib37cFQ+mPBKLGzhjWJhC28Mi/IxjVdi6dW3ZLB0uoU3h6XTLbw5LNYpluSNaqPyQZtXYunV5Waw9OpyM1h6dbkZLL263DQW5aNSr8SCy41iweXG7FxDx7sWxWJgiWHp1eVmsNDLjWKhlxvFQi83ioVebgxLS6cdl8SCy41iweVGseByo1iwc1Es2LkoFuxcFAt2Loal6rm87l2nH10GyzQtr5s0puBd5qMHe5c5Z8Zh9urMma2ZUTzqm18P7z/Yr5GH5/lV3zLsHp1i1W1jmHb3oTwefariUeUSVcLr0WkOR1VGVBFUxVBFUJUJVQRVCagiqMqMKoKqLKgiqMqKKherskwHVaqe0Y4q/1lVyPYXqbJl+zWiCtn+GlWmJaUK2V5RFUMVQVXI9peoEvzGzS9HVcj2iqqQ7RVVIdsrqkK2v0YVZ5sq60GVmWyvqArZXlEVsr2iKmR7RVUMVQRVIdsrqkK2v1qV8ZhXZrK9oipk+4tUGTduEVXI9teoMkwJVRayvaIqZHtFVcj216iyrUWG2R1VIdsrqmKoIqgK2V5RFbK9oipke0FVVvLKJaqk31ZdySvXqJJ8U2IlryiqQl5RVMVQRVAV8oqiKuQVRVXIK4qqsBZ5tSqR9yJX1iL1VLGBbH+RKom3VW0g21+jSuoNPBvI9oqqkO0VVTFUuUKV5LteNpDtFVUh2yuqQrZXVIVsf40qqTclbCDbC6riyPaKqpDtFVUh2yuqQrZXVMVQRVAVsv3VqhzfizRHtldUhWx/kSqJt1XNke2vUSX1Bp45sr2gKp5sr6gK2f4aVVLvr5gn2yuqQrZXVMVQRVAVsr2iKmR7RVXIK5eoknxb1UbyyjWqpN6UsJG8oqgKeUVRFfKKoiqGKoKqkFcUVSGvKKrCWuTVqkTeixxZi1RUhWx/kSqpt1WNbH+NKsk38Ixsr6gK2V5RFbL9Jaqk3/UyQxVBVcj2iqqQ7RVVIdtfo0ryTQkj2yuqQrYXVGUi2yuqQrZXVIVsr6gK2V5RFUOVi1WJvBc5ke0VVSHbX6RK6m3ViWx/jSrJN/Amsr2iKmR7QVUC2f4aVZLvrwSyvaIqZHtFVcj2iqoYqgiqQrZXVIW8cokq6bdVA3nlGlWSb0rM5BVFVcgriqqQVxRVIa8oqmKoIqgKeUVRFdYir1Yl8l7kzFqkoipk+4tUSb2tOpPtr1El+QbeQrZXVIVsr6gK2f4SVdLvei1ke0VVDFUEVSHbK6pCtr9GleSbEgvZXlEVsr2iKmR7QVVWsr2iKmR7RVXI9oqqkO2vViXyXuRqqCKoCtn+IlVSb6uuZPtrVEm+gbeS7RVVIdsrqkK2v0aV1Psr00C2V1SFbK+oCtleURWyvaIqhiqCqpzMK34ets6B+TQN77ZA6/30fkdzdBYFPY7jRnq07PPL/PoDccu60zz28DK+hFl2JT4efUJZuoTihmHYPtsdsTgHlhgWD5YYlrFTLON7fpjcEYuBJYZlAksMSwBLDEufriWLpVffksGygiWCxQ9giWHp1eVO0/bZYTli6dXlZrD06nIzWAwsMSy9utwMll5dbgZLry43gwWXG8WCy43ZuRGXG8XSq8vNYOnV5Waw0MuNYjGwxLDQy41ioZcbxUIvN4oFlxvFgsuNYTFcbhQLdi6KBTsXxWJgiWHBzkWxKE/Q7r01Z9zvzXGvwStPo7nBT8qTXXbwyo2X7OCV59Ps4JVnvezgleem7OCVZ5Ds4JVje3bwyuE6O/g7z7DTnWfYcOcZNtx5hg13nmHDnWfYs3ccfnLw/v060zAOa+5557YFdBfskFyC8HT8w0q9X1+P+338e1UqPHcXrlR4oi9cqbArKFypsIX4aaXBbZUux1+kWXjW+2Gl9n7c1qOms/AUWbjSdubTXKXtzKfBbb9IwcKx0nbm01yl7cynuUrbmU9zlbYzn2YqXYTze+FKhcN+4Urb8Ui5StvxSLlKrZtKu/FISzceaenGIy3deKSlIY8Utv0bYTm+L7M25JEylTbkkTKVNuSRMpU25JEylVo3lbYzy9iwVWr+W8fs+HDyLLYwtPPj9RMomd2HYWioY14SS0Pt9Z9gSa/4hqGd39CiWNoJpUWxtJNgi2JpJ+4WxdKna8liaSdIl8Ti2kndRbF06nJzWDp1uTksuNwoFusAy7PSHozrs9IevOiz0h7s5bPSHhzjs9IeTOBXpcqHyf60UtveKbYpHCttyKplKm3IfWUqbchQZSq1biptyCNlKm3II2UqbcgjZSptyCNlKm3II6UrVT6KtHCl3Xgk5QNDC1fay5tLQflYz8KVNuSRMpXe1Dk8B39TM/Ac/E3n96/BK5+rmB98n8sE6f1kyof8fXTjVPK2xmCdbm7IYel0c0MOS6ebGzK7D5UPJrwSC1t4o1jYwhvF0unmhhwWA0sMS6dbeHNYOt3Cm8PSq8tN3qgWlA/avBJLry43jUX5cNArsfTqcjNYenW5GSy9utwMFsO3xLDgcmN2rqHjXYti6dXlZrD06nIzWOjlxrDM9HKjWOjlRrHQy41ioZcbxWJgiWHB5Uax4HKjWLBzUSzYuRiWhk5ELooFOxfFcnKCdsv8wuLNpbG41V51+sEtWSwfvPI0vXPu7BG+N4WS2wt19mzYVrGsYIlgOXvq7G2xpH9wzx5R2yoWD5YYlhEsMSwGlhiWXn1LBksASwzLDJYYll5dbnq/wtqry01imYdeXW4GS68uN4OlV5ebwdKry81gMbDEsOByo1hwuRE7Nw+43CiWXl1uBkuvLjeNxdHLjWKhlxvFQi83ioVebhSLgSWGBZcbxYLLjWLB5UaxYOdiWDx2LooFOxfFgp2LYlGeoN17a87ojgfmzV55Gs0OXnmyyw5eufGSHbzyfJob/Kg862UHrzw3ZQevPINkB68c27ODtzsP/s4z7HjnGXa88ww73nmGHe88w9qdZ1gTnmF/+IJQ+vbI2YSn4x9W6v36etzbfKxUeO4uXKl1U6mwKyhcqbCF+GmlwW2VLpFfJOFZr+jtHPMkPEUWrrSd+TRXaTvzaXDbL1KwcKy0nfk0V2k782mu0nbm01yl7cynuUqF83vhSoXDfuFK2/FImUpDOx4pV2k7HilXaTceKXTjkc4eYXyjSrvxSKEhjxS2/RthOb4vExrySJlKG/JImUob8kjpSueGPFKm0oY8UqbSdmaZYreYznM7P14Fz+2b54Y65gWxLA2113+CJbPiuzTUiy+JpZ1QWhRLOwm2KBYDSwxLn64li6WdIF0USzupuyiWTl1uDkunLjeDRflo3Sux9OByn5X2YFyflfbgRZ+VWjeV9uAYn5X2YAKflTbk62x7p9im4wqZ8vmwhSttyH0lK12UT3EtXGlDHilTaUMeKVNpQx4pU6l1U2lDHilTaUMeKVNpLx5pUT5dtHCl3Xgk5TNAi77Psygf61m40oY8UqZSu2elz8Hf1Aw8B3/T+f05+JtO2V+DVz7m76r9ZIvyIX8f3TiVvK1x8Tf9ffw0lk43N+SwdLq5Ib37cFE+mPBKLGzhjWJhC28Mi/IxjVdi6dW3ZLB0uoU3h6XTLbw5LNYpluSNaovyQZtXYunV5Waw9OpyM1h6dbkZLL263DQW5aNSr8SCy41iweXG7FxDx7sWxWJgiWHp1eVmsNDLjWKhlxvFQi83ioVebgxLS6cdl8SCy41iweVGseByo1iwc1Es2LkoFuxcFAt2Lobl9Lm826PB7bZSR7GYvTpiZrsiRxd7dvAv3jb88a/+9bRfIw/P84vfMuwenSKPTtsYpt09JI9HnzR8ZzTC69FpDkcaIzR2NAwaOxoTNHY0AjR2NGZo7Ggs0NjRWLulsUwHGqfPNm6LRm9eNGxedI3Q6M2LTkuKRm9eNE3DoLGj0ZkXDd5vrYjlSKMzL5qh0ZkXzdDozItmaHTmRYPbxuvXA42lMy+aodGZF83Q6MyLZmh05kUzNAwaOxq9edE0jd686JvGePQbS29eNE2jNy/qXodOBYvQ6M2LDlOCxtqbF03T6M2Lpmn05kW33leY3ZFGb140TcOgsaPRmxdN0+jNi6Zp9OZFUzTWobd12NQuuHXobh02sWNhHdgTuKfBnsA9DYPGjgZ7Avc02BO4p8GewD2NfvcEHvd9rQN7Anc0XHd7AhO74FbXmxdN7XRaHXsC9zTYE7inYezt2dFgT+CeBnsC9zTYE7in0d06bGLHwurYE7ij4dkTuKfBnsA9DfYE7mmwJ3BPw6Cxo9HvnsDjvq/VsydwT6O7PYGJXXCr782LpnY6rZ49gTsaI3sC9zR686LJ/RsjewL3NNgTuKdh0NjRYE/gngZ7Avc0eluHTe6Cs37PZonsWDD2BO5psCdwT4M9gXsaBo0dDfYE7mmwJ3BPo989gZF9X8aewD2N7vYEpnbBTb150eROp4k9gXsa7Anc0+it95Xc2zMZNHY02BO4p8GewD2Nfs9miexYmNgTuKfBnsAdjcCewD0N9gTuabAncE+DPYF7Gsa+rx0N9gTuaXS3JzC1C663+1PSO516uz8lQ4M9gTsavd2fkt6/0dv9KRka7Anc02BP4J6GQWNHgz2Bexq9rcMmd8H1dkdGesdCb3dkZGiwJ3BPgz2BexrsCdzTMGjsaLAncE+j3z2BkX1fvd2RkaHR3Z7A1C643u7ISO906u2OjAwN9gTuafTW+0ru7enujow0DYPGjgZ7Avc0+j2bJbJjobs7MtI02BO4p8GewI3GNPR2f0qGBnsC9zTYE7in0e+ewMO+rwcNg8aORnd7Av/+LrgHjd68aGKn04MGewL3NNgTuKfRmxdN7N+Yht7uT8nQYE/gngZ7Avc02BO4p2HQ2NE46TeGN41hztCY5leB07JLTOvyayhLvaGEYd3Cm0WGssoM5ezVDCWH4nSG4nWGMuoMxXSGMtUcyrA9GyJDCTpDmXWGsugMZZUZyjjoDMXpDMXrDGXUGYrpDEXn13bU+bUddX5tR51f21Hn19Y0fm1/f/zX/+9P//rnP/3TX/753x7/yB//6//563//25//5a+//uvf/v///fxfHg//Xw==","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"is_admin","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"JAAEAQIlAAQIRAAAJAAEAAMkAAQABB8AAAAABAAAAAMAAAhDIgAAAAgrAAADCEM5AAAACEMAAAABHgAAAAQeAAAABTAAAAAABAAAAAUAAAAGJAACAQUKAAIGBQQhAAAPAAQ6AQAAHgALAAUkAAcBBgoABwUGBCEAABQABDoBAAAqAAAFJAAEAgQAAAQABAAkAQQBBQAABAUCBCoABAckAAcACCoCCAcqAQUEAAAEBAIEKgIEBSoAAAQAAAQAAgAqAgUEJAAEAQgkAAQABSoABQMgACYKAAQDBQchAAAwAAcgACkqAQQDAAAEAwIGAAAEBgUHKgEHBB4AAgAFCgAHBAUDIyoBBAccAAcDCQAABwYJCiwAAAAACgAAAAkkAAQBCwwABAMLDCEAADgADDoBAAArAAAHCAMlAAQAAggEIgAAAEYrAAgFAAoAAAQKAgwAAAQMAwsqAgkLAAAEAwgHDgAEAwcJIQAAQwAJOgEAACoCCgQqAAcDIAAmKwEIAwgGCwAECAYAAggHIQAASggHIABMKwAIAwgFIABaKwAAAAgFAQAEAAAIBAAAJQAEAAAICQ0ABAgJCAQIChcACAoICiEAAFgICgEABAgDCAkICysBCAsICAEABAgFCAkICysCCAgICwEABAgJAAIICSAATyUBBAABCAUgAFojKwAYyhjK","debug_symbols":"1ZrdjtowEIXfxddc2GPP2MOrVNUq7MIqUhRWwFaqEO/eZBubNKSOdimV5wYROLY//57xKGf1st28vz7V7W5/VOtvZ9Xsn6tTvW+7p/NlpTaHumnq16fxz0r3H+FDfnyr2v7peKoOJ7U2HtxKbduX/qt1XQW7utmqtdeX1Y2YrR+0jD5JDdoZrQPDg9gBhKRmmBFTMHYQUwAei7+vFN8NbrRJYj0SPxzd6PsH3cf6mZcG3YCLYgPMefJgMFIEM6p6IDf/kLwb9D/R+wbg0Q3YRzfgHt0A3t0AIscWkPTCivABcBD74MJ0RdAnafoy/gtlwhfK8OfLwPzeBPBpCzlcOld8iOJuAq/z52luLpjiuYLMOj8X6K2JYm9hMhdgBLODYHYrmN0JZkfB7CSY3QtmD4LZWS67FeyrVrCvWsG+agX7qi38nMGQ2HF6P3WFr3fvEnvQU/b/v97ThZm0xjy70UzXqq9iq+kD3kqGd5Lh/xJKoknwxHl4ZwPEBJFdWsTElNjZ32zA5eAQ9QINxO46Mje9lXw4lR0EBZNMIYCZsGPhQVDaInPshZtCsFd2yIu526oxe+r8TUcLj5hy7oeFR0xZdieYvfBMRJa98ExElr3wTESWvXATzrIXnonIsVPhJpxlF3wzI8G+SoJ9lQT7Kgn2VRLsqyTWVy/d04/qUFebZju8/LJ7b59H78Kcfr79/qcT/wI=","brillig_names":["is_admin"],"assert_messages":{"66":"attempt to add with overflow","55":"Array index out of bounds","14":"Not initialized","19":"Function is_admin can only be called statically"}},{"name":"get_admin_public","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAAQIRAAAJAAEAAMkAAQABB8AAAAABAAAAAMAAAhDIgAAAAgrAAADCEM5AAAACEMAAAABHgAAAAQeAAAABTAAAAAABAAAAAUAAAAGJAACAQUKAAIGBQQhAAAPAAQ6AQAAHgALAAYkAAcBBQoABwYFBCEAABQABDoBAAAqAAAGJAAEAgQAAAQABAAkAQQBBgAABAYCBCoABAckAAcACCoCCAcqAQYEAAAEBAIEKgIEBioAAAQAAAQAAgAqAgYEJAAEAQgkAAQABioABgMgACYKAAQDBgchAAAvAAcgACkqAQQFAAAEBQIDAAAEAwYHKgEHBCoABAMjKgEEBxwABwMJAAAHBQkKLAAAAAAKAAAACSQABAELDAAEAwsMIQAANwAMOgEAACsAAAcIAyUABAACCAQiAAAARSsACAUACgAABAoCDAAABAwDCyoCCQsAAAQDCAkOAAQDCQchAABCAAc6AQAAKgIKBCoACQMgACYrAQgDCAYLAAQIBgACCAchAABJCAcgAEsrAAgDCAUgAFkrAAAACAUBAAQAAAgEAAAlAAQAAAgJDQAECAkIBAgKFwAICggKIQAAVwgKAQAECAMICQgLKwEICwgIAQAECAUICQgLKwIICAgLAQAECAkAAggJIABOJQEEAAEIBSAAWSMrABjKGMo=","debug_symbols":"1ZrdbsIwDIXfJddcxHF+bF5lmqaywVSpKhOwSRPi3ddubehKFQSMKb5BpD2Jvyapj1t1r16Wi/fXp7Jerbdq/rBX1fq52JXrumntDzO12JRVVb4+DQ8r3f7Qt3z7VtRta7srNjs1h2DsTC3rl/Yv2maAVVkt1Tzow+xEzBg6LbsQpeBwQmsNcCe2xlBUs5kQewLsxJ4MD8WPM8U3g4OGKNYD8d3RQd8+6aEfn/ncpIOxvRgMc5qcwPUUBIOhO3L4Q/Jm0n+jtwHMvQPgvQPYewdwNwdwjvsIzuszOyKQcZ04kKXxjvAX0rR9whV96Io+fHkfM31vgvF9H7Bn80qgKNZ4XL/gp9aCfZ9XHLNOr4ULCL04oBmthQHB7EYwOwpmt4LZnWB2L5g9CGYnwewslx0F+yoK9lUU7Kso2Fcx8zzjKLK78fOpzXy/BxvZSY/Z/3+/xwdmr7VLs4PmI8dAjNp/w6NkeCsZPvOSJnm75p1qCGKaJANj9sxLmrhpJthd5iUN4ZHdpMVssedgG04uVLAfuMzrnyR75vVPkt0KZs/8vUKSPfP3Ckn2zE04yZ55vZ9kz9yEU+w+cxNOsgv2VS/YV71gX/WCfdUL9lUv1lcPTeuj2JTFolp2n4Os3uvnwdchu8+3nzON+As=","brillig_names":["get_admin_public"],"assert_messages":{"14":"Not initialized","65":"attempt to add with overflow","54":"Array index out of bounds","19":"Function get_admin_public can only be called statically"}},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"3715688037512703171":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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IAQpKgAKJyoAJCYgBCkeAAcAJBwABCQqHAAHKikcAAQpJAwABCQgKSEABDgAKSAEMCEABDQAJyAEMioADSAgBDYqACYgIAQ2KgAgJSAEQCEABDwAIiAEOioADSAgBD4qACMgIAQ+KgAgJSAEQAAABCQlKQ4ABCQpKiEABEQAKjoBAAAqAR8lKgETKioBHisMAAQkKywhAARMACwgBEoqACogIAROKgAlICAETioCIB8qAiETKgIpHioBFB4AAAQeAh4qAh4UKgEUHgAABB4CHioCHhQqARQeAAAEHgIeKgIeFCoBFB4AAAQeAh4qAh4UKgAAHgAABAACACoBCxMAAAQTAhMqAhMLKgAAEwAABAACACoAAB8AAAQAAgAqAAAkAAAEAAIAKgEUKgAABCoCKioCKhQqAQsqAAAEKgIqKgIqCyoBFCoAAAQqAioqAioUKgELKgAABCoCKioCKgsqARQqAAAEKgIqKgIqFCoBCyoAAAQqAioqAioLKgIUHioCCxMqAg0fKgIIJCoBFCoCAAQqAioqAioUKgELKgIABCoCKioCKgsqAAYlIASGCgAEJQYqIQARqwAqIASJKgEkKgoAASoIKyEABI0AKzoBAAAqAAYlIASPDAAEJREqIQARggAqIASSKgETHyoAAB4kAAQFKgAABAAqACQBBAEeAAAEHwIqJAAEBCsAAAQeAiw+AwAAACoAAAAsKgIeEyoCCiQAAAQeAhMAAAQTBh8qAR8kHAAHKR4qAAYlIASjDAAEJREfIQARZwAfIASmKgAAJAAABAACACoBCx8AAAQfAh8qAh8LKgAAHwAABAACACoAAB4AAAQAAgAqAAATAAAEAAIAKgELKgAABCoCKioCKgsqAQsqAAAEKgIqKgIqCyoBGyoAAAQqAioqAiobKgELKgAABCoCKioCKgsqAhskKgILHyoCDR4qAggTKgEbKgIABCoCKioCKhsqAQsqAgAEKgIqKgIqCyoABiUgBMkKAAQlBiohABDoACogBMwqARMqCgABKggrIQAE0AArOgEAACoABiUgBNIMAAQlESohABC/ACogBNUqAR8kKgAAHiQABAUqAAAEACoAJAEEAR4AAAQkAiokAAQEKwAABB4CLD4DAAAAKgAAACwqAh4fKgIKEwAABB4CHwAABB8GJCoBJBMcAAUjHgQABR4aHyQABQAsCgAFLBokIQAE7AAkBgAFHxoqCgAFKh4rIQAE7AArOgEAABwABSYeAAAFHx4sDgAFHywkIQAE8QAkOgEAABwABSIeBAAFHh0fHAAFJx4EAAUeGiQAAAUfJB4OAAUfHiohAAT5ACo6AQAAAAAFHigfDgAFHh8kIQAE/QAkOgEAABwAByweHAAHHywEAAcsFx8AAAceHywqAAYlIAUDCgAEJQYrIQAQqAArIAUGKgAAJAAABAACACoBCx8AAAQfAh8qAh8LKgAAHwAABAACACoAAB4AAAQAAgAqAAATAAAEAAIAKgELKgAABCoCKioCKgsqAQsqAAAEKgIqKgIqCyoBHCoAAAQqAioqAiocKgELKgAABCoCKioCKgsqAhwkKgILHyoCDR4qAggTKgEcKgIABCoCKioCKhwqAQsqAgAEKgIqKgIqCyoABiUgBSkKAAQlBiohABApACogBSwqARMWCgABFggSIQAFMAASOgEAACoABiUgBTIMAAQlERYhABAAABYgBTUqAR8kKgAAHiQABAUWAAAEABYAJAEEAR4AAAQkAhYkAAQEEgAABB4CKj4DAAAAFgAAACoqAh4fKgIKEwAABB4CHwAABB8GJCoBJBMcAAcpHhwABSMpBAAFKRojJAAFACQKAAUkGh8hAAVNAB8GAAUjGhIKAAUSKSohAAVNACo6AQAAHAAFJikAAAUjKSYOAAUjJiQhAAVSACQ6AQAAHAAFIikEAAUpHSIcAAUnKQQABSkaJwAABSInKQ4ABSIpIyEABVoAIzoBAAAAAAUpKCcOAAUpJyIhAAVeACI6AQAAHAAHJikcAAcnJgQAByYXJwAAByknJioAACckAAQFKQAABAApACQBBAEnAAAEJwIpKgApKCoCICgAAAQoAigqAiAoAAAEKAIoKgIgKAAABCgCKCoCICgqAScpAAAEKQIpKgIpJyoAACkAAAQAAgAqAicpKgANJSAFdwwABCURKCEAD9sAKCAFeioABiggBXwKAAQoBichAA+2ACcgBX8qASknKgEUKQAABCkCKSoCKRQqARQpAAAEKQIpKgIpFCoBFCkAAAQpAikqAikUKgEUKQAABCkCKSoCKRQqAAApAAAEAAIAKgIUKSoBFSYAAAQmAiYqAiYVKgAAJgAABAACACoCFSYqAAAlAAAEAAIAKgIGJSoAACQAAAQAAgAqAggkKgAGKCAFnQwABCgEIyEADzQAIyAFoCoBJCcKAAEnCCMhAAWkACM6AQAAKgAGKCAFpgwABCgRJyEADwsAJyAFqSoBJiMqAAAiJAAEBSEAAAQAIQAkAQQBIgAABCMCISQABAQgAAAEIgIfPgMAAAAhAAAAHyoCIiYqAgokAAAEIgImAAAEJgYjKgEjJCoABiUgBbkKAAQlBiMhAA70ACMgBbwAAAQPAhY5AQAAABYAAAAAIAW/JgAHUF0iYgAWCgAHAxYTKgAAFiQABAISAAAEABIAJAEEARYAAAQWAhIqABIeKgIYHiEABcoAEyAIiyoAABIkAAQCHgAABAAeACQBBAESAAAEEgIeHwQAAAANAAAADQAAAB4qARIeAAAEHgIeKgIeEioAAB4AAAQAAgAqAhIeKgAAHwAABAACACoCBh8qARIgAAAEIAIgKgIgEioAACAAAAQAAgAqAhAgKgESIQAABCECISoCIRIqARASAAAEEgISKgISECoABhMgBecKAAQTBhIhAA7UABIgBeoqAR8TAAAEEw0SDgAEExIhIQAF7wAhOgEAACoCEh8qASASKgEQIAIABCACICoCIBAAAAQSAh8AAAQfBhMqARMgHAAHIBIpAAcAAAAAAAAAAAAAAAD//////////////////////////wAfDgAHEh8TIQAF/AATOgEAAB4AAAAfHgAAABIwAAAAAB8AAAASAAAAEwoAAhMFEiEABgIAEjoBAAAqARQTAAAEEwITKgITFCoBFBMAAAQTAhMqAhMUKgEUEwAABBMCEyoCExQqARQTAAAEEwITKgITFCoAABMAAAQAAgAqAQsSAAAEEgISKgISCyoAABIAAAQAAgAqAAAfAAAEAAIAKgAAIQAABAACACoBFCIAAAQiAiIqAiIUKgELIgAABCICIioCIgsqARQiAAAEIgIiKgIiFCoBCyIAAAQiAiIqAiILKgEUIgAABCICIioCIhQqAQsiAAAEIgIiKgIiCyoCFBMqAgsSKgINHyoCCCEqARQiAgAEIgIiKgIiFCoBCyICAAQiAiIqAiILKgAGHiAGNwoABB4GIiEADlUAIiAGOioBISIKAAEiCCMhAAY+ACM6AQAAKgAGHiAGQAwABB4RIiEADiwAIiAGQyoBEh4qAAATJAAEBSIAAAQAIgAkAQQBEwAABB4CIiQABAQjAAAEEwIkPgMAAAAiAAAAJCoCExIqAgohAAAEEwISAAAEEgYeKgEeISoBFBMAAAQTAhMqAhMUKgAAEwAABAACACoCFBMqAAYfIAZZDAAEHxEeIQAOFgAeIAZcKgETHgAABB4CEgAABBIGISoBIRMcAAcTEikABwAAAAAAAAAAAAAAAP//////////////////////////ACEOAAcSISIhAAZlACI6AQAAAAAEHgISAAAEEg0iKgEiIRwAByESKQAHAAAAAAAAAAAAAAAA//////////////////////////8AIg4ABxIiIyEABm0AIzoBAAAAAAQeAhIAAAQSDCMqASMiHAAEIhIcAAcSHhwABB4iKgAAHgAABAACACoCEx4qAAATAAAEAAIAKgIhEyoAACEAAAQAAgAqAiIhKgAAIgAABAACACoBCxIAAAQSAhIqAhILKgAAEgAABAACACoAACMAAAQAAgAqAAAkAAAEAAIAKgELJQAABCUCJSoCJQsqAQslAAAEJQIlKgIlCyoBGyUAAAQlAiUqAiUbKgELJQAABCUCJSoCJQsqAhsiKgILEioCDSMqAggkKgEbJQIABCUCJSoCJRsqAQslAgAEJQIlKgIlCyoABh8gBp8KAAQfBiUhAA2XACUgBqIqASQlCgABJQgmIQAGpgAmOgEAACoABh8gBqgMAAQfESUhAA1uACUgBqsqARIiKgAAHyQABAUlAAAEACUAJAEEAR8AAAQiAiUkAAQEJgAABB8CJz4DAAAAJQAAACcqAh8SKgIKJAAABB8CEgAABBIGIioBIiQqARAfAAAEHwIfKgIfECoAAB8AAAQAAgAqAhAfKgAGIyAGwQoABCMGIiEADVgAIiAGxCoBHyIAAAQiAiMAAAQjBiQqASQfHAAHHyIoAAf/////////////////////ACMOAAciIyQhAAbNACQ6AQAAHAAFHyIcAAciIxwABSMiAgAHHyMkCAAHJBcfHAAFHyMcAAcjJBwABSQfBgAFHx0kHAABJCUcAAUlIxwAASMkBgAFIhojHAAEIyUGAAUfGiMcAAEjJxwABScmHAABJiMcAAQiJxwABScmHAAEJiIcAAQfJxwABScmHAAEJh8hAAbqACQgBucqAAgSKgAGECAG7SoAChIqACUQIAbtIQAG8gAjIAbvKgAIJSoABiQgBvUqAAolKgAiJCAG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YgATIAhsKgEZGgoAARoIEyEACHAAEzoBAAAqAAYcIAhyDAAEHBEaIQAKOQAaIAh1KgEXFSoAABMkAAQFEgAABAASACQBBAETAAAEFQISJAAEBBAAAAQTAhw+AwAAABIAAAAcKgITFyoCChkAAAQTAhcAAAQXBhUqARUZKgAGGiAIhQoABBoGFyEACiIAFyAIiAAABA8CFzkBAAAAFwAAAAAgCIsmAAdM+i+sABcKAAcDFxUhAAiPABUgCR8eAAAAFR4AAAATMAAAAAAVAAAAEwAAABIKAAISBRMhAAiVABM6AQAAHgALAAUKAAcFCRIhAAiZABI6AQAAHgAHAAUcAAQFEhwABxIJHAAECQUqARQJAAAECQIJKgIJFCoBFAkAAAQJAgkqAgkUKgEUCQAABAkCCSoCCRQqARQJAAAECQIJKgIJFCoAAAkAAAQAAgAqAQsSAAAEEgISKgISCyoAABIAAAQAAgAqAAATAAAEAAIAKgAAFQAABAACACoBFBAAAAQQAhAqAhAUKgELEAAABBACECoCEAsqARQQAAAEEAIQKgIQFCoBCxAAAAQQAhAqAhALKgEUEAAABBACECoCEBQqAQsQAAAEEAIQKgIQCyoCFAkqAgsSKgINEyoCCBUqARQQAgAEEAIQKgIQFCoBCxACAAQQAhAqAhALKgAGFyAI0goABBcGECEACaMAECAI1SoBFQ8KAAEPCAshAAjZAAs6AQAAKgAGECAI2wwABBARDyEACXoADyAI3ioBEhAqAAAPJAAEBQsAAAQACwAkAQQBDwAABBACCyQABAQJAAAEDwIHPgMAAAALAAAAByoCDxIqAgoVAAAEDwISAAAEEgYEKgEEFSoBFA8AAAQPAg8qAg8UKgAADwAABAACACoCFA8qAAYTIAj0DAAEExEUIQAJZAAUIAj3KgEPCwAABAsCCQAABAkGByoBBw8cAAcPCSkABwAAAAAAAAAAAAAAAP//////////////////////////AAcOAAcJBwQhAAkAAAQ6AQAAAAAECwIJAAAECQ0EKgEEBxwABwcNKQAHAAAAAAAAAAAAAAAA//////////////////////////8ACQ4ABw0JBCEACQgABDoBAAAAAAQLAg0AAAQNDAQqAQQJHAAECQscAAcLDBwABAwJDAAEBQkMIQAJEwAMIAkRKgAHDiAJ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LigrKgIqKyoCLSEgDI8AAAQoDSkOAAQoKSohAAyTACo6AQAAKgApKCAMPxwAByMhAAAHIiETKgAAISQABAQoAAAEACgAJAEEASEAAAQhAigqACgpKgIfKQAABCkCKSoCICkAAAQpAikqAh4pJAAEAykMAAQjKSohAAymACo6AQAAAAAEIQIqAAAEKiMpKgEpKC0AAAAAKAAAABMAAAQjDSgOAAQjKBMhAAyuABM6AQAAKgAoIyAHbyoBHigMAAQjKCkhAAy0ACkgDNMqARMoKgETKSQABAQrDAAEIyssIQAMugAsOgEAAAAABCkCLAAABCwjKyoBKyoqASEpJAAEAysMAAQjKy0hAAzCAC06AQAAAAAEKQItAAAELSMrKgErLAAAByosKSQABAQsDAAEIywtIQAMygAtOgEAACsAACgIAyUABAAFCAQiAAAWjSsACAUAKgAABCoCLQAABC0jLCoCKSwqAioTIAzTAAAEIw0oDgAEIygpIQAM1wApOgEAACoAKCMgB1skAAQBKQwABCMpKiEADN0AKjoBAAAAAAQWAioAAAQqIykqASkoKgEiKgoAASoIKSEADOQAKToBAAAqAR4qCgAEKhEpIQANAAApIAzoKgEhKSoBHioqAR4rJAAEAy0MAAQrLS4hAAzvAC46AQAAKwAAKQgDJQAEAAQIBCIAABaNKwAIBQAsAAAELAIuAAAEListKgIoLSoBLCgAAAQoAigqAigsAAAEKg0oDgAEKigrIQAM/QArOgEAACoCLCEqAigeIA0pKgAGKSANAgwABCkRKiEADS8AKiANBSoBISkqARMqKgAAKyQABAUsAAAEACwAJAEEASsAAAQqAiwkAAQELQAABCsCLj4DAAAALAAAAC4qASkqAgAEKgIqKgIqKSoBKSoAAAQqAioqAiopKgErKgAABCoCKioCKisrAAApCAMlAAQABAgEIgAAFo0rAAgFACoAAAQqAi4AAAQuBi0qAigtKgEqKQAABCkCKSoCKSoqASspAAAEKQIpKgIpKyoCKiEqAisTKgINHiANKQAABCMNKA4ABCMoKSEADS0AKToBAAAqACgjIAdSKgEeKgwABCkqKyEADTMAKyANUioBEyoqARMrJAAEBC0MAAQpLS4hAA05AC46AQAAAAAEKwIuAAAELiktKgEtLCoBISskAAQDLQwABCktLyEA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BQgEIgAAFo0rAAgFAC4AAAQuAjEAAAQxKzAqAi0wKgIuEyASJAAABCsNLA4ABCssLSEAEigALToBAAAqACwrIBHUKgEgIxwAByQiAAAHJSImLAAAAAAmAAAAIiQABAEnDAAEJCcoIQASMgAoOgEAACsAACMIAyUABAACCAQiAAAWjSsACAUAJgAABCYCKAAABCgkJyoCIicAAAQkDSMOAAQkIyIhABI9ACI6AQAAKgImICoAIyQgA/UqASQmDAAEICYnIQASRAAnIBJjKgEjJioBIyckAAQEKQwABCApKiEAEkoAKjoBAAAAAAQnAioAAAQqICkqASkoKgEiJyQABAMpDAAEICkrIQASUgArOgEAAAAABCcCKwAABCsgKSoBKSoAAAcoKickAAQEKgwABCAqKyEAEloAKzoBAAArAAAmCAMlAAQABQgEIgAAFo0rAAgFACgAAAQoAisAAAQrICoqAicqKgIoIyASYwAABCANJg4ABCAmJyEAEmcAJzoBAAAqACYgIAPcJAAEAScMAAQgJyghABJtACg6AQAAAAAEEgIoAAAEKCAnKgEnJioBJSgKAAEoCCchABJ0ACc6AQAAKgEkKAoABCgRJyEAEpAAJyASeCoBIicqASQoKgEkKSQABAMrDAAEKSssIQASfwAsOgEAACsAACcIAyUABAAECAQiAAAWjSsACAUAKgAABCoCLAAABCwpKyoCJisqASomAAAEJgImKgImKgAABCgNJg4ABCgmKSEAEo0AKToBAAAqAioiKgImJCASuSoABicgEpIMAAQnESghABK/ACggEpUqASInKgEjKCoAACkkAAQFKgAABAAqACQBBAEpAAAEKAIqJAAEBCsAAAQpAiw+AwAAACoAAAAsKgEnKAIABCgCKCoCKCcqAScoAAAEKAIoKgIoJyoBKSgAAAQoAigqAigpKwAAJwgDJQAEAAQIBCIAABaNKwAIBQAoAAAEKAIsAAAELAYrKgImKyoBKCYAAAQmAiYqAiYoKgEpJgAABCYCJioCJikqAigiKgIpIyoCDSQgErkAAAQgDSYOAAQgJichABK9ACc6AQAAKgAmICAD0yoBJCgMAAQnKCkhABLDACkgEuIqASMoKgEjKSQABAQrDAAEJyssIQASyQAsOgEAAAAABCkCLAAABCwnKyoBKyoqASIpJAAEAysMAAQnKy0h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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"512":"Function get_admin_public can only be called statically","1024":"call to assert_max_bit_size","2938":"attempt to add with overflow","4986":"attempt to add with overflow","3237":"Array index out of bounds","4261":"attempt to add with overflow","2591":"attempt to add with overflow","3292":"Array index out of bounds","5529":"attempt to add with overflow","4938":"attempt to add with overflow","2756":"Array index out of bounds","3780":"Array index out of bounds","4158":"Array index out of bounds","5316":"attempt to add with overflow","2488":"Array index out of bounds","3189":"Array index out of bounds","5292":"attempt to add with overflow","5481":"attempt to add with overflow","4134":"attempt to add with overflow","5347":"attempt to add with overflow","2464":"attempt to add with overflow","5725":"Array index out of bounds","471":"Not initialized","2196":"Not initialized","1361":"attempt to add with overflow","203":"attempt to add with overflow","3653":"Array index out of bounds","4220":"attempt to add with overflow","2550":"attempt to add with overflow","3062":"Array index out of bounds","3574":"Array index out of bounds","612":"Function get_passport_address can only be called statically","1636":"call to assert_max_bit_size","5220":"Array index out of bounds","5598":"Array index out of bounds","4172":"attempt to add with overflow","5385":"Array index out of bounds","2502":"attempt to add with overflow","3014":"Array index out of bounds","3392":"Array index out of bounds","3447":"Array index out of bounds","4471":"Array index out of bounds","4526":"Array index out of bounds","5093":"Array index out of bounds","3423":"Array index out of bounds","5337":"attempt to add with overflow","3990":"Array index out of bounds","5014":"Array index out of bounds","5069":"Array index out of bounds","2887":"Array index out of bounds","4423":"Array index out of bounds","3265":"Array index out of bounds","1272":"attempt to add with overflow","5557":"Array index out of bounds","547":"Not initialized","4887":"Array index out of bounds","4296":"Array index out of bounds","4808":"Array index out of bounds","2626":"Array index out of bounds","2303":"call to assert_max_bit_size","1980":"attempt to add with overflow","5351":"Array index out of bounds","2200":"Function get_jwt_registry can only be called statically","3413":"attempt to add with overflow","2578":"Array index out of bounds","4248":"Array index out of bounds","4626":"Array index out of bounds","4681":"Array index out of bounds","2822":"attempt to add with overflow","4657":"Array index out of bounds","3310":"Array index out of bounds","5358":"Array index out of bounds","2664":"Array index out of bounds","5413":"Array index out of bounds","3042":"Array index out of bounds","3097":"Array index out of bounds","3286":"attempt to add with overflow","2451":"Array index out of bounds","4121":"Array index out of bounds","4499":"Array index out of bounds","1537":"Not initialized","3372":"attempt to add with overflow","3482":"Array index out of bounds","3860":"Array index out of bounds","5128":"Array index out of bounds","1276":"attempt to add with overflow","3324":"attempt to add with overflow","3245":"attempt to add with overflow","3434":"attempt to add with overflow","4647":"attempt to add with overflow","551":"Function is_admin can only be called statically","4056":"attempt to add with overflow","5080":"attempt to add with overflow","1740":"call to assert_max_bit_size","2764":"Array index out of bounds","4544":"Array index out of bounds","3197":"Array index out of bounds","3898":"Array index out of bounds","5434":"attempt to add with overflow","3764":"Array index out of bounds","4276":"Array index out of bounds","2606":"Array index out of bounds","1259":"attempt to multiply with overflow","4331":"Array index out of bounds","4520":"attempt to add with overflow","1369":"attempt to add with overflow","5709":"Array index out of bounds","3070":"Array index out of bounds","3582":"Array index out of bounds","4606":"attempt to add with overflow","3637":"Array index out of bounds","1644":"call to assert_max_bit_size","4716":"Array index out of bounds","5228":"Array index out of bounds","2077":"attempt to add with overflow","3613":"Array index out of bounds","3802":"attempt to add with overflow","5393":"attempt to add with overflow","4558":"attempt to add with overflow","5259":"Array index out of bounds","3400":"Array index out of bounds","5582":"Array index out of bounds","3455":"Array index out of bounds","4479":"attempt to add with overflow","4668":"attempt to add with overflow","2998":"Array index out of bounds","5369":"attempt to add with overflow","5747":"attempt to add with overflow","5101":"Array index out of bounds","2785":"attempt to add with overflow","3998":"Array index out of bounds","2840":"Array index out of bounds","3218":"attempt to add with overflow","4431":"Array index out of bounds","3273":"Array index out of bounds","4998":"Array index out of bounds","1091":"attempt to add with overflow","3840":"Array index out of bounds","2682":"Array index out of bounds","2871":"Array index out of bounds","3115":"Array index out of bounds","2792":"attempt to add with overflow","5541":"Array index out of bounds","2847":"Array index out of bounds","3091":"attempt to add with overflow","3603":"attempt to add with overflow","4304":"Array index out of bounds","2634":"Array index out of bounds","2311":"call to assert_max_bit_size","1988":"attempt to add with overflow","4816":"Array index out of bounds","4871":"Array index out of bounds","1531":"call to assert_max_bit_size","2744":"attempt to add with overflow","5249":"attempt to add with overflow","4847":"Array index out of bounds","3500":"Array index out of bounds","3177":"attempt to add with overflow","5036":"attempt to add with overflow","1373":"attempt to add with overflow","4634":"Array index out of bounds","5146":"Array index out of bounds","3476":"attempt to add with overflow","4689":"Array index out of bounds","2696":"attempt to add with overflow","4232":"Array index out of bounds","2562":"Array index out of bounds","5122":"attempt to add with overflow","3129":"attempt to add with overflow","4019":"attempt to add with overflow","5421":"Array index out of bounds","490":"Aztec Passport: Unauthorized Admin Change","3050":"attempt to add with overflow","3562":"attempt to add with overflow","4074":"Array index out of bounds","3806":"Array index out of bounds","4452":"attempt to add with overflow","3672":"Array index out of bounds","4507":"Array index out of bounds","5208":"attempt to add with overflow","1356":"attempt to multiply with overflow","3916":"Array index out of bounds","4105":"Array index out of bounds","2435":"Array index out of bounds","4349":"Array index out of bounds","3514":"attempt to add with overflow","4026":"attempt to add with overflow","5751":"Array index out of bounds","4081":"Array index out of bounds","5617":"Array index out of bounds","2411":"Array index out of bounds","3624":"attempt to add with overflow","3813":"Array index out of bounds","4325":"attempt to add with overflow","2655":"attempt to add with overflow","3868":"Array index out of bounds","4837":"attempt to add with overflow","5160":"attempt to add with overflow","5270":"attempt to add with overflow","3978":"attempt to add with overflow","4734":"Array index out of bounds","4411":"attempt to add with overflow","5758":"Array index out of bounds","181":"attempt to add with overflow","4710":"attempt to add with overflow","2906":"Array index out of bounds","3930":"attempt to add with overflow","2772":"Array index out of bounds","401":"Initializer address is not the contract deployer","4363":"attempt to add with overflow","1992":"attempt to add with overflow","3205":"Array index out of bounds","3772":"Array index out of bounds","4284":"attempt to add with overflow","2614":"attempt to add with overflow","2803":"Array index out of bounds","4796":"attempt to add with overflow","5040":"Array index out of bounds","2858":"attempt to add with overflow","4906":"Array index out of bounds","5308":"Array index out of bounds","5717":"Array index out of bounds","4748":"attempt to add with overflow","5449":"Array index out of bounds","3078":"Array index out of bounds","3590":"Array index out of bounds","3645":"Array index out of bounds","2810":"Array index out of bounds","1975":"attempt to multiply with overflow","4858":"attempt to add with overflow","817":"attempt to add with overflow","1518":"attempt to add with overflow","3889":"attempt to add with overflow","5047":"Array index out of bounds","2085":"attempt to add with overflow","5236":"Array index out of bounds","5590":"Array index out of bounds","147":"attempt to add with overflow","3463":"Array index out of bounds","3006":"Array index out of bounds","3384":"Array index out of bounds","5109":"Array index out of bounds","4140":"Array index out of bounds","2470":"Array index out of bounds","4006":"Array index out of bounds","4439":"Array index out of bounds","3793":"attempt to add with overflow","5006":"Array index out of bounds","3848":"attempt to add with overflow","4037":"Array index out of bounds","831":"Not initialized","508":"Not initialized","185":"Array index out of bounds","2422":"attempt to add with overflow","2879":"Array index out of bounds","1264":"attempt to add with overflow","3257":"Array index out of bounds","3690":"Array index out of bounds","3824":"attempt to add with overflow","4092":"attempt to add with overflow","5281":"Array index out of bounds","5549":"Array index out of bounds","5738":"attempt to add with overflow","4312":"Array index out of bounds","405":"Aztec Passport: Invalid Address","82":"attempt to add with overflow","1807":"attempt to add with overflow","2642":"Array index out of bounds","3666":"attempt to add with overflow","4044":"Array index out of bounds","4824":"Array index out of bounds","192":"Array index out of bounds","4879":"Array index out of bounds","5635":"Array index out of bounds","5769":"attempt to add with overflow","5611":"attempt to add with overflow","3752":"attempt to add with overflow","4697":"Array index out of bounds","3027":"attempt to add with overflow","4240":"Array index out of bounds","2570":"Array index out of bounds","4618":"Array index out of bounds","5697":"attempt to add with overflow","3704":"attempt to add with overflow","2924":"Array index out of bounds","2089":"attempt to add with overflow","5027":"attempt to add with overflow","608":"Not initialized","5405":"Array index out of bounds","2900":"attempt to add with overflow","4113":"Array index out of bounds","5326":"Array index out of bounds","395":"Initialization hash does not match","2443":"Array index out of bounds","4491":"Array index out of bounds","5058":"attempt to add with overflow","5570":"attempt to add with overflow","4924":"Array index out of bounds","5649":"attempt to add with overflow","2986":"attempt to add with overflow","3876":"Array index out of bounds","4900":"attempt to add with overflow","5467":"Array index out of bounds","2072":"attempt to multiply with overflow","457":"attempt to add with overflow"}},{"name":"set_jwt_registry","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"_registry","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["set_jwt_registry"],"assert_messages":{"640":"attempt to add with overflow","1920":"Array index out of bounds","762":"Array index out of bounds","628":"attempt to add with overflow","1780":"attempt to add with overflow","1908":"attempt to add with overflow","811":"attempt to add with overflow","1579":"Array index out of bounds","1183":"attempt to add with overflow","153":"call to assert_max_bit_size","1043":"Array index out of bounds","1421":"Array index out of bounds","1226":"Array index out of bounds","1738":"Array index out of bounds","1860":"attempt to add with overflow","1793":"Array index out of bounds","1080":"Array index out of bounds","623":"attempt to multiply with overflow","1769":"Array index out of bounds","1062":"Array index out of bounds","928":"Array index out of bounds","1056":"attempt to add with overflow","532":"attempt to add with overflow","1361":"Array index out of bounds","14":"Not initialized","782":"Array index out of bounds","520":"attempt to add with overflow","1556":"Array index out of bounds","770":"attempt to add with overflow","959":"Array index out of bounds","636":"attempt to add with overflow","1154":"Array index out of bounds","1014":"attempt to add with overflow","1142":"attempt to add with overflow","1611":"Array index out of bounds","941":"attempt to add with overflow","1928":"Array index out of bounds","996":"Array index out of bounds","161":"call to assert_max_bit_size","1374":"attempt to add with overflow","1569":"attempt to add with overflow","277":"call to assert_max_bit_size","978":"attempt to add with overflow","1234":"Array index out of bounds","1429":"Array index out of bounds","1746":"Array index out of bounds","966":"Array index out of bounds","1027":"Array index out of bounds","1094":"attempt to add with overflow","838":"Array index out of bounds","515":"attempt to multiply with overflow","1271":"Array index out of bounds","820":"Array index out of bounds","948":"attempt to add with overflow","1198":"Array index out of bounds","1003":"Array index out of bounds","1393":"Array index out of bounds","1253":"Array index out of bounds","1442":"attempt to add with overflow","1247":"attempt to add with overflow","1448":"Array index out of bounds","1466":"Array index out of bounds","790":"Array index out of bounds","1619":"Array index out of bounds","528":"attempt to add with overflow","912":"Array index out of bounds","1162":"Array index out of bounds","1759":"attempt to add with overflow","900":"attempt to add with overflow","1345":"Array index out of bounds","1540":"Array index out of bounds","1801":"Array index out of bounds","1528":"attempt to add with overflow","1333":"attempt to add with overflow","1656":"Array index out of bounds","1936":"Array index out of bounds","1638":"Array index out of bounds","1632":"attempt to add with overflow","1949":"attempt to add with overflow","852":"attempt to add with overflow","1809":"Array index out of bounds","1035":"Array index out of bounds","1480":"attempt to add with overflow","1285":"attempt to add with overflow","1218":"Array index out of bounds","1413":"Array index out of bounds","1730":"Array index out of bounds","1401":"attempt to add with overflow","1206":"attempt to add with overflow","1590":"attempt to add with overflow","1718":"attempt to add with overflow","1846":"Array index out of bounds","1828":"Array index out of bounds","798":"Array index out of bounds","347":"attempt to add with overflow","920":"Array index out of bounds","1822":"attempt to add with overflow","1170":"Array index out of bounds","1548":"Array index out of bounds","1353":"Array index out of bounds","1670":"attempt to add with overflow","1603":"Array index out of bounds"}},{"name":"get_passport_address","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"JAAEAQIlAAQIRAAAJAAEAAMkAAQABB8AAAAABAAAAAMAAAhDIgAAAAgrAAADCEM5AAAACEMAAAABHgAAAAQeAAAABTAAAAAABAAAAAUAAAAGJAACAQUKAAIGBQQhAAAPAAQ6AQAAHgALAAYkAAcBBQoABwYFBCEAABQABDoBAAAeAAcABRwABAUEHAAHBAYcAAQGBSoAAAYkAAQEBAAABAAEACQBBAEGAAAEBgIEKgAEByQABwAIKgIIBwAABAcCByoCCAcAAAQHAgcqAggHKgEGBAAABAQCBCoCBAYqAQYEAAAEBAIEKgIEBioBBgQAAAQEAgQqAgQGKgEGBAAABAQCBCoCBAYqAAAEAAAEAAIAKgAAByQABAUJAAAEAAkAJAEEAQcAAAQHAgkqAAkKKgIICgAABAoCCioCCAoAAAQKAgoqAggKAAAECgIKKAAHAAAAAAAAAAIAAAAAAAAAAAALKgILCioBBwkAAAQJAgkqAgkHKgAACQAABAACACoAAAoAAAQAAgAqAAAMAAAEAAIAKgEGDQAABA0CDSoCDQYqAQcNAAAEDQINKgINByoBBg0AAAQNAg0qAg0GKgEHDQAABA0CDSoCDQcqAQYNAAAEDQINKgINBioBBw0AAAQNAg0qAg0HKgIGBCoCBwkkAAQBDSoCDQokAAEADioCDgwqAQYPAgAEDwIPKgIPBioBBw8CAAQPAg8qAg8HJAAEBAskAAcDByQABAMPKgAAECQABAIRAAAEABEAJAEEARAAAAQQAhEqABESKgIHEiQABAARKgARAyAAdAoABAMREiEAAPAAEiAAdyoBDAcKAAEHDgMhAAB7AAM6AQAAKgARECAAfQwABBAPDiEAAMcADiAAgCoBCQ4qAAAKJAAEBQcAAAQABwAkAQQBCgAABA4CByQABAQEAAAECgIDPgMAAAAHAAAAAyoCCgkkAAEBCSoCCQwAAAQKAgwAAAQMEQsqAQsJKgEGCgAABAoCCioCCgYqAAAKAAAEAAIAKgIGCioAERAgAJcMAAQQDw4hAACxAA4gAJoqAQoPAAAEDwIOAAAEDhEMKgEMCgAABA8CDgAABA4NDCoBDBEkAAQCDQAABA8CDAAABAwNCyoBCw4cAAQODxwABw8NHAAEDQ4MAAQFDg0hAACtAA0gAKsqABEQIACvKgAKECAAryoAEAMjKgEKDhwABxAMAAAHCQwLLAAAAAALAAAADCQABAMIDAAEEAgHIQAAuQAHOgEAACsAAA4IAyUABAAECAQiAAABbysACAUACwAABAsCBwAABAcQCCoCDAgAAAQQDQ4OAAQQDgwhAADEAAw6AQAAKgILCioADhAgAJcqAQoODAAEEA4HIQAAywAHIADqKgEJDioBCQckAAQEEgwABBASEyEAANEAEzoBAAAAAAQHAhMAAAQTEBIqARIDKgEEByQABAMSDAAEEBIUIQAA2QAUOgEAAAAABAcCFAAABBQQEioBEhMAAAcDEwckAAQEEwwABBATFCEAAOEAFDoBAAArAAAOCAMlAAQABQgEIgAAAW8rAAgFAAMAAAQDAhQAAAQUEBMqAgcTKgIDCSAA6gAABBANDg4ABBAOByEAAO4ABzoBAAAqAA4QIAB9JAAEARMMAAQDExQhAAD0ABQ6AQAAAAAEEAIUAAAEFAMTKgETEioBDBQKAAEUDhMhAAD7ABM6AQAAKgEKFAoABBQPEyEAARcAEyAA/yoBBBMqAQoUKgEKFSQABAMXDAAEFRcYIQABBgAYOgEAACsAABMIAyUABAAECAQiAAABbysACAUAFgAABBYCGAAABBgVFyoCEhcqARYSAAAEEgISKgISFgAABBQNEg4ABBQSFSEAARQAFToBAAAqAhYEKgISCiABQCoAERMgARkMAAQTDxQhAAFGABQgARwqAQQTKgEJFCoAABUkAAQFFgAABAAWACQBBAEVAAAEFAIWJAAEBBcAAAQVAhg+AwAAABYAAAAYKgETFAIABBQCFCoCFBMqARMUAAAEFAIUKgIUEyoBFRQAAAQUAhQqAhQVKwAAEwgDJQAEAAQIBCIAAAFvKwAIBQAUAAAEFAIYAAAEGBEXKgISFyoBFBMAAAQTAhMqAhMUKgEVEwAABBMCEyoCExUqAhQEKgIVCSoCDQogAUAAAAQDDRIOAAQDEhMhAAFEABM6AQAAKgASAyAAdCoBChQMAAQTFBUhAAFKABUgAWkqAQkUKgEJFSQABAQXDAAEExcYIQABUAAYOgEAAAAABBUCGAAABBgTFyoBFxYqAQQVJAAEAxcMAAQTFxkhAAFYABk6AQAAAAAEFQIZAAAEGRMXKgEXGAAABxYYFSQABAQYDAAEExgZIQABYAAZOgEAACsAABQIAyUABAAFCAQiAAABbysACAUAFgAABBYCGQAABBkTGCoCFRgqAhYJIAFpAAAEEw0UDgAEExQVIQABbQAVOgEAACoAFBMgARkrAQgDCAYLAAQIBgACCAchAAFzCAcgAXUrAAgDCAUgAYMrAAAACAUBAAQAAAgEAAAlAAQAAAgJDQAECAkIBAgKFwAICggKIQABgQgKAQAECAMICQgLKwEICwgIAQAECAUICQgLKwIICAgLAQAECAkAAggJIAF4JQEEAAEIBSABgyMrABjKGMo=","debug_symbols":"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","brillig_names":["get_passport_address"],"assert_messages":{"224":"Array index out of bounds","323":"attempt to add with overflow","343":"Array index out of bounds","14":"Not initialized","261":"Array index out of bounds","351":"Array index out of bounds","19":"Function get_passport_address can only be called statically","208":"Array index out of bounds","237":"attempt to add with overflow","243":"Array index out of bounds","275":"attempt to add with overflow","184":"Array index out of bounds","216":"Array index out of bounds","335":"Array index out of bounds","364":"attempt to add with overflow","195":"attempt to add with overflow"}},{"name":"set_passport_address","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"_passport_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["set_passport_address"],"assert_messages":{"1792":"Array index out of bounds","829":"Array index out of bounds","957":"Array index out of bounds","1018":"Array index out of bounds","1085":"attempt to add with overflow","1457":"Array index out of bounds","1262":"Array index out of bounds","811":"Array index out of bounds","939":"attempt to add with overflow","1189":"Array index out of bounds","994":"Array index out of bounds","1384":"Array index out of bounds","1244":"Array index out of bounds","1433":"attempt to add with overflow","1238":"attempt to add with overflow","1439":"Array index out of bounds","1750":"attempt to add with overflow","781":"Array index out of bounds","1610":"Array index out of bounds","903":"Array index out of bounds","1927":"Array index out of bounds","1153":"Array index out of bounds","518":"attempt to add with overflow","891":"attempt to add with overflow","1336":"Array index out of bounds","1531":"Array index out of bounds","1519":"attempt to add with overflow","1324":"attempt to add with overflow","1647":"Array index out of bounds","1629":"Array index out of bounds","1623":"attempt to add with overflow","1940":"attempt to add with overflow","337":"attempt to add with overflow","14":"Not initialized","843":"attempt to add with overflow","1800":"Array index out of bounds","1026":"Array index out of bounds","1471":"attempt to add with overflow","1276":"attempt to add with overflow","1209":"Array index out of bounds","1404":"Array index out of bounds","1721":"Array index out of bounds","1392":"attempt to add with overflow","1197":"attempt to add with overflow","1581":"attempt to add with overflow","1709":"attempt to add with overflow","1837":"Array index out of bounds","1819":"Array index out of bounds","789":"Array index out of bounds","1813":"attempt to add with overflow","911":"Array index out of bounds","1161":"Array index out of bounds","1539":"Array index out of bounds","1344":"Array index out of bounds","1661":"attempt to add with overflow","1594":"Array index out of bounds","631":"attempt to add with overflow","1911":"Array index out of bounds","753":"Array index out of bounds","619":"attempt to add with overflow","1771":"attempt to add with overflow","1899":"attempt to add with overflow","802":"attempt to add with overflow","1570":"Array index out of bounds","1174":"attempt to add with overflow","522":"attempt to add with overflow","1034":"Array index out of bounds","1412":"Array index out of bounds","1217":"Array index out of bounds","510":"attempt to add with overflow","1729":"Array index out of bounds","1784":"Array index out of bounds","1851":"attempt to add with overflow","1071":"Array index out of bounds","614":"attempt to multiply with overflow","1760":"Array index out of bounds","1053":"Array index out of bounds","919":"Array index out of bounds","1047":"attempt to add with overflow","267":"call to assert_max_bit_size","1352":"Array index out of bounds","773":"Array index out of bounds","1547":"Array index out of bounds","1602":"Array index out of bounds","1919":"Array index out of bounds","761":"attempt to add with overflow","505":"attempt to multiply with overflow","627":"attempt to add with overflow","950":"Array index out of bounds","1005":"attempt to add with overflow","1133":"attempt to add with overflow","1145":"Array index out of bounds","932":"attempt to add with overflow","987":"Array index out of bounds","1560":"attempt to add with overflow","1365":"attempt to add with overflow","1420":"Array index out of bounds","1737":"Array index out of bounds","1225":"Array index out of bounds","969":"attempt to add with overflow"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"},{"fields":[{"name":"address","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"},{"fields":[{"name":"address","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"AztecPassport"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"total_services","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"services","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"service_indexes","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"scores","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"VerifiableCredentialModule"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"jwt_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"passport_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"VerifiableCredentialModule::get_jwt_registry_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"VerifiableCredentialModule::get_jwt_registry_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"VerifiableCredentialModule::is_admin_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"VerifiableCredentialModule::is_admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"VerifiableCredentialModule::get_admin_public_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"VerifiableCredentialModule::get_admin_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}}],"kind":"struct","path":"VerifiableCredentialModule::verify_parameters"}}],"kind":"struct","path":"VerifiableCredentialModule::verify_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"VerifiableCredentialModule::get_passport_address_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"VerifiableCredentialModule::get_passport_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"_registry","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"VerifiableCredentialModule::set_jwt_registry_parameters"}}],"kind":"struct","path":"VerifiableCredentialModule::set_jwt_registry_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"VerifiableCredentialModule::constructor_parameters"}}],"kind":"struct","path":"VerifiableCredentialModule::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"_passport_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"VerifiableCredentialModule::set_passport_address_parameters"}}],"kind":"struct","path":"VerifiableCredentialModule::set_passport_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"VerifiableCredentialModule::set_admin_parameters"}}],"kind":"struct","path":"VerifiableCredentialModule::set_admin_abi"}]}},"file_map":{"114":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"115":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"118":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\nunconstrained pub fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"121":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_arguments_oracle_wrapper(args)\n    };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_arguments_array_oracle_wrapper(args)\n    };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"122":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"125":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT, utils::arr_copy_slice};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    let returned_message = get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    (leaf_index, sibling_path)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MSG_TREE_HEIGHT + 1] {}\n"},"126":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"127":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"148":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        value\n    }\n}\n"},"153":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"154":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"159":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"},"162":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse dep::protocol_types::{address::{AztecAddress, EthAddress}, merkle_tree::root::root_from_sibling_path};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    let (leaf_index, sibling_path) = unsafe {\n        get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret)\n    };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n"},"169":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> where T: ToField {\n    fn serialize(self) -> [Field; 3] {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> where T: FromField {\n    fn deserialize(input: [Field; 3]) -> Self {\n        Self {\n            pre: FromField::from_field(input[0]),\n            post: FromField::from_field(input[1]),\n            block_of_change: FromField::from_field(input[2])\n        }\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"170":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32)) + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33)\n            + (self.post.is_some() as u64 * (1 << 32))\n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some {\n                Option::some(pre_inner)\n            } else {\n                Option::none()\n            },\n            post: if post_is_some {\n                Option::some(post_inner)\n            } else {\n                Option::none()\n            },\n            block_of_change\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"174":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{poseidon2_hash, poseidon2_hash_with_separator}, address::AztecAddress,\n    traits::{FromField, ToField}, utils::arrays::array_concat\n};\n\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::mem::zeroed;\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// Separators separating storage slot of different values within the same state variable\nglobal VALUE_CHANGE_SEPARATOR: u32 = 0;\nglobal DELAY_CHANGE_SEPARATOR: u32 = 1;\nglobal HASH_SEPARATOR: u32 = 2;\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, let INITIAL_DELAY: u32, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> where T: ToField + FromField + Eq {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], VALUE_CHANGE_SEPARATOR)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], DELAY_CHANGE_SEPARATOR)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], HASH_SEPARATOR)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> where T: ToField + FromField + Eq {\n\n    pub fn schedule_value_change(self, new_value: T) {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> where T: ToField + FromField + Eq {\n    pub fn get_current_value_in_private(self) -> T {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage(self) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) {\n        let header = self.context.get_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = unsafe {\n            get_public_storage_hints(address, self.storage_slot, historical_block_number)\n        };\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        if hash != 0 {\n            assert_eq(\n                hash, SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint), \"Hint values do not match hash\"\n            );\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            assert_eq(\n                value_change_hint, ScheduledValueChange::deserialize(zeroed()), \"Non-zero value change for zero hash\"\n            );\n            assert_eq(\n                delay_change_hint, ScheduledDelayChange::deserialize(zeroed()), \"Non-zero delay change for zero hash\"\n            );\n        };\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field {\n        let concatenated: [Field; 4] = array_concat(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UnconstrainedContext> where T: ToField + FromField + Eq {\n    unconstrained pub fn get_current_value_in_unconstrained(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    unconstrained fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, let INITIAL_DELAY: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) where T: ToField + FromField + Eq {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"176":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"221":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"},"230":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE: u32 = 4;\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // We choose the last SELECTOR_SIZE bytes of the hash to avoid getting the first byte that is not full\n        let hash_bytes = hash.to_be_bytes::<SELECTOR_SIZE>();\n\n        FunctionSelector::from_field(field_from_bytes(hash_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector = FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"241":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\npub struct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber { _opt: Option { _is_some: serialized[0] as bool, _value: serialized[1] as u32 } }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"263":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"276":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"277":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr","source":"mod assert_array_appended;\nmod assert_array_prepended;\nmod assert_combined_array;\nmod assert_combined_sorted_transformed_value_array;\nmod assert_combined_transformed_array;\nmod assert_deduped_array;\nmod assert_exposed_sorted_transformed_value_array;\nmod assert_sorted_array;\nmod assert_sorted_transformed_value_array;\nmod assert_split_sorted_transformed_value_arrays;\nmod assert_split_transformed_value_arrays;\nmod get_sorted_result;\nmod get_sorted_tuple;\nmod sort_by;\nmod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{assert_array_appended, assert_array_appended_reversed, assert_array_appended_scoped};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_sorted_transformed_value_array::{\n    assert_combined_sorted_transformed_value_array_asc,\n    get_combined_order_hints::{CombinedOrderHint, get_combined_order_hints_asc}\n};\npub use assert_combined_transformed_array::{assert_combined_transformed_array, combine_and_transform_arrays};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint}\n};\npub use assert_deduped_array::{assert_deduped_array, dedupe_array};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc, assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints}\n};\npub use assert_sorted_transformed_value_array::{assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N> where T: Empty + Eq {\n    let mut len = 0;\n    for elem in array {\n        if !is_empty(elem) {\n            len += 1;\n        }\n    }\n\n    BoundedVec { storage: array, len }\n}\n\nunconstrained pub fn find_index_hint<T, let N: u32, Env>(array: [T; N], find: fn[Env](T) -> bool) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32 where T: Empty + Eq {\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32 where T: Empty + Eq {\n    let length = unsafe {\n        find_index_hint(array, |elem: T| is_empty(elem))\n    };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N] where T: Empty + Eq {\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N]\n) where T: Eq + Empty {\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe {\n        find_index_hint(values, |v: Field| min.lt(v))\n    };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe {\n        find_index_hint(values, |v: Field| min.lt(v))\n    };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    pedersen_hash_with_separator_noir(input, separator)\n}\n\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator_noir(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n"},"296":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"298":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"301":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl <let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"302":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl <T, let N: u32, let M: u32> Serialize<N * M> for [T; N] where T: Serialize<M> {\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl <T, let N: u32, let M: u32> Deserialize<N * M> for [T; N] where T: Deserialize<M> {\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n"},"305":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"306":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"310":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{constants::ETH_ADDRESS_LENGTH, traits::{Empty, ToField, Serialize, Deserialize}, utils};\nuse crate::traits::FromField;\n\npub struct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for EthAddress {\n    fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"314":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"318":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\npub struct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"329":{"path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/l2-contracts/crates/passport/src/main.nr","source":"pub mod service;\n\nuse dep::aztec::macros::aztec;\n\npub global SCALE: u64 = 1000000;\n\n#[aztec]\npub contract AztecPassport {\n    use aztec::{\n        prelude::{AztecAddress, PublicMutable, Map, SharedMutable},\n        macros::{storage::storage, functions::{initializer, public, private, view}},\n        keys::getters::get_public_keys\n    };\n\n    use dep::value_note::{balance_utils::get_balance};\n\n    use dep::easy_private_state::EasyPrivateUint;\n    use crate::service::Service;\n\n    pub global SCALE: u64 = 1000000;\n\n    #[storage]\n    struct Storage<Context> {\n        // Admin of Contract\n        admin: PublicMutable<AztecAddress, Context>,\n        // Track Count of Total Services\n        total_services: SharedMutable<u64, 1, Context>,\n        // Service ID => Service\n        services: Map<u64, PublicMutable<Service, Context>, Context>,\n        // Service Address -> ID\n        service_indexes: Map<AztecAddress, SharedMutable<u64, 1, Context>, Context>,\n        //  Address => Service ID => verified(boolean)\n        scores: Map<AztecAddress, Map<u64, EasyPrivateUint<Context>, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(_admin: AztecAddress) {\n        assert(!_admin.is_zero(), \"Aztec Passport: Invalid Address\");\n        storage.admin.write(_admin);\n    }\n\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Unauthorized Admin Change\");\n        storage.admin.write(new_admin);\n    }\n\n    #[public]\n    #[view]\n    fn get_admin_public() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    #[public]\n    fn add_service(address: AztecAddress, weight: u64, base_score: u64, max_score: u64) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Only Admin\");\n        let service_id = storage.total_services.get_current_value_in_public();\n        storage.services.at(service_id).write(Service { address, weight, base_score, max_score });\n        storage.service_indexes.at(address).schedule_value_change(service_id);\n        storage.total_services.schedule_value_change(service_id + 1);\n    }\n\n    #[public]\n    #[view]\n    fn get_service(service_id: u64) -> Service {\n        storage.services.at(service_id).read()\n    }\n\n    #[public]\n    #[view]\n    fn get_total_services() -> u64 {\n        storage.total_services.get_current_value_in_public()\n    }\n\n    #[private]\n    #[view]\n    fn get_total_services_private() -> u64 {\n        storage.total_services.get_current_value_in_private()\n    }\n\n    #[public]\n    #[view]\n    fn get_service_index(address: AztecAddress) -> u64 {\n        storage.service_indexes.at(address).get_current_value_in_public()\n    }\n\n    #[private]\n    #[view]\n    fn get_service_index_private(address: AztecAddress) -> u64 {\n        storage.service_indexes.at(address).get_current_value_in_private()\n    }\n\n    unconstrained fn is_verified(address: AztecAddress, service_id: u64) -> bool {\n        let res = storage.scores.at(address).at(service_id).set;\n        let balance = get_balance(res);\n        balance as u32 >= 1\n    }\n\n    #[private]\n    fn verify_service(address: AztecAddress, service_id: u64, service_address: AztecAddress) {\n        assert(service_address.eq(context.msg_sender()), \"Aztec Passport: Only Service\");\n        let res = storage.service_indexes.at(service_address).get_current_value_in_private();\n        assert(res == service_id, \"Aztec Passport: Invalid Service\");\n        storage.scores.at(address).at(service_id).add(1, address, address);\n    }\n\n    unconstrained fn get_total_score(address: AztecAddress) -> u64 {\n        let mut total_weight: u64 = 0;\n        let mut total_base_contribution: u64 = 0;\n        let mut total_max_contribution: u64 = 0;\n        let mut verified_count: u64 = 0;\n\n        let total_services = storage.total_services.get_current_value_in_unconstrained();\n\n        for i in 0..total_services {\n            let service = storage.services.at(i).read();\n            total_weight += service.weight;\n            let res = storage.scores.at(address).at(i).set;\n            let balance = get_balance(res);\n            let verified = balance as u32 >= 1;\n            if (verified) {\n                total_base_contribution += (service.base_score * service.weight) / SCALE;\n                total_max_contribution += (service.max_score * service.weight) / SCALE;\n                verified_count += 1;\n            }\n        }\n\n        if (verified_count == 0) {\n            0\n        }\n\n        let diminishing_factor = verified_count * verified_count / (total_services * total_services);\n        let adjusted_max_score = total_max_contribution * diminishing_factor;\n        let bonus_multiplier = (verified_count * SCALE) / total_services;\n        let final_score = (total_base_contribution + adjusted_max_score) * bonus_multiplier / SCALE;\n\n        final_score\n    }\n}\n"},"331":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/address-note/src/address_note.nr","source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"},"338":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\nglobal ZERO = 0;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"6":{"path":"std/cmp.nr","source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(s, quote { Eq }, signature, for_each_field, quote { & }, body)\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"68":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"70":{"path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/l2-contracts/crates/modules/vc_module/src/main.nr","source":"use dep::aztec::macros::aztec;\n\n#[aztec]\ncontract VerifiableCredentialModule {\n    use aztec::{\n        prelude::{AztecAddress, PublicMutable, SharedMutable}, protocol_types::{address::EthAddress},\n        macros::{storage::storage, functions::{initializer, public, private, view}}\n    };\n\n    use dep::passport::AztecPassport;\n\n    #[storage]\n    struct Storage<Context> {\n        // Admin of Contract\n        admin: PublicMutable<AztecAddress, Context>,\n        // JWT Registry\n        jwt_registry: SharedMutable<EthAddress, 1, Context>,\n        // Passport Contract Address\n        passport_address: SharedMutable<AztecAddress, 1, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(_admin: AztecAddress) {\n        assert(!_admin.is_zero(), \"Aztec Passport: Invalid Address\");\n        storage.admin.write(_admin);\n    }\n\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Unauthorized Admin Change\");\n        storage.admin.write(new_admin);\n    }\n\n    #[public]\n    #[view]\n    fn get_admin_public() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    #[public]\n    #[view]\n    fn is_admin() -> bool {\n        storage.admin.read().eq(context.msg_sender())\n    }\n\n    #[public]\n    #[view]\n    fn get_passport_address() -> AztecAddress {\n        storage.passport_address.get_current_value_in_public()\n    }\n\n    #[public]\n    fn set_passport_address(_passport_address: AztecAddress) {\n        let _ = storage.passport_address.schedule_value_change(_passport_address);\n    }\n\n    #[public]\n    fn set_jwt_registry(_registry: EthAddress) {\n        let _ = storage.jwt_registry.schedule_value_change(_registry);\n    }\n\n    #[public]\n    #[view]\n    fn get_jwt_registry() -> EthAddress {\n        storage.jwt_registry.get_current_value_in_public()\n    }\n\n    #[private]\n    fn verify(address: AztecAddress, content: Field, secret: Field) {\n        let passport_address = storage.passport_address.get_current_value_in_private();\n        let sender = storage.jwt_registry.get_current_value_in_private();\n\n        context.consume_l1_to_l2_message(content, secret, sender);\n\n        assert(content as u32 == 1, \"Aztec Passport: Invalid Content\");\n\n        let index = AztecPassport::at(passport_address).get_service_index_private(context.this_address()).view(&mut context);\n        let _ = AztecPassport::at(passport_address).verify_service(address, index, context.this_address()).call(&mut context);\n    }\n}\n"},"77":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\nunconstrained pub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"86":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe {\n            unpack_returns(self.packed_returns)\n        };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"90":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](()) -> T {\n        self.original\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](()) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](()) -> () {\n        self.original\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](()) -> T {\n        self.original\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](()) -> () {\n        self.original\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"92":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn () -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        panic(f\"'delegate_call_public_function' not implemented!\")\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained pub fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"93":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"}}}