{
  "transpiled": true,
  "noir_version": "0.35.0+b848cc128d2dc2b461581f21a35509a1af9065a7-aarch64",
  "name": "AztecPassport",
  "functions": [
    {
      "name": "get_admin_public",
      "is_unconstrained": true,
      "custom_attributes": ["public", "view"],
      "abi": {
        "error_types": {},
        "parameters": [],
        "return_type": {
          "abi_type": { "kind": "field" },
          "visibility": "public"
        }
      },
      "bytecode": "JAAEAQIlAAQIRAAAJAAEAAMkAAQABB8AAAAABAAAAAMAAAhDIgAAAAgrAAADCEM5AAAACEMAAAABHgAAAAQeAAAABTAAAAAABAAAAAUAAAAGJAACAQUKAAIGBQQhAAAPAAQ6AQAAHgALAAYkAAcBBQoABwYFBCEAABQABDoBAAAqAAAGJAAEAgQAAAQABAAkAQQBBgAABAYCBCoABAckAAcACCoCCAcqAQYEAAAEBAIEKgIEBioAAAQAAAQAAgAqAgYEJAAEAQgkAAQABioABgMgACYKAAQDBgchAAAvAAcgACkqAQQFAAAEBQIDAAAEAwYHKgEHBCoABAMjKgEEBxwABwMJAAAHBQkKLAAAAAAKAAAACSQABAELDAAEAwsMIQAANwAMOgEAACsAAAcIAyUABAACCAQiAAAARSsACAUACgAABAoCDAAABAwDCyoCCQsAAAQDCAkOAAQDCQchAABCAAc6AQAAKgIKBCoACQMgACYrAQgDCAYLAAQIBgACCAchAABJCAcgAEsrAAgDCAUgAFkrAAAACAUBAAQAAAgEAAAlAAQAAAgJDQAECAkIBAgKFwAICggKIQAAVwgKAQAECAMICQgLKwEICwgIAQAECAUICQgLKwIICAgLAQAECAkAAggJIABOJQEEAAEIBSAAWSMrABjKGMo=",
      "debug_symbols": "1ZrRbsIwDEX/Jc88xEmc2PzKNE1lg6lSVSZgkybEv6/dmtKVKggYU/yCCNzEp0nq61Tdq5fl4v31qaxX662aP+xVtX4uduW6blr7w0wtNmVVla9Pw5+Vbj/oW759K+q2td0Vm52aQzBuppb1S/vVumaAVVkt1TzAYXYiZhs6LWPopYB+QusMcCd2xlCvZpwQewLbiT0ZHoofZ4pvBgcNvVgPxHdHB337pIc4PvO5SQfjohgMc5qcACMFwWDojhz+kLyZ9N/obQBz7wD23gHcvQPgzQEQOUZAr8/siEAGO3EgR+Md4S+kafuEK/rQFX348j5m+t5EikkOvMZzeSVQFDcLeFy/wFNrwT7mFWTW6bXAYCGKgzWjtTAgmN0IZreC2Z1gdhTM7gWzB8HsJJid5bJbwb5qBfuqFeyrVrCv2szzDFLPjuPzqct8vwfXs5Mes///fu8PzF4Php5kB83+OPRRbJtDWAtvJcM7yfCZlzTJ2zXvVEPQp0kyMGbPvKTpN80EO2Ze0pA9spu0mJ2NHOzCyYUK9gPMvP5Jsmde/yTZnWD2zJ8rJNkzf66QZM/chJPsmdf7SfbMTTjF7jM34SS7YF/1gn3VC/ZVL9hXvWBf9WJ99dC0PopNWSyqZfc6yOq9fh68HbL7fPv5pxF/AQ==",
      "brillig_names": ["get_admin_public"],
      "assert_messages": {
        "14": "Not initialized",
        "65": "attempt to add with overflow",
        "54": "Array index out of bounds",
        "19": "Function get_admin_public can only be called statically"
      }
    },
    {
      "name": "get_total_services",
      "is_unconstrained": true,
      "custom_attributes": ["public", "view"],
      "abi": {
        "error_types": {},
        "parameters": [],
        "return_type": {
          "abi_type": { "kind": "integer", "sign": "unsigned", "width": 64 },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["get_total_services"],
      "assert_messages": {
        "349": "Array index out of bounds",
        "14": "Not initialized",
        "267": "Array index out of bounds",
        "357": "Array index out of bounds",
        "249": "Array index out of bounds",
        "281": "attempt to add with overflow",
        "243": "attempt to add with overflow",
        "214": "Array index out of bounds",
        "19": "Function get_total_services can only be called statically",
        "222": "Array index out of bounds",
        "190": "Array index out of bounds",
        "341": "Array index out of bounds",
        "370": "attempt to add with overflow",
        "329": "attempt to add with overflow",
        "230": "Array index out of bounds",
        "201": "attempt to add with overflow"
      }
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {
          "3715688037512703171": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 16
          }
        },
        "parameters": [
          {
            "name": "selector",
            "type": { "kind": "field" },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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GBIqAAAYAAAEAAIAKgEJGgAABBoCGioCGgkqAAAaAAAEAAIAKgAAGQAABAACACoAAB8AAAQAAgAqARIqAAAEKgIqKgIqEioBCSoAAAQqAioqAioJKgESKgAABCoCKioCKhIqAQkqAAAEKgIqKgIqCSoBEioAAAQqAioqAioSKgEJKgAABCoCKioCKgkqAhIYKgIJGioCDxkqAgofKgESKgIABCoCKioCKhIqAQkqAgAEKgIqKgIqCSoACCYgBRwKAAQmCCohABYpACogBR8qAR8qCgABKgorIQAFIwArOgEAACoACCYgBSUMAAQmDiohABYAACogBSgqARoZKgAAGCQABAUqAAAEACoAJAEEARgAAAQZAiokAAQEKwAABBgCLD4DAAAAKgAAACwqAhgaKgIHHwAABBgCGgAABBoIGSoBGR8cAAceGBwABxwaHAAHKRkqAAgmIAU7DAAEJg4qIQAV5QAqIAU+KgAAHwAABAACACoBCRoAAAQaAhoqAhoJKgAAGgAABAACACoAABkAAAQAAgAqAAAYAAAEAAIAKgEJKgAABCoCKioCKgkqAQkqAAAEKgIqKgIqCSoBIioAAAQqAioqAioiKgEJKgAABCoCKioCKgkqAiIfKgIJGioCDxkqAgoYKgEiKgIABCoCKioCKiIqAQkqAgAEKgIqKgIqCSoACCYgBWEKAAQmCCohABVmACogBWQqARgqCgABKgorIQAFaAArOgEAACoACCYgBWoMAAQmDiohABU9ACogBW0qARofKgAAGSQABAUqAAAEACoAJAEEARkAAAQfAiokAAQEKwAABBkCLD4DAAAAKgAAACwqAhkaKgIHGAAABBkCGgAABBoIHyoBHxgcAAUgGQQABRklGiQABQAsCgAFLCUfIQAFhAAfBgAFGiUqCgAFKhkrIQAFhAArOgEAABwABSQZAAAFGhksDgAFGiwfIQAFiQAfOgEAABwABSEZBAAFGSMaHAAFJxkEAAUZJR8AAAUaHxkOAAUaGSohAAWRACo6AQAAAAAFGSgfDgAFGR8aIQAFlQAaOgEAABwABywZHAAHHywEAAcsGx8AAAcZHywqAAgmIAWbCgAEJggrIQAVJgArIAWeKgAAHwAABAACACoBCRoAAAQaAhoqAhoJKgAAGgAABAACACoAABkAAAQAAgAqAAAYAAAEAAIAKgEJKgAABCoCKioCKgkqAQkqAAAEKgIqKgIqCSoAACokAAQEKwAABAArACQBBAEqAAAEKgIrKgArLCoCFywAAAQsAiwqAgwsAAAELAIsKgIMLCoBKisAAAQrAisqAisqKgEJKwAABCsCKyoCKwkqAiofKgIJGioCDxkqAgoYKgEqKwIABCsCKyoCKyoqAQkrAgAEKwIrKgIrCSoACCYgBcwKAAQmCCshABSnACsgBc8qARgdCgABHQoTIQAF0wATOgEAACoACCYgBdUMAAQmDh0hABR+AB0gBdgqARofKgAAHSQABAUZAAAEABkAJAEEAR0AAAQfAhkkAAQEEwAABB0CKz4DAAAAGQAAACsqAh0aKgIHGAAABB0CGgAABBoIHyoBHxgcAAceHRwABxweHAAHKRocAAUgKQQABSklICQABQArCgAFKyUfIQAF8gAfBgAFICUZCgAFGSkTIQAF8gATOgEAABwABSQpAAAFICkkDgAFICQrIQAF9wArOgEAABwABSEpBAAFKSMhHAAFJykEAAUpJScAAAUhJykOAAUhKSAhAAX/ACA6AQAAAAAFKSgnDgAFKSchIQAGAwAhOgEAABwAByQpHAAHJyQEAAckGycAAAcpJyQqAAAnJAAEBSkAAAQAKQAkAQQBJwAABCcCKSoAKSgqAh0oAAAEKAIoKgIdKAAABCgCKCoCHSgAAAQoAigqAh0oKgEnKQAABCkCKSoCKScqAAApAAAEAAIAKgInKSoADyYgBhwMAAQmDighABRZACggBh8qAAgoIAYhCgAEKAgnIQAUNAAnIAYkKgEpJyoBEikAAAQpAikqAikSKgESKQAABCkCKSoCKRIqARIpAAAEKQIpKgIpEioBEikAAAQpAikqAikSKgAAKQAABAACACoCEikoAAcAAAAAAAAABAAAAAAAAAAAACYqAAAkJAAEBSEAAAQAIQAkAQQBJAAABCQCISoAISAqAgwgAAAEIAIgKgIMIAAABCACICoCDCAAAAQgAiAqAiYgKgEkIQAABCECISoCISQqAAAhAAAEAAIAKgIkISoAACAAAAQAAgAqAgggKgAAHwAABAACACoCCh8qAAgoIAZQDAAEKBEeIQATsgAeIAZTKgEfJwoAAScKHiEABlcAHjoBAAAqAAgoIAZZDAAEKA4nIQATiQAnIAZcKgEhKCoAACckAAQFIAAABAAgACQBBAEnAAAEKAIgJAAEBB4AAAQnAh0+AwAAACAAAAAdKgInISoCBx8AAAQnAiEAAAQhCCgqASgfKgAIKSAGbAoABCkIKCEAE3IAKCAGbyQABQEoAAAFHCgnDgAFHCchIQAGdAAhOgEAACoBEigAAAQoAigqAigSKgESKAAABCgCKCoCKBIqARIoAAAEKAIoKgIoEioBEigAAAQoAigqAigSKgAAKAAABAACACoBCRwAAAQcAhwqAhwJKgAAHAAABAACACoAACEAAAQAAgAqAAAgAAAEAAIAKgESHwAABB8CHyoCHxIqAQkfAAAEHwIfKgIfCSoBEh8AAAQfAh8qAh8SKgEJHwAABB8CHyoCHwkqARIfAAAEHwIfKgIfEioBCR8AAAQfAh8qAh8JKgISKCoCCRwqAg8hKgIKICoBEh8CAAQfAh8qAh8SKgEJHwIABB8CHyoCHwkqAAgpIAapCgAEKQgfIQAS8wAfIAasKgEgHwoAAR8KHiEABrAAHjoBAAAqAAgpIAayDAAEKQ4fIQASygAfIAa1KgEcKCoAACEkAAQFHwAABAAfACQBBAEhAAAEKAIfJAAEBB4AAAQhAh0+AwAAAB8AAAAdKgIhHCoCByAAAAQhAhwAAAQcCCgqASggKgESIQAABCECISoCIRIqAAAhAAAEAAIAKgISISoACCkgBssMAAQpDighABK0ACggBs4qASEoAAAEKAIgAAAEIAgfKgEfIRwABSEfHAAHHyAcAAUgIQAABCgCHwAABB8PHioBHiAcAAUgHhwABx4fHAAFHyAAAAQoAh4AAAQeBh0qAR0fHAAEHx4cAAceKBwABCgfKgAAKAAABAACACoCISgqAAAhAAAEAAIAKgIgISoAACAAAAQAAgAqAh8gKgAAHwAABAACACoBCR4AAAQeAh4qAh4JKgAAHgAABAACACoAAB0AAAQAAgAqAAAcAAAEAAIAKgEJGgAABBoCGioCGgkqAQkaAAAEGgIaKgIaCSoBIhoAAAQaAhoqAhoiKgEJGgAABBoCGioCGgkqAiIfKgIJHioCDx0qAgocKgEiGgIABBoCGioCGiIqAQkaAgAEGgIaKgIaCSoACCkgBw0KAAQpCBohABI1ABogBxAqARwaCgABGgoZIQAHFAAZOgEAACoACCkgBxYMAAQpDhohABIMABogBxkqAR4fKgAAHSQABAUaAAAEABoAJAEEAR0AAAQfAhokAAQEGQAABB0CGD4DAAAAGgAAABgqAh0eKgIHHAAABB0CHgAABB4IHyoBHxwqARAdAAAEHQIdKgIdECoAAB0AAAQAAgAqAhAdKgAIKSAHLwoABCkIHyEAEfYAHyAHMioBHR4AAAQeAhwAAAQcCBoqARodHAAHHR4oAAf/////////////////////ABwOAAceHBohAAc7ABo6AQAAHAAFHR4cAAceHBwABRweAgAHHRwaCAAHGhsdHAAFHRwcAAccGhwABRodBgAFHSMaHAABGhkcAAUZHBwAARwaBgAFHiUcHAAEHBkGAAUdJRwcAAEcExwABRMYHAABGBwcAAQeExwABRMYHAAEGB4cAAQdExwABRMYHAAEGB0hAAdYABogB1UqAAopKgAIHyAHWyoABykqABkfIAdbIQAHYAAcIAddKgAKGioACBkgB2MqAAcaKgAeGSAHYx4ABwAcHAAEHCscAAcrExwABBMcDAAEHB0TIQAHcgATIAdqIQAHbgAaIAdsKgAPHSAHcCoAGR0gB3AqAB0eIAd6IQAHdgApIAd0KgAPHSAHeCoAHx0gB3gqAB0eIAd6AAAEHB4TDgAEHBMrIQAHfgArOgEAACoBKB4qASErKgEgLAwABBwsLSEAB4YALSAHhCoAKx0gB4gqAB4dIAeIKgIdKCoCJyEqAhMgKgESIAAABCACICoCIBIqARIgAAAEIAIgKgIgEioBEiAAAAQgAiAqAiASKgESIAAABCACICoCIBIqAAAgAAAEAAIAKgEJIQAABCECISoCIQkqAAAhAAAEAAIAKgAAKAAABAACACoAABwAAAQAAgAqARIrAAAEKwIrKgIrEioBCSsAAAQrAisqAisJKgESKwAABCsCKyoCKxIqAQkrAAAEKwIrKgIrCSoBEisAAAQrAisqAisSKgEJKwAABCsCKyoCKwkqAhIgKgIJISoCDygqAgocKgESKwIABCsCKyoCKxIqAQkrAgAEKwIrKgIrCSoACB4gB8AKAAQeCCshABF3ACsgB8MqARwrCgABKwosIQAHxwAsOgEAACoACB4gB8kMAAQeDishABFOACsgB8wqASEgKgAAHiQABAUrAAAEACsAJAEEAR4AAAQgAiskAAQELAAABB4CLT4DAAAAKwAAAC0qAh4hKgIHHAAABB4CIQAABCEIICoBIBwcAAcdHhwABychHAAHEyAqAAgoIAffDAAEKA4rIQARMwArIAfiKgAAIQAABAACACoBCSAAAAQgAiAqAiAJKgAAIAAABAACACoAAB4AAAQAAgAqAAAcAAAEAAIAKgEJKwAABCsCKyoCKwkqAQkrAAAEKwIrKgIrCSoBIisAAAQrAisqAisiKgEJKwAABCsCKyoCKwkqAiIhKgIJICoCDx4qAgocKgEiKwIABCsCKyoCKyIqAQkiAgAEIgIiKgIiCSoACCggCAUKAAQoCCIhABC0ACIgCAgqARwiCgABIgorIQAIDAArOgEAACoACCggCA4MAAQoDiIhABCLACIgCBEqASAiKgAAISQABAUeAAAEAB4AJAEEASEAAAQiAh4kAAQEKwAABCECLD4DAAAAHgAAACwqAiEgKgIHHAAABCECIAAABCAIIioBIhwcAAUfIQQABSElICQABQAsCgAFLCUiIQAIKAAiBgAFICUeCgAFHiErIQAIKAArOgEAABwABRkhAAAFICEsDgAFICwiIQAILQAiOgEAABwABSkhBAAFISMgHAAFGiEEAAUhJSIAAAUgIiEOAAUgIR4hAAg1AB46AQAAAAAFIRgiDgAFISIgIQAIOQAgOgEAABwABywhHAAHIiwEAAcsGyIAAAchIiwqAAgoIAg/CgAEKAgrIQAQdAArIAhCKgAAIgAABAACACoBCSEAAAQhAiEqAiEJKgAAIQAABAACACoAACAAAAQAAgAqAAAeAAAEAAIAKgEJHAAABBwCHCoCHAkqAQkcAAAEHAIcKgIcCSoBKhwAAAQcAhwqAhwqKgEJHAAABBwCHCoCHAkqAioiKgIJISoCDyAqAgoeKgEqHAIABBwCHCoCHCoqAQkqAgAEKgIqKgIqCSoACCggCGUKAAQoCBwhAA/1ABwgCGgqAR4cCgABHAoqIQAIbAAqOgEAACoACCggCG4MAAQoDhwhAA/MABwgCHEqASEiKgAAICQABAUcAAAEABwAJAEEASAAAAQiAhwkAAQEKgAABCACKz4DAAAAHAAAACsqAiAhKgIHHgAABCACIQAABCEIIioBIh4cAAcdIBwABycdHAAHEyccAAUfEwQABRMlHyQABQAiCgAFIiUhIQAIiwAhBgAFHyUqCgAFKhMrIQAIiwArOgEAABwABRkTAAAFHxMZDgAFHxkiIQAIkAAiOgEAABwABSkTBAAFEyMpHAAFGhMEAAUTJRoAAAUpGiUOAAUpJRMhAAiYABM6AQAAAAAFJRgaDgAFJRopIQAInAApOgEAABwABxklHAAHGhkEAAcZGxoAAAclGhsqAAAaJAAEBSUAAAQAJQAkAQQBGgAABBoCJSoAJRkqAiAZAAAEGQIZKgIgGQAABBkCGSoCIBkAAAQZAhkqAiAZKgEaJQAABCUCJSoCJRoqAAAlAAAEAAIAKgIaJSoADyggCLUMAAQoDiMhAA+nACMgCLgqAAgjIAi6CgAEIwgiIQAPggAiIAi9KgElIioBEiUAAAQlAiUqAiUSKgESJQAABCUCJSoCJRIqARIlAAAEJQIlKgIlEioBEiUAAAQlAiUqAiUSKgAAJQAABAACACoCEiUqASQhAAAEIQIhKgIhJCoAACEAAAQAAgAqAiQhKgAAJAAABAACACoCCCQqAAAmAAAEAAIAKgIKJioACCMgCNsMAAQjESAhAA8AACAgCN4qASYiCgABIgogIQAI4gAgOgEAACoACCMgCOQMAAQjDiIhAA7XACIgCOcqASEkKgAAIyQABAUiAAAEACIAJAEEASMAAAQkAiIkAAQEIAAABCMCHz4DAAAAIgAAAB8qAiMhKgIHJgAABCMCIQAABCEIJCoBJCYqAAglIAj3CgAEJQgkIQAOwAAkIAj6AAAECwITOQEAAAATAAAAACAI/SYAB+w4zhcAEwoABwMTCyEACQEACyAJsCoAAAskAAQCGAAABAAYACQBBAELAAAECwIYHwQAAAAPAAAADwAAABgqAQsYAAAEGAIYKgIYCyoAABgAAAQAAgAqAgsYKgAAGQAABAACACoCCBkqAQsaAAAEGgIaKgIaCyoAABoAAAQAAgAqAhAaKgELGwAABBsCGyoCGwsqARALAAAECwILKgILECoACBMgCR4KAAQTCAshAA6gAAsgCSEqARkTAAAEEw8LDgAEEwsbIQAJJgAbOgEAACoCCxkqARoLKgEQGgIABBoCGioCGhAAAAQLAhkAAAQZCBMqARMaHAAFGhkcAAcZCx4AAAAaHgAAABkwAAAAABoAAAAZAAAAEwoAAhMFGSEACTYAGToBAAAeAAsAEwoABxMNGSEACToAGToBAAAqARITAAAEEwITKgITEioBEhMAAAQTAhMqAhMSKgESEwAABBMCEyoCExIqARITAAAEEwITKgITEioAABMAAAQAAgAqAhITKgEJGQAABBkCGSoCGQkqAAAZAAAEAAIAKgIJGSoAABoAAAQAAgAqAggaKgAAGwAABAACACoCChsqAAgYIAlXDAAEGAYcIQAOFQAcIAlaKgEbFgoAARYKCyEACV4ACzoBAAAqAAgYIAlgDAAEGA4WIQAN7AAWIAljKgEZGCoAABYkAAQFEwAABAATACQBBAEWAAAEGAITJAAEBAsAAAQWAhw+AwAAABMAAAAcKgIWGSoCBxsAAAQWAhkAAAQZCBgqARgbCgAHGwwWCgABFgoZIQAJdQAZOgEAACoAABYkAAQFGQAABAAZACQBBAEWAAAEFgIZKgAZGCoCDBgAAAQYAhgqAgwYAAAEGAIYKgIMGAAABBgCGCoCDBgqARYZAAAEGQIZKgIZFioAABkAAAQAAgAqAhYZKgAIGiAJigwABBoRGCEADdYAGCAJjSoBGRgAAAQYAhYAAAQWCBMqARMZAAAEGAITAAAEEw8LKgELFhwABRYLHAAHCxMAAAQYAgsAAAQLBhoqARoWHAAFFhocAAcaCwAABBgCGgAABBoOGyoBGxYcAAUWGhwABxoYKgAAFiQABAUaAAAEABoAJAEEARYAAAQWAhoqABobKgIZGwAABBsCGyoCExsAAAQbAhsqAgsbAAAEGwIbKgIYGwAABBYCGjkBAAAAGgAAAAQgCbAmAAemSso4ABYKAAcDFhMhAAm0ABMgCkEeAAAAEx4AAAALMAAAAAATAAAACwAAABgKAAIYBQshAAm6AAs6AQAAHgALABgKAAcYDQshAAm+AAs6AQAAHgAHABgcAAQYExwABxMLHAAECxgqARILAAAECwILKgILEioBEgsAAAQLAgsqAgsSKgESCwAABAsCCyoCCxIqARILAAAECwILKgILEioAAAsAAAQAAgAqAQkTAAAEEwITKgITCSoAABMAAAQAAgAqAAAZAAAEAAIAKgAAGgAABAACACoBEhsAAAQbAhsqAhsSKgEJGwAABBsCGyoCGwkqARIbAAAEGwIbKgIbEioBCRsAAAQbAhsqAhsJKgESGwAABBsCGyoCGxIqAQkbAAAEGwIbKgIbCSoCEgsqAgkTKgIPGSoCChoqARIbAgAEGwIbKgIbEioBCRsCAAQbAhsqAhsJKgAIFiAJ9woABBYIGyEADVcAGyAJ+ioBGhYKAAEWChQhAAn+ABQ6AQAAKgAIFyAKAAwABBcOFiEADS4AFiAKAyoBExcqAAAWJAAEBRQAAAQAFAAkAQQBFgAABBcCFCQABAQLAAAEFgIbPgMAAAAUAAAAGyoCFhMqAgcaAAAEFgITAAAEEwgXKgEXGioBEhYAAAQWAhYqAhYSKgAAFgAABAACACoCEhYqAAgZIAoZDAAEGQ4XIQANGAAXIAocKgEWFAAABBQCEwAABBMICyoBCxYcAAUWCxwABwsTHAAFExYAAAQUAgsAAAQLDxkqARkTHAAFExkcAAcZCxwABQsTAAAEFAIZAAAEGQYaKgEaCxwABAsZHAAHGRQcAAQUCwwABBgLFCEACjQAFCAKMioAExcgCjYqABYXIAo2HAAHFxYqAAAXJAAEAhQAAAQAFAAkAQQBFwAABBcCFCoAFBMqAhYTAAAEFwIUOQEAAAAUAAAAASAKQSYAB34+7fIAFAoABwMUEyEACkUAEyALOioAABMkAAQCCwAABAALACQBBAETAAAEEwILHwQAAAAPAAAADwAAAAsqARMLAAAECwILKgILEyoAAAsAAAQAAgAqAhMLKgAAAwAABAACACoCCAMqARMWAAAEFgIWKgIWEyoAABYAAAQAAgAqAhAWKgETFwAABBcCFyoCFxMqARATAAAEEwITKgITECoACBQgCmIKAAQUCBMhAAz4ABMgCmUqAQMTAAAEEw8LDgAEEwsXIQAKagAXOgEAACoCCwMqARYLKgEQFgIABBYCFioCFhAAAAQLAhYAAAQWCAMqAQMQHgAAAAseAAAAFjAAAAAACwAAABYAAAADCgACAwUWIQAKeAAWOgEAAB4ACwADCgAHAw0FIQAKfAAFOgEAACoBEg0AAAQNAg0qAg0SKgESDQAABA0CDSoCDRIqARINAAAEDQINKgINEioBEg0AAAQNAg0qAg0SKgAADQAABAACACoCEg0qAQkDAAAEAwIDKgIDCSoAAAMAAAQAAgAqAgkDKgAABQAABAACACoCCAUqAAAWAAAEAAIAKgIKFioACBQgCpkMAAQUBhMhAAxtABMgCpwqARYUCgABFAoTIQAKoAATOgEAACoACBUgCqIMAAQVDhQhAAxEABQgCqUqAQMUKgAAEyQABAUQAAAEABAAJAEEARMAAAQUAhAkAAQEDQAABBMCCz4DAAAAEAAAAAsqAhMDKgIHFgAABBMCAwAABAMIFCoBFBYKAAcWDBMKAAETCgMhAAq3AAM6AQAAHgAHABMcAAQTFBwABxQDHAAEAxMqARIDAAAEAwIDKgIDEioBEgMAAAQDAgMqAgMSKgESAwAABAMCAyoCAxIqARIDAAAEAwIDKgIDEioAAAMAAAQAAgAqAQkUAAAEFAIUKgIUCSoAABQAAAQAAgAqAAALAAAEAAIAKgAADQAABAACACoBEhAAAAQQAhAqAhASKgEJEAAABBACECoCEAkqARIQAAAEEAIQKgIQEioBCRAAAAQQAhAqAhAJKgESEAAABBACECoCEBIqAQkQAAAEEAIQKgIQCSoCEgMqAgkUKgIPCyoCCg0qARIQAgAEEAIQKgIQEioBCRACAAQQAhAqAhAJKgAIFSAK8AoABBUIECEAC74AECAK8yoBDQkKAAEJCgUhAAr3AAU6AQAAKgAIECAK+QwABBAOCSEAC5UACSAK/CoBFAsqAAAJJAAEBQUAAAQABQAkAQQBCQAABAsCBSQABAQEAAAECQIDPgMAAAAFAAAAAyoCCRQqAgcNAAAECQIUAAAEFAgRKgERDSoBEgkAAAQJAgkqAgkSKgAACQAABAACACoCEgkqAAgQIAsSDAAEEA4SIQALfwASIAsVKgEJEQAABBECEAAABBAIDioBDgkcAAUJDhwABw4QHAAFEAkAAAQRAg4AAAQODw0qAQ0QHAAFEA4cAAcODxwABQ8QAAAEEQIOAAAEDgYNKgENDxwABA8GHAAHBhEcAAQRDwwABBMPESEACy0AESALKyoAEBIgCy8qAAkSIAsvHAAHEhEqAAASJAAEAhAAAAQAEAAkAQQBEgAABBICECoAEA8qAhEPAAAEEgIQOQEAAAAQAAAAASALOiQAAmUJJAACbgYkAAJsBSQAAmsEJAACYwMkAAJvCyQAAnQMJAACdw0kAAJyDiQAAiAPKgAAECQABBERAAAEABEAJAEEARAAAAQQAhEqABESJAACVRMqAhMSAAAEEgISKgIGEgAABBICEioCBBIAAAQSAhIqAgYSAAAEEgISKgILEgAABBICEioCDRIAAAQSAhIqAgYSAAAEEgISKgIPEgAABBICEiQAAnMUKgIUEgAABBICEioCCRIAAAQSAhIqAgUSAAAEEgISKgIJEgAABBICEioCAxIAAAQSAhIqAgwSAAAEEgISKgILEgAABBICEioCDhIKAAEKBxEhAAt+ABEqAAASJAAEEhUAAAQAFQAqABIVJwEFM5DGlWQc7MMAFQAABBUCFQAABBACFiQABBAXKwAAFggDKwAAFQgEKwAAFwgFIgAAHQUkAAQQFgAABBUWFSoCCBUAAAQVAhU6ARISIyoBCRIcAAcQEQAABw0RDCwAAAAADAAAABEkAAQDCwwABBALBSEAC4cABToBAAArAAASCAMlAAQABAgEIgAAHPArAAgFAAwAAAQMAgUAAAQFEAsqAhELAAAEEA8SDgAEEBIRIQALkgAROgEAACoCDAkqABIQIAsSKgELCQwABBAJBSEAC5kABSALuCoBFAkqARQFJAAEBBUMAAQQFRYhAAufABY6AQAAAAAEBQIWAAAEFhAVKgEVBCoBAwUkAAQDFQwABBAVFyEAC6cAFzoBAAAAAAQFAhcAAAQXEBUqARUWAAAHBBYFJAAEBBYMAAQQFhchAAuvABc6AQAAKwAACQgDJQAEAAUIBCIAABzwKwAIBQAEAAAEBAIXAAAEFxAWKgIFFioCBBQgC7gAAAQQDwkOAAQQCQUhAAu8AAU6AQAAKgAJECAK+SoAABAkAAQCCQAABAAJACQBBAEQAAAEEAIJKgAJBSoCFgUkAAQBBQwABBUFBCEAC8kABDoBAAAAAAQQAgQAAAQEFQUqAQUJKgENEAoAARAKBCEAC9AABDoBAAAqAQsQCgAEEA4EIQAL7AAEIAvUKgEDECoBCwUqAQsEJAAEAxgMAAQEGBkhAAvbABk6AQAAKwAAEAgDJQAEAAQIBCIAABzwKwAIBQAXAAAEFwIZAAAEGQQYKgIJGCoBFwkAAAQJAgkqAgkXAAAEBQ8JDgAEBQkEIQAL6QAEOgEAACoCFwMqAgkLIAwVKgAIECAL7gwABBAOBSEADBsABSAL8SoBAxAqARQFKgAABCQABAUXAAAEABcAJAEEAQQAAAQFAhckAAQEGAAABAQCGT4DAAAAFwAAABkqARAFAgAEBQIFKgIFECoBEAUAAAQFAgUqAgUQKgEEBQAABAUCBSoCBQQrAAAQCAMlAAQABAgEIgAAHPArAAgFAAUAAAQFAhkAAAQZCBgqAgkYKgEFCQAABAkCCSoCCQUqAQQJAAAECQIJKgIJBCoCBQMqAgQUKgIPCyAMFQAABBUPEA4ABBUQCSEADBkACToBAAAqABAVIArwKgELBQwABBAFBCEADB8ABCAMPioBFAUqARQEJAAEBBgMAAQQGBkhAAwlABk6AQAAAAAEBAIZAAAEGRAYKgEYFyoBAwQkAAQDGAwABBAYGiEADC0AGjoBAAAAAAQEAhoAAAQaEBgqARgZAAAHFxkEJAAEBBcMAAQQFxohAAw1ABo6AQAAKwAABQgDJQAEAAUIBCIAABzwKwAIBQAZAAAEGQIaAAAEGhAXKgIEFyoCGRQgDD4AAAQQDwUOAAQQBQQhAAxCAAQ6AQAAKgAFECAL7ioBBRQMAAQVFBMhAAxIABMgDGcqAQMUKgEDEyQABAQLDAAEFQsXIQAMTgAXOgEAAAAABBMCFwAABBcVCyoBCxAqAQ0TJAAEAwsMAAQVCxghAAxWABg6AQAAAAAEEwIYAAAEGBULKgELFwAABxAXEyQABAQQDAAEFRAYIQAMXgAYOgEAACsAABQIAyUABAAFCAQiAAAc8CsACAUAFwAABBcCGAAABBgVECoCExAqAhcDIAxnAAAEFQ8UDgAEFRQTIQAMawATOgEAACoAFBUgCqIMAAQUBhMhAAxwABMgDMkqAAATJAAEAwsAAAQACwAkAQQBEwAABBMCCyoACxcqAhUXAAAEFwIXKgIQFyQABAIXDAAEFBcYIQAMfQAYOgEAAAAABBMCGAAABBgUFyoBFwsqARYTCgABEwoYIQAMhAAYOgEAACoBBRMKAAQTDhghAAygABggDIgqAQ0TKgEFFyoBBRgkAAQDGgwABBgaGyEADI8AGzoBAAArAAATCAMlAAQABAgEIgAAHPArAAgFABkAAAQZAhsAAAQbGBoqAgsaKgEZCwAABAsCCyoCCxkAAAQXDwsOAAQXCxghAAydABg6AQAAKgIZDSoCCwUgDMkqAAgTIAyiDAAEEw4XIQAMzwAXIAylKgENEyoBAxcqAAAYJAAEBRkAAAQAGQAkAQQBGAAABBcCGSQABAQaAAAEGAIbPgMAAAAZAAAAGyoBExcCAAQXAhcqAhcTKgETFwAABBcCFyoCFxMqARgXAAAEFwIXKgIXGCsAABMIAyUABAAECAQiAAAc8CsACAUAFwAABBcCGwAABBsIGioCCxoqARcTAAAEEwITKgITFyoBGBMAAAQTAhMqAhMYKgIXDSoCGAMqAg8FIAzJAAAEFA8TDgAEFBMLIQAMzQALOgEAACoAExQgCpkqAQUXDAAEExcYIQAM0wAYIAzyKgEDFyoBAxgkAAQEGgwABBMaGyEADNkAGzoBAAAAAAQYAhsAAAQbExoqARoZKgENGCQABAMaDAAEExocIQAM4QAcOgEAAAAABBgCHAAABBwTGioBGhsAAAcZGxgkAAQEGwwABBMbHCEADOkAHDoBAAArAAAXCAMlAAQABQgEIgAAHPArAAgFABkAAAQZAhwAAAQcExsqAhgbKgIZAyAM8gAABBMPFw4ABBMXGCEADPYAGDoBAAAqABcTIAyiKgEWEyoBCxcqAQMYAAAEGBQZDgAEGBkaIQAM/wAaOgEAACQABAEaDAAEGRobIQANAwAbOgEAAAAABBcCGwAABBsZGioBGhgkAAQBGQwABBQZGyEADQoAGzoBAAArAAATCAMlAAQAAggEIgAAHPArAAgFABcAAAQXAhsAAAQbFBkqAhgZAAAEFA8YDgAEFBgTIQANFQATOgEAACoCFxYqABgUIApiKgEWFxwABxkUAAAHGhQTLAAAAAATAAAAFCQABAMLDAAEGQsbIQANIAAbOgEAACsAABcIAyUABAAECAQiAAAc8CsACAUAEwAABBMCGwAABBsZCyoCFAsAAAQZDxcOAAQZFxQhAA0rABQ6AQAAKgITFioAFxkgChkqARkWDAAEFxYUIQANMgAUIA1RKgETFioBExQkAAQEHAwABBccHSEADTgAHToBAAAAAAQUAh0AAAQdFxwqARwbKgELFCQABAMcDAAEFxweIQANQAAeOgEAAAAABBQCHgAABB4XHCoBHB0AAAcbHRQkAAQEHQwABBcdHiEADUgAHjoBAAArAAAWCAMlAAQABQgEIgAAHPArAAgFABsAAAQbAh4AAAQeFx0qAhQdKgIbEyANUQAABBcPFg4ABBcWFCEADVUAFDoBAAAqABYXIAoAJAAEARwMAAQWHB0hAA1bAB06AQAAAAAEFAIdAAAEHRYcKgEcGyoBGh0KAAEdChwhAA1iABw6AQAAKgEZHQoABB0OHCEADX4AHCANZioBCxwqARkdKgEZHiQABAMgDAAEHiAhIQANbQAhOgEAACsAABwIAyUABAAECAQiAAAc8CsACAUAHwAABB8CIQAABCEeICoCGyAqAR8bAAAEGwIbKgIbHwAABB0PGw4ABB0bHiEADXsAHjoBAAAqAh8LKgIbGSANpyoACBwgDYAMAAQcDh0hAA2tAB0gDYMqAQscKgETHSoAAB4kAAQFHwAABAAfACQBBAEeAAAEHQIfJAAEBCAAAAQeAiE+AwAAAB8AAAAhKgEcHQIABB0CHSoCHRwqARwdAAAEHQIdKgIdHCoBHh0AAAQdAh0qAh0eKwAAHAgDJQAEAAQIBCIAABzwKwAIBQAdAAAEHQIhAAAEIQggKgIbICoBHRsAAAQbAhsqAhsdKgEeGwAABBsCGyoCGx4qAh0LKgIeEyoCDxkgDacAAAQWDxsOAAQWGxwhAA2rABw6AQAAKgAbFiAJ9yoBGR0MAAQcHR4hAA2xAB4gDdAqARMdKgETHiQABAQgDAAEHCAhIQANtwAhOgEAAAAABB4CIQAABCEcICoBIB8qAQseJAAEAyAMAAQcICIhAA2/ACI6AQAAAAAEHgIiAAAEIhwgKgEgIQAABx8hHiQABAQfDAAEHB8iIQANxwAiOgEAACsAAB0IAyUABAAFCAQiAAAc8CsACAUAIQAABCECIgAABCIcHyoCHh8qAiETIA3QAAAEHA8dDgAEHB0eIQAN1AAeOgEAACoAHRwgDYAqARkYHAAHGhYAAAcbFhMsAAAAABMAAAAWJAAEBAsMAAQaCxwhAA3eABw6AQAAKwAAGAgDJQAEAAUIBCIAABzwKwAIBQATAAAEEwIcAAAEHBoLKgIWCwAABBoPGA4ABBoYFiEADekAFjoBAAAqAhMZKgAYGiAJiioBGhYMAAQYFgshAA3wAAsgDg8qARkWKgEZCyQABAQdDAAEGB0eIQAN9gAeOgEAAAAABAsCHgAABB4YHSoBHRwqARMLJAAEAx0MAAQYHR8hAA3+AB86AQAAAAAECwIfAAAEHxgdKgEdHgAABxweCyQABAQeDAAEGB4fIQAOBgAfOgEAACsAABYIAyUABAAFCAQiAAAc8CsACAUAHAAABBwCHwAABB8YHioCCx4qAhwZIA4PAAAEGA8WDgAEGBYLIQAOEwALOgEAACoAFhggCWAMAAQYBhwhAA4YABwgDnEqAAAcJAAEAx0AAAQAHQAkAQQBHAAABBwCHSoAHR4qAhYeAAAEHgIeKgILHiQABAIeDAAEGB4fIQAOJQAfOgEAAAAABBwCHwAABB8YHioBHh0qARscCgABHAofIQAOLAAfOgEAACoBGhwKAAQcDh8hAA5IAB8gDjAqARMcKgEaHioBGh8kAAQDIQwABB8hIiEADjcAIjoBAAArAAAcCAMlAAQABAgEIgAAHPArAAgFACAAAAQgAiIAAAQiHyEqAh0hKgEgHwAABB8CHyoCHyAAAAQeDx8OAAQeHxwhAA5FABw6AQAAKgIgEyoCHxogDnEqAAgcIA5KDAAEHA4eIQAOdwAeIA5NKgETHCoBGR4qAAAfJAAEBSAAAAQAIAAkAQQBHwAABB4CICQABAQhAAAEHwIiPgMAAAAgAAAAIioBHB4CAAQeAh4qAh4cKgEcHgAABB4CHioCHhwqAR8eAAAEHgIeKgIeHysAABwIAyUABAAECAQiAAAc8CsACAUAHgAABB4CIgAABCIIISoCHSEqAR4dAAAEHQIdKgIdHioBHx0AAAQdAh0qAh0fKgIeEyoCHxkqAg8aIA5xAAAEGA8cDgAEGBwdIQAOdQAdOgEAACoAHBggCVcqARoeDAAEHB4fIQAOewAfIA6aKgEZHioBGR8kAAQEIQwABBwhIiEADoEAIjoBAAAAAAQfAiIAAAQiHCEqASEgKgETHyQABAMhDAAEHCEjIQAOiQAjOgEAAAAABB8CIwAABCMcISoBISIAAAcgIh8kAAQEIAwABBwgIyEADpEAIzoBAAArAAAeCAMlAAQABQgEIgAAHPArAAgFACIAAAQiAiMAAAQjHCAqAh8gKgIiGSAOmgAABBwPHg4ABBweHyEADp4AHzoBAAAqAB4cIA5KKgEaCyoBGBsqARkcAAAEHBMdDgAEHB0eIQAOpwAeOgEAACQABAEeDAAEHR4fIQAOqwAfOgEAAAAABBsCHwAABB8dHioBHhwkAAQBGwwABBMbHyEADrIAHzoBAAArAAALCAMlAAQAAggEIgAAHPArAAgFAB0AAAQdAh8AAAQfExsqAhwbAAAEEw8cDgAEExwLIQAOvQALOgEAACoCHRoqABwTIAkeHAAHJSQAAAceJCMqAAAkJAAEAiIAAAQAIgAkAQQBJAAABCQCIioAIiEqAiYhJAAEASEMAAQlISAhAA7NACA6AQAAAAAEJAIgAAAEICUhKgEhIi0AAAAAIgAAACMAAAQlDyIOAAQlIiMhAA7VACM6AQAAKgAiJSAI9yoBJCIMAAQjIiAhAA7bACAgDvoqASEiKgEhICQABAQdDAAEIx0cIQAO4QAcOgEAAAAABCACHAAABBwjHSoBHR8qASUgJAAEAx0MAAQjHRshAA7pABs6AQAAAAAEIAIbAAAEGyMdKgEdHAAABx8cICQABAQcDAAEIxwbIQAO8QAbOgEAACsAACIIAyUABAAFCAQiAAAc8CsACAUAHwAABB8CGwAABBsjHCoCIBwqAh8hIA76AAAEIw8iDgAEIyIgIQAO/gAgOgEAACoAIiMgCOQMAAQjESAhAA8DACAgD1MkAAQEHwwABCMfHSEADwcAHToBAAAAAAQiAh0AAAQdIx8qAR8gKgEmHQoAAR0KHyEADw4AHzoBAAAqASQdCgAEHQ4fIQAPKgAfIA8SKgElHyoBJB0qASQcJAAEAxoMAAQcGhkhAA8ZABk6AQAAKwAAHwgDJQAEAAQIBCIAABzwKwAIBQAbAAAEGwIZAAAEGRwaKgIgGioBGxwAAAQcAhwqAhwbAAAEHQ8cDgAEHRwfIQAPJwAfOgEAACoCGyUqAhwkIA9TKgAIHyAPLAwABB8OHSEAD1kAHSAPLyoBJR8qASEdKgAAHCQABAUbAAAEABsAJAEEARwAAAQdAhskAAQEGgAABBwCGT4DAAAAGwAAABkqAR8dAgAEHQIdKgIdHyoBHx0AAAQdAh0qAh0fKgEcHQAABB0CHSoCHRwrAAAfCAMlAAQABAgEIgAAHPArAAgFAB0AAAQdAhkAAAQZCBoqAiAaKgEdIAAABCACICoCIB0qARwgAAAEIAIgKgIgHCoCHSUqAhwhKgIPJCAPUwAABCMPIA4ABCMgHyEAD1cAHzoBAAAqACAjIAjbKgEkHQwABB8dHCEAD10AHCAPfCoBIR0qASEcJAAEBBoMAAQfGhkhAA9jABk6AQAAAAAEHAIZAAAEGR8aKgEaGyoBJRwkAAQDGgwABB8aGCEAD2sAGDoBAAAAAAQcAhgAAAQYHxoqARoZAAAHGxkcJAAEBBsMAAQfGxghAA9zABg6AQAAKwAAHQgDJQAEAAUIBCIAABzwKwAIBQAZAAAEGQIYAAAEGB8bKgIcGyoCGSEgD3wAAAQfDx0OAAQfHRwhAA+AABw6AQAAKgAdHyAPLCoBJSIAAAQjDiEOAAQjISAhAA+HACA6AQAAKgAAICQABAIfAAAEAB8AJAEEASAAAAQgAh8qAB8dKgIbHSQABAEdDAAEIx0cIQAPkgAcOgEAAAAABCACHAAABBwjHSoBHR8kAAQEHAwABCEcHSEAD5kAHToBAAArAAAiCAMlAAQABQgEIgAAHPArAAgFACAAAAQgAh0AAAQdIRwqAh8cKgIgJQAABCMPIA4ABCMgHyEAD6UAHzoBAAAqACAjIAi6KgElIyoAACIkAAQEIQAABAAhACQBBAEiAAAEIgIhKgAhHyoCIB8AAAQfAh8qAh0fAAAEHwIfKgInHyQABAMfDAAEKB8cIQAPtwAcOgEAAAAABCICHAAABBwoHyoBHyEkAAQEHAwABCgcHyEAD74AHzoBAAArAAAjCAMlAAQABQgEIgAAHPArAAgFACIAAAQiAh8AAAQfKBwqAiEcAAAEKA8jDgAEKCMhIQAPyQAhOgEAACoCIiUqACMoIAi1KgEgHAwABCgcKiEAD9AAKiAP7yoBIRwqASEqJAAEBCwMAAQoLC0hAA/WAC06AQAAAAAEKgItAAAELSgsKgEsKyoBIiokAAQDLAwABCgsLiEAD94ALjoBAAAAAAQqAi4AAAQuKCwqASwtAAAHKy0qJAAEBC0MAAQoLS4hAA/mAC46AQAAKwAAHAgDJQAEAAUIBCIAABzwKwAIBQArAAAEKwIuAAAELigtKgIqLSoCKyEgD+8AAAQoDxwOAAQoHCohAA/zACo6AQAAKgAcKCAIbiQABAEqDAAEKCorIQAP+QArOgEAAAAABBQCKwAABCsoKioBKhwqAR4rCgABKwoqIQAQAAAqOgEAACoBICsKAAQrDiohABAcACogEAQqASIqKgEgKyoBICwkAAQDLgwABCwuLyEAEAsALzoBAAArAAAqCAMlAAQABAgEIgAAHPArAAgFAC0AAAQtAi8AAAQvLC4qAhwuKgEtHAAABBwCHCoCHC0AAAQrDxwOAAQrHCwhABAZACw6AQAAKgItIioCHCAgEEUqAAgqIBAeDAAEKg4rIQAQSwArIBAhKgEiKioBISsqAAAsJAAEBS0AAAQALQAkAQQBLAAABCsCLSQABAQuAAAELAIvPgMAAAAtAAAALyoBKisCAAQrAisqAisqKgEqKwAABCsCKyoCKyoqASwrAAAEKwIrKgIrLCsAACoIAyUABAAECAQiAAAc8CsACAUAKwAABCsCLwAABC8ILioCHC4qASsqAAAEKgIqKgIqKyoBLCoAAAQqAioqAiosKgIrIioCLCEqAg8gIBBFAAAEKA8cDgAEKBwqIQAQSQAqOgEAACoAHCggCGUqASArDAAEKissIQAQTwAsIBBuKgEhKyoBISwkAAQELgwABCouLyEAEFUALzoBAAAAAAQsAi8AAAQvKi4qAS4tKgEiLCQABAMuDAAEKi4wIQAQXQAwOgEAAAAABCwCMAAABDAqLioBLi8AAActLywkAAQELwwABCovMCEAEGUAMDoBAAArAAArCAMlAAQABQgEIgAAHPArAAgFAC0AAAQtAjAAAAQwKi8qAiwvKgItISAQbgAABCoPKw4ABCorLCEAEHIALDoBAAAqACsqIBAeHAAHKCsAAAccKyIqAAArJAAEAiEAAAQAIQAkAQQBKwAABCsCISoAISAqAiwgJAAEASAMAAQoIB4hABCBAB46AQAAAAAEKwIeAAAEHiggKgEgIS0AAAAAIQAAACIAAAQoDyEOAAQoISIhABCJACI6AQAAKgAhKCAIPyoBHiIMAAQoIishABCPACsgEK4qASAiKgEgKyQABAQtDAAEKC0uIQAQlQAuOgEAAAAABCsCLgAABC4oLSoBLSwqASErJAAEAy0MAAQoLS8hABCdAC86AQAAAAAEKwIvAAAELygtKgEtLgAABywuKyQABAQsDAAEKCwvIQAQpQAvOgEAACsAACIIAyUABAAFCAQiAAAc8CsACAUALgAABC4CLwAABC8oLCoCKywqAi4gIBCuAAAEKA8iDgAEKCIrIQAQsgArOgEAACoAIiggCA4kAAQBKwwABCgrLCEAELgALDoBAAAAAAQUAiwAAAQsKCsqASsiKgEcLAoAASwKKyEAEL8AKzoBAAAqAR4sCgAELA4rIQAQ2wArIBDDKgEhKyoBHiwqAR4tJAAEAy8MAAQtLzAhABDKADA6AQAAKwAAKwgDJQAEAAQIBCIAABzwKwAIBQAuAAAELgIwAAAEMC0vKgIiLyoBLisAAAQrAisqAisuAAAELA8rDgAELCsiIQAQ2AAiOgEAACoCLiEqAiseIBEEKgAIKyAQ3QwABCsOLCEAEQoALCAQ4CoBISsqASAsKgAALSQABAUuAAAEAC4AJAEEAS0AAAQsAi4kAAQELwAABC0CMD4DAAAALgAAADAqASssAgAELAIsKgIsKyoBKywAAAQsAiwqAiwrKgEtLAAABCwCLCoCLC0rAAArCAMlAAQABAgEIgAAHPArAAgFACwAAAQsAjAAAAQwCC8qAiIvKgEsIgAABCICIioCIiwqAS0iAAAEIgIiKgIiLSoCLCEqAi0gKgIPHiARBAAABCgPIg4ABCgiKyEAEQgAKzoBAAAqACIoIAgFKgEeLAwABCssLSEAEQ4ALSARLSoBICwqASAtJAAEBC8MAAQrLzAhABEUADA6AQAAAAAELQIwAAAEMCsvKgEvLioBIS0kAAQDLwwABCsvMSEAERwAMToBAAAAAAQtAjEAAAQxKy8qAS8wAAAHLjAtJAAEBC4MAAQrLjEhABEkADE6AQAAKwAALAgDJQAEAAUIBCIAABzwKwAIBQAwAAAEMAIxAAAEMSsuKgItLioCMCAgES0AAAQrDywOAAQrLC0hABExAC06AQAAKgAsKyAQ3RwABygrAAAHHCssKgAAKyQABAQtAAAEAC0AJAEEASsAAAQrAi0qAC0uKgIeLgAABC4CLioCIS4AAAQuAi4qAiAuJAAEAy4MAAQoLi8hABFEAC86AQAAAAAEKwIvAAAELyguKgEuLS0AAAAALQAAACwAAAQoDy0OAAQoLSwhABFMACw6AQAAKgAtKCAH3yoBKCsMAAQeKywhABFSACwgEXEqASErKgEhLCQABAQuDAAEHi4vIQARWAAvOgEAAAAABCwCLwAABC8eLioBLi0qASAsJAAEAy4MAAQeLjAhABFgADA6AQAAAAAELAIwAAAEMB4uKgEuLwAABy0vLCQABAQvDAAEHi8wIQARaAAwOgEAACsAACsIAyUABAAFCAQiAAAc8CsACAUALQAABC0CMAAABDAeLyoCLC8qAi0hIBFxAAAEHg8rDgAEHissIQARdQAsOgEAACoAKx4gB8kkAAQBLAwABB4sLSEAEXsALToBAAAAAAQUAi0AAAQtHiwqASwrKgEcLQoAAS0KLCEAEYIALDoBAAAqASgtCgAELQ4sIQARngAsIBGGKgEgLCoBKC0qASguJAAEAzAMAAQuMDEhABGNADE6AQAAKwAALAgDJQAEAAQIBCIAABzwKwAIBQAvAAAELwIxAAAEMS4wKgIrMCoBLysAAAQrAisqAisvAAAELQ8rDgAELSsuIQARmwAuOgEAACoCLyAqAisoIBHHKgAILCARoAwABCwOLSEAEc0ALSARoyoBICwqASEtKgAALiQABAUvAAAEAC8AJAEEAS4AAAQtAi8kAAQEMAAABC4CMT4DAAAALwAAADEqASwtAgAELQItKgItLCoBLC0AAAQtAi0qAi0sKgEuLQAABC0CLSoCLS4rAAAsCAMlAAQABAgEIgAAHPArAAgFAC0AAAQtAjEAAAQxCDAqAiswKgEtLAAABCwCLCoCLC0qAS4sAAAELAIsKgIsLioCLSAqAi4hKgIPKCARxwAABB4PKw4ABB4rLCEAEcsALDoBAAAqACseIAfAKgEoLQwABCwtLiEAEdEALiAR8CoBIS0qASEuJAAEBDAMAAQsMDEhABHXADE6AQAAAAAELgIxAAAEMSwwKgEwLyoBIC4kAAQDMAwABCwwMiEAEd8AMjoBAAAAAAQuAjIAAAQyLDAqATAxAAAHLzEuJAAEBDEMAAQsMTIhABHnADI6AQAAKwAALQgDJQAEAAUIBCIAABzwKwAIBQAvAAAELwIyAAAEMiwxKgIuMSoCLyEgEfAAAAQsDy0OAAQsLS4hABH0AC46AQAAKgAtLCARoCoBHR8cAAcpHgAABxweGiwAAAAAGgAAAB4kAAQBGQwABCkZGCEAEf4AGDoBAAArAAAfCAMlAAQAAggEIgAAHPArAAgFABoAAAQaAhgAAAQYKRkqAh4ZAAAEKQ8fDgAEKR8eIQASCQAeOgEAACoCGh0qAB8pIAcvKgEdGgwABCkaGSEAEhAAGSASLyoBHhoqAR4ZJAAEBBMMAAQpEyshABIWACs6AQAAAAAEGQIrAAAEKykTKgETGCoBHxkkAAQDEwwABCkTLCEAEh4ALDoBAAAAAAQZAiwAAAQsKRMqARMrAAAHGCsZJAAEBCsMAAQpKywhABImACw6AQAAKwAAGggDJQAEAAUIBCIAABzwKwAIBQAYAAAEGAIsAAAELCkrKgIZKyoCGB4gEi8AAAQpDxoOAAQpGhkhABIzABk6AQAAKgAaKSAHFiQABAEZDAAEKRkYIQASOQAYOgEAAAAABBQCGAAABBgpGSoBGRoqARwYCgABGAoZIQASQAAZOgEAACoBHRgKAAQYDhkhABJcABkgEkQqAR8ZKgEdGCoBHRMkAAQDLAwABBMsLSEAEksALToBAAArAAAZCAMlAAQABAgEIgAAHPArAAgFACsAAAQrAi0AAAQtEywqAhosKgErGgAABBoCGioCGisAAAQYDxoOAAQYGhMhABJZABM6AQAAKgIrHyoCGh0gEoUqAAgZIBJeDAAEGQ4YIQASiwAYIBJhKgEfGSoBHhgqAAATJAAEBSsAAAQAKwAkAQQBEwAABBgCKyQABAQsAAAEEwItPgMAAAArAAAALSoBGRgCAAQYAhgqAhgZKgEZGAAABBgCGCoCGBkqARMYAAAEGAIYKgIYEysAABkIAyUABAAECAQiAAAc8CsACAUAGAAABBgCLQAABC0ILCoCGiwqARgaAAAEGgIaKgIaGCoBExoAAAQaAhoqAhoTKgIYHyoCEx4qAg8dIBKFAAAEKQ8aDgAEKRoZIQASiQAZOgEAACoAGikgBw0qAR0YDAAEGRgTIQASjwATIBKuKgEeGCoBHhMkAAQELAwABBksLSEAEpUALToBAAAAAAQTAi0AAAQtGSwqASwrKgEfEyQABAMsDAAEGSwuIQASnQAuOgEAAAAABBMCLgAABC4ZLCoBLC0AAAcrLRMkAAQEKwwABBkrLiEAEqUALjoBAAArAAAYCAMlAAQABQgEIgAAHPArAAgFAC0AAAQtAi4AAAQuGSsqAhMrKgItHiASrgAABBkPGA4ABBkYEyEAErIAEzoBAAAqABgZIBJeKgEhKBwABykfAAAHIB8eLAAAAAAeAAAAHyQABAMdDAAEKR0cIQASvAAcOgEAACsAACgIAyUABAAECAQiAAAc8CsACAUAHgAABB4CHAAABBwpHSoCHx0AAAQpDygOAAQpKB8hABLHAB86AQAAKgIeISoAKCkgBssqASEfDAAEKR8eIQASzgAeIBLtKgEcHyoBHB4kAAQEGgwABCkaGSEAEtQAGToBAAAAAAQeAhkAAAQZKRoqARodKgEoHiQABAMaDAAEKRoYIQAS3AAYOgEAAAAABB4CGAAABBgpGioBGhkAAAcdGR4kAAQEHQwABCkdGCEAEuQAGDoBAAArAAAfCAMlAAQABQgEIgAAHPArAAgFABkAAAQZAhgAAAQYKR0qAh4dKgIZHCAS7QAABCkPHw4ABCkfHiEAEvEAHjoBAAAqAB8pIAayJAAEAR4MAAQpHh0hABL3AB06AQAAAAAEFAIdAAAEHSkeKgEeHyoBIB0KAAEdCh4hABL+AB46AQAAKgEhHQoABB0OHiEAExoAHiATAioBKB4qASEdKgEhGiQABAMYDAAEGhgTIQATCQATOgEAACsAAB4IAyUABAAECAQiAAAc8CsACAUAGQAABBkCEwAABBMaGCoCHxgqARkeAAAEHgIeKgIeGQAABB0PHg4ABB0eHyEAExcAHzoBAAAqAhkoKgIeISATQyoACB4gExwMAAQeDh0hABNJAB0gEx8qASgeKgEcHSoAABokAAQFGQAABAAZACQBBAEaAAAEHQIZJAAEBBgAAAQaAhM+AwAAABkAAAATKgEeHQIABB0CHSoCHR4qAR4dAAAEHQIdKgIdHioBGh0AAAQdAh0qAh0aKwAAHggDJQAEAAQIBCIAABzwKwAIBQAdAAAEHQITAAAEEwgYKgIfGCoBHR8AAAQfAh8qAh8dKgEaHwAABB8CHyoCHxoqAh0oKgIaHCoCDyEgE0MAAAQpDx8OAAQpHx4hABNHAB46AQAAKgAfKSAGqSoBIR0MAAQeHRohABNNABogE2wqARwdKgEcGiQABAQYDAAEHhgTIQATUwATOgEAAAAABBoCEwAABBMeGCoBGBkqASgaJAAEAxgMAAQeGCshABNbACs6AQAAAAAEGgIrAAAEKx4YKgEYEwAABxkTGiQABAQZDAAEHhkrIQATYwArOgEAACsAAB0IAyUABAAFCAQiAAAc8CsACAUAEwAABBMCKwAABCseGSoCGhkqAhMcIBNsAAAEHg8dDgAEHh0aIQATcAAaOgEAACoAHR4gExwcAAcpKAAABxgoJyoAACgkAAQCIQAABAAhACQBBAEoAAAEKAIhKgAhICoCHyAkAAQBIAwABCkgHiEAE38AHjoBAAAAAAQoAh4AAAQeKSAqASAhLQAAAAAhAAAAJwAABCkPIQ4ABCkhJyEAE4cAJzoBAAAqACEpIAZsKgEgJwwABCgnHiEAE40AHiATrCoBIScqASEeJAAEBBoMAAQoGhkhABOTABk6AQAAAAAEHgIZAAAEGSgaKgEaHSoBKR4kAAQDGgwABCgaEyEAE5sAEzoBAAAAAAQeAhMAAAQTKBoqARoZAAAHHRkeJAAEBBkMAAQoGRMhABOjABM6AQAAKwAAJwgDJQAEAAUIBCIAABzwKwAIBQAdAAAEHQITAAAEEygZKgIeGSoCHSEgE6wAAAQoDycOAAQoJx4hABOwAB46AQAAKgAnKCAGWQwABCgRHiEAE7UAHiAUBSQABAQdDAAEKB0aIQATuQAaOgEAAAAABCcCGgAABBooHSoBHR4qAR8aCgABGgodIQATwAAdOgEAACoBIBoKAAQaDh0hABPcAB0gE8QqASkdKgEgGioBIBkkAAQDKwwABBkrLCEAE8sALDoBAAArAAAdCAMlAAQABAgEIgAAHPArAAgFABMAAAQTAiwAAAQsGSsqAh4rKgETHQAABB0CHSoCHRMAAAQaDx0OAAQaHR4hABPZAB46AQAAKgITKSoCHSAgFAUqAAgdIBPeDAAEHQ4aIQAUCwAaIBPhKgEpHSoBIRoqAAAZJAAEBRMAAAQAEwAkAQQBGQAABBoCEyQABAQrAAAEGQIsPgMAAAATAAAALCoBHRoCAAQaAhoqAhodKgEdGgAABBoCGioCGh0qARkaAAAEGgIaKgIaGSsAAB0IAyUABAAECAQiAAAc8CsACAUAGgAABBoCLAAABCwIKyoCHisqARoeAAAEHgIeKgIeGioBGR4AAAQeAh4qAh4ZKgIaKSoCGSEqAg8gIBQFAAAEKA8eDgAEKB4dIQAUCQAdOgEAACoAHiggBlAqASAaDAAEHRoZIQAUDwAZIBQuKgEhGioBIRkkAAQEKwwABB0rLCEAFBUALDoBAAAAAAQZAiwAAAQsHSsqASsTKgEpGSQABAMrDAAEHSstIQAUHQAtOgEAAAAABBkCLQAABC0dKyoBKywAAAcTLBkkAAQEEwwABB0TLSEAFCUALToBAAArAAAaCAMlAAQABQgEIgAAHPArAAgFACwAAAQsAi0AAAQtHRMqAhkTKgIsISAULgAABB0PGg4ABB0aGSEAFDIAGToBAAAqABodIBPeKgEpJwAABCgOJg4ABCgmISEAFDkAIToBAAAqAAAhJAAEAiAAAAQAIAAkAQQBIQAABCECICoAIB8qAiQfJAAEAR8MAAQoHx4hABREAB46AQAAAAAEIQIeAAAEHigfKgEfICQABAQeDAAEJh4fIQAUSwAfOgEAACsAACcIAyUABAAFCAQiAAAc8CsACAUAIQAABCECHwAABB8mHioCIB4qAiEpAAAEKA8hDgAEKCEnIQAUVwAnOgEAACoAISggBiEqASkoKgAAJyQABAQhAAAEACEAJAEEAScAAAQnAiEqACEgKgIdIAAABCACICoCHiAAAAQgAiAqAhogJAAEAyAMAAQmIB8hABRpAB86AQAAAAAEJwIfAAAEHyYgKgEgISQABAQfDAAEJh8gIQAUcAAgOgEAACsAACgIAyUABAAFCAQiAAAc8CsACAUAJwAABCcCIAAABCAmHyoCIR8AAAQmDyEOAAQmISghABR7ACg6AQAAKgInKSoAISYgBhwqARkdDAAEJh0TIQAUggATIBShKgEaHSoBGhMkAAQELAwABCYsLSEAFIgALToBAAAAAAQTAi0AAAQtJiwqASwrKgEfEyQABAMsDAAEJiwuIQAUkAAuOgEAAAAABBMCLgAABC4mLCoBLC0AAAcrLRMkAAQEKwwABCYrLiEAFJgALjoBAAArAAAdCAMlAAQABQgEIgAAHPArAAgFAC0AAAQtAi4AAAQuJisqAhMrKgItGiAUoQAABCYPHQ4ABCYdEyEAFKUAEzoBAAAqAB0mIAXVJAAEASwMAAQmLC0hABSrAC06AQAAAAAEEwItAAAELSYsKgEsKyoBGC0KAAEtCiwhABSyACw6AQAAKgEZLQoABC0OLCEAFM4ALCAUtioBHywqARktKgEZLiQABAMwDAAELjAxIQAUvQAxOgEAACsAACwIAyUABAAECAQiAAAc8CsACAUALwAABC8CMQAABDEuMCoCKzAqAS8uAAAELgIuKgIuLwAABC0PLg4ABC0uLCEAFMsALDoBAAAqAi8fKgIuGSAU9yoACCwgFNAMAAQsDi0hABT9AC0gFNMqAR8sKgEaLSoAAC4kAAQFLwAABAAvACQBBAEuAAAELQIvJAAEBDAAAAQuAjE+AwAAAC8AAAAxKgEsLQIABC0CLSoCLSwqASwtAAAELQItKgItLCoBLi0AAAQtAi0qAi0uKwAALAgDJQAEAAQIBCIAABzwKwAIBQAtAAAELQIxAAAEMQgwKgIrMCoBLSsAAAQrAisqAistKgEuKwAABCsCKyoCKy4qAi0fKgIuGioCDxkgFPcAAAQmDysOAAQmKywhABT7ACw6AQAAKgArJiAFzCoBGS0MAAQsLS4hABUBAC4gFSAqARotKgEaLiQABAQwDAAELDAxIQAVBwAxOgEAAAAABC4CMQAABDEsMCoBMC8qAR8uJAAEAzAMAAQsMDIhABUPADI6AQAAAAAELgIyAAAEMiwwKgEwMQAABy8xLiQABAQxDAAELDEyIQAVFwAyOgEAACsAAC0IAyUABAAFCAQiAAAc8CsACAUALwAABC8CMgAABDIsMSoCLjEqAi8aIBUgAAAELA8tDgAELC0uIQAVJAAuOgEAACoALSwgFNAcAAcmKwAABxgrKioAACskAAQCHwAABAAfACQBBAErAAAEKwIfKgAfGioCLBokAAQBGgwABCYaGSEAFTMAGToBAAAAAAQrAhkAAAQZJhoqARofLQAAAAAfAAAAKgAABCYPHw4ABCYfKiEAFTsAKjoBAAAqAB8mIAWbKgEZKgwABCYqKyEAFUEAKyAVYCoBGioqARorJAAEBC0MAAQmLS4hABVHAC46AQAAAAAEKwIuAAAELiYtKgEtLCoBHyskAAQDLQwABCYtLyEAFU8ALzoBAAAAAAQrAi8AAAQvJi0qAS0uAAAHLC4rJAAEBC4MAAQmLi8hABVXAC86AQAAKwAAKggDJQAEAAUIBCIAABzwKwAIBQAsAAAELAIvAAAELyYuKgIrLioCLBogFWAAAAQmDyoOAAQmKishABVkACs6AQAAKgAqJiAFaiQABAErDAAEJissIQAVagAsOgEAAAAABBMCLAAABCwmKyoBKyoqARgsCgABLAorIQAVcQArOgEAACoBGSwKAAQsDishABWNACsgFXUqAR8rKgEZLCoBGS0kAAQDLwwABC0vMCEAFXwAMDoBAAArAAArCAMlAAQABAgEIgAAHPArAAgFAC4AAAQuAjAAAAQwLS8qAiovKgEuKgAABCoCKioCKi4AAAQsDyoOAAQsKi0hABWKAC06AQAAKgIuHyoCKhkgFbYqAAgrIBWPDAAEKw4sIQAVvAAsIBWSKgEfKyoBGiwqAAAtJAAEBS4AAAQALgAkAQQBLQAABCwCLiQABAQvAAAELQIwPgMAAAAuAAAAMCoBKywCAAQsAiwqAiwrKgErLAAABCwCLCoCLCsqAS0sAAAELAIsKgIsLSsAACsIAyUABAAECAQiAAAc8CsACAUALAAABCwCMAAABDAILyoCKi8qASwqAAAEKgIqKgIqLCoBLSoAAAQqAioqAiotKgIsHyoCLRoqAg8ZIBW2AAAEJg8qDgAEJiorIQAVugArOgEAACoAKiYgBWEqARksDAAEKywtIQAVwAAtIBXfKgEaLCoBGi0kAAQELwwABCsvMCEAFcYAMDoBAAAAAAQtAjAAAAQwKy8qAS8uKgEfLSQABAMvDAAEKy8xIQAVzgAxOgEAAAAABC0CMQAABDErLyoBLzAAAAcuMC0kAAQELgwABCsuMSEAFdYAMToBAAArAAAsCAMlAAQABQgEIgAAHPArAAgFADAAAAQwAjEAAAQxKy4qAi0uKgIwGiAV3wAABCsPLA4ABCssLSEAFeMALToBAAAqACwrIBWPHAAHJioAAAcfKisqAAAqJAAEBCwAAAQALAAkAQQBKgAABCoCLCoALC0qAhgtAAAELQItKgIaLQAABC0CLSoCGS0kAAQDLQwABCYtLiEAFfYALjoBAAAAAAQqAi4AAAQuJi0qAS0sLQAAAAAsAAAAKwAABCYPKw4ABCYrLCEAFf4ALDoBAAAqACsmIAU7KgEZKgwABCYqKyEAFgQAKyAWIyoBGioqARorJAAEBC0MAAQmLS4hABYKAC46AQAAAAAEKwIuAAAELiYtKgEtLCoBGCskAAQDLQwABCYtLyEAFhIALzoBAAAAAAQrAi8AAAQvJi0qAS0uAAAHLC4rJAAEBCwMAAQmLC8hABYaAC86AQAAKwAAKggDJQAEAAUIBCIAABzwKwAIBQAuAAAELgIvAAAELyYsKgIrLCoCLhogFiMAAAQmDyoOAAQmKishABYnACs6AQAAKgAqJiAFJSQABAErDAAEJissIQAWLQAsOgEAAAAABBMCLAAABCwmKyoBKyoqAR8sCgABLAorIQAWNAArOgEAACoBGSwKAAQsDishABZQACsgFjgqARgrKgEZLCoBGS0kAAQDLwwABC0vMCEAFj8AMDoBAAArAAArCAMlAAQABAgEIgAAHPArAAgFAC4AAAQuAjAAAAQwLS8qAiovKgEuLQAABC0CLSoCLS4AAAQsDy0OAAQsLSshABZNACs6AQAAKgIuGCoCLRkgFnkqAAgrIBZSDAAEKw4sIQAWfwAsIBZVKgEYKyoBGiwqAAAtJAAEBS4AAAQALgAkAQQBLQAABCwCLiQABAQvAAAELQIwPgMAAAAuAAAAMCoBKywCAAQsAiwqAiwrKgErLAAABCwCLCoCLCsqAS0sAAAELAIsKgIsLSsAACsIAyUABAAECAQiAAAc8CsACAUALAAABCwCMAAABDAILyoCKi8qASwqAAAEKgIqKgIqLCoBLSoAAAQqAioqAiotKgIsGCoCLRoqAg8ZIBZ5AAAEJg8qDgAEJiorIQAWfQArOgEAACoAKiYgBRwqARksDAAEKywtIQAWgwAtIBaiKgEaLCoBGi0kAAQELwwABCsvMCEAFokAMDoBAAAAAAQtAjAAAAQwKy8qAS8uKgEYLSQABAMvDAAEKy8xIQAWkQAxOgEAAAAABC0CMQAABDErLyoBLzAAAAcuMC0kAAQEMAwABCswMSEAFpkAMToBAAArAAAsCAMlAAQABQgEIgAAHPArAAgFAC4AAAQuAjEAAAQxKzAqAi0wKgIuGiAWogAABCsPLA4ABCssLSEAFqYALToBAAAqACwrIBZSKgEbHxwAByAeAAAHIR4jLAAAAAAjAAAAHiQABAEkDAAEICQlIQAWsAAlOgEAACsAAB8IAyUABAACCAQiAAAc8CsACAUAIwAABCMCJQAABCUgJCoCHiQAAAQgDx8OAAQgHx4hABa7AB46AQAAKgIjGyoAHyAgBIgqASAjDAAEGyMkIQAWwgAkIBbhKgEfIyoBHyQkAAQEJgwABBsmJyEAFsgAJzoBAAAAAAQkAicAAAQnGyYqASYlKgEeJCQABAMmDAAEGyYoIQAW0AAoOgEAAAAABCQCKAAABCgbJioBJicAAAclJyQkAAQEJwwABBsnKCEAFtgAKDoBAAArAAAjCAMlAAQABQgEIgAAHPArAAgFACUAAAQlAigAAAQoGycqAiQnKgIlHyAW4QAABBsPIw4ABBsjJCEAFuUAJDoBAAAqACMbIARvJAAEASQMAAQbJCUhABbrACU6AQAAAAAEEwIlAAAEJRskKgEkIyoBISUKAAElCiQhABbyACQ6AQAAKgEgJQoABCUOJCEAFw4AJCAW9ioBHiQqASAlKgEgJiQABAMoDAAEJigpIQAW/QApOgEAACsAACQIAyUABAAECAQiAAAc8CsACAUAJwAABCcCKQAABCkmKCoCIygqAScjAAAEIwIjKgIjJwAABCUPIw4ABCUjJiEAFwsAJjoBAAAqAiceKgIjICAXNyoACCQgFxAMAAQkDiUhABc9ACUgFxMqAR4kKgEfJSoAACYkAAQFJwAABAAnACQBBAEmAAAEJQInJAAEBCgAAAQmAik+AwAAACcAAAApKgEkJQIABCUCJSoCJSQqASQlAAAEJQIlKgIlJCoBJiUAAAQlAiUqAiUmKwAAJAgDJQAEAAQIBCIAABzwKwAIBQAlAAAEJQIpAAAEKQgoKgIjKCoBJSQAAAQkAiQqAiQlKgEmJAAABCQCJCoCJCYqAiUeKgImHyoCDyAgFzcAAAQbDyMOAAQbIyQhABc7ACQ6AQAAKgAjGyAEZioBICUMAAQkJSYhABdBACYgF2AqAR8lKgEfJiQABAQoDAAEJCgpIQAXRwApOgEAAAAABCYCKQAABCkkKCoBKCcqAR4mJAAEAygMAAQkKCohABdPACo6AQAAAAAEJgIqAAAEKiQoKgEoKQAABycpJiQABAQpDAAEJCkqIQAXVwAqOgEAACsAACUIAyUABAAFCAQiAAAc8CsACAUAJwAABCcCKgAABCokKSoCJikqAicfIBdgAAAEJA8lDgAEJCUmIQAXZAAmOgEAACoAJSQgFxAqARobHAAHHhkAAAcfGRgsAAAAABgAAAAZJAAEAyAMAAQeICEhABduACE6AQAAKwAAGwgDJQAEAAQIBCIAABzwKwAIBQAYAAAEGAIhAAAEIR4gKgIZIAAABB4PGw4ABB4bGSEAF3kAGToBAAAqAhgaKgAbHiAEGSoBGhsMAAQeGyAhABeAACAgF58qARgbKgEYICQABAQiDAAEHiIjIQAXhgAjOgEAAAAABCACIwAABCMeIioBIiEqARkgJAAEAyIMAAQeIiQhABeOACQ6AQAAAAAEIAIkAAAEJB4iKgEiIwAAByEjICQABAQjDAAEHiMkIQAXlgAkOgEAACsAABsIAyUABAAFCAQiAAAc8CsACAUAIQAABCECJAAABCQeIyoCICMqAiEYIBefAAAEHg8bDgAEHhsgIQAXowAgOgEAACoAGx4gBAAkAAQBIAwABBsgISEAF6kAIToBAAAAAAQTAiEAAAQhGyAqASAeKgEfEwoAARMKISEAF7AAIToBAAAqARoTCgAEEw4hIQAXzAAhIBe0KgEZEyoBGiAqARohJAAEAyMMAAQhIyQhABe7ACQ6AQAAKwAAEwgDJQAEAAQIBCIAABzwKwAIBQAiAAAEIgIkAAAEJCEjKgIeIyoBIh4AAAQeAh4qAh4iAAAEIA8eDgAEIB4hIQAXyQAhOgEAACoCIhkqAh4aIBf1KgAIEyAXzgwABBMOICEAF/sAICAX0SoBGRMqARggKgAAISQABAUiAAAEACIAJAEEASEAAAQgAiIkAAQEIwAABCECJD4DAAAAIgAAACQqARMgAgAEIAIgKgIgEyoBEyAAAAQgAiAqAiATKgEhIAAABCACICoCICErAAATCAMlAAQABAgEIgAAHPArAAgFACAAAAQgAiQAAAQkCCMqAh4jKgEgHgAABB4CHioCHiAqASEeAAAEHgIeKgIeISoCIBkqAiEYKgIPGiAX9QAABBsPHg4ABBseEyEAF/kAEzoBAAAqAB4bIAPwKgEaIAwABBMgISEAF/8AISAYHioBGCAqARghJAAEBCMMAAQTIyQhABgFACQ6AQAAAAAEIQIkAAAEJBMjKgEjIioBGSEkAAQDIwwABBMjJSEAGA0AJToBAAAAAAQhAiUAAAQlEyMqASMkAAAHIiQhJAAEBCIMAAQTIiUhABgVACU6AQAAKwAAIAgDJQAEAAUIBCIAABzwKwAIBQAkAAAEJAIlAAAEJRMiKgIhIioCJBggGB4AAAQTDyAOAAQTICEhABgiACE6AQAAKgAgEyAXzioBExoMAAQbGh4hABgoAB4gGEcqARgaKgEYHiQABAQgDAAEGyAhIQAYLgAhOgEAAAAABB4CIQAABCEbICoBIB8qARkeJAAEAyAMAAQbICIhABg2ACI6AQAAAAAEHgIiAAAEIhsgKgEgIQAABx8hHiQABAQfDAAEGx8iIQAYPgAiOgEAACsAABoIAyUABAAFCAQiAAAc8CsACAUAIQAABCECIgAABCIbHyoCHh8qAiEYIBhHAAAEGw8aDgAEGxoeIQAYSwAeOgEAACoAGhsgA6YMAAQaBh4hABhQAB4gGKkqAAAeJAAEAx8AAAQAHwAkAQQBHgAABB4CHyoAHyAqAhUgAAAEIAIgKgIbICQABAIgDAAEGiAhIQAYXQAhOgEAAAAABB4CIQAABCEaICoBIB8qAR0eCgABHgohIQAYZAAhOgEAACoBEx4KAAQeDiEhABiAACEgGGgqARkeKgETICoBEyEkAAQDIwwABCEjJCEAGG8AJDoBAAArAAAeCAMlAAQABAgEIgAAHPArAAgFACIAAAQiAiQAAAQkISMqAh8jKgEiHwAABB8CHyoCHyIAAAQgDx8OAAQgHyEhABh9ACE6AQAAKgIiGSoCHxMgGKkqAAgeIBiCDAAEHg4gIQAYrwAgIBiFKgEZHioBGCAqAAAhJAAEBSIAAAQAIgAkAQQBIQAABCACIiQABAQjAAAEIQIkPgMAAAAiAAAAJCoBHiACAAQgAiAqAiAeKgEeIAAABCACICoCIB4qASEgAAAEIAIgKgIgISsAAB4IAyUABAAECAQiAAAc8CsACAUAIAAABCACJAAABCQIIyoCHyMqASAeAAAEHgIeKgIeICoBIR4AAAQeAh4qAh4hKgIgGSoCIRgqAg8TIBipAAAEGg8eDgAEGh4fIQAYrQAfOgEAACoAHhogA50qARMgDAAEHiAhIQAYswAhIBjSKgEYICoBGCEkAAQEIwwABB4jJCEAGLkAJDoBAAAAAAQhAiQAAAQkHiMqASMiKgEZISQABAMjDAAEHiMlIQAYwQAlOgEAAAAABCECJQAABCUeIyoBIyQAAAciJCEkAAQEJAwABB4kJSEAGMkAJToBAAArAAAgCAMlAAQABQgEIgAAHPArAAgFACIAAAQiAiUAAAQlHiQqAiEkKgIiGCAY0gAABB4PIA4ABB4gISEAGNYAIToBAAAqACAeIBiCHAAHIB8AAAchHxoqAAAfJAAEBRkAAAQAGQAkAQQBHwAABB8CGSoAGRgqAhsYAAAEGAIYKgIdGAAABBgCGCoCHhgAAAQYAhgqAhMYJAAEBBgMAAQgGCIhABjrACI6AQAAAAAEHwIiAAAEIiAYKgEYGS0AAAAAGQAAABoAAAQgDxkOAAQgGRohABjzABo6AQAAKgAZICADfSoBIBkMAAQaGSIhABj5ACIgGRgqAR8ZKgEfIiQABAQkDAAEGiQlIQAY/wAlOgEAAAAABCICJQAABCUaJCoBJCMqARgiJAAEAyQMAAQaJCYhABkHACY6AQAAAAAEIgImAAAEJhokKgEkJQAAByMlIiQABAQjDAAEGiMmIQAZDwAmOgEAACsAABkIAyUABAAFCAQiAAAc8CsACAUAJQAABCUCJgAABCYaIyoCIiMqAiUfIBkYAAAEGg8ZDgAEGhkiIQAZHAAiOgEAACoAGRogA2YMAAQaBiIhABkhACIgGXoqAAAiJAAEAyMAAAQAIwAkAQQBIgAABCICIyoAIyQqAhYkAAAEJAIkKgIZJCQABAIkDAAEGiQlIQAZLgAlOgEAAAAABCICJQAABCUaJCoBJCMqASEiCgABIgolIQAZNQAlOgEAACoBICIKAAQiDiUhABlRACUgGTkqARgiKgEgJCoBICUkAAQDJwwABCUnKCEAGUAAKDoBAAArAAAiCAMlAAQABAgEIgAAHPArAAgFACYAAAQmAigAAAQoJScqAiMnKgEmIwAABCMCIyoCIyYAAAQkDyMOAAQkIyUhABlOACU6AQAAKgImGCoCIyAgGXoqAAgiIBlTDAAEIg4kIQAZgAAkIBlWKgEYIioBHyQqAAAlJAAEBSYAAAQAJgAkAQQBJQAABCQCJiQABAQnAAAEJQIoPgMAAAAmAAAAKCoBIiQCAAQkAiQqAiQiKgEiJAAABCQCJCoCJCIqASUkAAAEJAIkKgIkJSsAACIIAyUABAAECAQiAAAc8CsACAUAJAAABCQCKAAABCgIJyoCIycqASQiAAAEIgIiKgIiJCoBJSIAAAQiAiIqAiIlKgIkGCoCJR8qAg8gIBl6AAAEGg8iDgAEGiIjIQAZfgAjOgEAACoAIhogA10qASAkDAAEIiQlIQAZhAAlIBmjKgEfJCoBHyUkAAQEJwwABCInKCEAGYoAKDoBAAAAAAQlAigAAAQoIicqAScmKgEYJSQABAMnDAAEIicpIQAZkgApOgEAAAAABCUCKQAABCkiJyoBJygAAAcmKCUkAAQEKAwABCIoKSEAGZoAKToBAAArAAAkCAMlAAQABQgEIgAAHPArAAgFACYAAAQmAikAAAQpIigqAiUoKgImHyAZowAABCIPJA4ABCIkJSEAGacAJToBAAAqACQiIBlTKgEYHBwABx8ZAAAHIBkhLAAAAAAhAAAAGSQABAMiDAAEHyIjIQAZsQAjOgEAACsAABwIAyUABAAECAQiAAAc8CsACAUAIQAABCECIwAABCMfIioCGSIAAAQfDxwOAAQfHBkhABm8ABk6AQAAKgIhGCoAHB8gAyIqAR8hDAAEHCEiIQAZwwAiIBniKgEZISoBGSIkAAQEJAwABBwkJSEAGckAJToBAAAAAAQiAiUAAAQlHCQqASQjKgEYIiQABAMkDAAEHCQmIQAZ0QAmOgEAAAAABCICJgAABCYcJCoBJCUAAAcjJSIkAAQEJQwABBwlJiEAGdkAJjoBAAArAAAhCAMlAAQABQgEIgAAHPArAAgFACMAAAQjAiYAAAQmHCUqAiIlKgIjGSAZ4gAABBwPIQ4ABBwhIiEAGeYAIjoBAAAqACEcIAMJJAAEASIMAAQcIiMhABnsACM6AQAAAAAEFAIjAAAEIxwiKgEiISoBICMKAAEjCiIhABnzACI6AQAAKgEfIwoABCMOIiEAGg8AIiAZ9yoBGCIqAR8jKgEfJCQABAMmDAAEJCYnIQAZ/gAnOgEAACsAACIIAyUABAAECAQiAAAc8CsACAUAJQAABCUCJwAABCckJioCISYqASUhAAAEIQIhKgIhJQAABCMPIQ4ABCMhJCEAGgwAJDoBAAAqAiUYKgIhHyAaOCoACCIgGhEMAAQiDiMhABo+ACMgGhQqARgiKgEZIyoAACQkAAQFJQAABAAlACQBBAEkAAAEIwIlJAAEBCYAAAQkAic+AwAAACUAAAAnKgEiIwIABCMCIyoCIyIqASIjAAAEIwIjKgIjIioBJCMAAAQjAiMqAiMkKwAAIggDJQAEAAQIBCIAABzwKwAIBQAjAAAEIwInAAAEJwgmKgIhJioBIyIAAAQiAiIqAiIjKgEkIgAABCICIioCIiQqAiMYKgIkGSoCDx8gGjgAAAQcDyEOAAQcISIhABo8ACI6AQAAKgAhHCADACoBHyMMAAQiIyQhABpCACQgGmEqARkjKgEZJCQABAQmDAAEIiYnIQAaSAAnOgEAAAAABCQCJwAABCciJioBJiUqARgkJAAEAyYMAAQiJighABpQACg6AQAAAAAEJAIoAAAEKCImKgEmJwAAByUnJCQABAQnDAAEIicoIQAaWAAoOgEAACsAACMIAyUABAAFCAQiAAAc8CsACAUAJQAABCUCKAAABCgiJyoCJCcqAiUZIBphAAAEIg8jDgAEIiMkIQAaZQAkOgEAACoAIyIgGhEqARgcHAAHGRoAAAcNGh8sAAAAAB8AAAAaJAAEASAMAAQZICEhABpvACE6AQAAKwAAHAgDJQAEAAIIBCIAABzwKwAIBQAfAAAEHwIhAAAEIRkgKgIaIAAABBkPHA4ABBkcGiEAGnoAGjoBAAAqAh8YKgAcGSACvCoBHBMqARkfKgEaIAAABCAYIQ4ABCAhIiEAGoQAIjoBAAAkAAQEIgwABCEiIyEAGogAIzoBAAAAAAQfAiMAAAQjISIqASIgJAAEASEMAAQYISMhABqPACM6AQAAKwAAEwgDJQAEAAIIBCIAABzwKwAIBQAfAAAEHwIjAAAEIxghKgIgIQAABBgPIA4ABBggEyEAGpoAEzoBAAAqAh8cKgAgGCACnCoBHBMqARkeKgEaHwAABB8YIA4ABB8gISEAGqQAIToBAAAkAAQEIQwABCAhIiEAGqgAIjoBAAAAAAQeAiIAAAQiICEqASEfJAAEASAMAAQYICIhABqvACI6AQAAKwAAEwgDJQAEAAIIBCIAABzwKwAIBQAeAAAEHgIiAAAEIhggKgIfIAAABBgPHw4ABBgfEyEAGroAEzoBAAAqAh4cKgAfGCACgioBHBMqARkdKgEaHgAABB4YHw4ABB4fICEAGsQAIDoBAAAkAAQEIAwABB8gISEAGsgAIToBAAAAAAQdAiEAAAQhHyAqASAeJAAEAR8MAAQYHyEhABrPACE6AQAAKwAAEwgDJQAEAAIIBCIAABzwKwAIBQAdAAAEHQIhAAAEIRgfKgIeHwAABBgPHg4ABBgeEyEAGtoAEzoBAAAqAh0cKgAeGCACaCoBGxgqARkcKgEaHQAABB0THg4ABB0eHyEAGuQAHzoBAAAkAAQEHwwABB4fICEAGugAIDoBAAAAAAQcAiAAAAQgHh8qAR8dJAAEAR4MAAQTHiAhABrvACA6AQAAKwAAGAgDJQAEAAIIBCIAABzwKwAIBQAcAAAEHAIgAAAEIBMeKgIdHgAABBMPHQ4ABBMdGCEAGvoAGDoBAAAqAhwbKgAdEyACUCoBFRQcAAcSEwAABw0TFiwAAAAAFgAAABMkAAQBFwwABBIXGCEAGwUAGDoBAAArAAAUCAMlAAQAAggEIgAAHPArAAgFABYAAAQWAhgAAAQYEhcqAhMXAAAEEg8UDgAEEhQTIQAbEAATOgEAACoCFhUqABQSIAIJHAAHFRQAAAcNFBMqAAAUJAAEAhIAAAQAEgAkAQQBFAAABBQCEioAEhcqAhYXJAAEARcMAAQVFxghABsgABg6AQAAAAAEFAIYAAAEGBUXKgEXEi0AAAAAEgAAABMAAAQVDxIOAAQVEhMhABsoABM6AQAAKgASFSAB7SoBExUcAAcUEgAABw0SFywAAAAAFwAAABIkAAQBGAwABBQYGSEAGzIAGToBAAArAAAVCAMlAAQAAggEIgAAHPArAAgFABcAAAQXAhkAAAQZFBgqAhIYAAAEFA8VDgAEFBUSIQAbPQASOgEAACoCFxMqABUUIAHgKgEWEyoBFBcqARUYAAAEGBIZDgAEGBkaIQAbRwAaOgEAACQABAEaDAAEGRobIQAbSwAbOgEAAAAABBcCGwAABBsZGioBGhgkAAQBGQwABBIZGyEAG1IAGzoBAAArAAATCAMlAAQAAggEIgAAHPArAAgFABcAAAQXAhsAAAQbEhkqAhgZAAAEEg8YDgAEEhgTIQAbXQATOgEAACoCFxYqABgSIAHCHAAHFhQAAAcNFBMqAAAUJAAEAhIAAAQAEgAkAQQBFAAABBQCEioAEgUqAhUFJAAEAQUMAAQWBRchABttABc6AQAAAAAEFAIXAAAEFxYFKgEFEi0AAAAAEgAAABMAAAQWDxIOAAQWEhMhABt1ABM6AQAAKgASFiABmCoBFhIMAAQTEhohABt7ABogG5oqARQSKgEUGiQABAQcDAAEExwdIQAbgQAdOgEAAAAABBoCHQAABB0THCoBHBsqARkaJAAEAxwMAAQTHB4hABuJAB46AQAAAAAEGgIeAAAEHhMcKgEcHQAABxsdGiQABAQbDAAEExseIQAbkQAeOgEAACsAABIIAyUABAAFCAQiAAAc8CsACAUAHQAABB0CHgAABB4TGyoCGhsqAh0UIBuaAAAEEw8SDgAEExIaIQAbngAaOgEAACoAEhMgAXgqAAAbJAAEAxoAAAQAGgAkAQQBGwAABBsCGioAGhIqAhMSAAAEEgISKgIdEiQABAISDAAEHBIeIQAbrQAeOgEAAAAABBsCHgAABB4cEioBEhoqARgbCgABGwoeIQAbtAAeOgEAACoBFhsKAAQbDh4hABvQAB4gG7gqARkbKgEWEioBFh4kAAQDIAwABB4gISEAG78AIToBAAArAAAbCAMlAAQABAgEIgAAHPArAAgFAB8AAAQfAiEAAAQhHiAqAhogKgEfGwAABBsCGyoCGx8AAAQSDxsOAAQSGxohABvNABo6AQAAKgIfGSoCGxYgG/kqAAgbIBvSDAAEGw4SIQAb/wASIBvVKgEZGyoBFBIqAAAeJAAEBR8AAAQAHwAkAQQBHgAABBICHyQABAQgAAAEHgIhPgMAAAAfAAAAISoBGxICAAQSAhIqAhIbKgEbEgAABBICEioCEhsqAR4SAAAEEgISKgISHisAABsIAyUABAAECAQiAAAc8CsACAUAEgAABBICIQAABCEIICoCGiAqARIaAAAEGgIaKgIaEioBHhoAAAQaAhoqAhoeKgISGSoCHhQqAg8WIBv5AAAEHA8bDgAEHBsaIQAb/QAaOgEAACoAGxwgAW8qARYSDAAEGxIeIQAcAwAeIBwiKgEUEioBFB4kAAQEIAwABBsgISEAHAkAIToBAAAAAAQeAiEAAAQhGyAqASAfKgEZHiQABAMgDAAEGyAiIQAcEQAiOgEAAAAABB4CIgAABCIbICoBICEAAAcfIR4kAAQEHwwABBsfIiEAHBkAIjoBAAArAAASCAMlAAQABQgEIgAAHPArAAgFACEAAAQhAiIAAAQiGx8qAh4fKgIhFCAcIgAABBsPEg4ABBsSHiEAHCYAHjoBAAAqABIbIBvSKgEcGAwABBkYFiEAHCwAFiAcSyoBGxgqARsWJAAEBBIMAAQZEh4hABwyAB46AQAAAAAEFgIeAAAEHhkSKgESFCoBGhYkAAQDEgwABBkSHyEAHDoAHzoBAAAAAAQWAh8AAAQfGRIqARIeAAAHFB4WJAAEBB4MAAQZHh8hABxCAB86AQAAKwAAGAgDJQAEAAUIBCIAABzwKwAIBQAUAAAEFAIfAAAEHxkeKgIWHioCFBsgHEsAAAQZDxgOAAQZGBYhABxPABY6AQAAKgAYGSABISQABAEWDAAEFBYSIQAcVQASOgEAAAAABBkCEgAABBIUFioBFhgqAR0SCgABEgoWIQAcXAAWOgEAACoBHBIKAAQSDhYhABx4ABYgHGAqARoWKgEcEioBHB4kAAQDIAwABB4gISEAHGcAIToBAAArAAAWCAMlAAQABAgEIgAAHPArAAgFAB8AAAQfAiEAAAQhHiAqAhggKgEfGAAABBgCGCoCGB8AAAQSDxgOAAQSGB4hABx1AB46AQAAKgIfGioCGBwgHKEqAAgWIBx6DAAEFg4SIQAcpwASIBx9KgEaFioBGxIqAAAeJAAEBR8AAAQAHwAkAQQBHgAABBICHyQABAQgAAAEHgIhPgMAAAAfAAAAISoBFhICAAQSAhIqAhIWKgEWEgAABBICEioCEhYqAR4SAAAEEgISKgISHisAABYIAyUABAAECAQiAAAc8CsACAUAEgAABBICIQAABCEIICoCGCAqARIWAAAEFgIWKgIWEioBHhYAAAQWAhYqAhYeKgISGioCHhsqAg8cIByhAAAEFA8YDgAEFBgWIQAcpQAWOgEAACoAGBQgARgqARwSDAAEFhIeIQAcqwAeIBzKKgEbEioBGx4kAAQEIAwABBYgISEAHLEAIToBAAAAAAQeAiEAAAQhFiAqASAfKgEaHiQABAMgDAAEFiAiIQAcuQAiOgEAAAAABB4CIgAABCIWICoBICEAAAcfIR4kAAQEIQwABBYhIiEAHMEAIjoBAAArAAASCAMlAAQABQgEIgAAHPArAAgFAB8AAAQfAiIAAAQiFiEqAh4hKgIfGyAcygAABBYPEg4ABBYSHiEAHM4AHjoBAAAqABIWIBx6KgEVEioBExYqARQXAAAEFwUYDgAEFxgZIQAc1wAZOgEAACQABAEZDAAEGBkaIQAc2wAaOgEAAAAABBYCGgAABBoYGSoBGRckAAQBGAwABAUYGiEAHOIAGjoBAAArAAASCAMlAAQAAggEIgAAHPArAAgFABYAAAQWAhoAAAQaBRgqAhcYAAAEBQ8XDgAEBRcSIQAc7QASOgEAACoCFhUqABcFIABLKwEIAwgGCwAECAYAAggHIQAc9AgHIBz2KwAIAwgFIB0EKwAAAAgFAQAEAAAIBAAAJQAEAAAICQ0ABAgJCAQIChcACAoICiEAHQIICgEABAgDCAkICysBCAsICAEABAgFCAkICysCCAgICwEABAgJAAIICSAc+SUBBAABCAUgHQQjJQAEAAAIBw0ABAgHCAUICBcACAgICCEAHQ8ICAEABAgDCAcICSsBCAkIBgEABAgECAcICSsCCAYICQEABAgHAAIIByAdBiMrABjKGMo=",
      "debug_symbols": "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",
      "brillig_names": ["public_dispatch"],
      "assert_messages": {
        "512": "Function get_admin_public can only be called statically",
        "890": "Storage slot 0 not allowed. Storage slots must start from 1.",
        "3450": "attempt to add with overflow",
        "4474": "Array index out of bounds",
        "6254": "Array index out of bounds",
        "6766": "Array index out of bounds",
        "3048": "attempt to add with overflow",
        "3560": "attempt to add with overflow",
        "3938": "Array index out of bounds",
        "4962": "Array index out of bounds",
        "5797": "attempt to add with overflow",
        "6553": "Array index out of bounds",
        "5206": "attempt to add with overflow",
        "4371": "Array index out of bounds",
        "6608": "Array index out of bounds",
        "6986": "Array index out of bounds",
        "5694": "Array index out of bounds",
        "5048": "Array index out of bounds",
        "5426": "Array index out of bounds",
        "6316": "attempt to add with overflow",
        "5481": "Array index out of bounds",
        "5670": "attempt to add with overflow",
        "4835": "Array index out of bounds",
        "6883": "attempt to add with overflow",
        "3165": "Array index out of bounds",
        "471": "Not initialized",
        "4244": "Array index out of bounds",
        "4756": "Array index out of bounds",
        "6993": "Array index out of bounds",
        "203": "attempt to add with overflow",
        "1416": "attempt to add with overflow",
        "7048": "Array index out of bounds",
        "3330": "Array index out of bounds",
        "3196": "Array index out of bounds",
        "2361": "Function get_service can only be called statically",
        "1526": "attempt to add with overflow",
        "691": "Not initialized",
        "5756": "attempt to add with overflow",
        "6189": "Array index out of bounds",
        "5866": "Array index out of bounds",
        "6268": "attempt to add with overflow",
        "4196": "Array index out of bounds",
        "6378": "Array index out of bounds",
        "4574": "Array index out of bounds",
        "2203": "attempt to add with overflow",
        "6756": "attempt to add with overflow",
        "4629": "Array index out of bounds",
        "5708": "attempt to add with overflow",
        "3337": "Array index out of bounds",
        "3526": "Array index out of bounds",
        "6787": "attempt to add with overflow",
        "3581": "Array index out of bounds",
        "4605": "Array index out of bounds",
        "5629": "attempt to add with overflow",
        "2100": "attempt to add with overflow",
        "3124": "Array index out of bounds",
        "2990": "Array index out of bounds",
        "5818": "attempt to add with overflow",
        "6653": "Array index out of bounds",
        "4069": "Array index out of bounds",
        "6629": "attempt to add with overflow",
        "4447": "Array index out of bounds",
        "5148": "Array index out of bounds",
        "1241": "attempt to add with overflow",
        "6873": "attempt to add with overflow",
        "5581": "Array index out of bounds",
        "2186": "attempt to multiply with overflow",
        "3399": "Array index out of bounds",
        "6148": "Array index out of bounds",
        "4990": "Array index out of bounds",
        "6715": "attempt to add with overflow",
        "3296": "Array index out of bounds",
        "3808": "Array index out of bounds",
        "7069": "attempt to add with overflow",
        "5454": "Array index out of bounds",
        "5966": "Array index out of bounds",
        "6344": "Array index out of bounds",
        "6021": "Array index out of bounds",
        "6667": "attempt to add with overflow",
        "6777": "attempt to add with overflow",
        "4595": "attempt to add with overflow",
        "7344": "Array index out of bounds",
        "5997": "Array index out of bounds",
        "6887": "Array index out of bounds",
        "4004": "attempt to add with overflow",
        "5784": "Array index out of bounds",
        "3602": "attempt to add with overflow",
        "5839": "Array index out of bounds",
        "4492": "Array index out of bounds",
        "3846": "Array index out of bounds",
        "5382": "Array index out of bounds",
        "3712": "Array index out of bounds",
        "4224": "Array index out of bounds",
        "6406": "Array index out of bounds",
        "4279": "Array index out of bounds",
        "2420": "Storage slot 0 not allowed. Storage slots must start from 1.",
        "4468": "attempt to add with overflow",
        "5169": "attempt to add with overflow",
        "6894": "Array index out of bounds",
        "5224": "Array index out of bounds",
        "2341": "attempt to add with overflow",
        "5602": "attempt to add with overflow",
        "7028": "attempt to add with overflow",
        "7004": "attempt to add with overflow",
        "5657": "Array index out of bounds",
        "7217": "Array index out of bounds",
        "7382": "attempt to add with overflow",
        "4554": "attempt to add with overflow",
        "5066": "Array index out of bounds",
        "5255": "Array index out of bounds",
        "6791": "Array index out of bounds",
        "5499": "Array index out of bounds",
        "2104": "attempt to add with overflow",
        "3317": "attempt to add with overflow",
        "4664": "Array index out of bounds",
        "623": "attempt to add with overflow",
        "5176": "attempt to add with overflow",
        "5231": "Array index out of bounds",
        "3750": "attempt to add with overflow",
        "5475": "attempt to add with overflow",
        "5987": "attempt to add with overflow",
        "4506": "attempt to add with overflow",
        "599": "attempt to add with overflow",
        "3348": "attempt to add with overflow",
        "5018": "Array index out of bounds",
        "3214": "Array index out of bounds",
        "4427": "attempt to add with overflow",
        "4616": "attempt to add with overflow",
        "5128": "attempt to add with overflow",
        "6743": "Array index out of bounds",
        "6798": "Array index out of bounds",
        "5884": "Array index out of bounds",
        "2489": "Not initialized",
        "5561": "attempt to add with overflow",
        "7176": "Array index out of bounds",
        "3946": "Array index out of bounds",
        "2087": "attempt to multiply with overflow",
        "5860": "attempt to add with overflow",
        "4379": "Array index out of bounds",
        "5080": "attempt to add with overflow",
        "6427": "attempt to add with overflow",
        "4946": "Array index out of bounds",
        "6616": "Array index out of bounds",
        "3276": "attempt to add with overflow",
        "3788": "Array index out of bounds",
        "5513": "attempt to add with overflow",
        "6537": "Array index out of bounds",
        "1850": "call to assert_max_bit_size",
        "5434": "attempt to add with overflow",
        "5946": "attempt to add with overflow",
        "6056": "Array index out of bounds",
        "3228": "attempt to add with overflow",
        "4252": "Array index out of bounds",
        "4764": "Array index out of bounds",
        "4819": "Array index out of bounds",
        "1424": "attempt to add with overflow",
        "3149": "Array index out of bounds",
        "5898": "attempt to add with overflow",
        "7056": "Array index out of bounds",
        "1534": "attempt to add with overflow",
        "4795": "Array index out of bounds",
        "6008": "attempt to add with overflow",
        "6197": "Array index out of bounds",
        "6386": "attempt to add with overflow",
        "5039": "attempt to add with overflow",
        "4582": "Array index out of bounds",
        "675": "attempt to add with overflow",
        "6819": "attempt to add with overflow",
        "4637": "Array index out of bounds",
        "7386": "Array index out of bounds",
        "4180": "Array index out of bounds",
        "7252": "Array index out of bounds",
        "3589": "Array index out of bounds",
        "3967": "attempt to add with overflow",
        "6905": "attempt to add with overflow",
        "3510": "Array index out of bounds",
        "1651": "attempt to add with overflow",
        "4022": "Array index out of bounds",
        "4400": "attempt to add with overflow",
        "3754": "Array index out of bounds",
        "4455": "Array index out of bounds",
        "5156": "Array index out of bounds",
        "3108": "Array index out of bounds",
        "3620": "Array index out of bounds",
        "2974": "Array index out of bounds",
        "3864": "Array index out of bounds",
        "4053": "Array index out of bounds",
        "5290": "Array index out of bounds",
        "5589": "Array index out of bounds",
        "6156": "Array index out of bounds",
        "4297": "Array index out of bounds",
        "4998": "attempt to add with overflow",
        "5187": "Array index out of bounds",
        "2950": "Array index out of bounds",
        "2493": "Function get_total_services can only be called statically",
        "4029": "Array index out of bounds",
        "3383": "Array index out of bounds",
        "3974": "attempt to add with overflow",
        "3761": "Array index out of bounds",
        "4273": "attempt to add with overflow",
        "4785": "attempt to add with overflow",
        "3304": "Array index out of bounds",
        "3816": "Array index out of bounds",
        "5242": "attempt to add with overflow",
        "3359": "Array index out of bounds",
        "6943": "Array index out of bounds",
        "6809": "attempt to add with overflow",
        "3926": "attempt to add with overflow",
        "5462": "Array index out of bounds",
        "5974": "Array index out of bounds",
        "6029": "Array index out of bounds",
        "4682": "Array index out of bounds",
        "4359": "attempt to add with overflow",
        "5194": "Array index out of bounds",
        "6218": "attempt to add with overflow",
        "6328": "Array index out of bounds",
        "7352": "Array index out of bounds",
        "4658": "attempt to add with overflow",
        "7084": "Array index out of bounds",
        "2665": "attempt to add with overflow",
        "3878": "attempt to add with overflow",
        "4311": "attempt to add with overflow",
        "1428": "attempt to add with overflow",
        "5847": "Array index out of bounds",
        "5390": "Array index out of bounds",
        "6414": "Array index out of bounds",
        "3720": "Array index out of bounds",
        "4232": "attempt to add with overflow",
        "1538": "attempt to add with overflow",
        "4744": "attempt to add with overflow",
        "5768": "Array index out of bounds",
        "7225": "Array index out of bounds",
        "4854": "Array index out of bounds",
        "6445": "Array index out of bounds",
        "490": "Aztec Passport: Unauthorized Admin Change",
        "6823": "Array index out of bounds",
        "6177": "attempt to add with overflow",
        "4696": "attempt to add with overflow",
        "2191": "attempt to add with overflow",
        "5263": "Array index out of bounds",
        "5641": "Array index out of bounds",
        "710": "Aztec Passport: Only Admin",
        "1411": "attempt to multiply with overflow",
        "4806": "attempt to add with overflow",
        "3837": "attempt to add with overflow",
        "954": "Storage slot 0 not allowed. Storage slots must start from 1.",
        "2679": "Not initialized",
        "6074": "Array index out of bounds",
        "1521": "attempt to multiply with overflow",
        "6830": "Array index out of bounds",
        "7393": "Array index out of bounds",
        "5026": "Array index out of bounds",
        "6050": "attempt to add with overflow",
        "7184": "Array index out of bounds",
        "7373": "attempt to add with overflow",
        "6727": "Array index out of bounds",
        "6916": "Array index out of bounds",
        "4088": "Array index out of bounds",
        "181": "attempt to add with overflow",
        "3954": "Array index out of bounds",
        "6136": "attempt to add with overflow",
        "7404": "attempt to add with overflow",
        "7270": "Array index out of bounds",
        "4387": "Array index out of bounds",
        "5411": "attempt to add with overflow",
        "3741": "attempt to add with overflow",
        "3418": "Array index out of bounds",
        "4954": "Array index out of bounds",
        "3796": "attempt to add with overflow",
        "2961": "attempt to add with overflow",
        "401": "Initializer address is not the contract deployer",
        "3985": "Array index out of bounds",
        "3016": "Array index out of bounds",
        "4040": "attempt to add with overflow",
        "6088": "attempt to add with overflow",
        "6545": "Array index out of bounds",
        "3772": "attempt to add with overflow",
        "5308": "Array index out of bounds",
        "3638": "Array index out of bounds",
        "6600": "Array index out of bounds",
        "6576": "Array index out of bounds",
        "7246": "attempt to add with overflow",
        "3370": "attempt to add with overflow",
        "4260": "Array index out of bounds",
        "4772": "Array index out of bounds",
        "5284": "attempt to add with overflow",
        "4827": "Array index out of bounds",
        "3992": "Array index out of bounds",
        "3157": "Array index out of bounds",
        "7332": "attempt to add with overflow",
        "6851": "attempt to add with overflow",
        "7040": "Array index out of bounds",
        "6205": "Array index out of bounds",
        "5370": "attempt to add with overflow",
        "3700": "attempt to add with overflow",
        "6961": "Array index out of bounds",
        "7284": "attempt to add with overflow",
        "4645": "Array index out of bounds",
        "7205": "attempt to add with overflow",
        "4188": "Array index out of bounds",
        "6236": "Array index out of bounds",
        "4566": "Array index out of bounds",
        "147": "attempt to add with overflow",
        "1171": "call to assert_max_bit_size",
        "5322": "attempt to add with overflow",
        "3652": "attempt to add with overflow",
        "3518": "Array index out of bounds",
        "2683": "Function get_service_index can only be called statically",
        "7102": "Array index out of bounds",
        "3573": "Array index out of bounds",
        "5621": "Array index out of bounds",
        "4975": "attempt to add with overflow",
        "2092": "attempt to add with overflow",
        "3116": "Array index out of bounds",
        "2982": "Array index out of bounds",
        "5676": "Array index out of bounds",
        "6566": "attempt to add with overflow",
        "3549": "Array index out of bounds",
        "4061": "Array index out of bounds",
        "4439": "Array index out of bounds",
        "5140": "Array index out of bounds",
        "6164": "Array index out of bounds",
        "4872": "Array index out of bounds",
        "5573": "Array index out of bounds",
        "3391": "Array index out of bounds",
        "508": "Not initialized",
        "185": "Array index out of bounds",
        "6463": "Array index out of bounds",
        "6841": "attempt to add with overflow",
        "3824": "Array index out of bounds",
        "4848": "attempt to add with overflow",
        "3178": "attempt to add with overflow",
        "6951": "attempt to add with overflow",
        "7164": "attempt to add with overflow",
        "3288": "Array index out of bounds",
        "405": "Aztec Passport: Invalid Address",
        "82": "attempt to add with overflow",
        "6037": "Array index out of bounds",
        "6927": "attempt to add with overflow",
        "649": "attempt to add with overflow",
        "4934": "attempt to add with overflow",
        "5446": "Array index out of bounds",
        "192": "Array index out of bounds",
        "1917": "attempt to add with overflow",
        "5958": "Array index out of bounds",
        "6336": "Array index out of bounds",
        "6525": "attempt to add with overflow",
        "4209": "attempt to add with overflow",
        "6982": "attempt to add with overflow",
        "6635": "Array index out of bounds",
        "7116": "attempt to add with overflow",
        "7360": "Array index out of bounds",
        "4886": "attempt to add with overflow",
        "3539": "attempt to add with overflow",
        "3728": "Array index out of bounds",
        "5398": "Array index out of bounds",
        "4106": "Array index out of bounds",
        "5776": "Array index out of bounds",
        "5831": "Array index out of bounds",
        "3137": "attempt to add with overflow",
        "3326": "attempt to add with overflow",
        "3003": "attempt to add with overflow",
        "6398": "Array index out of bounds",
        "2357": "Not initialized",
        "4082": "attempt to add with overflow",
        "5807": "Array index out of bounds",
        "3436": "Array index out of bounds",
        "6477": "attempt to add with overflow",
        "6587": "attempt to add with overflow",
        "6855": "Array index out of bounds",
        "7020": "Array index out of bounds",
        "7233": "Array index out of bounds",
        "3034": "Array index out of bounds",
        "2199": "attempt to add with overflow",
        "3412": "attempt to add with overflow",
        "5271": "Array index out of bounds",
        "5649": "Array index out of bounds",
        "395": "Initialization hash does not match",
        "4168": "attempt to add with overflow",
        "6862": "Array index out of bounds",
        "6972": "attempt to add with overflow",
        "2742": "Storage slot 0 not allowed. Storage slots must start from 1.",
        "3498": "attempt to add with overflow",
        "3096": "attempt to add with overflow",
        "4120": "attempt to add with overflow",
        "5010": "Array index out of bounds",
        "6357": "attempt to add with overflow",
        "6735": "Array index out of bounds",
        "457": "attempt to add with overflow",
        "7192": "Array index out of bounds",
        "4419": "Array index out of bounds"
      }
    },
    {
      "name": "verify_service",
      "is_unconstrained": false,
      "custom_attributes": ["private"],
      "abi": {
        "error_types": {},
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            { "name": "inner", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "storage_contract_address",
                        "type": {
                          "fields": [
                            { "name": "inner", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_delegate_call",
                        "type": { "kind": "boolean" }
                      },
                      {
                        "name": "is_static_call",
                        "type": { "kind": "boolean" }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            { "name": "root", "type": { "kind": "field" } },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            { "name": "num_txs", "type": { "kind": "field" } },
                            {
                              "name": "txs_effects_hash",
                              "type": { "kind": "field" }
                            },
                            { "name": "in_hash", "type": { "kind": "field" } },
                            { "name": "out_hash", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": { "kind": "field" }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": { "kind": "field" }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": { "kind": "field" }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": { "kind": "field" }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            { "name": "chain_id", "type": { "kind": "field" } },
                            { "name": "version", "type": { "kind": "field" } },
                            {
                              "name": "block_number",
                              "type": { "kind": "field" }
                            },
                            {
                              "name": "slot_number",
                              "type": { "kind": "field" }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": { "kind": "field" }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      { "name": "total_fees", "type": { "kind": "field" } }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::header::Header"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      { "name": "chain_id", "type": { "kind": "field" } },
                      { "name": "version", "type": { "kind": "field" } },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": { "kind": "field" }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "inclusion_fee",
                              "type": { "kind": "field" }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": { "kind": "integer", "sign": "unsigned", "width": 32 }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "address",
            "type": {
              "fields": [{ "name": "inner", "type": { "kind": "field" } }],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "service_id",
            "type": { "kind": "integer", "sign": "unsigned", "width": 64 },
            "visibility": "private"
          },
          {
            "name": "service_address",
            "type": {
              "fields": [{ "name": "inner", "type": { "kind": "field" } }],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          { "name": "inner", "type": { "kind": "field" } }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "storage_contract_address",
                      "type": {
                        "fields": [
                          { "name": "inner", "type": { "kind": "field" } }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_delegate_call",
                      "type": { "kind": "boolean" }
                    },
                    { "name": "is_static_call", "type": { "kind": "boolean" } }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              { "name": "args_hash", "type": { "kind": "field" } },
              { "name": "returns_hash", "type": { "kind": "field" } },
              {
                "name": "min_revertible_side_effect_counter",
                "type": { "kind": "integer", "sign": "unsigned", "width": 32 }
              },
              { "name": "is_fee_payer", "type": { "kind": "boolean" } },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          { "name": "_is_some", "type": { "kind": "boolean" } },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  { "name": "x", "type": { "kind": "field" } },
                                  { "name": "y", "type": { "kind": "field" } },
                                  {
                                    "name": "is_infinite",
                                    "type": { "kind": "boolean" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            { "name": "sk_app", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": { "kind": "field" }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      { "name": "note_hash", "type": { "kind": "field" } }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "fields": [
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            { "name": "inner", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "storage_contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_delegate_call",
                              "type": { "kind": "boolean" }
                            },
                            {
                              "name": "is_static_call",
                              "type": { "kind": "boolean" }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      { "name": "args_hash", "type": { "kind": "field" } },
                      { "name": "returns_hash", "type": { "kind": "field" } },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            { "name": "inner", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "storage_contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_delegate_call",
                              "type": { "kind": "boolean" }
                            },
                            {
                              "name": "is_static_call",
                              "type": { "kind": "boolean" }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      { "name": "args_hash", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          { "name": "inner", "type": { "kind": "field" } }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "call_context",
                      "type": {
                        "fields": [
                          {
                            "name": "msg_sender",
                            "type": {
                              "fields": [
                                { "name": "inner", "type": { "kind": "field" } }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "storage_contract_address",
                            "type": {
                              "fields": [
                                { "name": "inner", "type": { "kind": "field" } }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "function_selector",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                            }
                          },
                          {
                            "name": "is_delegate_call",
                            "type": { "kind": "boolean" }
                          },
                          {
                            "name": "is_static_call",
                            "type": { "kind": "boolean" }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                      }
                    },
                    { "name": "args_hash", "type": { "kind": "field" } },
                    {
                      "name": "counter",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            { "name": "inner", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      { "name": "content", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": { "kind": "integer", "sign": "unsigned", "width": 32 }
              },
              {
                "name": "end_side_effect_counter",
                "type": { "kind": "integer", "sign": "unsigned", "width": 32 }
              },
              {
                "name": "note_encrypted_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      { "name": "length", "type": { "kind": "field" } },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::NoteLogHash"
                  }
                }
              },
              {
                "name": "encrypted_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      { "name": "length", "type": { "kind": "field" } },
                      { "name": "randomness", "type": { "kind": "field" } }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::EncryptedLogHash"
                  }
                }
              },
              {
                "name": "unencrypted_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      { "name": "length", "type": { "kind": "field" } }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          { "name": "root", "type": { "kind": "field" } },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          { "name": "num_txs", "type": { "kind": "field" } },
                          {
                            "name": "txs_effects_hash",
                            "type": { "kind": "field" }
                          },
                          { "name": "in_hash", "type": { "kind": "field" } },
                          { "name": "out_hash", "type": { "kind": "field" } }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                { "name": "root", "type": { "kind": "field" } },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": { "kind": "field" }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": { "kind": "field" }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": { "kind": "field" }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          { "name": "chain_id", "type": { "kind": "field" } },
                          { "name": "version", "type": { "kind": "field" } },
                          {
                            "name": "block_number",
                            "type": { "kind": "field" }
                          },
                          {
                            "name": "slot_number",
                            "type": { "kind": "field" }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                { "name": "inner", "type": { "kind": "field" } }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                { "name": "inner", "type": { "kind": "field" } }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": { "kind": "field" }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": { "kind": "field" }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    { "name": "total_fees", "type": { "kind": "field" } }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::header::Header"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    { "name": "chain_id", "type": { "kind": "field" } },
                    { "name": "version", "type": { "kind": "field" } },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": { "kind": "field" }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": { "kind": "field" }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "inclusion_fee",
                            "type": { "kind": "field" }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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eKfyti9zeduXubzty1Qfe7Mvc3nbl5m815N9mcvbvsy8X64n+zKXt32Zy3vgncrbvszlbV/m8rYvc3nbl7m87ctU3ot9mcvbvszlbV/m8rYvc3kPvFN525epPnaxL3N525e5vO3LXN72Zer9crUvc3nbl7m87ctc3vZlLu+Bdypv+zKXt32Zy9u+zOVtX+byti9TeW/2ZS5v+zKXt32Zy9u+TPWx28A7lbd9mcvbvszlbV/m3i/ty1ze9mUq72Ff5vK2L3N525e5vO3LXN4D71Te9mUub/syl7d9mcvbvszlbV+m8j7bl7m87ctUH3u2L3N525e5vAfeqbzty9z7pX2Zy9u+zOVtX+byti9TeV/sy1ze9mUub/syl7d9mct74J3K277M5W1f5vK2L3N525e5vO3LVB97tS9zeduXubzty1ze9mXq/fI68E7lbV/m8rYvc3nbl7m87ctc3vZlKu/dvszlbV/m8rYvc3nbl7m8B96pvO3LXN72ZS5v+zLVx+72ZS5v+zKV982+zOVtX6beL2/2ZS5v+zKX98A7lbd9mcvbvszlbV/m8rYvc3nbl5m8t5N9mcvbvszlbV/m8rYvc3kPvFN525eZPnY72Ze5vO3LXN72ZS5v+zL1frnYl7m87ctc3vZlLm/7Mpf3wDuVt32Zy9u+zOVtX+byti9zeduXqbxX+zKXt32Zy9u+zOVtX6b62HXgncrbvszlbV/m8rYvc++X9mUub/sylfdmX+byti9zeduXubzty1zeA+9U3vZlLm/7Mpe3fZnL277M5W1fpvIe9mUub/sy1ccO+zKXt32Zy3vgncrbvsy9X9qXubzty1ze9mUub/sylffZvszlbV/m8rYvc3nbl7m8B96pvO3LXN72ZS5v+zKXt32Zy9u+TPWxF/syl7d9mcvbvszlbV+m3i8vA+9U3vZlLm/7Mpe3fZnL277M5W1fpvK+2pe5vO3LXN72ZS5v+zKX98A7lbd9mcvbvszlbV+m+tirfZnL275M5b3bl7m87cvU++VuX+byti9zeQ+8U3nbl7m87ctc3vZlLm/7Mpe3fZnK+2Zf5vK2L3N525e5vO3LXN4D71Te9mWqj73Zl7m87ctc3vZlLm/7MvN+OU72ZS5v+zKXt32Zy9u+zOU98E7lbV/m8rYvc3nbl7m87ctc3vZlKu/FvszlbV/m8rYvc3nbl5k+diwD71Te9mUub/syl7d9mXu/tC9zeduXqbxX+zKXt32Zy9u+zOVtX+byHnin8rYvc3nbl7m87ctc3vZlLm/7MpX3Zl/m8rYvU33sZl/m8rYvc3kPvFN525e590v7Mpe3fZnL277M5W1fpvIe9mUub/syl7d9mcvbvszlPfBO5W1f5vK2L3N525e5vO3LXN72ZaqPPduXubzty1ze9mUub/sy9X55Hnin8rYvc3nbl7m87ctc3vZlLm/7MpX3xb7M5W1f5vK2L3N525e5vAfeqbzty1ze9mUub/sy1cde7Mtc3vZlKu+rfZnL275MvV9e7ctc3vZlLu+Bdypv+zKXt32Zy9u+zOVtX+byti9Tee/2ZS5v+zKXt32Zy9u+zOU98E7lbV+m+tjdvszlbV/m8rYvc3nbl6n3y5t9mcvbvszlbV/m8rYvc3kPvFN525e5vO3LXN72ZS5v+zKXt32Zyft8si9zeduXubzty1ze9mWmjz2fBt6pvO3LXN72Ze73b/syl7d9mcvbvkzlvdiXubzty1ze9mXq8+BiX+byHnin8rYvc79/25e5vO3LXN72ZS5v+zKV92pf5vK2L1OfB1f7Mpe3fZnLe+Cdytu+zL1f2pe5vO3LXN72ZS5v+zKV92Zf5vK2L3N525e5vO3LXN4D71Te9mUub/tyLu993e/k9u30mbd9+Zj37f7ZfVv+wvsPhE0n43Jaz/dPn86nBxDH7f7h8zg9KO15vH92//DZy1ef3a5j+UHjwzeU8Wc6TQfmQdLZL/cPb/sX6Yymc/RF0mk6Xl8knaZT90XSaTqMXySdIZ0Dp9N0dL9IOk0n+ouk03TQv0g6XMHkdC6ny5+fvWznB+nsl/tn9/2DyNn2P8OhCp4Yzu0d8+3jX7O3cL64hu203TPZlttHq/nF3983AvcrXsfyb/+sQM8cRMvYyY2WsbMmLWOnY1rGPsTeMXYCqWXszFTL2CmvlrFzaS1jZ+k6xn5h6VrGztK1jJ2laxk7S9cy9iH2jrGzdC1jZ+laxs7StYydpWsZO0vXMfYrS9cydpauZewsXcvYWbqWsQ+xd4ydpWsZO0vXMnaWrmXsLF3L2Fm6jrHvLF3L2Fm6lrGzdC1jZ+laxj7E3jF2lq5l7Cxdy9hZupaxs3QtY2fpOsZ+Y+laxs7StYydpWsZO0vXMvYh9o6xs3QtY2fpWsbO0rWMnaVrGTtL9yqxX873V4aOy+XTO4gvJ+KtSpJcWpUk6bEqSTJer5Lk9XSnMa7LF0kOSRZJkpeqkiTVVCVJ9qhKkoRQlWdXjqdIkgvHUyVJjqdKkhxPkSeeheOpkuSQZJEkOZ4qSXI8VZLkeKokyfFUSZLjKZLkyvFUSZLjqZIkx1MlSY6nSpJDkkWS5HiqJMnxFDnVWjmeKklyPFWS5HiKJLlxPEWeeDaOp0qSHE+VJDmeKkkOSRZJkuOpkiTHUyVJjqdKkhxPlSQ5niJJDo6nSpIcT5UkOZ4qSXI8VZIckqxxqjU4nipJcjxVkuR4qiTJ8VR54uF4iiR55niqJMnxVEmS46mSJMdTJckhySJJcjxVkuR4qiTJ8VRJkuOpkiTHUyTJC8dTJUmOp0qSHE+RU60Lx1MlySHJIklyPFWS5HiqPPFwPFWS5HiqJMnxFEnyyvFUSZLjqZIkx1MlSY6nSpJDkkWS5HiqJMnxVEmS46mSJMdTJUmOp0iSO8dT5FRr53iqJMnxVEmS46mS5JBkkScejqdKkhxPlSQ5nipJcjxVkuR4iiR543iqJMnxVEmS46mSJMdTJckhySJJcjxVkuR4qiTJ8VRJkuMpcqp143hqJHk9cTxVkuR4qiTJ8dR44rmeOJ4qSQ5JFkmS46mSJMdTJUmOp0qSHE+VJDmeIkkuHE+VJDmeKklyPFWS5HiqJDkkWSRJjqdKkhxPkVOtheOpkiTHUyVJjqdIkivHU+SJZ+V4qiTJ8VRJkuOpkuSQZJEkOZ4qSXI8VZLkeKokyfFUSZLjKZLkxvFUSZLjqZIkx1MlSY6nSpJDkjVOtTaOp0qSHE+VJDmeKklyPFWeeDieIkkOjqdKkhxPlSQ5nipJcjxVkhySLJIkx1MlSY6nSpIcT5UkOZ4qSXI8RZI8czxVkuR4qiTJ8RQ51TpzPFWSHJIskiTHUyVJjqfKEw/HUyVJjqdKkhxPkSQvHE+VJDmeKklyPFWS5HiqJDkkWSRJjqdKkhxPlSQ5nipJcjxVkuR4iiR55XiKnGpdOZ4qSXI8VZLkeKokOSRZ5ImH46mSJMdTJUmOp0qSHE+VJDmeIknuHE+VJDmeKklyPFWS5HiqJDkkWSRJjqdKkhxPlSQ5nipJcjxFTrV2jqdIkjeOp0qSHE+VJDmeIk88N46nSpJDkkWS5HiqJMnxVEmS46mSJMdTJUmOp0aS+4njqZIkx1MlSY6nSpIcT5UkhySLJMnxVEmS46lxqrWfOJ4qSXI8VZLkeIokuXA8RZ54Fo6nSpIcT5UkOZ4qSQ5JFkmS46mSJMdTJUmOp0qSHE+VJDmeIkmuHE+VJDmeKklyPFWS5HiqJDkkWeNUa+V4qiTJ8VRJkuOpkiTHU+WJh+MpkuTG8VRJkuOpkiTHUyVJjqdKkkOSRZLkeKokyfFUSZLjqZIkx1MlSY6nSJKD46mSJMdTJUmOp8ip1uB4qiQ5JFkkSY6nSpIcT5UnHo6nSpIcT5UkOZ4iSZ45nipJcjxVkuR4qiTJ8VRJckiySJIcT5UkOZ4qSXI8VZLkeKokyfEUSfLC8RQ51bpwPFWS5HiqJMnxVElySLLIEw/HUyVJjqdKkhxPlSQ5nipJcjxFkrxyPFWS5HiqJMnxVEmS46mS5JBkkSQ5nipJcjxVkuR4qiTJ8RQ51bpyPEWS3DmeKklyPFWS5HiKPPHsHE+VJIckiyTJ8VRJkuOpkiTHUyVJjqdKkhxPkSRvHE+VJDmeKklyPFWS5HiqJDkkWSRJjqdKkhxPkVOtG8dTJUmOp0qSHE+NJG8njqfGE8/txPFUSZLjqZIkx1MlySHJIklyPFWS5HiqJMnxVEmS46mSJMdTJMmF46mSJMdTJUmOp0qSHE+VJIcka5xqLRxPlSQ5nipJcjxVkuR4qjzxcDxFklw5nipJcjxVkuR4qiTJ8VRJckiySJIcT5UkOZ4qSXI8VZLkeKokyfEUSXLjeKokyfFUSZLjKXKqtXE8VZIckiySJMdTJUmOp8oTD8dTJUmOp0qSHE+RJAfHUyVJjqdKkhxPlSQ5nipJDkkWSZLjqZIkx1MlSY6nSpIcT5UkOZ4iSZ45niKnWmeOp0qSHE+VJDmeKkkOSRZ54uF4qiTJ8VRJkuOpkiTHUyVJjqdIkheOp0qSHE+VJDmeKklyPFWSHJIskiTHUyVJjqdKkhxPlSQ5niKnWheOp0iSV46nSpIcT5UkOZ4iTzxXjqdKkkOSRZLkeKokyfFUSZLjqZIkx1MlSY6nSJI7x1MlSY6nSpIcT5UkOZ4qSQ5JFkmS46mSJMdT5FRr53iqJMnxVEmS4ymS5I3jKfLEc+N4qiTJ8VRJkuOpkuSQZJEkOZ4qSXI8VZLkeKokyfFUSZLjKZHk+XTieKokyfFUSZLjqZIkx1MlySHJCqdab0lyPFWS5HiqJMnxVEmS46nyxMPxFEly4XiqJMnxVEmS46mSJMdTJckhySJJcjxVkuR4qiTJ8VRJkuOpkiTHUyTJleOpkiTHUyVJjqfIqdbK8VRJckiySJIcT5UkOZ4qTzwcT5UkOZ4qSXI8RZLcOJ4qSXI8VZLkeKokyfFUSXJIskiSHE+VJDmeKklyPFWS5HiqJMnxFElycDxFTrUGx1MlSY6nSpIcT5UkhySLPPFwPFWS5HiqJMnxVEmS46mSJMdTJMkzx1MlSY6nSpIcT5UkOZ4qSQ5JFkmS46mSJMdTJUmOp0qSHE+RU60zx1MkyQvHUyVJjqdKkhxPkSeeC8dTJckhySJJcjxVkuR4qiTJ8VRJkuOpkiTHUyTJK8dTJUmOp0qSHE+VJDmeKkkOSRZJkuOpkiTHU+RU68rxVEmS46mSJMdTJMmd4ynyxLNzPFWS5HiqJMnxVElySLJIkhxPlSQ5nipJcjxVkuR4qiTJ8RRJ8sbxVEmS46mSJMdTJUmOp0qSQ5I1TrVuHE+VJDmeKklyPFWS5HiqPPFwPDWSfLsYSRZJkuOpkiTHUyVJjqdKkkOSRZLkeKokyfFUSZLjqZIkx1MlSY6nSJILx1MlSY6nSpIcT41TrWXheKokOSRZJEmOp8p9kuOpkiTHUyVJjqdKkhxPkSRXjqdKkhxPkRWycjxVkuR4qiQ5JFnkPsnxVEmS46mSJMdTJUmOp0qSHE+RJDeOp8gK2TieKklyPFWS5HiqJDkkWeSJh+OpkiTHUyVJjqdKkhxPlSQ5niJJDo6nSpIcT5UkOZ4qSXI8VZIckiySJMfzKknu637PZN9On5PkeJ6Y5NvNbXlHd748yPKyrcv7Hz3Gxyy/4ny5B/+G/McfvX5FetuW2/3D23r++OE/WsIfacnjlnBTWvK4JbyXljxsyZlT05J///an3Ulv47x/bglfpyWPW8IFaslbNa7vqYzb+v2H19v+/iefTqcHHx7nO7p1XPfvP3w+vWPelk9z/Ex2quqLVHWoqqr+yqre7n/yel5PoarS1ar6IlXl41X1V1b1ut1xrNfr+cGHT+P+Ba6nywj12gmCXlfstTMPvT5Or693qb6+BRTqtVMavS7Y64tzJb3+uV5vp3W893p78Cev2/7e63HaPn74j/45sdK/X9m/eYL34thMVV+kqo7NVPVFqjpUVVV/ZVWnnUVcHJup6otU1bGZqv7Kql7e67dePvbvPusdb+nfM/vnGEr/ntk/x0X698T+XR3r6N+v7N/PHFcu+3vgy235fAZ0dQakrC9TVqdAynqUsk78wb2rIyO9rtjrodd6XbDXDqP0+ji9nvYDqVcnV3pdsddOxPT6J3u9vP/W0W3Zot7CiZj+PbN/TsT07xf2b+K02h2eqeqLVNXRmaq+SFUdnKnqL63qtK2+OwtT1Rep6lBVVd3O5+3+4fPlwb/H+7nfS/Hg3+/vjqH071f2b96/NN2dLKnqi1TVYZGqvkhVnSup6i+t6rR/FL07glLV16jqzRGUqv7Kqj7494M350r698z+OSzSv2f2zwmQ/j2zf0P/9O8X9m/mP4m+OQNS1pcpq1MgZT1KWSf+eN3NkZFeV+y18yW9rthrh1F6fZxez/qB1PXk5EqvK/baiZhe/1yvn/RKlfXk8ExVX6SqztlU9ZdWddaPZL1NP1VV1deoqgM5Vf2VVX2OM3v7n+u1XhfstbM7vT5Or+c5M2d3el2x187u9Ponez3xd2m+1Vf/9O+J/XMWpn+/sH8Tp9XiLExVX6SqzsJU9UWqOlRVVX9lVadt9cVZmKq+SFUdbz2zqvt7OMu+Ln+p6h/xOKU5dDwOGw4dD2d+5HhWSvko8Szji3gY10PHwzIeOh5m7dDxDPEcOR4G5dBPbqzBoeNhDQ4dD2tw6HhYgyPHs7EGh46HNTh0PKzBoeNhDQ4dzxDPkeNhDQ4dD2tw0B+L+SMe1uDQ8bAGh46HNThyPIM1OHQ8rMHkeK7jftH7cnoQz+V0/3HSy/rjMG57u+I/wuEMDhwOY3DgcIZwjhsOW3DgcLiCA4fDFBw4HJ7gwOGwBMcN58wRHDgchuDA4TAEBw6HIThwOEM4xw2HIThwOAzBgcNhCA4cDkNw4HAYguOGc2EIDhwOQ3DgcBiCA4fDEBw4nCGc44bDEBw4HIbgwOEwBAcOhyE4cDgMwXHDuTIEBw6HIThwOAzB5HD22/33j98e/gudtyVz/wI/wNjOX17CncV5uT746Oly/0dCY1kuHz/8R+bEQ7/Mh8zbZU6T9MucfemXOanTL3OuqF/mFFS7zHdmq1/mhFm/zHm4fpnzcP0yHzJvlzkP1y9zHq5f5jxcv8x5uH6Z83DtMr/xcP0y5+H6Zc7D9cuch+uX+ZB5u8x5uH6Z83D9Mufh+mXOw/XLnIfrlvl24uH6Zc7D9cuch+uXOQ/XL/Mh83aZ83D9Mufh+mXOw/XLnIfrlzkP1y7zhYfrlzkP1y9zHq5f5jxcv8yHzNtlzsP1y5yH65c5D9cvcx6uX+Y8XLvMVx6uX+Y8XL/Mebh+mfNw/TIfMm+XOQ/XL3Merl/mPFy/zHm4fpnzcO0y33i4fpnzcP0y5+H6Zc7D9ct8yLxd5jxcv8x5uH6Z83D1Ml/3+x87trF+/+F1We7Xuy5jfC4Iaacg3xaE4VOQ7woy6EAF+bYg3KGCfFsQolFBvi0IK6kg3xZkKIiCfFcQvlNBvi0IOaog3xaESVWQbwvCpCrItwVhUhXku4KcmVQF+bYgTKqCfFsQJlVBvi0Ik6og3xZkKIiCfFcQJlVBvi0Ik6og3xaESVWQbwvCpCrItwVhUhXku4JcmFQF+bYgTKqCfFsQJlVBvi0Ik6og3xZkKIiCfFcQJlVBvi0Ik6og3xaESVWQbwvCpCrItwVhUhXku4JcmdRyBTmv+53xb7+R/3Pm5Gi/zPnOfplTmP0yHzJvlznR2C9z7rBf5nRgv8wZvn6Zk3btMt95uH6Z83D9Mufh+mXOw/XLfMi8XeY8XL/Mebh+mfNw/TLn4fplzsO1y/zGw/XLnIfrlzkP1y9zHq5f5kPm7TLn4fplzsP1y5yH65c5D9cvcx6uW+bjxMP1y5yH65c5D9cvcx6uX+ZD5u0y5+H6Zc7D9cuch+uXOQ/XL3Merl3mCw/XL3Merl/mPFy/zHm4fpkPmbfLnIfrlzkP1y9zHq5f5jxcv8x5uHaZrzxcv8x5uH6Z83D9Mufh+mU+ZN4ucx6uX+Y8XL/Mebh+mfNw/TLn4dplvvFw/TLn4fplzsP1y5yH65f5kHm5zM/X98+eb7fPmfNw/TLn4fplzsP1y5yH65c5D9cu88HD9cuch+uXOQ/XL3Merl/mQ+btMufh+mXOw/XLnIfrlzkP1y9zHq5d5mcerl/mPFy/zHm4fpnzcP0yHzJvlzkP1y9zHq5f5jxcv8x5uH6Z83DtMr/wcP0y5+H6Zc7D9cuch+uX+ZB5u8x5uH6Z83D9Mufh+mXOw/XLnIdrl/mVh+uXOQ/XL3Merl/mPFy/zIfM22XOw/XLnIfrlzkP1y9zHq5f5jxcu8x3Hq5f5jxcv8x5uH6Z83D9Mh8yb5c5D9cvcx6uX+Y8XL/Mebh+mfNw7TK/8XD9Mufh+mXOw/XLnIfrl/mQebvMebh+mfNw/TLn4fplzsOVy/yyjuXPz1620/Y5cx6uW+bnEw/XL3Merl/mPFy/zHm4fpkPmbfLnIfrlzkP1y9zHq5f5jxcv8x5uHaZLzxcv8x5uH6Z83D9Mufh+mU+ZN4ucx6uX+Y8XL/Mebh+mfNw/TLn4dplvvJw/TLn4fplzsP1y5yH65f5kHm7zHm4fpnzcP0y5+H6Zc7D9cuch2uX+cbD9cuch+uXOQ/XL3Merl/mQ+btMufh+mXOw/XLnIfrlzkP1y9zHq5e5m+fuGd+HuNT5oOH65c5D9cvcx6uX+Y8XL/Mh8zbZc7D9cuch+uXOQ/XL3Merl/mPFy7zM88XL/Mebh+mfNw/TLn4fplPmTeLnMerl/mPFy/zHm4fpnzcP0y5+HaZX7h4fplzsP1y5yH65c5D9cv8yHzdpnzcP0y5+H6Zc7D9cuch+uXOQ/XLvMrD9cvcx6uX+Y8XL/Mebh+mQ+Zt8uch+uXOQ/XL3Merl/mPFy/zHm4dpnvPFy/zHm4fpnzcP0y5+H6ZT5k3i5zHq5f5jxcv8x5uH6Z83D9Mufh2mV+4+H6Zc7D9cuch+uXOQ/XL/Mh83aZ83D1Mt+v9z/2cjtdPmfOw/XLnIfrlzkPVy/z23p6z/zD1/blh/e3mP788L6dLw8+PO7h7R/yeO8Sv6dLc7p0OfGGujSrS3ykLs3qEs+pS7O6xJ/q0qwuDV3SpUld4nt1aVaXeGRdmtUlflqXZnWJ99alWV3ivXVpUpcW3luXZnWJ99alWV3ivXVpVpd4b12a1aWhS7o0qUu8ty7N6hLvrUuzusR769KsLvHeujSrS7y3Lk3q0sp769KsLvHeujSrS7y3Ls3qEu+tS7O6NHRJlyZ1iffWpVld4r11aVaXeG9dmtUl3luXZnWJ99alSV3aeG9dmtUl3luXZnWJ99alWV3ivXVpVpeGLunSpC7x3ro0q0u8ty7N6hLvrUuzusR769KsLvHeujSpS4P31qVZXeK9dWlWl3hvXZrVJd5bl2Z1aeiSLk3qEu+tS7O6xHvr0qwu8d66NKtLvLcuzeoS761Lk7p05r11aVaXeG9dmtUl3luXZnWJ99alWV0auqRLk7rEe+vSrC7x3ro0q0u8ty7N6hLvrUuzusR769KkLl14b12a1SXeW5dmdYn31qVZXeK9dWlWl4Yu6dKkLvHeujSrS7y3Ls3qEu+tS7O6xHvr0qwu8d66NKlLV95bl2Z1iffWpVld4r11aVaXeG9dmtWloUu6NKlLvLcuzeoS761Ls7rEe+vSrC7x3ro0q0u8ty5N6tLOe+vSrC7x3ro0q0u8ty7N6hLvrUuzujR0SZcmdYn31qVZXeK9dWlWl3hvXZrVJd5bl2Z1iffWpUlduvHeujSrS7y3Ls3qEu+tS7O6xHvr0qwuDV3SpUld4r11aVaXeG9dmtUl3luXZnWJ99alWV3ivXVpTpeuJ95bl2Z1iffWpVld4r11aVaXeG9dmtWloUu6NKlLvLcuzeoS761Ls7rEe3fv0rK9d+kyPheEzG5ekHF+/wby9t/4/sPr7brfL/h2+9Gm9fLFh8+n9+qdT9vy8cN/VI/7Vr3nVG+hylXvSdVj1lXvSdUj4lXvSdXj7VXvSdUbqqd6z6meUwHVe1L1HCKo3pOq58xB9Z5UPacZqvek6jnNUL3nVG91mqF6T6qe0wzVe1L1nGao3pOq5zRD9Z5UvaF6qvec6jnNUL0nVc9phuo9qXpOM1TvSdVzmqF6T6qe0wzVe071NqcZqvek6jnNUL0nVc9phuo9qXpOM1TvSdUbqqd6z6me0wzVe1L1nGao3pOq5zRD9Z5UPacZqvek6jnNUL3nVG84zVC9J1XPaYbqPal6TjNU70nVc5qhek+q3lA91XtO9ZxmqN6Tquc0Q/WeVD2nGar3pOo5zVC9J1XPaYbqPad6Z6cZqvek6jnNUL0nVc9phuo9qXpOM1TvSdUbqqd6z6me0wzVe1L1nGao3pOq5zRD9Z5UPacZqvek6jnNUL3nVO/iNEP1nlQ9pxmq96TqOc1QvSdVz2mG6j2pekP1Hlfver7/0df9/KB6YzvdiY9tuT2I5+1K7/Gs44t4GP9Dx8OKHzoe5vjQ8bCrh46HgTxyPFeW7tDxMFmHjoftOXQ8jMih4xniOXI8rMGh42ENDh0Pa3DoeFiDQ8fDGhw5np01OHQ8rMGh42ENDh0Pa3DoeIZ4jhwPa3DoeFiDQ8fDGhw6Htbg0PGwBkeO58YaHDoe1uDQ8bAGh46HNTh0PEM8R46HNTh0PKzBoeNhDQ4dD2tw6HhYgwPHs59Yg0PHwxocOh7W4NDxsAaHjmeI58jxsAaHjoc1OHQ8rMGh42ENDh0Pa3DkeBbW4NDxsAaHjoc1OHQ8rMHseC7n5c7ucrl+Jj4QTyZu22cTN9eziVvgs4lfT/erHtflC+JGdTZxOzmZ+Gr6ZhO3ZrOJG6jJzyqrzZlNfCCeTNzmzCZuc2bfOW3ObOI2ZzZxmzOZ+GZzZhO3ObOJ25zZxG3ObOID8WTiNmc2cZszm7jNmU3c5swmbnMmEx82Z7KtHTZnNnGbM5u4zZlNfCCefOe0ObOJ25zZxG3ObOI2ZzZxmzOZ+NnmzCZuc2YTtzmziduc2cQH4snEbc5s4jZnNnGbM5u4zZlsa882ZzLxi82ZTdzmzCZucybfOS82ZzbxgXgycZszm7jNmU3c5swmbnNmE7c5k4lfbc5s4jZnNnGbM5u4zZlNfCCeTNzmzCZucybb2qvNmU3c5swmbnMmE99tzuQ7525zZhO3ObOJ25zZxAfiycRtzmziNmc2cZszm7jNmU3c5kwmfrM5s4nbnNnEbc5s4jZnNvGBeK6tvdmc2cRtzmziNmc2cZsz+85pc+YSv51szmziNmc2cZszm7jNmU18IJ5M3ObMJm5zZhO3ObOJ25zZxG3OZOKLzZlN3ObMJm5z5tra22JzZhMfiCcTtzmziduc2XdOmzObuM2ZTdzmTCa+2pzZxG3ObOI2ZzZxmzOb+EA8mbjNmU3c5swmbnNmE7c5s4nbnMnEN5sz2dZuNmc2cZszm7jNmU18IJ5857Q5s4nbnNnEbc5s4jZnNnGbM5n4sDmziduc2cRtzmziNmc28YF4MnGbM5u4zZlN3ObMJm5zJtvaYXMmEz/bnNnEbc5s4jZn8p3zbHNmEx+IJxO3ObOJ25zZxG3ObOI2ZzZxmzOZ+MXmzCZuc2YTtzmziduc2cQH4snEbc5s4jZnsq292JzZxG3ObOI2ZzLxq82ZfOe82pzZxG3ObOI2ZzbxgXgycZszm7jNmU3c5swmbnNmE7c5k4nvNmc2cZszm7jNmU3c5swmPhDPtbW7zZlN3ObMJm5zZhO3ObPvnDZnMvGbzZlN3ObMJm5zZhO3ObOJD8STiduc2cRtzmziNmc2cZszm7jNmUr8cjrZnNnEbc5s4jZnqq19I25zZhMfiCcTtzmziduc2XdOmzObuM2ZTdzmTCa+2JzZxG3ObOI2ZzZxmzOb+EA8mbjNmU3c5swmbnNmE7c5s4nbnMnEV5sz2dauNmc2cZszm7jNmU18IJ5857Q5s4nbnNnEbc5s4jZnNnGbM5n4ZnNmE7c5s4nbnNnEbc5s4gPxZOI2ZzZxmzObuM2ZTdzmTLa1m82ZTHzYnNnEbc5s4jZn8p1z2JzZxAfiycRtzmziNmc2cZszm7jNmU3c5kwmfrY5s4nbnNnEbc5s4jZnNvGBeDJxmzObuM2ZbGvPNmc2cZszm7jNmUz8YnMm3zkvNmc2cZszm7jNmU18IJ5M3ObMJm5zZhO3ObOJ25zZxG3OZOJXmzObuM2ZTdzmzCZuc2YTH4jn2tqrzZlN3ObMJm5zZhO3ObPvnDZnMvHd5swmbnNmE7c5s4nbnNnEB+LJxG3ObOI2ZzZxmzObuM2ZTdzmTCZ+szmziduc2cRtzmRbe7M5s4kPxJOJ25zZxG3O7DunzZlN3ObMJm5z5hJ/+x8hnkzc5swmbnNmE7c5s4kPxJOJ25zZxG3ObOI2ZzZxmzObuM2ZTHyxOXNt7bLYnNnEbc5s4jZnNvGBePKd0+bMJm5zZhO3ObOJ25zZxG3OZOKrzZlN3ObMJm5zZhO3ObOJD8STiduc2cRtzmziNmc2cZsz2dauNmcy8c3mzCZuc2YTtzmT75ybzZlNfCCeTNzmzCZuc2YTtzmziduc2cRtzmTiw+bMJm5zZhO3ObOJ25zZxAfiycRtzmziNmeyrR02ZzZxmzObuM2ZTPxscybfOc82ZzZxmzObuM2ZTXwgnkzc5swmbnNmE7c5s4nbnNnEbc5k4hebM5u4zZlN3ObMJm5zZhMfiOfa2ovNmU3c5swmbnNmE7c5s++cNmcy8avNmU3c5swmbnNmE7c5s4kPxJOJ25zZxG3ObOI2ZzZxmzObuM2ZTHy3ObOJ25zZxG3OZFu725zZxAfiycRtzmziNmf2ndPmzCZuc2YTtzmTid9szmziNmc2cZszm7jNmU18IJ5M3ObMJm5zZhO3ObOJ25zZxG3OXOLryebMtbXryebMJm5zZhO3ObOJD8ST75w2ZzZxmzObuM2ZTdzmzCZucyYTX2zObOI2ZzZxmzObuM2ZTXwgnkzc5swmbnNmE7c5s4nbnMm2drE5k4mvNmc2cZszm7jNmXznXG3ObOID8WTiNmc2cZszm7jNmU3c5swmbnMmE99szmziNmc2cZszm7jNmU18IJ5M3ObMJm5zJtvazebMJm5zZhO3OZOJD5sz+c45bM5s4jZnNnGbM5v4QDyZuM2ZTdzmzCZuc2YTtzmziducycTPNmc2cZszm7jNmU3c5swmPhDPtbVnmzObuM2ZTdzmzCZuc2bfOW3OZOIXmzObuM2ZTdzmzCZuc2YTH4gnE7c5s4nbnNnEbc5s4jZnNnGbM5n41ebMJm5zZhO3OZNt7dXmzCY+EE8mbnNmE7c5s++cNmc2cZszm7jNmUx8tzmziduc2cRtzmziNmc28YF4MnGbM5u4zZlN3ObMJm5zZhO3OZOJ32zOZFt7szmziduc2cRtzmziA/HkO6fNmU3c5swmbnNmE7c5s4nbnLnEt5PNmU3c5swmbnNmE7c5s4kPxJOJ25zZxG3ObOI2ZzZxmzPX1m4nmzOZ+GJzZhO3ObOJ25zJd87F5swmPhBPJm5zZhO3ObOJ25zZxG3ObOI2ZzLx1ebMJm5zZhO3ObOJ25zZxAfiycRtzmziNmeyrV1tzmziNmc2cZsz+fv4ZnNmE7c5s4nbnNnEbc5s4gPxZOI2Z/LT4WZzZhO3ObOJ25zZ38dtzmTiw+bMJm5zZhO3ObOJ25zZxAfiuU+Hw+bMJm5zZhO3ObOJ25zZd06bM5n42ebMJm5zZhO3ObOJ25zZxAfiycRtzmziNmc2cZszm7jNmU3c5pxNfF/3O7t9O30ifrE5/xXit/tF79vyF+J/QOw6I9/+v++fXs77A4hvXbt/eruMR58+j3s+5/1DPJevSr5dx/KDx4dvK+PPfLqOzqPks1/uH972r/LpOlFfJZ8hn0Pn03X+vko+Xcfyq+TTdVq/Sj5dh/ir5NN1tr9IPteuI/9V8uEPpudzOV3+/PCbVnyQz365f3bfP+idbf8zHvrgqfHc3kHfPv5Ve4vnC9+5nbZ7Ktty++g7v/g7/Mbg/pd4Hcu//bMcvfISTYMfgu8ZPJPSNHiKpmnw3E/T4EmlpsGzVT2D32mwpsHza02DZ+6aBs/cNQ1+CL5n8Mxd0+CZu6bBM3dNg2fumgbP3PUM/sbcNQ2euWsaPHPXNHjmrmnwQ/A9g2fumgbP3DUNnrlrGjxz1zR45q5l8OPE3DUNnrlrGjxz1zR45q5p8EPwPYNn7poGz9w1DZ65axo8c9c0eOauZ/ALc9c0eOauafDMXdPgmbumwQ/B9wyeuWsaPHPXNHjmrmnwzF3T4Jm7nsGvzF3T4Jm7psEzd68T/OV8v4pxuVw/Z0nG1clyyLJMlpRZnSxZsNfJ8nq68xjX5Yssia06WXJVdbKkn8pkuTFKdbIkico8x268T50seZ86WQ5ZlsmS96nz7MP71MmS96mTJe9TJ0vep0yWg/epkyXvUydL3qdOlrxPnSyHLMtkyfvUyZL3qZMl71MnS96nTpa8T5kzrzPvUydL3qdOlrxPnSx5nzLPPuchyzJZ8j51suR96mTJ+9TJkvepkyXvUybLC+9TJ0vep06WvE+dLHmfOlkOWZbJkvepkyXvUydL3qfMmdeF96mTJe9TJssr71MnS96nzLPPlfepkyXvUyfLIcsyWfI+dbLkfepkyfvUyZL3qZMl71Mmy533qZMl71MnS96nTpa8T50shyzLZMn7lDnz2nmfOlnyPnWy5H3qZMn7lHn2ufE+dbLkfepkyfvUyZL3qZPlkGWZLHmfOlnyPnWy5H3qZMn71MmS96mS5fnE+9TJkvepkyXvUydL3qfKmdf5NGRZJkvep06WvE+dLHmfOs8+vE+dLHmfMlkuvE+dLHmfOlnyPnWy5H3qZDlkWSZL3qdOlrxPnSx5nzpZ8j51suR9ymS58j51suR9ypx5rbxPnSx5nzpZDlmWyZL3qfPsw/vUyZL3qZMl71MnS96nTJYb71MnS96nTpa8T50seZ86WQ5ZlsmS96mTJe9TJ0vep06WvE+dLHmfMmdeg/epkyXvUydL3qdOlrxPmWefMWRZJkvep06WvE+dLHmfOlnyPnWy5H3KZHnmfepkyfvUyZL3qZMl71MnyyHLMlnyPnWy5H3qZMn7lDnzOvM+dbLkfcpkeeF96mTJ+5R59rnwPnWy5H3qZDlkWSZL3qdOlrxPnSx5nzpZ8j51suR9ymR55X3qZMn71MmS96mTJe9TJ8shyzJZ8j5lzryuvE+dLHmfOlnyPnWy5H3KPPvsvE+dLHmfOlnyPnWy5H3qZDlkWSZL3qdOlrxPnSx5nzpZ8j51suR9ymR5433qZMn71MmS96mTJe9T5szrNmRZJkvep06WvE+dLHmfOs8+vE+dLHmfKlleTrxPnSx5nzpZ8j51suR96mQ5ZFkmS96nTpa8T50seZ86WfI+dbLkfcpkufA+dbLkfaqceV0W3qdOlrxPnSyHLMtkyfvUefbhfepkyfvUyZL3qZMl71Mmy5X3qZMl71MnS96nTpa8T50shyzLZMn71MmS96mTJe9TJ0vep06WvE+ZM6+N96mTJe9TJ0vep06WvE+ZZ59tyLJMlrxPnSx5nzpZ8j51suR96mTJ+5TJcvA+dbLkfepkyfvUyZL3qZPlkGWZLHmfOlnyPnWy5H3KnHkN3qdOlrxPmSzPvE+dLHmfMs8+Z96nTpa8T50shyzLZMn71MmS96mTJe9TJ0vep06WvE+ZLC+8T50seZ86WfI+dbLkfepkOWRZJkvep8yZ14X3qZMl71MnS96nTpa8T5lnnyvvUydL3qdOlrxPnSx5nzpZDlmWyZL3qZMl71MnS96nTpa8T50seZ8yWe68T50seZ86WfI+dbLkfcqcee1DlmWy5H3qZMn71MmS96nz7MP71MmS9ymT5Y33qZMl71MnS96nTpa8T50shyzLZMn71MmS96mTJe9TJ0vep06WvE+VLK8n3qdOlrxPlTOvt6RlWSZL3qdOlkOWZbLkfeo8+/A+dbLkfepkyfvUyZL3KZPlwvvUyZL3qZMl71MnS96nTpZDlmWy5H3qZMn71MmS96mTJe9TJ0vep8yZ18r71MmS96mTJe9TJ0vep8yzzzpkWSZL3qdOlrxPnSx5nzpZ8j51suR9ymS58T51suR96mTJ+9TJkvepk+WQZZkseZ86WfI+dbLkfcqceW28T50seZ8yWQ7ep06WvE+ZZ5/B+9TJkvepk+WQZZkseZ86WfI+dbLkfepkyfvUyZL3KZPlmfepkyXvUydL3qdOlrxPnSyHLMtkyfuUOfM68z51suR96mTJ+9TJkvcp8+xz4X3qZMn71MmS96mTJe9TJ8shyzJZ8j51suR96mTJ+9TJkvepkyXvUybLK+9TJ0vep06WvE+dLHmfMmde1yHLMlnyPnWy5H3qZMn71Hn24X3qZMn7lMly533qZMn71MmS96mTJe9TJ8shyzJZ8j51suR96mTJ+9TJkvepkyXvUybLG+9TJ0vep8yZ1433qZMl71MnyyHLMlnyPnWefXifOlnyPnWy5H3qZMn7VMlyP/E+dbLkfepkyfvUyZL3qZPlkGWZLHmfOlnyPnWy5H3qZMn71MmS96ly5rUvvE+dLHmfOlnyPnWy5H3KPPssQ5ZlsuR96mTJ+9TJkvepkyXvUydL3qdMlivvUydL3qdOlrxPnSx5nzpZDlmW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",
      "brillig_names": [
        "get_public_storage_hints",
        "get_public_data_witness",
        "lt_32_hint",
        "decompose_hint",
        "lte_16_hint",
        "get_public_keys_and_partial_address",
        "random",
        "notify_created_note_oracle_wrapper",
        "get_key_validation_request",
        "build_msg_block_iter",
        "pad_msg_block",
        "attach_len_to_msg_block",
        "build_msg_block_iter",
        "emit_encrypted_note_log_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient"
      ]
    },
    {
      "name": "get_service_index",
      "is_unconstrained": true,
      "custom_attributes": ["public", "view"],
      "abi": {
        "error_types": {},
        "parameters": [
          {
            "name": "address",
            "type": {
              "fields": [{ "name": "inner", "type": { "kind": "field" } }],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": { "kind": "integer", "sign": "unsigned", "width": 64 },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7d3djtu2FgXgd5nrXPBn80d5lYODImnTYoBgUiTpAQ6CvHttZyRrSImMzW16wr1uiqRhbPPL2FqLkqlvD398eP/PX789Pv356cvD2/98e/j46fd3Xx8/PR1+9+37m4f3nx8/fnz867f1/35Qx/9Mp+Ff/n73dPzdl6/vPn99eKuDoTcPH57+OP7S0uEB/nz8+OHhbdDf32SDJxuex04uLEO18xtjyejpeTAZE5fRk9sY7KO2z4N9NNN68H/fPGjV/Mq10stgtRp8+9eu29XD/PjTVFPXhubB2kxT+ZVH7eZXEfXqoZ9fuWF85Qf0ly/9+AT21k9At34Cd+sn8M1P4Nw0P4PzqvITEaJxz4NDpJj+RIQLX83x78Qr/s50+d8x6oq/s/neNJ7mN7/xwVX++Yye35vHP5//9bY/g9w8dv1ms8ps/lhotzywt+fROmyMtnH5uLLqPJY2hhrj1Tw7E2J5sDdm/mQzdj30iGeAdz2eBd71eAS86/Ec8K7H88C7Hi8A73q8CLzr8SbgXY1nFfCux0PDaMBDw2jAQ8NowCPgXY+HhtGAh4ZRwXN+xludgnjGQ8NowEPDaMBDw7gej9AwGvDQMBrw0DBSEdSGVIQgkogg4KciSO2pCKJ4KoJ8nYogNCciDkk4FUG8TUWQWVMRZNZUhCCSiCCzpiLIrKkIMmsqgsyaiiCzJiIemTUVQWZNRZBZUxFk1lSEIJKIILOmIsisqQgyayqCzJqKILMmIgGZNRVBZk1FkFlTEWTWVIQgkoggsyYiUeK7xqpFxGqdikhM8SHOD2zCal+OSwcf+SRG/kv4dHDzA+sQ0mv+osR+wMgnsUzw8U0SU+VFfDHM347RcdLlwdHODxxt+jE5SUwiN5PWysZ5sHLpEX3CEZ3TWi8vWWtPqTUO//2skRX6WSNYdLPWSuIC6N2wJa6t3g0bAbsjtsS1rbthE7CvxT75oRC2+aHktfmhuFUGKzWvMRhlcj+UsTY/FKwmP93emQ7HcL8c4ZWtCDqzbNy9mufmUEPT/MDG6fUDhx+vXf/Cr938wq/d/sKvnWqvPWhTfgryyxGR/PreBWHrfe308tBOrz4FtneqJzV/vgQyZj349OId64sPyuc+/vZPEW7/FLH9KYL2y1PYWPtXNpNafkQNVUZbHefHtsaryujDUsvqdgpG144kpZ3YtJ4gsy1jFGR2ZLRkmcJOS7p+uwixMhYyOzIEmR0ZB5kdGQ+ZHZkgRuY0XTnB9jRdOWn1OF0rJ4KepisnV56mKycsnqYrJwGepkuypisnq52mKyeAnaYrK1VZWanKykpVJCtV0Vip6nzT6sOvrXkx3Y3x5auNaKwIxmszVl7jtSHY7NqMlQR5bcaKjbw2Y2XMC23OlykcfpmtatJYgZTXZqz0ymrjxoq6vDaic3HFRnQurtiIzsX+PNyTz2wINrs2onNxxUZ0Lq7YiM7FFRvRubhiIzoXe7/s5OFjuluZ9qJzccVGdC6u2IjOxRUb2bm4bEOw2bWRnYvLNrJzcdlGdi4u28jOxUWbMFi+WZ/+j+6FzWm6Yx16rD1P11Ko/CiU95jVYaxDz2U25S08dRjr0MNrM9ahh9UmjlWtL7Th2tdVx7Ha1A0Zy5u26ij5+Me5M1cUfbDkhBR9ZOWEFH0Y5oQcqy7eEXKscy73g5yQIpkgx1rtuCPkWKd+2CBPNigr+zYkef2tvNngJLlS1Gwkt4SaTf/g72m2MXGqjZ78ssXfNJ1tNrf4c8HOW/wdfplt8TdFOVOdpEzVKCVnqlrOVI2cqbqRpuriMlU3ZVMd6hM4LA8dosqm+to/gd082ivlylON3ofnwXG9/bAO5jRX/do/gjnn+to/gznn+to/hC+aK7nzXP2LuW6E5hjmj2wT42ojCEU/ZCxkdmQIMjsyr/04f4lM0PNx/rBk4/NPDi9orq+9QXPO9bUHuIve3ct3Uw9zDa3v7qHyHqeMGSodssqMlCUPHWiRiTH75DAjZcnaXEdKh7W50khzdeej34uH3nx3h3C+IDqG/N09VN5jlRkqHbLKMGdJ5ypzPZyLn5cADqfJTPb2tq/9n4pvcdKOdCYs6mXJOa5O+s1THWoddolkm1Md6kxYtOepmvLgiZZruScKmQsNddqsuBRPQ502K091qNNm5am+9pDNOFWSM9WhToaWpzpUtCpPdaiLjMpTlXOKm4aKVsWpOjlpyclJS05OWnJy0tIdNs6821TlpKXBtie803fhzWA7Gd70u/BKLY+tM8jBtq+7IyS+8MQESYD8WcjSNhdmsF307giJ3RmYILE7AxMkUiQTJHIkD2TA7gxMkNidgQkSzeanId2yzYXyMYNEs2GCJEDyQKLZMEGi2TBBotkwQaLZMEGi2VyTI3NI7F7MFMgjmg0TJJoNEySaDRMkAZIHEs2GCRLNhgkSzYYJEs2GCRLNhgcSO2pzQaLZMEEikDNBEiB5IBHImSARyJkgB4s/+nwxqF1fDfrjZpVWDRZSatMdLErUpjvYUmZtuoPlm9p0SdZ0B8sKtekOdkSvTXewhbDadAdbrqpNV1aq0rJSlZaVqrSsVKXHSlVm2QjsMF31crob44v3qLN32Mf8FdkYM09Tm3VJf7YZK6/x2owV7nhtxkqCvDZjxcZLbbxebGL2WWzGSiEX2tB5OE3Zz40ZK7Lw2ojONxUbkmzj9fJZ7MlnNqLzTcVGdL6p2IjONxUb0fmmYjPWGhqrjR1rwY3XRnQurtiIzsUVG9G5uGJDsNm1QS7et0Eu3rdBLt63kZ2L/XLFno8xs5Gdi4s2JDsXl21k5+KyjexcXLaRnYvLNqKP4aQWGzIv1tLzwaX9t60T/bF9CWP5an7rZJ8TZISUfQLxEsjyFUNO9tlGRkgCJA+k6PUaTkjRizuckEiRTJCil404IUWvMTFCejQbJkg0GyZINBsmSDSbTciTDcFm1wb9Y98GlWLfBi1h3wbBf99GdpanZWcdctl1BoPdZ4jXRnbiLtvIDtFlG9m5uGxDsNm1kZ2Lyzayc3HZRnYuLtvIzsVlG+TiXZvB7lLDa4NcvG+D790/2+TfLR/s9jC8NgSbXRs52e80XTlx7jRdOQntNF05oes43QknWzfXpfPBxevDB7uRw00va1bn3Q11Donza0yQOBnHBIkzdz8NWfzGwmA3crgbJA12i4g7QuKSPSZIpEgmSORIJkgCJA8kLgZkgkSz+WlIt1zWrHzMINFsmCDRbJgg0Wx4IAe7TcsdIdFsmCDRbJgg0WyuyZEbkARIlkAu+3Y4nJBoNkyQaDZMkGg2TJBoNjyQBs2GCRLNhgkSzYYJEs2GCZIAyQOJZsMEiUDOBIlAzgSJQM4DKfsGVZyQ1fjjgytDTma+jewU9GqqW2O1W245u/4mijJbjxuW/bGm4G0Fxcb5FR9+OMokJkS3/JhMU8UvBjO/5Djp8uDSVeZUv8kRqH+eunzdL9XvfgNsPuwI7H7YE7A5sYuHx/oNf4DNh62B3Q/bALsfNlJ2R2wCdj9sB+x+2B7Y/bDRIFmxi9cXEhpkR2w0yH7YDg2yIzYaZEdsNMiO2GiQHbEJ2DfK2RvYaJD9So1Dg+yIjQbZERsNsiM2GmQ/bI8G2REbDbIjNhpkR2w0yI7YBOx+2GiQHbHRIDtio9R0xEap6YcdUGo6YqPUdMQmgdjWLLOz+TdfgsSFULv8SBkbVUYi8cheIZF4/C2TRIlHyQqJxGNZhUTiMlqFROJiV4WEQJKSSFw4qpBIXN6pkCC9ZiRIrxkJ0mtKMiG9ZiRIrxkJ0mtGIjK9uriQhNoSnF5ehdaeMj+CX9nPLOt12lDI/ETmYkY/kSGa0U9k4mb0ExnPL/Lzy0s2MT1+OCUypV3iR+cN62gKmZ/ISMfoh/zX5kfwK/t5vRw/PPnMD/mvzQ/5r80P+a/ND/mvzU/kWi6fnxa58Mvoh/7R5of+0eaH/tHmR/Br8kP/aPND/2jzQ/9o80P/qPn55SsEPsbMD/2jyc+gf7T5oX+0+aF/tPmhf7T5Ib9U/C65g1bppk7O4lDDSF3+aqWzOC51xMZBjBO7eMWiE3kbvrthE7D7YWMtryM2Fv46YiNld8TGkmJHbKw/9sMWeYvJu2GjQXbERoPsiI0GeTX2yY/g1+SHntfmh+rW5oc21uaHgtXmh85U8yO7+LnsmiGR90nk9EOzafNDWWnzQ/9o8yP4Nfmhf7T5oX+0+aF/tPmhf7T5oX80+Ym8yx6nH/pHmx/6R82vuOeLyNvbcfoR/Jr8kJ8zEkTijAQpNyNBcE1JArJA7bOY6/s7AbGBkVorpebBSufYOEZ2xMbRtyM2juus2MVvpsm8UdydsGXegu5e2FhE64iNlN0RGzm7IzYBux82LjzoiI0GyYrtlq+UKJ9tIyPzxof3wkaD7IiNBtkPW+ZtIO+FjQbZERsNsiM2GuStcvYGNgG7W6nB7TZ7YqNBdsRGg+yIjQbZERsNshu2V2iQHbHRIDtio0F2xEaD7IhNwO6HjQbZERulpiM2Sk1HbJSafti4SW4v7O+H3/3v3efHd+8/fvhy+DvHP/zn6fevj5+enn/79f9///iTw+B/AQ==",
      "brillig_names": ["get_service_index"],
      "assert_messages": {
        "442": "Array index out of bounds",
        "113": "Storage slot 0 not allowed. Storage slots must start from 1.",
        "430": "attempt to add with overflow",
        "296": "attempt to add with overflow",
        "610": "attempt to add with overflow",
        "409": "Array index out of bounds",
        "275": "Array index out of bounds",
        "589": "Array index out of bounds",
        "458": "Array index out of bounds",
        "327": "Array index out of bounds",
        "254": "attempt to add with overflow",
        "507": "Array index out of bounds",
        "309": "Array index out of bounds",
        "489": "Array index out of bounds",
        "471": "attempt to add with overflow",
        "20": "Function get_service_index can only be called statically",
        "401": "Array index out of bounds",
        "267": "Array index out of bounds",
        "389": "attempt to add with overflow",
        "450": "Array index out of bounds",
        "581": "Array index out of bounds",
        "569": "attempt to add with overflow",
        "243": "Array index out of bounds",
        "417": "Array index out of bounds",
        "283": "Array index out of bounds",
        "341": "attempt to add with overflow",
        "597": "Array index out of bounds",
        "15": "Not initialized",
        "521": "attempt to add with overflow"
      }
    },
    {
      "name": "get_total_score",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {},
        "parameters": [
          {
            "name": "address",
            "type": {
              "fields": [{ "name": "inner", "type": { "kind": "field" } }],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": { "kind": "integer", "sign": "unsigned", "width": 64 },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["get_total_score"]
    },
    {
      "name": "is_verified",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {},
        "parameters": [
          {
            "name": "address",
            "type": {
              "fields": [{ "name": "inner", "type": { "kind": "field" } }],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "service_id",
            "type": { "kind": "integer", "sign": "unsigned", "width": 64 },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": { "kind": "boolean" },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["is_verified"]
    },
    {
      "name": "set_admin",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {},
        "parameters": [
          {
            "name": "new_admin",
            "type": {
              "fields": [{ "name": "inner", "type": { "kind": "field" } }],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "JAAEAQIlAAQIRAAAJAAEAQQkAAQABR8AAAAABQAAAAQAAAhDKwAIQwADIgAAAAg5AAAACEQAAAAAHgAAAAUeAAAABjAAAAAABQAAAAYAAAAHJAACAQUKAAIHBQYhAAAPAAY6AQAAKgAABSQABAIHAAAEAAcAJAEEAQUAAAQFAgcqAAcGJAAHAAgqAggGKgEFBwAABAcCByoCBwUqAAAHAAAEAAIAKgIFByQABAAFJAAHAQgkAAQBBioABQQgACIKAAQEBQkhAABKAAkgACUqAQcJAAAECQIKAAAECgULKgELBx4AAgAJCgAHBwkKIQAALQAKOgEAACoABQQgAC8KAAQEBQchAAAzAAcgADIjHAAHBAcAAAcIBwkqAAAHJAAEAgoAAAQACgAkAQQBBwAABAcCCioACgsqAgMLJAAEAQsMAAQECwwhAABAAAw6AQAAAAAEBwIMAAAEDAQLKgELCi0AAAAACgAAAAkAAAQEBgkOAAQECQohAABIAAo6AQAAKgAJBCAALyoBBwkcAAcECgAABwgKCywAAAAACwAAAAokAAQBDAwABAQMDSEAAFIADToBAAArAAAJCAMlAAQAAggEIgAAAGArAAgFAAsAAAQLAg0AAAQNBAwqAgoMAAAEBAYJDgAEBAkKIQAAXQAKOgEAACoCCwcqAAkEIAAiKwEIAwgGCwAECAYAAggHIQAAZAgHIABmKwAIAwgFIAB0KwAAAAgFAQAEAAAIBAAAJQAEAAAICQ0ABAgJCAQIChcACAoICiEAAHIICgEABAgDCAkICysBCAsICAEABAgFCAkICysCCAgICwEABAgJAAIICSAAaSUBBAABCAUgAHQjKwAYyhjK",
      "debug_symbols": "1Zthb9owEIb/Sz7zwXe2z3f9K9NUQQtVJAQV0EkT4r8v6bDJ0syR2jHdfUEEXvueJJe88dk5N8/r1dvLY7vb7I/Nw7dzs90/LU/tftdtnS+LZnVot9v25XH4c+P6D36XH1+Xu37reFoeTs0DJAyLZr177r/60HWwabfr5iHBZfFBLD5dtRJTkUKkCW1AkKs4IHJRS5wQE4O/iolRhuLvi0a+DA4OitgNxHdHB/f1g55y/yJzBx0wZDGgSJ2cIWYKhkHXV3L4h+TdQf8TvQ+A9w7g7x0g3DtAnAzgE+VGXmYzP3EWdyFuEZJMqKNQzvwo4ur5E5OHLE4ex/lDhtmTYXY2zC522dEZZgfD7GiY3RtmD4bZDfsqGvZVNOyraNhXvfJrNXJhj+MRlFeeMykUdnZj9v+fM2VIR87FOjs4oVvXN7F38g4vhuGDsww//TgWnMuNAnAdPnjGXMLwc0lMQoVd0vgCDLMPWF29ZEjTt/GfaBM+0Wb65hBSKm2EZk4zEpaSCfPMaSYPuWvyfqbAQl3fWQw4LrBE0M2eoLAzjNlRN3ukCrvXzc6lnAgyNvIYDLNHw+xkmF35PbLKzobZxS47OcPsyn21yq7cV6vshn2VDPsqGfZVMuyrpNxXA97YfV3cjV1vE/vM4x1VbsJ/3dGeXbkJ19iTchOusis34Sp7sFstTbpnNhhKlZpxPDBPymc2Ss1uil15lboYWceOM2bQ1Q6zGYT0YUeVT4PUyvFJ+fKCGjsrX15QZVe+vKDKrnx5QZVd+fKCKrtyE66yK19eUGVXbsJVdsNTxWzYV9mwr4phXxXDviqGfVXM+uql2/qxPLTL1XZ9fV9k87Z7Grw+cvr5+vufTvwL",
      "brillig_names": ["set_admin"],
      "assert_messages": {
        "81": "Array index out of bounds",
        "63": "Array index out of bounds",
        "92": "attempt to add with overflow",
        "44": "Aztec Passport: Unauthorized Admin Change",
        "71": "attempt to add with overflow",
        "14": "Not initialized"
      }
    },
    {
      "name": "get_service",
      "is_unconstrained": true,
      "custom_attributes": ["public", "view"],
      "abi": {
        "error_types": {},
        "parameters": [
          {
            "name": "service_id",
            "type": { "kind": "integer", "sign": "unsigned", "width": 64 },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "address",
                "type": {
                  "fields": [{ "name": "inner", "type": { "kind": "field" } }],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              },
              {
                "name": "weight",
                "type": { "kind": "integer", "sign": "unsigned", "width": 64 }
              },
              {
                "name": "base_score",
                "type": { "kind": "integer", "sign": "unsigned", "width": 64 }
              },
              {
                "name": "max_score",
                "type": { "kind": "integer", "sign": "unsigned", "width": 64 }
              }
            ],
            "kind": "struct",
            "path": "service::Service"
          },
          "visibility": "public"
        }
      },
      "bytecode": "JAAEAQIlAAQISAAAJAAEAQQkAAQABR8AAAAABQAAAAQAAAhDHQAFCEMIQysACEMAAyIAAAANKwAAAwhEKwAABAhFKwAABQhGKwAABghHOQAAAAhEAAAABB4AAAAFHgAAAAYwAAAAAAUAAAAGAAAAByQAAgEGCgACBwYFIQAAFAAFOgEAAB4ACwAHJAAHAQYKAAcHBgUhAAAZAAU6AQAAHAAHAwYkAAcAAyoAAAckAAQEBQAABAAFACQBBAEHAAAEBwIFKgAFCCoCAwgAAAQIAggqAgMIAAAECAIIKgIDCCoBBwUAAAQFAgUqAgUHKgEHBQAABAUCBSoCBQcqAQcFAAAEBQIFKgIFByoBBwUAAAQFAgUqAgUHKgAABQAABAACACoCBwUqAAAHJAAEBQgAAAQACAAkAQQBBwAABAcCCCoACAkqAgMJAAAECQIJKgIDCQAABAkCCSoCAwkAAAQJAgkoAAcAAAAAAAAAAgAAAAAAAAAAAAoqAgoJKgEHCAAABAgCCCoCCAcqAAAIAAAEAAIAKgIHCCoAAAcAAAQAAgAkAAQACioCCgcqAAAJAAAEAAIAJAABAAsqAgsJJAAHAwwkAAQEDSQABAMOJAAEAg8kAAQBECoACgQgAFgMAAQEDxEhAADpABEgAFsqAQkGCgABBgsEIQAAXwAEOgEAACoACgwgAGEMAAQMDgYhAADAAAYgAGQqAQgHKgAABiQABAUFAAAEAAUAJAEEAQYAAAQHAgUkAAQEBAAABAYCET4DAAAABQAAABEqAgYIJAABAQgqAggJAAAEBgIIAAAECAoHKgEHCQoABwkDBgoAAQYLCCEAAHcACDoBAAAqAAALJAAEBQYAAAQABgAkAQQBCwAABAsCBioABggqAgMIAAAECAIIKgIDCAAABAgCCCoCAwgAAAQIAggqAgMIKgELBgAABAYCBioCBgsqAAAGAAAEAAIAKgILBioACgwgAIwMAAQMDQshAACqAAsgAI8qAQYNAAAEDQIMAAAEDAoLKgELBgAABA0CDAAABAwQCyoBCwocAAUKDBwABwwQHAAFEAoAAAQNAgwAAAQMDwsqAQsQHAAFEAwcAAcMDxwABQ8QAAAEDQIMAAAEDA4LKgELDxwABQ8NHAAHDQ4cAAUODyoAEAUqAAoEKgAGAyoADwYjKgEGCxwABwwIAAAHCQgHLAAAAAAHAAAACCQABAQFDAAEDAUEIQAAsgAEOgEAACsAAAsIAyUABAAFCAQiAAABdCsACAUABwAABAcCBAAABAQMBSoCCAUAAAQMEAsOAAQMCwghAAC9AAg6AQAAKgIHBioACwwgAIwqAQcGDAAEDAYEIQAAxAAEIADjKgEIBioBCAQkAAQEEgwABAwSEyEAAMoAEzoBAAAAAAQEAhMAAAQTDBIqARIRKgEFBCQABAMSDAAEDBIUIQAA0gAUOgEAAAAABAQCFAAABBQMEioBEhMAAAcREwQkAAQEEwwABAwTFCEAANoAFDoBAAArAAAGCAMlAAQABQgEIgAAAXQrAAgFABEAAAQRAhQAAAQUDBMqAgQTKgIRCCAA4wAABAwQBg4ABAwGBCEAAOcABDoBAAAqAAYMIABhDAAEBA8RIQAA7AARIAFFKgAAESQABAMSAAAEABIAJAEEAREAAAQRAhIqABITKgIMEwAABBMCEyoCBhMkAAQCEwwABAQTFCEAAPkAFDoBAAAAAAQRAhQAAAQUBBMqARMSKgEJEQoAARELFCEAAQAAFDoBAAAqAQcRCgAEEQ4UIQABHAAUIAEEKgEFESoBBxMqAQcUJAAEAxYMAAQUFhchAAELABc6AQAAKwAAEQgDJQAEAAQIBCIAAAF0KwAIBQAVAAAEFQIXAAAEFxQWKgISFioBFRQAAAQUAhQqAhQVAAAEExAUDgAEExQRIQABGQAROgEAACoCFQUqAhQHIAFFKgAKESABHgwABBEOEyEAAUsAEyABISoBBREqAQgTKgAAFCQABAUVAAAEABUAJAEEARQAAAQTAhUkAAQEFgAABBQCFz4DAAAAFQAAABcqARETAgAEEwITKgITESoBERMAAAQTAhMqAhMRKgEUEwAABBMCEyoCExQrAAARCAMlAAQABAgEIgAAAXQrAAgFABMAAAQTAhcAAAQXChYqAhIWKgETEgAABBICEioCEhMqARQSAAAEEgISKgISFCoCEwUqAhQIKgIQByABRQAABAQQEQ4ABAQREiEAAUkAEjoBAAAqABEEIABYKgEHEwwABBETFCEAAU8AFCABbioBCBMqAQgUJAAEBBYMAAQRFhchAAFVABc6AQAAAAAEFAIXAAAEFxEWKgEWFSoBBRQkAAQDFgwABBEWGCEAAV0AGDoBAAAAAAQUAhgAAAQYERYqARYXAAAHFRcUJAAEBBUMAAQRFRghAAFlABg6AQAAKwAAEwgDJQAEAAUIBCIAAAF0KwAIBQAXAAAEFwIYAAAEGBEVKgIUFSoCFwggAW4AAAQREBMOAAQRExQhAAFyABQ6AQAAKgATESABHisBCAMIBgsABAgGAAIIByEAAXgIByABeisACAMIBSABiCsAAAAIBQEABAAACAQAACUABAAACAkNAAQICQgECAoXAAgKCAohAAGGCAoBAAQIAwgJCAsrAQgLCAgBAAQIBQgJCAsrAggICAsBAAQICQACCAkgAX0lAQQAAQgFIAGIIysAGMoYyg==",
      "debug_symbols": "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",
      "brillig_names": ["get_service"],
      "assert_messages": {
        "340": "Array index out of bounds",
        "209": "Array index out of bounds",
        "177": "Array index out of bounds",
        "369": "attempt to add with overflow",
        "328": "attempt to add with overflow",
        "188": "attempt to add with overflow",
        "217": "Array index out of bounds",
        "118": "Storage slot 0 not allowed. Storage slots must start from 1.",
        "19": "Not initialized",
        "348": "Array index out of bounds",
        "266": "Array index out of bounds",
        "356": "Array index out of bounds",
        "24": "Function get_service can only be called statically",
        "248": "Array index out of bounds",
        "280": "attempt to add with overflow",
        "201": "Array index out of bounds",
        "230": "attempt to add with overflow"
      }
    },
    {
      "name": "get_all_verified",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {},
        "parameters": [
          {
            "name": "address",
            "type": {
              "fields": [{ "name": "inner", "type": { "kind": "field" } }],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 10,
            "type": {
              "fields": [
                {
                  "name": "address",
                  "type": {
                    "fields": [
                      { "name": "inner", "type": { "kind": "field" } }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                  }
                },
                {
                  "name": "weight",
                  "type": { "kind": "integer", "sign": "unsigned", "width": 64 }
                },
                {
                  "name": "base_score",
                  "type": { "kind": "integer", "sign": "unsigned", "width": 64 }
                },
                {
                  "name": "max_score",
                  "type": { "kind": "integer", "sign": "unsigned", "width": 64 }
                }
              ],
              "kind": "struct",
              "path": "service::Service"
            }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["get_all_verified"]
    },
    {
      "name": "add_service",
      "is_unconstrained": true,
      "custom_attributes": ["public"],
      "abi": {
        "error_types": {},
        "parameters": [
          {
            "name": "address",
            "type": {
              "fields": [{ "name": "inner", "type": { "kind": "field" } }],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "weight",
            "type": { "kind": "integer", "sign": "unsigned", "width": 64 },
            "visibility": "private"
          },
          {
            "name": "base_score",
            "type": { "kind": "integer", "sign": "unsigned", "width": 64 },
            "visibility": "private"
          },
          {
            "name": "max_score",
            "type": { "kind": "integer", "sign": "unsigned", "width": 64 },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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BAgEIgAAEk8rAAgFACgAAAQoAiwAAAQsCCsqAiYrKgEoJgAABCYCJioCJigqASkmAAAEJgImKgImKSoCKBIqAikPKgIMDiAMyQAABCEMJg4ABCEmJyEADM0AJzoBAAAqACYhIANjKgEOKAwABCcoKSEADNMAKSAM8ioBDygqAQ8pJAAEBCsMAAQnKywhAAzZACw6AQAAAAAEKQIsAAAELCcrKgErKioBEikkAAQDKwwABCcrLSEADOEALToBAAAAAAQpAi0AAAQtJysqASssAAAHKiwpJAAEBCoMAAQnKi0hAAzpAC06AQAAKwAAKAgDJQAEAAUIBCIAABJPKwAIBQAsAAAELAItAAAELScqKgIpKioCLA8gDPIAAAQnDCgOAAQnKCkhAAz2ACk6AQAAKgAoJyAMohwAByEmAAAHByYlKgAAJiQABAISAAAEABIAJAEEASYAAAQmAhIqABIPKgInDyQABAEPDAAEIQ8OIQANBQAOOgEAAAAABCYCDgAABA4hDyoBDxItAAAAABIAAAAlAAAEIQwlDgAEISUSIQANDQASOgEAACoAJSEgAzIqAQ4lDAAEISUmIQANEwAmIA0yKgEPJSoBDyYkAAQEKAwABCEoKSEADRkAKToBAAAAAAQmAikAAAQpISgqASgnKgESJiQABAMoDAAEISgqIQANIQAqOgEAAAAABCYCKgAABCohKCoBKCkAAAcnKSYkAAQEJwwABCEnKiEADSkAKjoBAAArAAAlCAMlAAQABQgEIgAAEk8rAAgFACkAAAQpAioAAAQqIScqAiYnKgIpDyANMgAABCEMJQ4ABCElJiEADTYAJjoBAAAqACUhIAMBJAAEASYMAAQhJichAA08ACc6AQAAAAAEBAInAAAEJyEmKgEmJSoBBycKAAEnFSYhAA1DACY6AQAAKgEOJwoABCcWJiEADV8AJiANRyoBEiYqAQ4nKgEOKCQABAMqDAAEKCorIQANTgArOgEAACsAACYIAyUABAAECAQiAAASTysACAUAKQAABCkCKwAABCsoKioCJSoqASkoAAAEKAIoKgIoKQAABCcMKA4ABCcoJiEADVwAJjoBAAAqAikSKgIoDiANiCoACCYgDWEMAAQmFichAA2OACcgDWQqARImKgEPJyoAACgkAAQFKQAABAApACQBBAEoAAAEJwIpJAAEBCoAAAQoAis+AwAAACkAAAArKgEmJwIABCcCJyoCJyYqASYnAAAEJwInKgInJioBKCcAAAQnAicqAicoKwAAJggDJQAEAAQIBCIAABJPKwAIBQAnAAAEJwIrAAAEKwgqKgIlKioBJyUAAAQlAiUqAiUnKgEoJQAABCUCJSoCJSgqAicSKgIoDyoCDA4gDYgAAAQhDCUOAAQhJSYhAA2MACY6AQAAKgAlISAC+CoBDicMAAQmJyghAA2SACggDbEqAQ8nKgEPKCQABAQqDAAEJiorIQANmAArOgEAAAAABCgCKwAABCsmKioBKikqARIoJAAEAyoMAAQmKiwhAA2gACw6AQAAAAAEKAIsAAAELCYqKgEqKwAABykrKCQABAQrDAAEJissIQANqAAsOgEAACsAACcIAyUABAAFCAQiAAASTysACAUAKQAABCkCLAAABCwmKyoCKCsqAikPIA2xAAAEJgwnDgAEJicoIQANtQAoOgEAACoAJyYgDWEcAAchJQAABxIlJioAACUkAAQEJwAABAAnACQBBAElAAAEJQInKgAnKCoCDigAAAQoAigqAgcoAAAEKAIoKgIPKCQABAMoDAAEISgpIQANyAApOgEAAAAABCUCKQAABCkhKCoBKCctAAAAACcAAAAmAAAEIQwnDgAEIScmIQAN0AAmOgEAACoAJyEgAtIqAQ8lDAAEISUmIQAN1gAmIA31KgEHJSoBByYkAAQEKAwABCEoKSEADdwAKToBAAAAAAQmAikAAAQpISgqASgnKgEOJiQABAMoDAAEISgqIQAN5AAqOgEAAAAABCYCKgAABCohKCoBKCkAAAcnKSYkAAQEKQwABCEpKiEADewAKjoBAAArAAAlCAMlAAQABQgEIgAAEk8rAAgFACcAAAQnAioAAAQqISkqAiYpKgInByAN9QAABCEMJQ4ABCElJiEADfkAJjoBAAAqACUhIAK8JAAEASYMAAQhJichAA3/ACc6AQAAAAAEBAInAAAEJyEmKgEmJSoBEicKAAEnFSYhAA4GACY6AQAAKgEPJwoABCcWJiEADiIAJiAOCioBDiYqAQ8nKgEPKCQABAMqDAAEKCorIQAOEQArOgEAACsAACYIAyUABAAECAQiAAASTysACAUAKQAABCkCKwAABCsoKioCJSoqASklAAAEJQIlKgIlKQAABCcMJQ4ABCclKCEA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",
      "debug_symbols": "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",
      "brillig_names": ["add_service"],
      "assert_messages": {
        "3962": "Array index out of bounds",
        "2158": "Array index out of bounds",
        "811": "attempt to add with overflow",
        "2670": "Array index out of bounds",
        "2725": "Array index out of bounds",
        "3804": "attempt to add with overflow",
        "921": "attempt to add with overflow",
        "2701": "Array index out of bounds",
        "3914": "attempt to add with overflow",
        "4103": "Array index out of bounds",
        "4292": "attempt to add with overflow",
        "2945": "attempt to add with overflow",
        "2488": "Array index out of bounds",
        "2543": "Array index out of bounds",
        "1574": "attempt to add with overflow",
        "2086": "Array index out of bounds",
        "794": "attempt to multiply with overflow",
        "337": "Storage slot 0 not allowed. Storage slots must start from 1.",
        "1873": "attempt to add with overflow",
        "904": "attempt to multiply with overflow",
        "1928": "Array index out of bounds",
        "2306": "attempt to add with overflow",
        "3196": "Array index out of bounds",
        "2361": "Array index out of bounds",
        "3062": "Array index out of bounds",
        "1770": "Array index out of bounds",
        "1959": "Array index out of bounds",
        "3495": "Array index out of bounds",
        "4062": "Array index out of bounds",
        "2203": "Array index out of bounds",
        "1880": "attempt to add with overflow",
        "2904": "attempt to add with overflow",
        "3093": "Array index out of bounds",
        "1935": "Array index out of bounds",
        "3148": "attempt to add with overflow",
        "2179": "attempt to add with overflow",
        "2691": "attempt to add with overflow",
        "1722": "Array index out of bounds",
        "1832": "attempt to add with overflow",
        "3368": "Array index out of bounds",
        "3880": "Array index out of bounds",
        "3935": "Array index out of bounds",
        "2588": "Array index out of bounds",
        "2265": "attempt to add with overflow",
        "3100": "Array index out of bounds",
        "4124": "attempt to add with overflow",
        "4234": "Array index out of bounds",
        "2564": "attempt to add with overflow",
        "1784": "attempt to add with overflow",
        "2217": "attempt to add with overflow",
        "3753": "Array index out of bounds",
        "3296": "Array index out of bounds",
        "4320": "Array index out of bounds",
        "2138": "attempt to add with overflow",
        "2650": "attempt to add with overflow",
        "3674": "Array index out of bounds",
        "2760": "Array index out of bounds",
        "4351": "Array index out of bounds",
        "4083": "attempt to add with overflow",
        "554": "call to assert_max_bit_size",
        "2602": "attempt to add with overflow",
        "3169": "Array index out of bounds",
        "3547": "Array index out of bounds",
        "2712": "attempt to add with overflow",
        "1743": "attempt to add with overflow",
        "3980": "Array index out of bounds",
        "1475": "attempt to add with overflow",
        "2932": "Array index out of bounds",
        "3956": "attempt to add with overflow",
        "4633": "Array index out of bounds",
        "269": "Storage slot 0 not allowed. Storage slots must start from 1.",
        "1994": "Array index out of bounds",
        "4042": "attempt to add with overflow",
        "1860": "Array index out of bounds",
        "2293": "Array index out of bounds",
        "3317": "attempt to add with overflow",
        "2860": "Array index out of bounds",
        "1702": "attempt to add with overflow",
        "1891": "Array index out of bounds",
        "4451": "Array index out of bounds",
        "1946": "attempt to add with overflow",
        "3994": "attempt to add with overflow",
        "1300": "attempt to add with overflow",
        "4506": "Array index out of bounds",
        "3214": "Array index out of bounds",
        "4482": "Array index out of bounds",
        "2166": "Array index out of bounds",
        "2678": "Array index out of bounds",
        "3190": "attempt to add with overflow",
        "2733": "Array index out of bounds",
        "1898": "Array index out of bounds",
        "4111": "Array index out of bounds",
        "3276": "attempt to add with overflow",
        "2551": "Array index out of bounds",
        "1582": "attempt to add with overflow",
        "2094": "Array index out of bounds",
        "2472": "Array index out of bounds",
        "4142": "Array index out of bounds",
        "3228": "attempt to add with overflow",
        "3527": "Array index out of bounds",
        "2881": "attempt to add with overflow",
        "3582": "Array index out of bounds",
        "4472": "attempt to add with overflow",
        "1967": "Array index out of bounds",
        "2345": "Array index out of bounds",
        "3046": "Array index out of bounds",
        "4070": "Array index out of bounds",
        "2778": "Array index out of bounds",
        "3479": "Array index out of bounds",
        "4369": "Array index out of bounds",
        "1730": "Array index out of bounds",
        "2754": "attempt to add with overflow",
        "3943": "Array index out of bounds",
        "2840": "attempt to add with overflow",
        "3352": "Array index out of bounds",
        "3864": "Array index out of bounds",
        "4242": "Array index out of bounds",
        "4431": "attempt to add with overflow",
        "2115": "attempt to add with overflow",
        "4541": "Array index out of bounds",
        "2792": "attempt to add with overflow",
        "3304": "Array index out of bounds",
        "3682": "Array index out of bounds",
        "799": "attempt to add with overflow",
        "2012": "Array index out of bounds",
        "3737": "Array index out of bounds",
        "4383": "attempt to add with overflow",
        "4304": "Array index out of bounds",
        "909": "attempt to add with overflow",
        "4493": "attempt to add with overflow",
        "1988": "attempt to add with overflow",
        "3713": "Array index out of bounds",
        "50": "Aztec Passport: Only Admin",
        "1586": "attempt to add with overflow",
        "3177": "Array index out of bounds",
        "3555": "Array index out of bounds",
        "2074": "attempt to add with overflow",
        "1483": "attempt to add with overflow",
        "624": "attempt to add with overflow",
        "2026": "attempt to add with overflow",
        "4263": "attempt to add with overflow",
        "2916": "Array index out of bounds",
        "1569": "attempt to multiply with overflow",
        "4641": "Array index out of bounds",
        "2325": "Array index out of bounds",
        "2380": "Array index out of bounds",
        "4160": "Array index out of bounds",
        "4672": "Array index out of bounds",
        "3703": "attempt to add with overflow",
        "1844": "Array index out of bounds",
        "2868": "Array index out of bounds",
        "4459": "Array index out of bounds",
        "3112": "attempt to add with overflow",
        "2277": "Array index out of bounds",
        "4514": "Array index out of bounds",
        "3600": "Array index out of bounds",
        "2954": "Array index out of bounds",
        "3332": "Array index out of bounds",
        "4222": "attempt to add with overflow",
        "3387": "Array index out of bounds",
        "3576": "attempt to add with overflow",
        "2741": "Array index out of bounds",
        "2150": "Array index out of bounds",
        "2662": "Array index out of bounds",
        "3662": "attempt to add with overflow",
        "4174": "attempt to add with overflow",
        "4095": "Array index out of bounds",
        "3772": "Array index out of bounds",
        "4284": "Array index out of bounds",
        "2102": "Array index out of bounds",
        "4662": "attempt to add with overflow",
        "2480": "Array index out of bounds",
        "2535": "Array index out of bounds",
        "3614": "attempt to add with overflow",
        "1487": "attempt to add with overflow",
        "2511": "Array index out of bounds",
        "3535": "attempt to add with overflow",
        "3724": "attempt to add with overflow",
        "4559": "Array index out of bounds",
        "1975": "Array index out of bounds",
        "4535": "attempt to add with overflow",
        "2353": "Array index out of bounds",
        "3054": "Array index out of bounds",
        "3487": "Array index out of bounds",
        "4054": "Array index out of bounds",
        "2896": "Array index out of bounds",
        "4621": "attempt to add with overflow",
        "1470": "attempt to multiply with overflow",
        "1714": "Array index out of bounds",
        "3360": "Array index out of bounds",
        "3872": "Array index out of bounds",
        "4250": "Array index out of bounds",
        "3927": "Array index out of bounds",
        "20": "Not initialized",
        "1233": "call to assert_max_bit_size",
        "4573": "attempt to add with overflow",
        "4683": "attempt to add with overflow",
        "2501": "attempt to add with overflow",
        "3903": "Array index out of bounds",
        "1910": "attempt to add with overflow",
        "3690": "Array index out of bounds",
        "807": "attempt to add with overflow",
        "3745": "Array index out of bounds",
        "2398": "Array index out of bounds",
        "1752": "Array index out of bounds",
        "917": "attempt to add with overflow",
        "2130": "Array index out of bounds",
        "3288": "Array index out of bounds",
        "4312": "Array index out of bounds",
        "2185": "Array index out of bounds",
        "2374": "attempt to add with overflow",
        "3075": "attempt to add with overflow",
        "3130": "Array index out of bounds",
        "3508": "attempt to add with overflow",
        "3563": "Array index out of bounds",
        "2460": "attempt to add with overflow",
        "2972": "Array index out of bounds",
        "3161": "Array index out of bounds",
        "3405": "Array index out of bounds",
        "1034": "attempt to add with overflow",
        "2570": "Array index out of bounds",
        "3082": "attempt to add with overflow",
        "3137": "Array index out of bounds",
        "3381": "attempt to add with overflow",
        "3893": "attempt to add with overflow",
        "2412": "attempt to add with overflow",
        "2924": "Array index out of bounds",
        "4649": "Array index out of bounds",
        "2333": "attempt to add with overflow",
        "2522": "attempt to add with overflow",
        "3034": "attempt to add with overflow",
        "3790": "Array index out of bounds",
        "3467": "attempt to add with overflow",
        "1852": "Array index out of bounds",
        "3766": "attempt to add with overflow",
        "2285": "Array index out of bounds",
        "2986": "attempt to add with overflow",
        "4333": "attempt to add with overflow",
        "2852": "Array index out of bounds",
        "4522": "Array index out of bounds",
        "1694": "Array index out of bounds",
        "3419": "attempt to add with overflow",
        "4443": "Array index out of bounds",
        "3340": "attempt to add with overflow",
        "3852": "attempt to add with overflow"
      }
    },
    {
      "name": "get_service_index_private",
      "is_unconstrained": false,
      "custom_attributes": ["private", "view"],
      "abi": {
        "error_types": {},
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            { "name": "inner", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "storage_contract_address",
                        "type": {
                          "fields": [
                            { "name": "inner", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_delegate_call",
                        "type": { "kind": "boolean" }
                      },
                      {
                        "name": "is_static_call",
                        "type": { "kind": "boolean" }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            { "name": "root", "type": { "kind": "field" } },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            { "name": "num_txs", "type": { "kind": "field" } },
                            {
                              "name": "txs_effects_hash",
                              "type": { "kind": "field" }
                            },
                            { "name": "in_hash", "type": { "kind": "field" } },
                            { "name": "out_hash", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": { "kind": "field" }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": { "kind": "field" }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": { "kind": "field" }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": { "kind": "field" }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            { "name": "chain_id", "type": { "kind": "field" } },
                            { "name": "version", "type": { "kind": "field" } },
                            {
                              "name": "block_number",
                              "type": { "kind": "field" }
                            },
                            {
                              "name": "slot_number",
                              "type": { "kind": "field" }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": { "kind": "field" }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      { "name": "total_fees", "type": { "kind": "field" } }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::header::Header"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      { "name": "chain_id", "type": { "kind": "field" } },
                      { "name": "version", "type": { "kind": "field" } },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": { "kind": "field" }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "inclusion_fee",
                              "type": { "kind": "field" }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": { "kind": "integer", "sign": "unsigned", "width": 32 }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          },
          {
            "name": "address",
            "type": {
              "fields": [{ "name": "inner", "type": { "kind": "field" } }],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          { "name": "inner", "type": { "kind": "field" } }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "storage_contract_address",
                      "type": {
                        "fields": [
                          { "name": "inner", "type": { "kind": "field" } }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_delegate_call",
                      "type": { "kind": "boolean" }
                    },
                    { "name": "is_static_call", "type": { "kind": "boolean" } }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              { "name": "args_hash", "type": { "kind": "field" } },
              { "name": "returns_hash", "type": { "kind": "field" } },
              {
                "name": "min_revertible_side_effect_counter",
                "type": { "kind": "integer", "sign": "unsigned", "width": 32 }
              },
              { "name": "is_fee_payer", "type": { "kind": "boolean" } },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          { "name": "_is_some", "type": { "kind": "boolean" } },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  { "name": "x", "type": { "kind": "field" } },
                                  { "name": "y", "type": { "kind": "field" } },
                                  {
                                    "name": "is_infinite",
                                    "type": { "kind": "boolean" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            { "name": "sk_app", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": { "kind": "field" }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      { "name": "note_hash", "type": { "kind": "field" } }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "fields": [
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            { "name": "inner", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "storage_contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_delegate_call",
                              "type": { "kind": "boolean" }
                            },
                            {
                              "name": "is_static_call",
                              "type": { "kind": "boolean" }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      { "name": "args_hash", "type": { "kind": "field" } },
                      { "name": "returns_hash", "type": { "kind": "field" } },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            { "name": "inner", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "storage_contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_delegate_call",
                              "type": { "kind": "boolean" }
                            },
                            {
                              "name": "is_static_call",
                              "type": { "kind": "boolean" }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      { "name": "args_hash", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          { "name": "inner", "type": { "kind": "field" } }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "call_context",
                      "type": {
                        "fields": [
                          {
                            "name": "msg_sender",
                            "type": {
                              "fields": [
                                { "name": "inner", "type": { "kind": "field" } }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "storage_contract_address",
                            "type": {
                              "fields": [
                                { "name": "inner", "type": { "kind": "field" } }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "function_selector",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                            }
                          },
                          {
                            "name": "is_delegate_call",
                            "type": { "kind": "boolean" }
                          },
                          {
                            "name": "is_static_call",
                            "type": { "kind": "boolean" }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                      }
                    },
                    { "name": "args_hash", "type": { "kind": "field" } },
                    {
                      "name": "counter",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            { "name": "inner", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      { "name": "content", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": { "kind": "integer", "sign": "unsigned", "width": 32 }
              },
              {
                "name": "end_side_effect_counter",
                "type": { "kind": "integer", "sign": "unsigned", "width": 32 }
              },
              {
                "name": "note_encrypted_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      { "name": "length", "type": { "kind": "field" } },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::NoteLogHash"
                  }
                }
              },
              {
                "name": "encrypted_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      { "name": "length", "type": { "kind": "field" } },
                      { "name": "randomness", "type": { "kind": "field" } }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::EncryptedLogHash"
                  }
                }
              },
              {
                "name": "unencrypted_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      { "name": "length", "type": { "kind": "field" } }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          { "name": "root", "type": { "kind": "field" } },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          { "name": "num_txs", "type": { "kind": "field" } },
                          {
                            "name": "txs_effects_hash",
                            "type": { "kind": "field" }
                          },
                          { "name": "in_hash", "type": { "kind": "field" } },
                          { "name": "out_hash", "type": { "kind": "field" } }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                { "name": "root", "type": { "kind": "field" } },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": { "kind": "field" }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": { "kind": "field" }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": { "kind": "field" }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          { "name": "chain_id", "type": { "kind": "field" } },
                          { "name": "version", "type": { "kind": "field" } },
                          {
                            "name": "block_number",
                            "type": { "kind": "field" }
                          },
                          {
                            "name": "slot_number",
                            "type": { "kind": "field" }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                { "name": "inner", "type": { "kind": "field" } }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                { "name": "inner", "type": { "kind": "field" } }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": { "kind": "field" }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": { "kind": "field" }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    { "name": "total_fees", "type": { "kind": "field" } }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::header::Header"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    { "name": "chain_id", "type": { "kind": "field" } },
                    { "name": "version", "type": { "kind": "field" } },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": { "kind": "field" }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": { "kind": "field" }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "inclusion_fee",
                            "type": { "kind": "field" }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_storage_hints",
        "get_public_data_witness",
        "lt_32_hint",
        "decompose_hint",
        "lte_16_hint",
        "pack_returns_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient"
      ]
    },
    {
      "name": "get_total_services_private",
      "is_unconstrained": false,
      "custom_attributes": ["private", "view"],
      "abi": {
        "error_types": {},
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "fields": [
                            { "name": "inner", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "storage_contract_address",
                        "type": {
                          "fields": [
                            { "name": "inner", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                        }
                      },
                      {
                        "name": "is_delegate_call",
                        "type": { "kind": "boolean" }
                      },
                      {
                        "name": "is_static_call",
                        "type": { "kind": "boolean" }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "fields": [
                            { "name": "root", "type": { "kind": "field" } },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "fields": [
                            { "name": "num_txs", "type": { "kind": "field" } },
                            {
                              "name": "txs_effects_hash",
                              "type": { "kind": "field" }
                            },
                            { "name": "in_hash", "type": { "kind": "field" } },
                            { "name": "out_hash", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": { "kind": "field" }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": { "kind": "field" }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": { "kind": "field" }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": { "kind": "field" }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ],
                                      "kind": "struct",
                                      "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "fields": [
                            { "name": "chain_id", "type": { "kind": "field" } },
                            { "name": "version", "type": { "kind": "field" } },
                            {
                              "name": "block_number",
                              "type": { "kind": "field" }
                            },
                            {
                              "name": "slot_number",
                              "type": { "kind": "field" }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": { "kind": "field" }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                        }
                      },
                      { "name": "total_fees", "type": { "kind": "field" } }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::header::Header"
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "fields": [
                      { "name": "chain_id", "type": { "kind": "field" } },
                      { "name": "version", "type": { "kind": "field" } },
                      {
                        "name": "gas_settings",
                        "type": {
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": { "kind": "field" }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                              }
                            },
                            {
                              "name": "inclusion_fee",
                              "type": { "kind": "field" }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": { "kind": "integer", "sign": "unsigned", "width": 32 }
                }
              ],
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "fields": [
                          { "name": "inner", "type": { "kind": "field" } }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "storage_contract_address",
                      "type": {
                        "fields": [
                          { "name": "inner", "type": { "kind": "field" } }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                      }
                    },
                    {
                      "name": "is_delegate_call",
                      "type": { "kind": "boolean" }
                    },
                    { "name": "is_static_call", "type": { "kind": "boolean" } }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                }
              },
              { "name": "args_hash", "type": { "kind": "field" } },
              { "name": "returns_hash", "type": { "kind": "field" } },
              {
                "name": "min_revertible_side_effect_counter",
                "type": { "kind": "integer", "sign": "unsigned", "width": 32 }
              },
              { "name": "is_fee_payer", "type": { "kind": "boolean" } },
              {
                "name": "max_block_number",
                "type": {
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "fields": [
                          { "name": "_is_some", "type": { "kind": "boolean" } },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "std::option::Option"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::read_request::ReadRequest"
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "fields": [
                                  { "name": "x", "type": { "kind": "field" } },
                                  { "name": "y", "type": { "kind": "field" } },
                                  {
                                    "name": "is_infinite",
                                    "type": { "kind": "boolean" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint"
                              }
                            },
                            { "name": "sk_app", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": { "kind": "field" }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::note_hash::NoteHash"
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      { "name": "note_hash", "type": { "kind": "field" } }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::nullifier::Nullifier"
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "fields": [
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            { "name": "inner", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "storage_contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_delegate_call",
                              "type": { "kind": "boolean" }
                            },
                            {
                              "name": "is_static_call",
                              "type": { "kind": "boolean" }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      { "name": "args_hash", "type": { "kind": "field" } },
                      { "name": "returns_hash", "type": { "kind": "field" } },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      {
                        "name": "contract_address",
                        "type": {
                          "fields": [
                            { "name": "inner", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                        }
                      },
                      {
                        "name": "call_context",
                        "type": {
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "storage_contract_address",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": { "kind": "field" }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ],
                                "kind": "struct",
                                "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                              }
                            },
                            {
                              "name": "is_delegate_call",
                              "type": { "kind": "boolean" }
                            },
                            {
                              "name": "is_static_call",
                              "type": { "kind": "boolean" }
                            }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                        }
                      },
                      { "name": "args_hash", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "fields": [
                    {
                      "name": "contract_address",
                      "type": {
                        "fields": [
                          { "name": "inner", "type": { "kind": "field" } }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                      }
                    },
                    {
                      "name": "call_context",
                      "type": {
                        "fields": [
                          {
                            "name": "msg_sender",
                            "type": {
                              "fields": [
                                { "name": "inner", "type": { "kind": "field" } }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "storage_contract_address",
                            "type": {
                              "fields": [
                                { "name": "inner", "type": { "kind": "field" } }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "function_selector",
                            "type": {
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::function_selector::FunctionSelector"
                            }
                          },
                          {
                            "name": "is_delegate_call",
                            "type": { "kind": "boolean" }
                          },
                          {
                            "name": "is_static_call",
                            "type": { "kind": "boolean" }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::call_context::CallContext"
                      }
                    },
                    { "name": "args_hash", "type": { "kind": "field" } },
                    {
                      "name": "counter",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest"
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "fields": [
                            { "name": "inner", "type": { "kind": "field" } }
                          ],
                          "kind": "struct",
                          "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                        }
                      },
                      { "name": "content", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": { "kind": "integer", "sign": "unsigned", "width": 32 }
              },
              {
                "name": "end_side_effect_counter",
                "type": { "kind": "integer", "sign": "unsigned", "width": 32 }
              },
              {
                "name": "note_encrypted_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      { "name": "length", "type": { "kind": "field" } },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::NoteLogHash"
                  }
                }
              },
              {
                "name": "encrypted_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      { "name": "length", "type": { "kind": "field" } },
                      { "name": "randomness", "type": { "kind": "field" } }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::EncryptedLogHash"
                  }
                }
              },
              {
                "name": "unencrypted_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 4,
                  "type": {
                    "fields": [
                      { "name": "value", "type": { "kind": "field" } },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      { "name": "length", "type": { "kind": "field" } }
                    ],
                    "kind": "struct",
                    "path": "address_note::aztec::protocol_types::abis::log_hash::LogHash"
                  }
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "fields": [
                          { "name": "root", "type": { "kind": "field" } },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "fields": [
                          { "name": "num_txs", "type": { "kind": "field" } },
                          {
                            "name": "txs_effects_hash",
                            "type": { "kind": "field" }
                          },
                          { "name": "in_hash", "type": { "kind": "field" } },
                          { "name": "out_hash", "type": { "kind": "field" } }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::content_commitment::ContentCommitment"
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "fields": [
                                { "name": "root", "type": { "kind": "field" } },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": { "kind": "field" }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": { "kind": "field" }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": { "kind": "field" }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ],
                                    "kind": "struct",
                                    "path": "address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::partial_state_reference::PartialStateReference"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::state_reference::StateReference"
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "fields": [
                          { "name": "chain_id", "type": { "kind": "field" } },
                          { "name": "version", "type": { "kind": "field" } },
                          {
                            "name": "block_number",
                            "type": { "kind": "field" }
                          },
                          {
                            "name": "slot_number",
                            "type": { "kind": "field" }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "fields": [
                                { "name": "inner", "type": { "kind": "field" } }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::eth_address::EthAddress"
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "fields": [
                                { "name": "inner", "type": { "kind": "field" } }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": { "kind": "field" }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": { "kind": "field" }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::global_variables::GlobalVariables"
                      }
                    },
                    { "name": "total_fees", "type": { "kind": "field" } }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::header::Header"
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "fields": [
                    { "name": "chain_id", "type": { "kind": "field" } },
                    { "name": "version", "type": { "kind": "field" } },
                    {
                      "name": "gas_settings",
                      "type": {
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas::Gas"
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": { "kind": "field" }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": { "kind": "field" }
                                }
                              ],
                              "kind": "struct",
                              "path": "address_note::aztec::protocol_types::abis::gas_fees::GasFees"
                            }
                          },
                          {
                            "name": "inclusion_fee",
                            "type": { "kind": "field" }
                          }
                        ],
                        "kind": "struct",
                        "path": "address_note::aztec::protocol_types::abis::gas_settings::GasSettings"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "address_note::aztec::protocol_types::transaction::tx_context::TxContext"
                }
              }
            ],
            "kind": "struct",
            "path": "address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "get_public_storage_hints",
        "get_public_data_witness",
        "lt_32_hint",
        "decompose_hint",
        "lte_16_hint",
        "pack_returns_oracle_wrapper",
        "directive_integer_quotient",
        "directive_invert"
      ]
    },
    {
      "name": "compute_note_hash_and_optionally_a_nullifier",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "error_types": {
          "12265343917440897559": {
            "error_kind": "fmtstring",
            "item_types": [],
            "length": 20
          }
        },
        "parameters": [
          {
            "name": "contract_address",
            "type": {
              "fields": [{ "name": "inner", "type": { "kind": "field" } }],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": { "kind": "field" },
            "visibility": "private"
          },
          {
            "name": "storage_slot",
            "type": { "kind": "field" },
            "visibility": "private"
          },
          {
            "name": "note_type_id",
            "type": { "kind": "field" },
            "visibility": "private"
          },
          {
            "name": "compute_nullifier",
            "type": { "kind": "boolean" },
            "visibility": "private"
          },
          {
            "name": "serialized_note",
            "type": {
              "kind": "array",
              "length": 6,
              "type": { "kind": "field" }
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 4,
            "type": { "kind": "field" }
          },
          "visibility": "public"
        }
      },
      "bytecode": "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",
      "debug_symbols": "7b3Rruw6dmX5L/nsB5FaoiT/SqNRsKtchQSMdMF2NdAw8t9r3xMnJG2LJr0tBjVFjhcj06kbl2vMHcE5Fyny3/70P/7h7//P//pvf/7L//ynf/nT3/4///anf/yn//53//rnf/rL13/7t7/+zZ/+/p///I//+Of/9d+O/+8/DX/8Hxt/Pf8v//vv/vLHf/2Xf/27f/7XP/3tEv7mT//wl//xp79d3dc//T///I//8Ke/nd1f/9+/+ZPZz5530/LTf2D94T8Q/A/+gb85PTj73w/O8/bgtL4+efzYJ9vHPnn62CeHj33y/LFPXj72yeunPnkePvbJ7mOf/LHv4Pyx7+D8se/g/LHv4Pyx7+D8se/g/LHv4Pyx7+Dyse/g8rHv4PKx7+Dyse/g8rHv4PKx7+Dyse/g8rHv4PKx7+Dyse/g+rHv4Pqx7+D6se/g+rHv4Pqx7+D6se/g+rHv4Pqx7+D6se/g+qnvoB+Gj32y+9gn+4998vixT7aPffL0sU8OH/vk+WOfvHzskz/2HXQf+w66j30H3ce+g+5j30H3se+g+9h30H3sO+g+9h10H/sOuo99B/3HvoP+Y99B/7HvoP/Yd9B/7DvoP/Yd9B/7DvqPfQf9x76D/mPfwfFj38HxY9/B8WPfwfFj38HxY9/B8WPfwfFj38HxY9/B6ZqCYRjt96NhmMP28DJEHh6XMP1+eFyWfSjeXkMxnaFMOkMJOkOZdYayyAwluHpDmeb597PTsm6PjoN7jaTiFygMw/ZsOI9kkhlJkBnJLDOSq18edxjJnBnJ+v6LnYf9c8dxfo1kVRnJxfXukiNxMiPxMiMZZUZiMiOZZEYSZEYyf2okvz59+einr5/89GX46Ke7j366/+injx/9dPvop08f/fTw0U//6Hd1+eh3dfnod3X96Hd1vfpdXcbt09flUnRavc5QRp2hmM5QJp2hBJ2hzDpDufgz5/ZQ6aZcqPwPrdf5WRv8+2Eb5mEf9hprT87v8S7D4dEp9rl+fX+s+fSjXzItv5/162r7wyHWWBncW5NpGN3x4V+YVzB/HvN4caMPmP+TmB2Ya2D2YK6BeQRzDczWGeZt0dTm8fjoLxgTMHYYARg7jLkvGF+/GtuPhj/B6CydpGF0liGSMFxnTn/y70cnP59gdObH0zA6c81pGJ35jMneza7JzjA6m03C9DbvYXYnGJ3NJkkYXnU2cdM7Upk7jMKvr2Gr/u47m1PDVv2FduOaGrZqnyAzbHvmsHtLyPd0ZXxv2fsmzJ2l+rsws5pZBTOrmTUwj6xmVsHc22pmqv089rbmmITR28pgEobRft5h9NZXS8LoLEOkYfS2fpdqP4+9rd8lYfS2fpeCYb2t0qQWJqyz2STZi7fOZpM0DNXZJL0wYaq/++mFCVP9hU63yifZ1av0sGVXr9LDZlduja7MxK7cKpgNzDUws5pZBTOrmVUws5pZBXNvq5mp9vPU25pjCkbobWUwCaO33c+p9nPora+WhNFZhkjDMNrPO4ze1u+SMHpbv0vC6G2VJrUwMXc2myR78XNns0kahupskl6YmFV/99MLE7PqL3S6VT7Lrl6lhy27epUeNrtya3RlFnblVsHMGUNVMLOaWQUzq5lVMBuYa2Dm9KI9CS2cXnSA0dvKYBIGpxcdYHB60Q5j7e30oiQMTi86wOD0ogOM3tbvkjB6W6VJLUz0dp52qhdvvZ16nYYhu6s8tTBhsmc9JxcmTPbs5GSr3AZ75rBlV6/Swxadub4WMd+29GvN599fjWGqJ/Hmhi2aOnPDFp3RM8NWPYc2N2zRWTI3bNFZMjds0VkyN2zRWTI3bNFZMjfsZ86S7pmzpOpZwLlhP3OWVD1fNzfsZ86Squfr5ob9zFlS9Xzd3LCfOUuqnlebG/YzZ0nV81Rzw37mLKl63mdu2M+cJVVPuswN+5mzpOrpkblhP3OWVD2RMTds1Vlyce+Hx+W4He73sFVnycywVWfJ9LDt6iy5vD89eHPpYbvV3p/rB7fftD262MDd4Ob3Gp8bvBu/Pf9r7O7BY/cPHvv44LHbg8c+PXjs4cFjnx889uXBY1+fO/bpwfPqJDyverfuYx997nnn3tvenAv7axrjy/xMwpNw2UKFZ+yyhVozhdr6/vSv/zifChX2AmULFTYOZQsVdhk/LDTsjwcLp0KFLUnZQoX9S9FCg7DZKVtoO84oU2g7zihTaDvOKIRlK3RZToVaL4W244wyhbbjjDKFNuSM0oU25IzShTbkjJKFzg05o3ShDTmjdKENOaN0ocrz6LGDuUx//fcdzFn4h3Qc97GPh3dx/yvP/6pV+Lf0h7XO0/b3O8+nBski/FtatlDh39KyhVozhS7b0TVuOYz7q9Dzw8v4bmEv43piImx2P8jk6wO3yWiY3IlKOz/oP6KSXu1Y2vnpL0hlbWeeKEmlnUmlJBVhN38jFeGm6I1UDCoRKsIx8UYqwr3ZYlR+FdqDXf1VaDMO1A/DdnbtV8voVGgzpjJd6DQ04xNzhV60fn4e3oWOh4ORo4V6t5117P2U725l9iJOV0/yunXs44PHbg8e+/TgsYcHj31+8NiXB499fe7Yr574devYHzyvOuF5teSO8MkJT8JlCxWescsWKjy9l9wRPjlhL1C2UGHjULZQYZdRclvt5IQtSdFCvbB/KVuosNkpW2g7zihTaDvOKFOotVNoasve5NtxRplC23FGmULbcUaZQhtyRulCG3JGyULHhpxRutCGnFG60IacUbrQhpxRulDleTS9x38ahX9IC+/xn0z4t7TkjvDJhH9LyxYq/FtatlDhTHLTHv/JhM3ubXv8J2vnB73cTsJpauenvySVduaJklTamVRKUhF28zdSMahEqPTpVnJUhGPijVSEe7Mlt75PUw929VehzTjQzI7w0IypzBXajE/MFfqxn+hfnz5/9NOXj376+slPn4ePfrr76Kf7j376Rdttw/unOpgN6a+em4Ztpp4OD8evxPia0N73pkzh8FWKf/Rge9NizozjR9d8f3W4fz9sxw/2a+TheX5zW4bDo1Psc/12e/hBlOijfp2335R13Q2ODzFqw/bzNg3Hi0TCS25D7p7knpC7J7kDcvck94zcPcm9IHdPcq/IfYvcW/PJ5vH46B+iXD3dEFE+IYpDFD1RPKLcIcrXrLJNKv4kCt0eQVEMUfREoXNyjyj+/ejk55Mo9DcERaELoSfKSk65RxR7o5jsLAru6xZRwvQeb5jdSRRDFD1RcF9pUdz0bh2aO9D4EuUXPnxSBp/NKXw4mgy+cU3hY53iEj76/hfwhQHne8t8fs8qWRjo/XclN6sKXclNYu5KbkPunuQm5XclN12Je+RObNMIA70OQVHooAiKQl/mFlFS2zSCo9sjKAo9GUFR6JzcI0pim0Zw9DcERTFE0ROFnHKPKIkNTcHjvm4RJbV3Jnjcl6AouK+0KMkNTcHjkzL4UhuawtWrVTrfUuJZp7iEj77/JXw431vm85tWyTy9/67kZlWhJ7lHEnNXcpPFu5KblN+V3HQl7pE7tU1jNETRE4UOiqAo9GVuESW5TWOk2yMoCj0ZQVHonNwjSmqbhtHfEBSFLoSgKIYot4iS2tBkuK9bREnunTHcl6AouK+0KOkNTRM+KYMvuaFpwtFk8CW3lEysU1zCR9//Ej4D3x3z+U2rZBO9/67kZlWhK7lJzF3JTRbvSm5Sfk9yB7oS98id2qYR6HUIikIHRVAU+jK3iJLcphEMUfREoScjKAqdk3tESW3TCPQ3BEWhC6EnykxOuUeU1Iam2RDlDlGSe2dm3JegKLivtCjpDU0zPimDL7mhacbRZPAlt5TMrFNcwbfQ97+ED+ebHMU423sU47wcPKq98NFLv4SPrvclfAa+K/jIMpfwkTou4SN1XMJH6riEj9RxBd9K6riEj9RxCR+p4xI+UsclfAa+K/hIHZfwkTou4SN1XMJH6riEj9RxAd88kDou4SN1XMJH6riEj9RxCZ+B7wo+UsclfKSOS/hIHZfwkTou4SN1XMHnSB2X8JE6LuEjdaTxLe798Lgcj0X4jY/UcQmfge8KvkZSh9vOKXFu/TaOX1U2Eg4yVTbiovz4Hofzs2UeXu1dnx/cso/DzdFvmZvH7Wvm3fjt+T8Y+kas1K0MG/FTtzJsxFTdyrARZ3UrQ4PhZYaNeKxbGTbi4G5l2EiP91aGjTR6b2VITrnMsJWr3j/J0Lt1Zzj63PPObVW6sA9lfDVKWrls/TnASUCVgROXSgO39f3pX/9xPgE3gNcFThCrDJzUVhp42B8PFk7AiXiVgZMHKwMnPNYF3sql288BTtKsDJykWRx42DYqhGU5ASdpVgZuAK8LnKRZGThJszJwkmZl4CTNysBJmnWBTyTNysBJmpWBG8CzwI87H5bp2/O/GGI8sgzHcWc4Hu5t+a88/4s53qM083naflfm+bRw1srVyI8B3srlxM8BTg+wNPBlu77WLQd+X8DPDy/jm8gyridtaKbcqc3XB+7vgk7upA4G6FZ10rvoWrk9slF18FXC6syYMGV16BYpq8MmBmV1SDvK6hjqCKvDXop66vwCTvyvDJxEXxi4H4Zl+3R/Bk5Irwyc3F0XeCvX3rbYXm/lTt3HtteHYftsd1YH96OsDlZJWR181b3qJBcOW7lRtk11WrmwtlF1WPxQVoe0o6wOeUdZHUMdYXVY/FBWh17BvepMG5IhnN62aeUm5UbVoVegrA69Al11llaumW5UHXoFyurQK1BWh16BTN6JqGOoI5tGl1ZuEG9UHXoFyurQK1BWh16Bsjr0CoTVaeVy+EbVoVegrA69AmV16BUoq2OoI6wOvQJldUijyuqQRpXVIY0Kq+NJo8rq4Kjz6rj9Dajx+ArU66zcxRsMLzPEnV5nyHrTdYb48OsMccvXGeJpLzMccZ7XGbJacZ0hawrXGZJTrjM0GF5mSE65zpCccp0hOeU6Q3LKdYbklCxDv4ad4bDmnk+ejbsYoaY0cO+3a4v8sfn+GzgJqDJw4lJl4GSrysAN4KWBB7cNZTlPmrjl0sBtf9zW81841roycHx4XeBcXV4ceNgv3g4WTsDx4ZWB48MrA8eHVwZuAK8LnNWTysBZaqkMnKRZGThJszJwkmZd4IGkWRk4SbMycJJmZeAkzcrADeClgYftvbawnM4tDCTNysBJmpWBkzQrAydpVgZO0qwLfMYWlgZu253Nzvy3ReTzw6krhJeZ+fVObTLHKMxMxsrqMHPfqk56R/vMNC+szkL3WVkdWtXK6tDXVlaHtKOsjqGOsDq015XVoVegrA69AmV16BUoq0OvoJ46fwBfif+VgZPoKwMnpFcGTu6uDNwAXhc46bg4cNtOyLfptL1yJfBWBk6GrQycWFoZOEmzKvB1IGlWBk7SrAycpFkZOEmzMnADeF3gJM3KwEmalYGTNCsDJ2kWB546SXAdSJp1gTuSZmXgBJ9LwH8xJMtcZ2gwvMyQxHGdIRar+ARU6D3blcvkb36Tc9gvHHIndTxOQlkdPIqyOoY6t6qTekd99fgqZXVo+yqrQ49YWR3SjrI65B1hdUZa1crqsINKWR16BfeqM21IhrCc1KFXoKyOoY6wOvQKlNWhV6CsDr0CZXXoFSirQ69AJu+c1TF6BcJp1OgVKKtDr0BZHXoFyuoY6girQ69AWR16Bcrq0CtQVodegbI69AqE1ZnoFSirQ69AWR3SqLI6hjrC6pBGldUhjQqrE3RdQfDzps665j46bOpM6zcpf1Wp24kvWaXu7+BPqvTO3n+x3vsp97Abt4enOftNc/N2TM3g3fjt+V8MdX+tnsNQt8P1HIa6fajnMNTtFj2G4azb03kOwzY81r0M23Bw9zLU7TE9h6HB8DJDcsp1huSUfFfFrTvD0eeeT14SuM6EmsrASUCVgROXSgNPn2C6kK0qAyeIVQZOaisNPOyPBzuds74Q8SoDN4DXBU54rAycpFkZOEmzMnCSZnHgYdt0EpbTS8ULSbMu8JWkWRk4SbMycJJmZeAkzcrADeB1gZM0KwMnaVYGTtKsCvyPuzQgniV+3PqwTN+ef0HEemQhjuMOcbRrz7+gG9ALQ5+n7adlnufzbwX+ozZxDEht4nQCSxNf5u0dsWX99r7f+eHUpYVuEL5htwdx0m9ufsmDDbpVnuRuui95DHmU5cFdScuDFZOWh86RtDzsaJCWh9SjLI+nSSstD3sr6snzIk4joDZxsn1h4n7YDs3yg48QN4hXJk4Cr02cWHCnsUl324XvzO6j2z4M22e7szzCF/8izx//auRRlseQ51Z50kuJwnf/Is/X/8piiLQ8LIZIy0PqkZaH3KMsj/AFwMjzJQ+LIdLy0DW4V57U1fNf8tA1kJbHkEdZHroG0vLQNZCWh66BtDx0DaTloWsgk3si8ghfBUws/eP/hTzK8tA1kJaHroG0PIY8yvLQNZCWh66BtDx0DaTloWsgLQ9dA2V5Al0DaXnoGkjLQyyVlseQR1keYqm0PMRSaXkw1nl53P6K1Hh8R+p9xO6M/S0AEZNaACILUAUg4scLQDQgXoeIty0AEQdaACLLFwUgsshQACKJ5TrEhcRSACKJpQBEEksBiCSWAhANiNchkliyEP0adojDmns+c6ruQrwpTdz77e4jf2zHv4mThWoTJzjVJk7Kqkx8JZIVJx7cRnw5z5zchF6cuO2P2xr5GzeIVyaOH69NHD9emnjYr/IOFs7E8eO1iePHaxPHj9cl7gb8eG3irKfUJs7iS23iZM7axA3ilYmTOWsTJ3PWJk7mrE2czFmbOJmzMnFH5ixOPGzvv4VlORMnc9YmTuasTZzMWZu4QbwycTJnbeK4w9LEbbsF2pn/trJ8fjh5J7HzTLJ3ipM5dcF5ZmRpeQx57pQnvePdeeZ6aXloRkvLQ+daWh7a3NLykHqU5RlpoEvLQ7ddWh66BtLy0DWQlseQR1keugb15HkRpxFQmzjZvjZx4npt4iTwysSNUF2bODm5OHHbzti36bzz0oi+tYmTZmsTN4hXJk7mrE2czFmbOJmzNnEyZ23iZM7KxCcyZ23iZM7axMmctYmTOWsTN4iXJp48f9BNZM7axMmctYmTgC4Rf0Ek1FyHGMgpBSASPQpANCCWnoWKvY/LJfX37g0chv3eIheRBz8hLQ9ORVmeGQ90rzzpt9ln3JW0PHSBpeWhZSwtjyGPsjzkHml56FxLy8PWKml56BrcK8+0IRnC+YDCma6BsjwLXQNpeegaSMtD10BaHroG0vIY8ijLQ9dAJvfE5KFroBxLF7oG0vLQNZCWh66BsjwrXQNpeegaSMtD10BaHroG0vIY8ijLQ9dAWh66BtLy0DWQlodYKiyPH4il0vIQS6XlIZZKy9OGsXZh/+jg/fHhV5ltNObdMtr7o9chN47V3vV9/Ugu2b9CN2+nvQzejd+ef0Fsw6fcC9G14SZuhtjGnH8zxDZm5pshttHWvRmiAfE6xEac3L0Q22hk3gyxjXbjzRBJLAUgkljyzQe37hBHn3s+fROf98Sb2sTJQrWJE5xKE0+fCeo9Kas2cYN4ZeLkt9LEw/54sHAmTtirTZxkWJs4MbI2cTJnZeIjmbM2cTJnceJh26cRluVMnMxZmziZszZxg3hl4mTO2sTJnLWJkzlrEydz1iZO5qxM3MictYnjx/PEjxsilunb8y+I2I8sxHHcIY42X3r+BR0HUhr6PG0/LfN8XkszHEht4jiQysQbuWFcifgyv5G4Zf32rtz54eSdgL6Ri5qfKk7urcdGbnV+rDyZDXYThklaHtyVtDxYMWV5GrlVvFl52NogLQ+pR1oemrTS8hjyVJPnRZxGQG3iZPvCxP2wHTjlvxb1zsSJ67WJk8BrE28kVK9uJ7649MM/PcYu+zr+3Ej0vRdiIwH1XoiNxMh7ITYS9u6FaEC8DrGRlHUvxEaC070QG8lC90JsJN7cC5HEch1iIxfZfxRi2cOVGrmb/knEyUK1iROcShPPHK7UyKXwTyJOJKtNnPxWmnjmGJRGbmN/EnGSYW3ixMjKxBu5Bv1JxMmctYmTOYsTT78+38j9408ibhCvTJzMWZs4mbM2cTJnbeJkztrEyZx1iY+N3HH+JOJkztrEDeJZ4pkDxMYB+5GFWPoAsbGV28uFoKcPVxpbuer8OcRbuRf9QcTpCJYmXuwAsbGVi4gfKk7mALGxlSuOnypPeoPd2Mrlya3Kg7tSlqeVO5xblYfOkbQ8bG2QlofUIy2PIY+yPOywqCfPiziNgNrEyfaFiWcOVxpbuaT6QcRJ4JWJt3KBb5Pd9lbu+n1st30Yts92EXnwQNLyYJik5cFd3StPeimxlbtbG5WnlYteW5WHxRBpeUg90vKQe6TlMeRRlofFEGl56BrcK8+0IRnC+XWcVm5Fb1UeugbS8tA1UJZnomsgLQ9dA2l56BpIy0PXQCb3xOQx5BGOpRNdA2l56BpIy0PXQFoeugbS8tA1UJYn0DWQloeugbQ8dA2k5aFrIC2PIY+yPHQNpOUhlkrLQyyVlodYqizPTCyVlgdjnZfH7a9Ijcd3pN5H7M4GxOsQMakFILIAVQAifrwARFxzAYh42+sQFxxoAYgsXxSAyCJDAYgklgIQDYjXIZJYCkAksRSASGIpAJHEUgAiiSUL0a9hhzisueczp+quxJvSxL3f7j7yx3b8mzhZqDZxglNt4qSs2sQN4qWJB7cRXyIzJ665NHHbH7c18jeOxa5NHD9el7hxG3px4mG/yjtYOBPHj9cmjh+vTRw/Xpu4QbwycdZTahNn8aU2cTJnbeJkztrEyZyViTsyZ23iZM7axMmctYmTOWsTN4iXJh6299/CspyJkzlrEydz1iZO5qxNnMxZmziZszJxjzssTdy2W6C/8H5bWT4/nLyT2DyT7J3iZE5d+PrnkUdZHqbvW+VJ73g3z1yvLM9IM1paHjrX0vLQ5paWh9QjLY8hj7I8dNul5aFrIC0PXQNpeegaSMtD16CePL+IG42A2sTJ9rWJE9drEyeB1yZuEK9MnJxcnLhtZ+zbdN55aUTf2sRJs7WJE1BrEydzViY+kTlrEydz1iZO5qxNnMxZm7hBvDJxMmdt4mTO2sTJnLWJkzmLE0+fPziROSsTD2TO2sRJQJeIvyASagpANCBeh0j0KAARp1V8Fir2Pi6X1N+7N3AY9nuL3FmeGT8hLQ9ORVoeQ55b5Um/zT7jrqTloQssLQ8tY2l5SD3S8pB7lOVZ6FxLy8PWKml56BrcK8+0IRnC+YDCha6BtDyGPMry0DWQloeugbQ8dA2k5aFrIC0PXQOZ3BORZ6VroBxLV7oG0vLQNZCWh66BtDyGPMry0DWQloeugbQ8dA2k5aFrIC0PXQNheaaBroG0PHQNpOUhlkrLY8ijLA+xVFoeYqm0PI0Y62Xc5Rly41jtXZ8f3JKVZxzHXR7LyrnMbyRuWV1anuSbpZNrxFY/VJzMu3GTa8S3tSqPIY+yPI34tsfKkzYGrhHf1qo8jSwntCpPI8sJrcpD6lGWx5N7pOVpZDmhVXka2YTYqjx0De6VJ/l+wuQNeZTloWsgLQ9dA2l56BpIy0PXQFoeugbK8ox0DWRyT0weugbKsXSkayAtD10DaXkMeZTloWsgLQ9dA2l56BpIy0PXQFoeugbK8hhdA2l56BpIy0PXQFoeQx5leYil0vIQS6XlIZYqyzNhrPPyuP0VqdGdL36dJuxvAYiY1AIQWYAqANGAeB0irrkARLxtAYg40AIQWb4oAJFFhusQA4mlAEQSSwGIJJYCEEksBSAaEK9DJLEUgEhiyUL84UGCzm1VumB//fcd3EC8KU3c+/X9uD+249/EyUK1iROcKhOfSVm1iRPJihMPbiO+nGfO2SBemLjtj9sa+RvHYtcmjh+vTRw/Xpp4cNvMGSyciePHaxPHj1cmvuDHaxPHj9cmznpKbeIsvtQmbhCvTJzMWZs4mbM2cTJnbeJkztrEyZyVia9kztrEyZzFiYft/bewnM87XMmctYmTOWsTN4hXJk7mrE2czFmXeBhwh6WJ/+TK6OSdxGFgkr1TnMypC2FgRpaWh+n7VnnSO97DwFwvLQ/NaGl56FxLy0ObW1keR+qRlocGurQ8dNul5aFrIC2PIY+yPHQNpOWha1BPnhdxGgG1iZPtaxMnrlcm7kngtYkTqmsTJycXJ27bGfs2hTNxom9t4gbxysQJqLWJkzlrEydz1iZO5qxNnMxZmfhI5qxNnMxZmziZszZxMmdt4gbxysTJnMWJJ88fDCOZszZxMmdt4iSgS8R/QTRCTQGI5JQCEIkeBSDitIrPQsXex+WS+ptf+Bz2e4tcRB78hLI8XFKvLQ8e6F550m+zT7graXnoAkvLY8ijLA+pR1oeco+0PHSupeVha5W0PHQN7pVn2pAM4XxAYaBrIC0PXQNpeegaSMtD10BaHkMeZXnoGkjLQ9dAJvfE5KFroBxLA10DaXnoGijLM9M1kJaHroG0PHQNpOWhayAtjyGPsjx0DaTloWsgLQ9dA2l56Booy7MQS6XlIZZKy0MslZaHWKosz1p17gnbeSLT4ZPj8owb8HHZkbjgY8PYBjzbuD8bxWfb+uTk3LdnX0AcQL4D8QD5DmQEyHcgBpDvQCaAfAcSegMyuc1bTEvmWed22+LcfruN9+9JegbfFXwL+K7gq7mpIQzuPZh5HjP43ODmjfbg3fjNOf8x+HkYnjx49+TB+ycPfnzy4O3Jg5+ePPjw5MHPTx788uTBP3mGdcIzrHfrPvjRfxt8zAklb5mcnfB0XLhS4bm7cKXCE/0PK02fqzpXvWH43kqFLUThSoX9xg8rDfvjwcK5UmFzUrhSYSdTuFJh21O2Ut+OR8pV2o5HylXajkcKYVsjDstyrrQdj5Sr1LqptB2PlKu0IY+UqbQhj5SptCGPlKm0IY+UrnRsyCNlKm3II2UqVZ5Pj43NZfrrqbE5Cv+cjuM++NHmnEzJ51/FCv+i/rDYeVr3Tz/3TEbhX9SylZrwL2rhSoUTyg8rXeb3UNyyftuve344eS/JbMLG94NQMjueZ2vnZ/1HWDILIdbOBFAUSzuzRUksUztTS1Esws7+TizCrdI7sfTpWrJYDCwxLMId22JYXpX2YFxflTbjRf2wvZTov5pI50qbsZfZSptxjLlK5z69cTp1L5064/Q9gvPSqdfJYTGwxLD04HV+3rpa6OhFsXTa0cth6bSjl8PSaUcvg2Xt1bdksHTa0cth6bSjl8PSq8tN3vkxVz0g5EFYenW5GSy9utwMll5dbgZLry43g6VXl5vEsigfB1LLt8Sw4HIjdm5RPsLkTiy9utwMFgNLDAu93CgWerlRLPRyo1jo5Uax0MuNYVE+kudOLLjcKBZcbhSLgSWGBTsXxYKdi2LBzsWwKJ8HM7p9a87ovl9G8Rq88jSaHbzyZJcdvHLjJTt45fk0O3jlWS87eOW5KTt45RkkO3jl2J4dvHK4zg1e+TSR/OCfPMOOT55hxyfPsMqnreQH/+QZdlQ+Y+xnl8ul30JclA/F+WGl3m9nivhj/HtXqnzGWNlKlc8YK1qp8ok4hStVPmPsh5WG7dP9cv5FMuFZ76cXeyZP+15M+czOspW2M5/mKm1nPk2fl7woHzBUuNJ25tNMpcrHABWutJ35NFep8rnmZStVPte8bKXWTaXteKRcpe14pFyl3Xgk5VNyClfajUcK3Xik0JBHSp5rvoSGPFKm0oY8UqZS66bShjxSptKGPFK60rmdWca2U+ec+W8ds/PDybPYlrmdH6+fQMntPpzb+aUriqWh9vpPsGRWfOeGevElsbQTSotiaSfBFsXSTtwtiUX5sNQ7sbQTpItiaSd1F8XSqcvNYTGwxLDgcqNYenC5r0p7MK6vSnvwoq9Ke7CXvypVPqa2cKU9mMBXpQ35OtveKbbpvEKmfD5s4Uqtm0obMlSZShvySJlKG/JImUob8kiZShvySMlKV+VDTgtX2pBHylTai0dalU8XLVypdVNpL28urcrHehautCGPlKn0oc7h1+CVz4LMD/6h8/tr8A+dsl+D73OZILmfbFU+5O+jG6eStzWurtPNDRksyof83Yml080N6d2Hq/LBhHdiYQtvFIuBJYal080NOSy9+pYMlk638OawdLqFN4elV5ebvFFtVT5o804svbrcDJZeXW4GS68uN4PFwBLD0qvLzWDB5Uax4HJjdq6h412LYunV5aaxNHRwbFEs9HKjWOjlRrHQy41iMbDEsNDLjWLB5Uax4HKjWHC5MSwNnVtcFAt2LooFOxfFgp2LYqk5QU/D1hKbDg/HsUzT8oY4Be8yHz3YXuacGUdY59/PzoPLjOKrvvfDdvxgv0Yenuc3t2U4PDrFqrM3iulwH8rXoy9VZlS5RZXwfnSaw1mVBVUEVVlRRU+VqudIo8p/VhWHKoKqeFQRVGVEFUFVDFVuVmWZzqpMqCKoCtn+JlW2bL9GVCHb36PKtKRUIdsrqkK2F1RlJtvfokrwGze/nFUh2yuqQrZXVIVsr6iKocotqjjbVFnPqpDtFVUh2yuqQrZXVIVsr6gK2V5QlYVsr6gK2f5uVcZzXlnI9oqqkO1vUmXcuEVUMVS5RZUNRVQVsr2iKmR7RVXI9veosq1FhtmdVSHbK6pCthdUZSXbK6pCtldUhWyvqAp55RZV0m+rruSVe1RJvimxklcUVSGvKKpCXpFTxQ8DeUVRFfKKoirkFUVVWIu8W5XTe5FfqhiqCKpCtr9Jlf/4bdUvVcj296iSeAPvSxWyvaIqZHtFVcj2t6iSetfLD45sr6gK2V5RFbK9oipk+3tUSbwp8aWKoYqgKmR7RVXI9oqqkO0VVSHbK6pCthdUxZPt71ZlPOcVT7ZXVIVsf5Mq//Hbql+qkO3vUSXxBt6XKoYqgqqQ7RVVIdvfo0ri/ZUvVcj2iqqQ7RVVIdsLqjKS7RVVIdsrqmKococqqbdVv1Qhr9yjSvJNiZG8oqgKeUVRFfKKoirkFUFVjLyiqAp5RVEV1iLvViXyXqSxFqmoiqHKPaqk3lY1sv09qiTfwDOyvaIqZHtFVcj2t6iSftfLyPaCqkxke0VVyPaKqpDt71El+abERLZXVMVQRVAVsr2iKmR7RVXI9oqqkO0VVSHb361K5L3IQLZXVIVsf5MqqbdVA9n+HlWSb+AFsr2iKoYqgqqQ7e9RJfn+SiDbK6pCtldUhWyvqArZXlCVmWyvqAp55RZV0m+rzoYqt6iSfFNiJq8oqkJeUVSFvKKoCnlFURXyiqAqC3lFURXWIu9WJfJe5MJapKIqZPubVEm9rboYqtyiSvINvIVsr6gK2V5RFbL9Laqk3/VayPaKqpDtBVVZyfaKqpDt71El+abESrZXVIVsr6iKoYqgKmR7RVXI9oqqkO0VVSHb361K5L3IlWyvp4obyPY3qZJ4W9UNZPt7VEm9gecGsr2iKmR7RVUMVW5RJfX+ihvI9oqqkO0VVSHbK6pCtldUhWwvqIq7mFf8PGydA/NpGl//tneg9X7a39Ec3RwFPY7jRnq07PPL/P4Dccth3KNFHl7G99/HMq7HR19Qxi6hfDV6hu2zXQRLAEsMywyWGJalUyzjPj9M7oxlBUsEix/AEsPiwBLD0qdryWLp1bdksBhYYlgmsMSw9Opypy0yD2E5Y+nV5Waw9OpyM1h6dblpLGOvLjeDpVeXm8HSq8vNYMHlRrEYWCJ2bsTlRrH06nIzWHp1uRks9HKjWOjlxrAYvdwoFnq5USz0cqNYcLlRLAaWGBZcbhQLdi6KBTsXxYKdi2GZsHNRLMoTtNu35ozHvTlfz78GrzyNZgevPNllB6/ceMkOXnk+zQ5eedbLDl55bsoNPijPINnBK8f27OCVw3V28E+eYa9ekHrv4J88w4Ynz7DhyTNsePIMG4RnWL+GffDDmnveuW0B/et36JRcZuHp+IeVer++H/fH+PeuVHjuLlyp8ERfuFJhV1C4Umun0uC2SpfIL5LwrPfDSm1/3NaIpsJTZOFK25lPM5Uu7cynwW2/SMHCudJ25tNcpe3Mp7lK25lPc5W2M5/mKhXO74UrFQ77hSttxyPlKm3HI+UqbccjZSpdu/FIazceae3GI63deKSr9y0oVRq2/RthOb8vszbkkTKVNuSRMpU25JEylTbkkTKVNuSRkpX6oZ1ZxoatUvPfOmbnh5NnsfmhnR+vn0DJ7D70Q0Md85JYGmqv/wRLesXXDw314gtice2E0qJY2kmwRbG0E3eLYunTtWSxGFhiWNpJ3UWxdOpyc1g6dbk5LLjcKJYeXO6vSpVPyy1caQ9e9FVpD/byVWkPjvFVqXVTaUO+zrZ3im0K50obsmqZShtyX5lKGzJUmUob8kjpSpXPWi1caUMeKVNpQx4pU2lDHilTqXVTaTceSfl00cKVduORlM8ALfo+j1c+1rNspcondRau9KHO4TX4h5qB1+DtyYN/6JT9GnyfywTp/WTKh/x9dONU8rZGP3W6uSGHpdPNDTksD/1Nv4wlvftQ+WDCO7GwhTeKhS28USydbm7IYenVt6SxKB8teSeWTrfw5rD06nKTN6p55YM278RiYIlh6dXlZrD06nIzWHp1uRksvbrcDBZcbgxLQye2lrRzDR3vWhRLry43g6VXl5vBYmCJYaGXG8VCLzeKhV5uFAu93CgWXG4MS0PnKBfFgsuNYsHORbEYWGJYsHNRLNi5KJaLE7Rb5jcWby6Nxa32/lw/uCWL5YNXnqZ3zl09wvehUHJ7oa6eDdsqFgNLDMvUKZb0D+7VI2pbxTKDJYZlAUsMS5+uJYNlHHr1LRksDiwxLB4sMSy9utzkfoVxMLDEsPTqcjNYenW5GSy9utwMll5dbgZLry43jcXhcqNYcLkxO+dwuVEsvbrcDBYDSwwLvdwoFnq5USz0cqNY6OVGsdDLjWHxuNwoFlxuFAsuN4rFwBLDgp2LYsHORbFg52JYRuUJ2u1bc0Z3PjBvHJWn0ezglSe77OCVGy/ZwSvPp9nBK8962cErz03ZwSvPINnBK8f27OCVw3Vu8PbkGdaePMPak2dYe/IMe/UM6XsH/+QZ1oRn2B++IJS+PfIrJzVTqffr+3Fv87lS4bm7cKXCE33ZSidhV1C4UmEL8dNKg9sqXc6/SFdP2RaqNH07xzgJT5GFK21nPs1V2s58Gtz2ixQsnCttZz7NVdrOfJqpNLQzn+YqbWc+zVUqnN8LVyoc9gtXat1U2o5HylXajkfKVdqNRwrdeKTQjUeau/FIc0MeKWz7N8Jyfl9mbsgjZSptyCNlKrVuKm3II2UqbcgjpStd2pllit1iOi7t/HgVPLdvXNr5pSuKpaH2+k+wZFZ8l4Z68SWxtBNKi2JpJ8EWxdJO3C2JRfmw1DuxtBOki2JpJ3UXxdKpy81hMbDEsOByo1h6cLmvSnswrq9Ke/Cir0p7sJd/VGrKx9QWrrQHE/iqtCFfZ9s7xTaFc6UNWbVMpdZNpQ0ZqkylDXmkTKUNeaRMpQ15pEylDXmkdKXKh5wWrrQhj5SptBuPpHy6aOFKrZtKe3lzyZSP9SxcaUMeKVPpQ53Dr8ErnwWZH/xD5/fX4B86Zb8G3+cyQXI/mSkf8vfRjVPJ2xrNd7q5IYNF+ZC/O7F0urkhvfvQlA8mvBMLW3ijWAwsMSydbm7IYenVt2SwdLqFN4el0y28OSy9utzkjWqmfNDmnVh6dbkZLL263AyWXl1uBouBJYalV5ebwYLLjWLB5cbsXEPHuxbF0qvLTWNp6ODYoljo5Uax0MuNYqGXG8ViYIlhoZcbxYLLjWLB5Uax4HJjWBo6t7goFuxcFAt2LooFOxfFcnWCHu2NxR22UkexhPWNcB4OIxljRdrg3w/bMA/b036NPDzP7/Euw+HRKfLoZO+u3HS4h+Tr0ReNuTMa4f3oNIczjQUaBxorNHYal88JbouGg8aBhofGgcYIjQMN65bGMp1pTNA40OjNi4bNi64RGr150WlJ0ejNi6Zp9OZFkzSWzrxo8H5rRSxnGp150QyNzrxohkZnXjRDwzqj4bbx+vVMozMvmqHRmRfN0OjMi2ZodOZFMzQ686JpGmtvXjRNozcvutMYz35j7c2Lpmn05kXd+9CpYBEa1hmNYUrR6M2Lpmn05kXTNHrzolvvK8zuTKM3L5qm0ZsXTdGYht68aJpGb140TaM3L5qm0ds6bGoX3DR0tw6b2LEwDewJPNJgT+CRBnsCDzQcewKPNNgTeKTBnsAjjX73BJ73fU2XT5Zvi0Z3ewITu+Am15sXTe10mhx7Ao802BN4pNFb7yu1t2fy7Ak80mBP4JEGewKPNLpbh03sWJi8QeNAgz2BRxrsCTzSYE/gkQZ7Ao802BN4oDH2uyfwvO9rGtkTeKTR3Z7AxC64aezNi6Z2Ok2Xr01piwZ7Ao80evOiyf0bI3sCjzTYE3ikwZ7AAw1jT+CRBnsCjzSMXXAHGv2ezRLZsWDsCTzSYE/gkQZ7Ao802BN4oDGxJ/BIgz2BRxr97gmM7Pua2BN4pGHsgjvQ6M2LJnc6TewJPNJgT+CRRm+9r+Tenok9gQcagT2BRxrsCTzS6PdslsiOhcCewCMNg8aBBnsCjzTYE3ikwZ7AIw32BB5p9LsnMLLvq7f7UzI0utsTmNoF19v9KemdTr3dn5KhYdA40OjNiyb3b/R2f0qGBnsCjzTYE3ikwZ7AA43u7k9J0+htHTa5C663OzLSOxZ6uyMjQ4M9gUca7Ak80mBP4JEGewIPNHq7IyNDo989gZF9X73dkZGh0d2ewNQuuN7uyEjvdOrtjowMDfYEHmn01vtK7u3p7o6MNA32BO40Qnd3ZKRp9Hs2y3nHQujujow0DfYEHmkYNA402BN4pMGewCMN9gQeafS7J3CM+A32BB5o9HZ/SnIXXOjt/pTkTqfQ2/0pGRrsCTzSMPZvHGiwJ/BIgz2BRxrsCTzSYE/gkQZ7Ag80rt6RMew0hjlDY5rfBU7LnpjGLzKvoYz1hvKVSLbwZpGhmM5QJp2hBJ2hzDpDWXSGssoM5epZ+D8byrA9GyJDcTpD8TpDGXWGYjpDmXSGEnSGMusMZdEZyiozFNP5tTWdX1vT+bU1nV9b0/m1NZ1fW6v4uzIu2/bHcVkO7+LY77GsOmOZBqGxOKGxeKGxjEJjCTL9hElnfg4683PQmZ+Dzvx89SC0wR2GMqeHYtuLmGb7n+08/h6JyYxkkhlJkBnJLDOSRWYkq8pIrh62VHAkTmYk/lMjeX38+NmPt89+/PTZjw+f/fj5sx+/fPbj149+/DJ89uPdZz/+s9/a5bPf2uWz39rls9/aq8cdDMu23W1Ylyu/3VePGig4kkVmJKvKSK6+3l5wJE5mJF5mJBW3Dv6HI6m3y8P8ug3Bpx/16/zeEeLXdV+79SHWYxm2zbvTMLrjwy/MBuYamCcw18AcwFwD8wzmGpgXMNfAvPaFeX6/WW5//Hv3R/+AMdd8z14fhgPGDsN3BePrV2P70fBnGH2lkwwMA8YOoy+nP/n3o5OfzzD68uMZGH255jQM15fPSB7ePLu+ZpPkG01zzbdk9WGIziZuekcqc4dBfMF4DVv0d9/ZnBy26C+0G9fksEX7BLlhi+buzLB9Zwn5nq7M7DvL3ndh7ivV34aZ1cwqmA3MNTCzmlkFc2ermcn2s+9szTENo7OVwTSMvtbv0u3nsbO+WhpGXxkiA6Oz9btk+3nsbP0uDcOAscPobJUmuTBhfc0m6V689TWbZGCIziaZhQkT/d3PLEyY6C90plVuqqtXmWGrrl5lhs2u3BpdGWNXbhXMne3KvQnzxGpmFcysZlbBzGpmFcydrWYm28+TAWOH0dnKYBpGZ7ufk+3nqbO+WhpGXxkiA6Oz9btk+zl0tn6XhtHZ+l0ahrEwscPoazZJ9+JDX7NJBobqrvL0wsQs+rufWZiYRX+hM63yWXX1KjNs1dWrzLD7mrnu6srM7MqtgpkzhqpgZjWzCmZWM6tgZjWzBuaF04v2JLRwetEBRmcrg2kYnF50gGHA2GF0dnpRGganFx1gcHrRAUZn63dJGGtnqzTJhYnOztNO9+I7O/U6A0N1V3l6YUL1rOfMwoTq2cmZVrnqWcTpYS+qpwbnhq05c42zvW3pOJ/v6FxET+LNDlszdWaHbc8ctubcmx225iyZHbbmLJkdtuYsmR225iyZG7bombfZYT9zlnTPnCVFzwLODvuZs6To+brZYT9zlhQ9Xzc77GfOkqLn6+aGLXq+bnbYz5wlRc9/zQ77mbOk6Pmk2WE/c5YUPT8zO+xnzpKiZ1Jmh/3MWVL0nMfssJ85S4qenTh+Oer3sJfjdrj3sEVnydywRWfJ3LCvzpLL++ODN5cetlvt/bl+cPtF26ObY08Pbn4v8rnBu/Hb86/BhycPfn7y4JcnD3598OAvn2556+Ddkwfvnzz48cmDtycP/skzrAnPsN6t++BHn3veubdpci7sr2yMv42QCU/HhSsVnrsLVyo80f+wUlvfn/71H+dTpZOwKyhcqbCFKFypsN/4YaVhfzxYOFcqbE4KV2rdVCpsewpX2o5HylXajkfKVdqORwph2SpdlnOl7XikTKWhHY+Uq7Qdj5SrtCGPlKm0IY+UqdS6qbQhj5SptCGPlKm0IY+UrnRWnk+Pjc1l+uupsTkL/5yO4z748fC67n/l+Vexwr+oPyx2nrY/4Xk+90xm4V/UwpUK/6IWrlQ4ofyw0mU74cYth3F/VXp+eBnfve2vBesTlEXY+H4QytcHbnPSMLkzlnZ+1n+EJbMQcvm4oEaxtDNbFMXSztRSFIuws78Ti3Cr9E4sfbqWHJZVODTeiUW4Y1sMy6vSHozrq9JmvKgfhu24268m0rlS66bSZhxjttKLJtDPw7vS8XCccrRS77YTkr2f8g2v7LbFq+d/3Tv45cmDX587+PXqiWD3Dt49efD+yYMfnzx4e/LgpycP/sEz7DoIz7BFN5Gvg/B0XLhS4bm7bKVOeKIvuol8dcKuoHClwhaicKXCfqPoNtz16gFtD6pU2MkUrlTY9hSutB2PlKu0HY+Uq7Qdj5Te3rf6djxSrtJ2PFKu0nY8Uq7ShjxSplLrptKGPFKm0oY8UqbShjxSptKGPFK60lF5Ps28GLCOwj+npV8MWEfhX9Sim8jXUfgXtXClwr+oZSs14YRy14sBqwkb3/teDFitnZ/1gvsOV2tnAiiKpZ3ZoiiWdqaWoliEnf2dWIRbpTdimfp0LVkswqHxTizCHdui2+XXqQfj+qrUWqk0s4l8nZqxl9lKm3GMuUrDx36oXx/vP/vx42c/3j778dNnPz589uPnz378RRtuw/tXO5gN6a+gc/sWLX+4ViN6B8c0Le+LWqZw+EbFP3mwvZExZ4bxk2vFv1rf72ePn+vXyMPz/K5uGQ6PTrHP9dtt5QdNoo/6dd5+WdZ19zo+xKAN24/cNBwvLgm/1V5Rux+1r541hdqPUtuhdkdqe9TuSO0RtTtS21D7BrW3/pPN4/HRlyYTmshpEtBETpMZTepr8jWjbBOKP2tCj0dPEzoxcpos9Evu0MS/H538fNaEroaeJvQe9DQhn9yhyTaEySKa4Ltu0CRM7+GG2Z01wXfJabLiu1KauOndLTR3YPGlyYseDilJz+YkPbxMkt64JumxLnGFnkHvAj0c7w0z+V1rYiu9/p7UZhWhJ7XJyT2pTQLvRu1xGMj2PalNL+IOtRM7Mr40ocOhpwl9Ez1NDE3qa5LakfGlCT0ePU3oxOhpQr/kDk0SOzK+NKGroacJvQc5TRz55A5NEjuXvjTBd92gSWqXzJcm+C49TfBdKU2SO5e+6OGQkvRSO5e+6OFlkvRSu0fGwbMucYUeff4r9HC8N8zkd62JeXr9PaltqN2R2uTkntQmgfekNtm+J7XpRdyhdnJHhqfDIafJSN9ETxO6MTdokt6RMdLj0dOEToyeJoYmN2iS3JEx0tXQ04Teg54m5JM7NEnuXDJ81w2apHfJGL5LTxNDk4QmmZ1LhkNK0kvvXDK8TJJeeveIsS5xhR59/iv0cLw3zOR3rYlN9Pp7UptVhJ7UJif3pDYJvCe1DbU7UptexB1qJ3dkTHQ49DShb6KnCd2YGzRJ78iY6PHIaRLoxOhpQr/kDk2SOzICXQ09Teg96GlCPrlDk+TOpYDvukGT9C6ZGd+lpwm+K6VJZufSjENK0kvvXJrxMkl66d0js0HvAj36/Ffo4XgTgxhnew9inJeDN7Xf9OidX6FHl/sKPXLRBXoLCeYKPbLGFXpkjSv0yBpX6Bn0LtAja1yhR9a4Qo+scYUeWeMKPbLGBXorWeMKPbLGFXpkjSv0yBpX6Bn0LtAja1yhR9a4Qo+scYUeWeMKPbLGf52eG8gaV+iRNa7QI2tcoUfWuELPoHeBHlnjCj2yxhV6ZI0UvcW9d96Oy/GUgzc9ssYVemSNC/RcG1nDbYeOfP1Lvg3jVWUbmSBXpTVRpR/99smzZR5e7T0MP7hle3h0c/RL5uZx+5Z5N357/sWwDRd1L8M2vNS9DNtwVPcybMNX3cuwDXd1K0Pfhse6l2EbDu5ehm30du9l2EaH916GBsPLDMkpOYberTvD0eee/4p+W7gO+1DG342SRi5IfxBwElBl4MSlwsBtL9LW+QycbFUXeCMXfD8IOKmtMPCwPx4snIET8SoDJw9WBm4ArwucpFkZOEmzMnCSZmngYduoEJblDJykWRk4SbMucCNpVgZO0qwMnKRZGThJszJwA3hd4CTNysBJmpWB48OzwI87H5bp2/O/GDZyu/MnGY7jznA8XMfyX3n+xRzvUZj5PG2/K/N8Xjhr5JrjBwHHe1QGTg+wMPBlu47WLQd8X8DPDy/jeyvQMq4nbRq5/vGh2nx94P4q6OTO6mCA7lQns4uukSshW1XHUEdYHUyYsjp0i5TVYRODsjqkHWV1aMsKq9PIRcWPUOcFnPhfGTiJvixwPwzL9uk+ApyQXhm4AbwucOLAjZYm3V5v5M7cx7bXh2H7bHdWp5F7UVtVB6ukrA6+6lZ10guHjdwb26o6LH4oq8Pih7I6pB1ldcg7yuqw+CGsTiP3DreqDr2CW9WZtoXDIZzftmnk3uRW1aFXoKyOoY6wOvQKlNWhV6CsDr0CZXXoFajknZg69Ap006hv5N7wVtWhV6CsDr0CZXXoFSirY6gjrA69AmV16BUoq0OvQFkdegXK6tArEFbH0StQVoc0qqwOaVRZHUMdYXVIo8rq4Kiz6rj9Dajx+ArU77NyvcP3XmbocafXGbLedJ0hPvw6Q9zydYYGw8sMcZ7XGbJacZ0hawrXGZJTrjMkp1xmOJJTrjMkp1xnSE65zpCccp2hwTDD0O+jHsZhzT2fPhvXj4SawsC/fNE2lGPz/Q2cBFQZOHGpMnCyVWXgBLHSwIPbhrKcJ02uLi8N3PbHbT3/hXN1eW3gBvC6wPHhhYGH/eLtYOEMHB9eGTg+vDJwfHhl4PjwusAnVk8qA2eppTJwkmZl4CTNysAN4HWBkzQrAydpVgZO0qwMnKRZGThJszTwsL3XFpbTuYU+kDQrAydpVgZO0qwMnKRZGbgBvC5wbGFh4Lbd2ezMf1tEPj+cvELYz8yvN2qTO0ZhZjJWVoeZ+051MjvaZ0MdYXXoPiurQ6taWR362srqkHaU1aFjLqzOQntdWR16Bcrq0CtQVodegbI6hjq11HkBJ/5XBk6irwyckF4ZOLm7MnCidF3gK+m4NHDbTsi36by9ciXwVgZOhq0MnFhaGbgBvC5wkmZl4CTNysBJmpWBkzQrAydpVgU+DiTNysBJmpWBkzQrAydplgaePElwHAzgdYGTNCsDJ/hcAf5iSJa5zpB4cpmhI3FcZ4jFKj0BlXrPduQy+Tu1ccOwXzjkIurgJJTVwaMoq4P7uVWd5Dvqo8dXKatD21dZHXrEyuqQdpTVMdQRVodWtbI67KBSVodewa3qTNubnENYzurQK1BWh16BsDojvQJldegVKKtDr0BZHXoFyuoY6ojknZg69AqE0+hIr0BZHXoFyurQK1BWh16BsDpGr0BZHXoFyurQK1BWh16BsjqGOsLq0CtQVodegbI6pFFldUijwupMpFFldUijyurIuoLg502ddc188tfT70+e1m9SvqqU7cSXrFL3evqfVOmdvf9ivfdT7mE3bg9Pc/ab5ubtmJrBu/Hb8y+Gsr9WD2Io2+F6EEPZPtSDGBoMLzOU7ek8iGETHutmhk04uJsZyvaYHsRQthP0HIYzOeU6Q3JKtqvi1p3h6HPPpy8JHGdCTWXgJKDKwA3gZYFnTjCdyVaVgRPEKgMntRUGHvbHg53PWZ+JeJWBkwfrAl8Ij5WBkzQrAydpVgZO0iwNPGybTsJyfql4MYDXBU7SrAycpFkZOEmzMnCSZmXgJM26wFeSZmXgJM3KwEmalYHjw7PAjzsflunb8y+GGI8cw3HcGY527fkXc7xHYebztP2uzPNp4cx0r+BuFTjeozJwA3hZ4Mu8vR22rN/e9Ds/nLyu0HSv1u1Bm8wrm6Z7aW8X6qR30ZnudcCoM5ruRcOo86UOJkxZHbpFyuqwiUFZHUMdYXVoyyqrw16Kauq8gBP/KwMn0ZcF7oftiCw/+AhwQnpd4LoX0bcKnDhwo6VJt9d1b8fuo70+DNtnu4g6uB9ldbBKyurgq25VJ71wqHvDL+p8qcPih7I6LH4oq0PaUVbHUEdYHRY/lNVh8UNZHXoFt6qTvFnedG/4RZ0vdegVCKuje8Mv6nypQ69AWR16Bcrq0CtQVsdQRyTvxNShVyCcRnVv+EWdL3XoFSirQ69AWR16BcLq6N6/jDpf6tArUFaHXoGyOvQKlNUx1BFWh16Bsjr0CpTVIY0qq0MaFVYnkEaV1SGNKqtjqJNTx+1vQI3HV6B+n5VrAd97nSHu9DpD1puuM8SHX2eIW77McMbTXmeI87zOkNWK6wxZU7jO0GB4mSE55TpDcsp1huSU6wzJKdcZklMuM1zIKTmGfh/1MA5r7vnM2bgLoaYwcO+3a4v8sfn+Bk4CqgycuFQZuAG8LnCCWGngwW1FLpFJE7dcGLjtj9sa+QvHWtcFztXltYHjwwsDD/vF28HCGTg+vDJwfHhl4AbwusDx4ZWBs3pSGThLLZWBkzQrAydpVgU+DSTNysBJmpWBkzQrAydpVgZuAK8LnKRZGnjY3msLy3IGTtKsDJykWRk4SbMycJJmXeCOpFkZuAG8LHDb7mx25r8tIp8fTl4hPDnm1xu1yRyjMDkmY2V1mLnvVCe9o33yTPPK6tB9VlaHVrWyOvS1ldUx1BFWh465sjq015XVoVegrA69AmV16BUIqzPSK6imzgs48b8ycBJ9ZeCE9MrADeB1gROlKwMnHZcGbtsJ+Tadt1eOBN7KwMmwlYETS+sCN5JmZeAkzcrASZqVgZM0KwM3gNcFTtKsDJykWRk4SbMycJJmZeAkzdLAkycJThNJszJwkmZl4ASfK8BfDA2GlxkST64zJHFcZ4jFKj0BFXvPlsvk79TGDcN+4ZCLqIOTUFbHUEdYHdzPreqk31EP+CpldWj7KqtDj1hZHdKOsDozeUdZHVrVyuqwg0pZHXoFt6ozbW9yDuF81uBsqCOsDr0CZXXoFSirQ69AWR16Bcrq0CsQVmehV6CSd2Lq0CsQTqMLvQJldegVKKtjqCOsDr0CZXXoFSirQ69AWR16Bcrq0CsQVmelV6CsDr0CZXXoFSirY6gjrA5pVFkd0qiyOqRRXXXC0ISjdmHY1hiD98eHX1U20Yl3y2jvT16H3DBWew/DD27J/g26eTvAZfBu/Pb8i6HB8DLDJnzEzQybmO1vZtjEnHwzwyb6uDczbKLbei9D14aDu5dhE53Lmxk20V+8mSE55TpDg2Gu3+DWneHoc8+nr88LjlBTGTgJqDJw4lJh4OmzPYMjW1UGThCrC9yT2goDD/vjwcIZOBGvMnDyYGXghMfKwA3gdYGTNCsDJ2mWBh627RhhWc7ASZqVgZM0KwMnadYFPpI0KwMnaVYGTtKsDJykWRm4AbwucJJmZeD48Czw486HZfr2/C+GbVx2/1GG47gzHG2+9PyLOd6jMPN52n5X5vm8cNbGffdPAm4ArwucHmBh4Mv8JuKW9ds7cOeHkxf5hTauVX6qNrmXGdu4g/mx6mR20U1YJWV18FXK6hjqCKtDt0hZHTYxKKtD2lFWh7assjrspaimzi/ggfhfGTiJvixwP2yHR/mvJbwzcEJ6ZeDk7srArQngq9uBLy798E/Po8u+Yx/aCLz3Mmwjlt7LsI3weC/DNiLevQzbCGK3MpzbyFb3MmwjLt3LsI0EdC/DNkLNvQwNhpcZklNyDMuelNTGJfJPAk4CqgycuFQYeOakpDZub38Q8DYuZH8ScFJbYeCZY03auDb9ScDJg5WBG8DrAidpVgZO0qwMnKRZGnj6lfg2Lgp/EnCSZl3gbVzn/STgJM3KwEmalYGTNCsDN4DXBU7SrAycpFkZOD48CzxzFtg8YDxyDEufBTY3csu4EPP0SUnzYACvCxzvURk4PcDCwIudBTY3cmnwQ7XJnAU2N3Id8VPVSe+imxu56LhVdQx1hNXBhCmrQ7dIWR02MSirQ9pRVoe2rLA6jVwo/Qh1XsCJ/5WBk+jLAs+clDQ3cqH0g4AbwOsCJw7caGnS7fVGbuZ9bHt9GLbPdmd1GrnktFV1sErK6uCrblUnvXDYyF2rrarD4oeyOix+KKtD2lFWh7yjrA6LH8LqGIsfyurQK7hVnWlbOBzCclaHXoGyOvQKlNUx1BFWh16Bsjr0CpTVoVegrA69ApW8E1OHXoFwGp3oFSirQ69AWR16Bcrq0CtQVsdQR1gdegXK6tArUFaHXoGyOvQKlNWhVyCsTqBXoKwOaVRZHdKosjqGOsLqkEaV1cFRZ9Vx+xtQ4/EVqPdZuQHfe5nhjDu9zpD1pusM8eHXGeKWrzM0GF5miPO8zpDViusMWVO4zpCccp0hOeUyw4Wccp0hOeU6Q3LKdYbklOsMDYYZhn4f9TAOa+75zNm4C6GmMHDvt2uL/LH5/gZOAqoMnLhUGTjZqjJwglhp4MFtRS7nSZOry0sDt/1xW89/4VxdXhu4AbwucHx4YeBhv3g7WDgDx4dXBo4PrwwcH14ZOD68KvBlYPWkMnCWWioDJ2lWBk7SrAzcAF4XOEmzMnCSZmXgJM3KwEmalYGTNEsDD9t7bWE5nVu4OJJmZeAkzcrASZqVgZM0KwM3gNcFji0sDNy2O5ud+W+LyOeHk1cIL5759UZtMscoLJ7JWFkdZu471UnvaF+8oY6wOnSfldWhVa2sDn1tZXVIO8rq0DEXVmekva6sDr0CZXXoFSirQ69AWR1DnVrqvIAT/ysDJ9FXBk5Irwyc3F0ZOFG6LnAjHZcGbtsJ+Tadt1cagbcycDJsZeDE0srADeB1gZM0KwMnaVYGTtKsDJykWRk4SbMu8ImkWRk4SbMycJJmZeAkzdLAkycJLpMBvC5wkmZl4ASfK8BfDMky1xkSTy4zDCSO6wyxWKUnoGLv2XKZ/J3auGHYLxxyEXVwEsrq4FGU1cH93KpO+h31GV+lrA5tX2V16BErq0PaUVbHUEdYHVrVyuqwg0pZHXoFt6ozbW9yDuF81uBMr0BZHXoFwuos9AqU1aFXoKwOvQJldegVKKtjqCOSd2Lq0CsQTqMLvQJldegVKKtDr0BZHXoFwuqs9AqU1aFXoKwOvQJldegVKKtjqCOsDr0CZXXoFSirQxpVVoc0qqvOOpBGldUhjSqrY02os4y7OkNuGKu9h+EHt2TVGcdxV8eyai7zm4hbVpdWJ/nW6Dq04acfqk3mzbd1aMOxtapOG46tUXVcG47tseqkPYFrw7G1qk4b6wetqtPG+kGr6hjqCKtD3lFWp431g1bVaWOvYavq0Cu4VZ3kGwiro1cgrI6nV6CsDr0CZXXoFSirQ69AWR1DHWF16BWo5J2YOvQKhNOop1egrA69AmV16BUIqzPSK1BWh16Bsjr0CpTVoVegrI6hjrA69AqU1aFXoKwOvQJldUijwuoYaVRZHdKosjqkUWV1cNRZddz+BtTozve1fn0cDC8zxJ1eZ8h603WG+PDLDCfc8nWGeNrrDHGe1xmyWnGdocHwMkNyynWG5JTrDMkp1xmSU64zJKdcZhjIKdcZklNyDH94JqBz2+sSLthf/33DNhBqCgP3ft2KtPkMnARUGbgBvC5wslVl4ASx0sCD24pcIpMmbrkwcNsft/X8Fz5jrSsDx4dXBo4PLww8uG3SDBbOwPHhlYEbwOsCx4dXBo4Prwyc1ZPKwFlqqQycpFkX+ELSrAycpFkZOEmzMnCSZmXgBvC6wEmalYGTNEsDD9t7bWE5n1u4kDQrAydpVgZO0qwLfCVpVgZO0qwMHFtYGPhPLnhOXyG8Mr/eqE3uGIWVyVhWHRsGZu471UnuaP9Sh2leWR26z8rq0KpWVsdQR1gd0o6yOnTMldWhva6sDr0CZXXoFQir4+gVKKtDr6CaOi/gxP/KwEn0lYEbwOsCJ3dXBk6UrgycdFwauG0n5NsUzsAJvJWBk2HrAvfE0srASZqVgZM0KwMnaVYGbgCvC5ykWRk4SbMycJJmZeAkzcrASZp1gY8kzdLAUycJfgEnaVYGTtKsDNwAfgH4iyFZ5jpD4sl1hiSOywy5Tr74BFToPdsvbXBjN2rjhmG/cMhF1DHUEVYHj6KsDu7nVnXS76gbvkpZHdq+yurQIxZWZyLtKKtD3lFWh1a1sjrsoFJWx1DnTnWm7U3OISxndegVKKtDr0BZHXoFyurQK1BWh16BsDqBXoGyOvQKVPJOTB16BcJpNNArUFbHUEdYHXoFyurQK1BWh16Bsjr0CpTVoVcgrM5Mr0BZHXoFyurQK1BWh16BsjqkUWV1SKPK6pBGldUhjQqrs9Scd/y0MfSLT6szbrzHZSfigo+NYhvvbOP+bJSebauRk3Pfnn3xCPD4xmOGxzceCzy+8VjhceRR9T73J/BwnfGY3GYqpiXzrPuakt8Ddm6/mMb737Pz6qF3gd4IvQv0rCa91W+W9nBDU5SeG9y8HTY3eDd+88uvsU8PHnt48NjnB499efDY18eO3Q3Dg8fuHjx2/+Cxjw8e+3PnVTfozqverfvYR/9t7DH3k7wS0g26k3DhQnVn7MKF6k7vPyw0fS6qG3S9QNlCna5xKFyorsv4YaFhfzxYOBeqa0kKF6rrXwoXar0U2owzyhXajDPKFdqMMwphWwIOy3IutBlnlCu0GWeUKdQ344xyhbbjjDKFtuOMMoW244wyhVovhbbjjDKFtuOMMoUKz6PHDuYy/fXUwRx1f0jHcR/7aHNOpOTzr1p1f0t/WOs8bX+/83xukIy6v6WFC9X9LS1cqG4m+WGhy7x9+LJ+2397fjh5iYgzXbP7QSaZDczOmvlB/xGVzGqHNfPTX5RKM/NEUSrNTCpFqei6+Tup6DZF76TSpVvJUtGNiTdSmXR7s8WovArtwK6+Cm3Fgfphe7HQf7WMzoW2YiqzhVonhc5dGuJ0zJ77tMPpe/7c3KfFyVHp0+JkqCwdWJyfN6oW2ncxKn2273JU+mzf5agYVCJUOvUrGSp9tu9yVPps3+WodOptk/dyuKVTb5umsnbqbTNUOvW2GSqdetsMlU69bYaKQSVCBW8bo4K3jbg44bNH7qTSqbfNUOnU2yapeOGTWO6kQt82RoW+bYwKfdsYFYNKhAreNkYFbxujgreNUcHFRagIH4tzJxVcXIwKLi5GRXhmdvvOm9F9vyniNXbh+TM7duFZLjt24T5LduzC82hu7MJHneTHLjwnZccuPHNkxy6c0rNjtweP/cHzqvDhHvmxP3he9Q+eV4XPScmOfXzwvDoKnwr2s5ve0u8SeuHDbH5Y6Nd35f24t/lcqPCpYGULtV4KFT4VrGyhwqeC/bDQ4LZCl8iPkfCpYD+8XzN5HLc34dM1yxbazDyaK7SZeTR9prEXPhaocKHNzKO5QpuZR3OFNjOP5goVPne8bKHC546XLbQZZ5QpVPhsm8KFNuOMcoX24oyEz7YpXKj1Umgvzmhqxxklzx33UzvOKFNoO84oU2g7zihdaGjHGWUKbccZZQptZnqx7Yw4Z/5bc+z8cPLoNB+a+d36CZPcdsLQTmO8IJW5nS76T6hkVnTndlruJak0k0KLUmkmshalYlCJUOnSrWSpNJOci1JpJmYXpdKnt81R6dPbZqgIH4B7J5UOvO2r0A7s6qvQDhzoq1DrpdAOfOKr0A6s36vQdtycbW8E23ReBhM+xbVwoe14rnShwmetFi60HWeUKbQdZ5QptB1nlCnUeim0HWeUKbQdZ5QptBdnJHwGaOFCO3FGo/BJnUXfzBmFD98sXGg7zihTqD2y0NfYn+kBXmN/5rT+GvszZ+pfYxc+ju+ufWKj8GF8H90Rlbw2cXTP/GX8NJU+dy7kqPS5cyG9p3AUPkDwTirsyo1RYVduhIrwcYp3UunUr2So9LkrN0elz125OSrWJ5Xk9Waj8IGYd1Lp1NtmqHTqbTNUOvW2GSqdets0FeEjTe+kgreNUcHbRlxcO8ewFqViUIlQ6dTbZqjQt41RoW8bo0LfNkaFvm2ESkNnEpekgreNUcHbxqjgbWNUcHExKri4GBVcXIwKLi5CpeoBum6v048uTWWalvctF1PwLvPJg+1VzplhmL37cGZrehBf1c3vZ4+f69fIw/P8rm4ZDo9OseK2IUyHm0q+Hn1p4tHkBk3C+9FpDmdNRjSR08TQRE6TCU3kNAloIqfJjCZymixoIqfJiia3arJMJ02qnqGOJv85Tcjxt2iy5fg1ogk5/g5NpiWlCTleTxNDEzlNyPE3aBL8Rs0vZ03I8XqakOP1NCHH62lCjr9DE2ebJutJk5kcr6cJOV5PE3K8nibkeD1NDE3kNCHH62lCjr9Xk/GcT2ZyvJ4m5PhbNBk3ahFNyPF3aDJMCU0WcryeJuR4PU3I8Xdosq0zhtmdNSHH62liaCKnCTleTxNyvJ4m5Hg5TVbyyQ2apN8xXcknd2iSfNdhJZ/oaUI+0dPE0EROE/KJnibkEz1NyCd6mrDOeK8mkfcZV9YZ1TSxgRx/iyaJd0xtIMffoUnq3TkbyPF6mpDj9TQxNKmvSfI9LRvI8XqakOP1NCHH62lCjr9Dk9S7DjaQ4+U0ceR4PU3I8XqakOP1NCHH62liaCKnCTn+Xk3O7zOaI8fraUKOv0WTxDum5sjxd2iSenfOHDleThNPjtfThBx/hyap90/Mk+P1NCHH62liaCKnCTleTxNyvJ4m5JMbNEm+Y2oj+eQOTVLvOthIPtHThHyipwn5RE8TQxM5TcgnepqQT/Q0YZ3xXk0i7zOOrDPqaUKOv0WT1DumRo6/Q5Pku3NGjtfThByvpwk5/gZN0u9pmaGJnCbkeD1NyPF6mpDj79Ak+a6DkeP1NCHHy2kykeP1NCHH62lCjtfThByvp4mhya2aRN5nnMjxepqQ42/RJPWO6USOv0OT5LtzEzleTxNyvJwmgRx/hybJ908COV5PE3K8nibkeD1NDE3kNCHH62lCPrlBk/Q7poF8cocmyXcdZvKJnibkEz1NyCd6mpBP9DQxNJHThHyipwnrjPdqEnmfcWadUU8TcvwtmqTeMZ3J8Xdoknx3biHH62lCjtfThBx/gybp97QWcryeJoYmcpqQ4/U0IcffoUnyXYeFHK+nCTleTxNyvJwmKzleTxNyvJ4m5Hg9Tcjx92oSeZ9xNTSR04Qcf4smqXdMV3L8HZok351byfF6mpDj9TQhx9+hSer9k2kgx+tpQo7X04Qcr6cJOV5PE0MTOU0u5hM/D1uXwHwahndbfPV+2t+tHN0c5TyO4wZ6tOzzy/z+83DLYdyjRR5exrcuy7geH31BWbqE4oZh2D7bnbE4B5YYFg+WGJaxUyzjPj1M7ozFwBLDMoElhiWAJYalT9eSxdKrb8lgWcESweIHsMSw9Opyp2n77LCcsfTqcjNYenW5GSwGlhiWXl1uBkuvLjeDpVeXm8GCy41iweXG7NyIy41i6dXlZrD06nIzWOjlRrEYWGJY6OVGsdDLjWKhlxvFgsuNYsHlxrAYLjeKBTsXxYKdi2IxsMSwYOeiWJQnaLdvzRmPe3O+nn8NXnkazQ1+Up7ssoNXbrxkB688n2YHrzzrZQevPDdlB688g2QHrxzbs4NXDtfZwT95hp2ePMOGJ8+w4ckzbHjyDBuePMNevZXwk4P3+8tMwzisueed2xbQXbBTcgnC0/EPK/V+fT/uj/HvXanw3F24UuGJvnClwq6gcKXCFuKnlQa3Vbqcf5Fm4Vnvh5Xa/ritZ01n4SmycKXtzKe5StuZT4PbfpGChXOl7cynuUrbmU9zlbYzn+YqbWc+zVS6COf3wpUKh/3ClbbjkXKVtuORcpVaN5V245GWbjzS0o1HWrrxSEtDHils+zfCcn5fZm3II2UqbcgjZSptyCNlKm3II2UqtW4qbWeWsWGr1Py3jtn54eRZbGFo58frJ1Ayuw/D0FDHvCSWhtrrP8GSXvENQzu/oUWxtBNKi2JpJ8EWxdJO3C2KpU/XksXSTpAuicW1k7qLYunU5eawdOpyc1hwuVEs1gGWV6U9GNdXpT140VelPdjLV6U9OMZXpT2YwF+VKh8m+9NKbXun2KZwrrQhq5aptCH3lam0IUOVqdS6qbQhj5SptCGPlKm0IY+UqbQhj5SptCGPlK5U+SjSwpV245GUDwwtXGkvby4F5WM9C1fakEfKVPpQ5/Aa/EPNwGvwD53ffw1e+VzF/OD7XCZI7ydTPuTvoxunkrc1But0c0MOS6ebG3JYOt3ckNl9qHww4Z1Y2MIbxcIW3iiWTjc35LAYWGJYOt3Cm8PS6RbeHJZeXW7yRrWgfNDmnVh6dblpLMqHg96JpVeXm8HSq8vNYOnV5WawGL4lhgWXG7NzDR3vWhRLry43g6VXl5vBQi83hmWmlxvFQi83ioVebhQLvdwoFgNLDAsuN4oFlxvFgp2LYsHOxbA0dCJyUSzYuSiWixO0W+Y3Fm8ujcWt9v5cP7gli+WDV56md85dPcL3oVBye6Gung3bKpYVLBEsV0+dfSyW9A/u1SNqW8XiwRLDMoIlhsXAEsPSq2/JYAlgiWGZwRLD0qvLTe9XWHt1uUks89Cry81g6dXlZrD06nIzWHp1uRksBpYYFlxuFAsuN2Ln5gGXG8XSq8vNYOnV5aaxOHq5USz0cqNY6OVGsdDLjWIxsMSw4HKjWHC5USy43CgW7FwMi8fORbFg56JYsHNRLMoTtNu35ozufGDe7JWn0ezglSe77OCVGy/ZwSvPp7nBj8qzXnbwynNTdvDKM0h28MqxPTt4e/LgnzzDjk+eYccnz7Djk2fY8ckzrD15hjXhGfaHLwilb4+cTXg6/mGl3q/vx73N50qF5+7ClVo3lQq7gsKVCluIn1Ya3FbpEvlFEp71it7OMU/CU2ThStuZT3OVtjOfBrf9IgUL50rbmU9zlbYzn+YqbWc+zVXaznyaq1Q4vxeuVDjsF660HY+UqTS045FylbbjkXKVduORQjce6eoRxg+qtBuPFBrySGHbvxGW8/syoSGPlKm0IY+UqbQhj5SudG7II2UqbcgjZSptZ5YpdovpPLfz41Xw3L55bqhjXhDL0lB7/SdYMiu+S0O9+JJY2gmlRbG0k2CLYjGwxLD06VqyWNoJ0kWxtJO6i2Lp1OXmsHTqcjNYlI/WvRNLDy73VWkPxvVVaQ9e9FWpdVNpD47xVWkPJvBVaUO+zrZ3im06r5Apnw9buNKG3Fey0kX5FNfClTbkkTKVNuSRMpU25JEylVo3lTbkkTKVNuSRMpX24pEW5dNFC1fajUdSPgO06Ps8i/KxnoUrbcgjZSq1Z1b6GvxDzcBr8A+d31+Df+iU/Wvwysf83bWfbFE+5O+jG6eStzUu/qG/j5/G0unmhhyWTjc3pHcfLsoHE96JhS28USxs4Y1hUT6m8U4svfqWDJZOt/DmsHS6hTeHxTrFkrxRbVE+aPNOLL263AyWXl1uBkuvLjeDpVeXm8aifFTqnVhwuVEsuNyYnWvoeNeiWAwsMSy9utwMFnq5USz0cqNY6OVGsdDLjWFp6bTjklhwuVEsuNwoFlxuFAt2LooFOxfFgp2LYsHOxbBcPpd3tDcWd9hKHcVi9u6Ime1FzmPs0cG/cdswD9vDfo08PM/v4S7D4dEp8ui0DWE6XEPy9egLhu8LRng/Os3hDGMExg7DgLHDmICxwwjA2GHMwNhhLMDYYay9wlimE4zLRxo3BaMzBxo2B7pGYHTmQKclBaMzB5qGYcDYYfTlQIP3W+9hOcPoy4FmYPTlQDMw+nKgGRh9OdDgtuH69QRj6cuBZmD05UAzMPpyoBkYfTnQDAwDxg6jMweahtGZA91hjGefsXTmQNMwOnOg7n2wVLAIjM4c6DAlYKydOdA0jM4caBpGZw5063SF2Z1hdOZA0zAMGDuMzhxoGkZnDjQNozMHmoKxDp2ttaY2uK1Db2utiS0J68BuvwMMdvsdYBgwdhjs9jvAYLffAQa7/Q4wut3td97TtQ7s9tthuN52+yU2uK2uMwea2sa0Onb7HWCw2+8Aw9i5s8Ngt98BBrv9DjDY7XeA0dtaa2JLwurY7bfD8Oz2O8Bgt98BBrv9DjDY7XeAYcDYYXS72++8p2v17PY7wOhtt19ig9vqO3OgqW1Mq2e33w5jZLffAUZnDjS5P2Nkt98BBrv9DjAMGDsMdvsdYLDb7wCjs7XW5AY36/ZklciWBGO33wEGu/0OMNjtd4BhwNhhsNvvAIPdfgcY3e72i+zpMnb7HWD0ttsvtcFt6syBJrcxTez2O8Bgt98BRmedruTOncmAscNgt98BBrv9DjC6PVklsiVhYrffAQa7/XYYgd1+Bxjs9jvAYLffAQa7/Q4wjD1dOwx2+x1g9LbbL7XBrbP7TdLbmDq73yQDg91+O4zO7jdJ78/o7H6TDAx2+x1gsNvvAMOAscNgt98BRmdrrckNbp3dYpHektDZLRYZGOz2O8Bgt98BBrv9DjAMGDsMdvsdYHS72y+yp6uzWywyMHrb7Zfa4NbZLRbpbUyd3WKRgcFuvwOMzjpdyZ07vd1ikYZhwNhhsNvvAKPbk1UiWxJ6u8UiDYPdfgcY7PZ7w5iGzu43ycBgt98BBrv9DjC63e132tP1BcOAscPobbfff7zB7QtGZw40sY3pCwa7/Q4w2O13gNGZA03sz5iGzu43ycBgt98BBrv9DjDY7XeAYcDYYVz0GcMOY5gzMKb5XeC07DDGwf0eylJvKGFYt8BmkaGsMkO5en9CyaE4naF4naGMOkMxnaFMNYcybM+GyFCCzlBmnaEsOkNZZYYyDjpDcTpD8TpDGXWGYjpD0fm1HXV+bUedX9tR59d21Pm1NY1f279+/df/7+/++c9/9/f/+A//8vWP/PG//p+//Pd//fM//eX3f/3X//9/v/6Xr4f/Lw==",
      "brillig_names": ["compute_note_hash_and_optionally_a_nullifier"]
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": ["public", "initializer"],
      "abi": {
        "error_types": {},
        "parameters": [
          {
            "name": "_admin",
            "type": {
              "fields": [{ "name": "inner", "type": { "kind": "field" } }],
              "kind": "struct",
              "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
            },
            "visibility": "private"
          }
        ],
        "return_type": null
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": ["constructor"],
      "assert_messages": {
        "128": "attempt to add with overflow",
        "448": "Array index out of bounds",
        "698": "Array index out of bounds",
        "110": "Array index out of bounds",
        "366": "Array index out of bounds",
        "616": "Array index out of bounds",
        "430": "Array index out of bounds",
        "415": "attempt to add with overflow",
        "598": "Array index out of bounds",
        "592": "attempt to add with overflow",
        "394": "Array index out of bounds",
        "522": "Array index out of bounds",
        "510": "attempt to add with overflow",
        "571": "Array index out of bounds",
        "117": "Array index out of bounds",
        "690": "Array index out of bounds",
        "678": "attempt to add with overflow",
        "538": "Array index out of bounds",
        "340": "Initializer address is not the contract deployer",
        "334": "Initialization hash does not match",
        "462": "attempt to add with overflow",
        "72": "attempt to add with overflow",
        "386": "Array index out of bounds",
        "706": "Array index out of bounds",
        "374": "attempt to add with overflow",
        "563": "Array index out of bounds",
        "630": "attempt to add with overflow",
        "106": "attempt to add with overflow",
        "551": "attempt to add with overflow",
        "344": "Aztec Passport: Invalid Address",
        "402": "Array index out of bounds",
        "530": "Array index out of bounds",
        "719": "attempt to add with overflow",
        "579": "Array index out of bounds"
      }
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "00000000000000000000000000000000000000000000000000000000850bb34d"
            },
            { "kind": "string", "value": "AddressNote" },
            {
              "fields": [
                {
                  "name": "address",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": { "kind": "boolean", "value": false }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": { "kind": "boolean", "value": false }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": { "kind": "boolean", "value": false }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "000000000000000000000000000000000000000000000000000000003de78269"
            },
            { "kind": "string", "value": "ValueNote" },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": { "kind": "boolean", "value": false }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "npk_m_hash",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": { "kind": "boolean", "value": false }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": { "kind": "boolean", "value": false }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": { "kind": "string", "value": "AztecPassport" }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_services",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "services",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "service_indexes",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "scores",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AztecPassport::get_total_services_parameters"
              }
            },
            {
              "name": "return_type",
              "type": { "kind": "integer", "sign": "unsigned", "width": 64 }
            }
          ],
          "kind": "struct",
          "path": "AztecPassport::get_total_services_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "service_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecPassport::get_service_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        { "name": "inner", "type": { "kind": "field" } }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "weight",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "base_score",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "max_score",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "service::Service"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecPassport::get_service_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        { "name": "inner", "type": { "kind": "field" } }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecPassport::get_service_index_parameters"
              }
            },
            {
              "name": "return_type",
              "type": { "kind": "integer", "sign": "unsigned", "width": 64 }
            }
          ],
          "kind": "struct",
          "path": "AztecPassport::get_service_index_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        { "name": "inner", "type": { "kind": "field" } }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "weight",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "base_score",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "max_score",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecPassport::add_service_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecPassport::add_service_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "new_admin",
                    "type": {
                      "fields": [
                        { "name": "inner", "type": { "kind": "field" } }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecPassport::set_admin_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecPassport::set_admin_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AztecPassport::get_admin_public_parameters"
              }
            },
            { "name": "return_type", "type": { "kind": "field" } }
          ],
          "kind": "struct",
          "path": "AztecPassport::get_admin_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "_admin",
                    "type": {
                      "fields": [
                        { "name": "inner", "type": { "kind": "field" } }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecPassport::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecPassport::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AztecPassport::get_total_services_private_parameters"
              }
            },
            {
              "name": "return_type",
              "type": { "kind": "integer", "sign": "unsigned", "width": 64 }
            }
          ],
          "kind": "struct",
          "path": "AztecPassport::get_total_services_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        { "name": "inner", "type": { "kind": "field" } }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecPassport::get_service_index_private_parameters"
              }
            },
            {
              "name": "return_type",
              "type": { "kind": "integer", "sign": "unsigned", "width": 64 }
            }
          ],
          "kind": "struct",
          "path": "AztecPassport::get_service_index_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "address",
                    "type": {
                      "fields": [
                        { "name": "inner", "type": { "kind": "field" } }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "service_id",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "service_address",
                    "type": {
                      "fields": [
                        { "name": "inner", "type": { "kind": "field" } }
                      ],
                      "kind": "struct",
                      "path": "address_note::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AztecPassport::verify_service_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AztecPassport::verify_service_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"
    },
    "101": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr",
      "source": "use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::get_ovsk_app, public_keys::{PublicKeys, OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_log\n};\nuse dep::protocol_types::{hash::sha256_to_field, address::AztecAddress, abis::note_hash::NoteHash};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] = compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress\n) {\n    let ovsk_app: Field  = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"
    },
    "103": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes, encrypted_logs::{header::EncryptedLogHeader},\n    keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::{OvpkM, IvpkM}}\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P]\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe {\n        random()\n    };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(plaintext: [u8; P], eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field\n    ).to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::{compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext},\n        keys::public_keys::{OvpkM, IvpkM}\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{address::AztecAddress, point::Point, scalar::Scalar};\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41, 2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239, 247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118, 183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183, 12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78, 101, 153, 0, 0, 16, 39\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_log(contract_address, ovsk_app, ovpk_m, ivpk_m, recipient, plaintext);\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239, 95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25, 244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91, 68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76, 26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178, 143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189, 117, 147, 101, 230, 132\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(recipient, recipient_ivpk, sender_ovsk_app, eph_sk, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n"
    },
    "116": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "117": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"
    },
    "119": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr",
      "source": "/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\nunconstrained pub fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"
    },
    "120": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(storage_slot, note_type_id, serialized_note, note_hash, counter)\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter)\n    };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"
    },
    "121": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr",
      "source": "/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\nunconstrained pub fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"
    },
    "122": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained pub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "125": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "126": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(contract_address: AztecAddress, randomness: Field, encrypted_event: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(contract_address, randomness, encrypted_event, counter)\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\nunconstrained pub fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n"
    },
    "129": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"
    },
    "130": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"
    },
    "138": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n"
    },
    "151": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "156": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/initializer.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"
    },
    "157": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"
    },
    "160": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr",
      "source": "use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"
    },
    "162": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"
    },
    "163": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr",
      "source": "use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m: NpkM { inner: Point::empty() },\n            ivpk_m: IvpkM { inner: Point::empty() },\n            ovpk_m: OvpkM { inner: Point::empty() },\n            tpk_m: TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x: serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x: serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x: serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "171": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context> Storage<T> for Map<K, T, Context> {}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V where K: ToField {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "172": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr",
      "source": "use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> where T: ToField {\n    fn serialize(self) -> [Field; 3] {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> where T: FromField {\n    fn deserialize(input: [Field; 3]) -> Self {\n        Self {\n            pre: FromField::from_field(input[0]),\n            post: FromField::from_field(input[1]),\n            block_of_change: FromField::from_field(input[2])\n        }\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"
    },
    "173": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr",
      "source": "use dep::protocol_types::traits::{Serialize, Deserialize};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32)) + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33)\n            + (self.post.is_some() as u64 * (1 << 32))\n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some {\n                Option::some(pre_inner)\n            } else {\n                Option::none()\n            },\n            post: if post_is_some {\n                Option::some(post_inner)\n            } else {\n                Option::none()\n            },\n            block_of_change\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"
    },
    "177": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr",
      "source": "use dep::protocol_types::{\n    hash::{poseidon2_hash, poseidon2_hash_with_separator}, address::AztecAddress,\n    traits::{FromField, ToField}, utils::arrays::array_concat\n};\n\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::mem::zeroed;\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// Separators separating storage slot of different values within the same state variable\nglobal VALUE_CHANGE_SEPARATOR: u32 = 0;\nglobal DELAY_CHANGE_SEPARATOR: u32 = 1;\nglobal HASH_SEPARATOR: u32 = 2;\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, let INITIAL_DELAY: u32, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> where T: ToField + FromField + Eq {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], VALUE_CHANGE_SEPARATOR)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], DELAY_CHANGE_SEPARATOR)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], HASH_SEPARATOR)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> where T: ToField + FromField + Eq {\n\n    pub fn schedule_value_change(self, new_value: T) {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> where T: ToField + FromField + Eq {\n    pub fn get_current_value_in_private(self) -> T {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage(self) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) {\n        let header = self.context.get_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = unsafe {\n            get_public_storage_hints(address, self.storage_slot, historical_block_number)\n        };\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        if hash != 0 {\n            assert_eq(\n                hash, SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint), \"Hint values do not match hash\"\n            );\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            assert_eq(\n                value_change_hint, ScheduledValueChange::deserialize(zeroed()), \"Non-zero value change for zero hash\"\n            );\n            assert_eq(\n                delay_change_hint, ScheduledDelayChange::deserialize(zeroed()), \"Non-zero delay change for zero hash\"\n            );\n        };\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field {\n        let concatenated: [Field; 4] = array_concat(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UnconstrainedContext> where T: ToField + FromField + Eq {\n    unconstrained pub fn get_current_value_in_unconstrained(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    unconstrained fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, let INITIAL_DELAY: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) where T: ToField + FromField + Eq {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"
    },
    "179": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "182": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/private_set.nr",
      "source": "use dep::protocol_types::{constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, abis::read_request::ReadRequest};\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, create_note_hash_from_public, destroy_note_unsafe},\n    note_getter::{get_notes, view_notes}, note_getter_options::NoteGetterOptions,\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request, note_emission::NoteEmission\n};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateSet<T, Context> {}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PublicContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:insert_from_public\n    pub fn insert_from_public(self, note: &mut Note) {\n        create_note_hash_from_public(self.context, self.storage_slot, note);\n    }\n    // docs:end:insert_from_public\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, &mut PrivateContext> where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // docs:start:insert\n    pub fn insert(self, note: &mut Note) -> NoteEmission<Note> {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    pub fn pop_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        let (notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in less constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, note, note_hash);\n            }\n        }\n\n        notes\n    }\n\n    /// Note that if you obtained the note via `get_notes` it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding an extra hash and read request check.\n    pub fn remove(self, note: Note) {\n        let note_hash = compute_note_hash_for_read_request(note);\n        let has_been_read = self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, note, note_hash);\n    }\n\n    /// Note that if you later on remove the note it's much better to use `pop_notes` as `pop_notes` results\n    /// in significantly less constrains due to avoiding 1 read request check.\n    pub fn get_notes<PREPROCESSOR_ARGS, FILTER_ARGS>(\n        self,\n        options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note, let N: u32> PrivateSet<Note, UnconstrainedContext> where Note: NoteInterface<N> + NullifiableNote {\n    // docs:start:view_notes\n    unconstrained pub fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, N>\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n"
    },
    "224": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr",
      "source": "use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"
    },
    "233": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE: u32 = 4;\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // We choose the last SELECTOR_SIZE bytes of the hash to avoid getting the first byte that is not full\n        let hash_bytes = hash.to_be_bytes::<SELECTOR_SIZE>();\n\n        FunctionSelector::from_field(field_from_bytes(hash_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector = FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "24": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "25": {
      "path": "std/field/bn254.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "26": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"
    },
    "266": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "279": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "280": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "mod assert_array_appended;\nmod assert_array_prepended;\nmod assert_combined_array;\nmod assert_combined_sorted_transformed_value_array;\nmod assert_combined_transformed_array;\nmod assert_deduped_array;\nmod assert_exposed_sorted_transformed_value_array;\nmod assert_sorted_array;\nmod assert_sorted_transformed_value_array;\nmod assert_split_sorted_transformed_value_arrays;\nmod assert_split_transformed_value_arrays;\nmod get_sorted_result;\nmod get_sorted_tuple;\nmod sort_by;\nmod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{assert_array_appended, assert_array_appended_reversed, assert_array_appended_scoped};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_sorted_transformed_value_array::{\n    assert_combined_sorted_transformed_value_array_asc,\n    get_combined_order_hints::{CombinedOrderHint, get_combined_order_hints_asc}\n};\npub use assert_combined_transformed_array::{assert_combined_transformed_array, combine_and_transform_arrays};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint}\n};\npub use assert_deduped_array::{assert_deduped_array, dedupe_array};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc, assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints}\n};\npub use assert_sorted_transformed_value_array::{assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N> where T: Empty + Eq {\n    let mut len = 0;\n    for elem in array {\n        if !is_empty(elem) {\n            len += 1;\n        }\n    }\n\n    BoundedVec { storage: array, len }\n}\n\nunconstrained pub fn find_index_hint<T, let N: u32, Env>(array: [T; N], find: fn[Env](T) -> bool) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32 where T: Empty + Eq {\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32 where T: Empty + Eq {\n    let length = unsafe {\n        find_index_hint(array, |elem: T| is_empty(elem))\n    };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N] where T: Empty + Eq {\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N]\n) where T: Eq + Empty {\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe {\n        find_index_hint(values, |v: Field| min.lt(v))\n    };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe {\n        find_index_hint(values, |v: Field| min.lt(v))\n    };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "29": {
      "path": "std/hash/mod.nr",
      "source": "pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    pedersen_hash_with_separator_noir(input, separator)\n}\n\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator_noir(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n"
    },
    "299": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    /// \n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    /// \n    /// example\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    /// \n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    /// \n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    /// \n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    /// \n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    /// \n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Ord + Eq {\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Eq {\n    /// Returns a new sorted array by sorting it with a custom comparison function. \n    /// The original array remains untouched. \n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    /// \n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    /// \n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]), \"Array has not been sorted correctly according to `ordering`.\"\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n"
    },
    "301": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr",
      "source": "// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"
    },
    "302": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field where K: ToField {\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f);\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript = 0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "304": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl <let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"
    },
    "305": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl <T, let N: u32, let M: u32> Serialize<N * M> for [T; N] where T: Serialize<M> {\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl <T, let N: u32, let M: u32> Deserialize<N * M> for [T; N] where T: Deserialize<M> {\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n"
    },
    "308": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"
    },
    "309": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "317": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "318": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"
    },
    "321": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\npub struct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "332": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/easy-private-state/src/easy_private_uint.nr",
      "source": "use dep::aztec::{\n    context::PrivateContext, protocol_types::{address::AztecAddress},\n    note::note_getter_options::NoteGetterOptions, state_vars::PrivateSet,\n    encrypted_logs::encrypted_note_emission::encode_and_encrypt_note, keys::getters::get_public_keys\n};\nuse dep::value_note::{filter::filter_notes_min_sum, value_note::ValueNote};\n\npub struct EasyPrivateUint<Context> {\n    context: Context,\n    set: PrivateSet<ValueNote, Context>,\n    storage_slot: Field,\n}\n\n// Holds a note that can act similarly to an int.\nimpl<Context> EasyPrivateUint<Context> {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        let set = PrivateSet::new(context, storage_slot);\n        EasyPrivateUint { context, set, storage_slot }\n    }\n}\n\nimpl EasyPrivateUint<&mut PrivateContext> {\n    // Very similar to `value_note::utils::increment`.\n    pub fn add(self, addend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let owner_keys = get_public_keys(owner);\n        let outgoing_viewer_keys = get_public_keys(outgoing_viewer);\n        // Creates new note for the owner.\n        let mut addend_note = ValueNote::new(addend as Field, owner_keys.npk_m.hash());\n\n        // Insert the new note to the owner's set of notes.\n        // docs:start:insert\n        self.set.insert(&mut addend_note).emit(\n            encode_and_encrypt_note(\n                self.context,\n                outgoing_viewer_keys.ovpk_m,\n                owner_keys.ivpk_m,\n                owner\n            )\n        );\n        // docs:end:insert\n    }\n\n    // Very similar to `value_note::utils::decrement`.\n    pub fn sub(self, subtrahend: u64, owner: AztecAddress, outgoing_viewer: AztecAddress) {\n        let owner_keys = get_public_keys(owner);\n        let outgoing_viewer_keys = get_public_keys(outgoing_viewer);\n\n        // docs:start:pop_notes\n        let options = NoteGetterOptions::with_filter(filter_notes_min_sum, subtrahend as Field);\n        let notes = self.set.pop_notes(options);\n        // docs:end:pop_notes\n\n        let mut minuend: u64 = 0;\n        for i in 0..options.limit {\n            if i < notes.len() {\n                let note = notes.get_unchecked(i);\n\n                minuend += note.value as u64;\n            }\n        }\n\n        assert(minuend >= subtrahend);\n\n        // Creates change note for the owner.\n        let result_value = minuend - subtrahend;\n        let mut result_note = ValueNote::new(result_value as Field, owner_keys.npk_m.hash());\n        self.set.insert(&mut result_note).emit(\n            encode_and_encrypt_note(\n                self.context,\n                outgoing_viewer_keys.ovpk_m,\n                owner_keys.ivpk_m,\n                owner\n            )\n        );\n    }\n}\n"
    },
    "334": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/value-note/src/balance_utils.nr",
      "source": "use dep::aztec::{context::UnconstrainedContext, state_vars::PrivateSet, note::{note_viewer_options::NoteViewerOptions}};\nuse crate::value_note::ValueNote;\n\nunconstrained pub fn get_balance(set: PrivateSet<ValueNote, UnconstrainedContext>) -> Field {\n    get_balance_with_offset(set, 0)\n}\n\nunconstrained pub fn get_balance_with_offset(\n    set: PrivateSet<ValueNote, UnconstrainedContext>,\n    offset: u32\n) -> Field {\n    let mut balance = 0;\n    // docs:start:view_notes\n    let mut options = NoteViewerOptions::new();\n    let notes = set.view_notes(options.set_offset(offset));\n    // docs:end:view_notes\n    for i in 0..options.limit {\n        if i < notes.len() {\n            balance += notes.get_unchecked(i).value;\n        }\n    }\n\n    if (notes.len() == options.limit) {\n        balance += get_balance_with_offset(set, offset + options.limit);\n    }\n\n    balance\n}\n"
    },
    "337": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/value-note/src/value_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"
    },
    "34": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "35": {
      "path": "std/hash/sha256.nr",
      "source": "use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\nglobal ZERO = 0;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"
    },
    "58": {
      "path": "std/option.nr",
      "source": "use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "59": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "6": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(s, quote { Eq }, signature, for_each_field, quote { & }, body)\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "68": {
      "path": "std/uint128.nr",
      "source": "use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"
    },
    "7": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"
    },
    "70": {
      "path": "/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/l2-contracts/crates/passport/src/service.nr",
      "source": "use dep::aztec::prelude::AztecAddress;\n\nuse dep::aztec::protocol_types::traits::{Serialize, Deserialize};\n\npub struct Service {\n    address: AztecAddress,\n    weight: u64,\n    base_score: u64,\n    max_score: u64,\n}\n\nimpl Serialize<4> for Service {\n    fn serialize(self) -> [Field; 4] {\n        [\n            self.address.to_field(), self.weight as Field, self.base_score as Field, self.max_score as Field\n        ]\n    }\n}\n\nimpl Deserialize<4> for Service {\n    fn deserialize(data: [Field; 4]) -> Self {\n        Service {\n            address: AztecAddress::from_field(data[0]),\n            weight: data[1] as u64,\n            base_score: data[2] as u64,\n            max_score: data[3] as u64\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/l2-contracts/crates/passport/src/main.nr",
      "source": "pub mod service;\n\nuse dep::aztec::macros::aztec;\n\npub global SCALE: u64 = 1000000;\n\n#[aztec]\npub contract AztecPassport {\n    use aztec::{\n        prelude::{AztecAddress, PublicMutable, Map, SharedMutable},\n        macros::{storage::storage, functions::{initializer, public, private, view}},\n        keys::getters::get_public_keys\n    };\n\n    use dep::value_note::{balance_utils::get_balance};\n\n    use dep::easy_private_state::EasyPrivateUint;\n    use crate::service::Service;\n\n    pub global SCALE: u64 = 1000000;\n\n    #[storage]\n    struct Storage<Context> {\n        // Admin of Contract\n        admin: PublicMutable<AztecAddress, Context>,\n        // Track Count of Total Services\n        total_services: SharedMutable<u64, 1, Context>,\n        // Service ID => Service\n        services: Map<u64, PublicMutable<Service, Context>, Context>,\n        // Service Address -> ID\n        service_indexes: Map<AztecAddress, SharedMutable<u64, 1, Context>, Context>,\n        //  Address => Service ID => verified(boolean)\n        scores: Map<AztecAddress, Map<u64, EasyPrivateUint<Context>, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(_admin: AztecAddress) {\n        assert(!_admin.is_zero(), \"Aztec Passport: Invalid Address\");\n        storage.admin.write(_admin);\n    }\n\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Unauthorized Admin Change\");\n        storage.admin.write(new_admin);\n    }\n\n    #[public]\n    #[view]\n    fn get_admin_public() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    #[public]\n    fn add_service(address: AztecAddress, weight: u64, base_score: u64, max_score: u64) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Only Admin\");\n        let service_id = storage.total_services.get_current_value_in_public();\n        storage.services.at(service_id).write(Service { address, weight, base_score, max_score });\n        storage.service_indexes.at(address).schedule_value_change(service_id);\n        storage.total_services.schedule_value_change(service_id + 1);\n    }\n\n    #[public]\n    #[view]\n    fn get_service(service_id: u64) -> Service {\n        storage.services.at(service_id).read()\n    }\n\n    #[public]\n    #[view]\n    fn get_total_services() -> u64 {\n        storage.total_services.get_current_value_in_public()\n    }\n\n    #[private]\n    #[view]\n    fn get_total_services_private() -> u64 {\n        storage.total_services.get_current_value_in_private()\n    }\n\n    #[public]\n    #[view]\n    fn get_service_index(address: AztecAddress) -> u64 {\n        storage.service_indexes.at(address).get_current_value_in_public()\n    }\n\n    #[private]\n    #[view]\n    fn get_service_index_private(address: AztecAddress) -> u64 {\n        storage.service_indexes.at(address).get_current_value_in_private()\n    }\n\n    unconstrained fn is_verified(address: AztecAddress, service_id: u64) -> bool {\n        let res = storage.scores.at(address).at(service_id).set;\n        let balance = get_balance(res);\n        balance as u32 >= 1\n    }\n\n    unconstrained fn get_all_verified(address: AztecAddress) -> [Service; 10] {\n        let mut verified_services: [Service; 10] = [Service { address: AztecAddress::zero(), weight: 0, base_score: 0, max_score: 0 }; 10];\n\n        let total = storage.total_services.get_current_value_in_unconstrained();\n\n        for i in 0..total {\n            let service = storage.services.at(i).read();\n            let res = storage.scores.at(address).at(i).set;\n            let balance = get_balance(res);\n            let verified = balance as u32 >= 1;\n            if (verified) {\n                verified_services[i] = service;\n            }\n        }\n        verified_services\n    }\n\n    #[private]\n    fn verify_service(address: AztecAddress, service_id: u64, service_address: AztecAddress) {\n        assert(service_address.eq(context.msg_sender()), \"Aztec Passport: Only Service\");\n        let res = storage.service_indexes.at(service_address).get_current_value_in_private();\n        assert(res == service_id, \"Aztec Passport: Invalid Service\");\n        storage.scores.at(address).at(service_id).add(1, address, address);\n    }\n\n    unconstrained fn get_total_score(address: AztecAddress) -> u64 {\n        let mut total_weight: u64 = 0;\n        let mut total_base_contribution: u64 = 0;\n        let mut total_max_contribution: u64 = 0;\n        let mut verified_count: u64 = 0;\n\n        let total_services = storage.total_services.get_current_value_in_unconstrained();\n\n        for i in 0..total_services {\n            let service = storage.services.at(i).read();\n            total_weight += service.weight;\n            let res = storage.scores.at(address).at(i).set;\n            let balance = get_balance(res);\n            let verified = balance as u32 >= 1;\n            if (verified) {\n                total_base_contribution += (service.base_score * service.weight) / SCALE;\n                total_max_contribution += (service.max_score * service.weight) / SCALE;\n                verified_count += 1;\n            }\n        }\n\n        if (verified_count == 0) {\n            0\n        }\n\n        let diminishing_factor = verified_count / total_services;\n        let bonus_multiplier = (verified_count * SCALE) / total_services;\n\n        let adjusted_max_score = total_max_contribution * diminishing_factor;\n        let final_score = (total_base_contribution + adjusted_max_score) * bonus_multiplier / SCALE;\n\n        final_score\n    }\n}\n"
    },
    "73": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/address-note/src/address_note.nr",
      "source": "use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"
    },
    "79": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr",
      "source": "use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"
    },
    "80": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\nunconstrained pub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"
    },
    "82": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr",
      "source": "use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N> + NullifiableNote {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\nunconstrained pub fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"
    },
    "83": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/note_header.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Empty, Serialize}};\n\nglobal NOTE_HEADER_LENGTH: u32 = 4;\n\npub struct NoteHeader {\n    contract_address: AztecAddress,\n    nonce: Field,\n    storage_slot: Field,\n    note_hash_counter: u32, // a note_hash_counter of 0 means non-transient\n}\n\nimpl Empty for NoteHeader {\n    fn empty() -> Self {\n        NoteHeader { contract_address: AztecAddress::zero(), nonce: 0, storage_slot: 0, note_hash_counter: 0 }\n    }\n}\n\nimpl Eq for NoteHeader {\n    fn eq(self, other: Self) -> bool {\n        (self.contract_address == other.contract_address)\n            & (self.nonce == other.nonce)\n            & (self.storage_slot == other.storage_slot)\n            & (self.note_hash_counter == other.note_hash_counter)\n    }\n}\n\nimpl NoteHeader {\n    pub fn new(contract_address: AztecAddress, nonce: Field, storage_slot: Field) -> Self {\n        NoteHeader { contract_address, nonce, storage_slot, note_hash_counter: 0 }\n    }\n}\n\nimpl Serialize<NOTE_HEADER_LENGTH> for NoteHeader {\n    /// The following method is used by implementations of the Serialize trait for notes --> the implementation\n    // of the Serialize trait for notes needs to be implemented when the note is passed as an argument to a contract\n    // function --> in that situation the serialize method is called by aztec-nr when computing an arguments hash.\n    fn serialize(self) -> [Field; NOTE_HEADER_LENGTH] {\n        // Note: If you change this function don't forget to update implementations of Serialize trait for notes.\n        // (Serialize trait needs to be implemented for a note when it's passed as an argument to a contract function\n        // --> then it's used when computing args hash.)\n        [\n            self.contract_address.to_field(), self.nonce, self.storage_slot, self.note_hash_counter as Field\n        ]\n    }\n}\n"
    },
    "85": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr",
      "source": "/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"
    },
    "94": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{execution::{get_chain_id, get_version, get_contract_address, get_block_number}, storage::storage_read};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "95": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn () -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        panic(f\"'delegate_call_public_function' not implemented!\")\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained pub fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"
    },
    "96": {
      "path": "/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"
    }
  }
}
