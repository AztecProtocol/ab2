{"transpiled":true,"noir_version":"0.35.0+b848cc128d2dc2b461581f21a35509a1af9065a7-aarch64","name":"ENSModule","functions":[{"name":"get_admin_public","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAAQIRAAAJAAEAAMkAAQABB8AAAAABAAAAAMAAAhDIgAAAAgrAAADCEM5AAAACEMAAAABHgAAAAQeAAAABTAAAAAABAAAAAUAAAAGJAACAQUKAAIGBQQhAAAPAAQ6AQAAHgALAAYkAAcBBQoABwYFBCEAABQABDoBAAAqAAAGJAAEAgQAAAQABAAkAQQBBgAABAYCBCoABAckAAcACCoCCAcqAQYEAAAEBAIEKgIEBioAAAQAAAQAAgAqAgYEJAAEAQgkAAQABioABgMgACYKAAQDBgchAAAvAAcgACkqAQQFAAAEBQIDAAAEAwYHKgEHBCoABAMjKgEEBxwABwMJAAAHBQkKLAAAAAAKAAAACSQABAELDAAEAwsMIQAANwAMOgEAACsAAAcIAyUABAACCAQiAAAARSsACAUACgAABAoCDAAABAwDCyoCCQsAAAQDCAkOAAQDCQchAABCAAc6AQAAKgIKBCoACQMgACYrAQgDCAYLAAQIBgACCAchAABJCAcgAEsrAAgDCAUgAFkrAAAACAUBAAQAAAgEAAAlAAQAAAgJDQAECAkIBAgKFwAICggKIQAAVwgKAQAECAMICQgLKwEICwgIAQAECAUICQgLKwIICAgLAQAECAkAAggJIABOJQEEAAEIBSAAWSMrABjKGMo=","debug_symbols":"1ZrdbsIwDIXfJddcxHF+bF5lmqaywVSpKhOwSRPi3ddubehKFQSMKb5BpD2Jvyapj1t1r16Wi/fXp7Jerbdq/rBX1fq52JXrumntDzO12JRVVb4+DQ8r3f7Qt3z7VtRta7srNjs1h2DsTC3rl/Yv2maAVVkt1Tzow+xEzBg6LbsQpeBwQmsNcCe2xlBUs5kQewLsxJ4MD8WPM8U3g4OGKNYD8d3RQd8+6aEfn/ncpIOxvRgMc5qcwPUUBIOhO3L4Q/Jm0n+jtwHMvQPgvQPYewdwNwdwjvsIzuszOyKQcZ04kKXxjvAX0rR9whV96Io+fHkfM31vApi+D6A+l1cCRbHG4/oFP7UW7Pu84ph1ei1cQOjFAc1oLQwIZjeC2VEwuxXM7gSze8HsQTA7CWZnuewo2FdRsK+iYF9Fwb6KmecZR5HdjZ9Pbeb7PdjITnrM/v/7PT4we61dmh00++PQRzFq/w2PkuGtZPjMS5rk7Zp3qiGIaZIMjNkzL2nipplgd5mXNIRHdpMWs8Weg204uVDBfuAyr3+S7JnXP0l2K5g98/cKSfbM3ysk2TM34SR75vV+kj1zE06x+8xNOMku2Fe9YF/1gn3VC/ZVL9hXvVhfPTStj2JTFotq2X0Osnqvnwdfh+w+337ONOIv","brillig_names":["get_admin_public"],"assert_messages":{"14":"Not initialized","65":"attempt to add with overflow","54":"Array index out of bounds","19":"Function get_admin_public can only be called statically"}},{"name":"verify","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"content","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_public_storage_hints","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","get_public_storage_hints","build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","get_l1_to_l2_membership_witness","pack_arguments_oracle_wrapper","call_private_function_internal","unpack_returns","pack_arguments_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"is_admin","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"JAAEAQIlAAQIRAAAJAAEAAMkAAQABB8AAAAABAAAAAMAAAhDIgAAAAgrAAADCEM5AAAACEMAAAABHgAAAAQeAAAABTAAAAAABAAAAAUAAAAGJAACAQUKAAIGBQQhAAAPAAQ6AQAAHgALAAUkAAcBBgoABwUGBCEAABQABDoBAAAqAAAFJAAEAgQAAAQABAAkAQQBBQAABAUCBCoABAckAAcACCoCCAcqAQUEAAAEBAIEKgIEBSoAAAQAAAQAAgAqAgUEJAAEAQgkAAQABSoABQMgACYKAAQDBQchAAAwAAcgACkqAQQDAAAEAwIGAAAEBgUHKgEHBB4AAgAFCgAHBAUDIyoBBAccAAcDCQAABwYJCiwAAAAACgAAAAkkAAQBCwwABAMLDCEAADgADDoBAAArAAAHCAMlAAQAAggEIgAAAEYrAAgFAAoAAAQKAgwAAAQMAwsqAgkLAAAEAwgHDgAEAwcJIQAAQwAJOgEAACoCCgQqAAcDIAAmKwEIAwgGCwAECAYAAggHIQAASggHIABMKwAIAwgFIABaKwAAAAgFAQAEAAAIBAAAJQAEAAAICQ0ABAgJCAQIChcACAoICiEAAFgICgEABAgDCAkICysBCAsICAEABAgFCAkICysCCAgICwEABAgJAAIICSAATyUBBAABCAUgAFojKwAYyhjK","debug_symbols":"1ZrdbuIwEIXfJddceMb22MOrrFZVaKGKFIUK6EorxLtv0o2dbMg6bSmV5wYROLY//57xKOfiabt5fX6omt3+WKx/nIt6/1ieqn3TPp0vq2JzqOq6en4Y/1yo7sO/yY8vZdM9HU/l4VSswaFZFdvmqfuqTVvBrqq3xdqpy+pKzNr1WrYuSsHqGa1B4F5sEH1UM86IyYPuxeSRx+Kfq4JvBgcFUaxG4rujg7p90F2on3lp0AFNEAMyp8k92EDhYVR1Tw5fSN4O+r/oXQN47wb0vRsw927A3tyAtRxasKQWVoTzaHux88ZPVwR9kKYr4z5Rxn+iDH+8DM7vTYRhC2lYOlecD+J2Aof5czQ3F0zhXLHMKj0X1mkIYqdxMhcIgtlRMLsWzG4Es1vB7CSY3Qlm94LZWS67FuyrWrCvasG+qgX7qs78nLE+stvp/dRkvt6diexeTdm/f73HCzMpZdPsoJiGqgexVvQGryXDG8nw/wklY24L0No0vNEeQ4JILy1iYors7K424DuCQ1qgwdBdQ3DVW8mHU95BkIdoCh5hwm4zD4LiFpljz9wUvB7YMS3mdquG7KlxVx3NPGJKuZ/NPGJKshvB7JlnIpLsmWcikuyZZyKS7JmbcJI980xEip0yN+Eku+CbGQn2VRLsqyTYV0mwr5JgXyWxvnppn36Vh6rc1Nv+5Zfda/M4ehfm9Pvl7z+t+A8=","brillig_names":["is_admin"],"assert_messages":{"66":"attempt to add with overflow","55":"Array index out of bounds","14":"Not initialized","19":"Function is_admin can only be called statically"}},{"name":"set_ens_registry","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"_registry","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"7Z3djuQ4coXfpa/3QiSDf/sqhmHM2mtjgMGssTs2YCzm3Z1V2WJmtSSysuekkh1xbhY1O5xMnY9V0heUxPjnl//461/+57/+7edf//Nv//jy53/555df/vbvP/32899+vfzTP3//05e//P3nX375+b/+7f7//rK8/U95H/6P//7p17d/+sdvP/39ty9/dtnLn7789df/ePsxyOUD/vPnX/765c95+f1Pm8E15K9ja8xtqIthZ6x4V78OFu9LG139zuBUXPg6OBVf7wf/65++1D984G5xbfByN/jph+6WPw49r59f6wi687IOdr7W/pEXF9ejKO7uo78euQMe+QX6x0N/+wL/7C8Iz/4CefYXxN0vSDGt/1Gqpf8FIcv6uxxydrdvyLIzOvq6fB0dg5fB6ODKeiDBp2Uw+vI3eBfWu9DGB7c3Pnm//l35u7HyDiYRzD6YTDD7YArB7IOpBLMLxi8Esw/GEcw+GE8w+2ACweyDEYLZB0PzPQBD8z0AQ/M9AEPzPQBD890HE0ybb0uZ7tY4v4Ixbb49MKbNtwfGtPn2wAjB7IMxbb49MHbM9y2tHZ19S2vHUd/S2hHPS1qxY5Nvae0o4ltaO973ltaOzL2lFVNp7WjXW1pTLiWmXEpMuZSYcqloyqWiKZeKplwqmnKpKKbSmnKpaMqloimXiqZcKppyqWTKpZIpl0qmXCqZcqkkqtLe3jW6/Bz8h7Q7452L63CXbsdyvUWWdIkXFI0uS4Oi0aV0UDS6/A+KRpcsItFkXWb5IBqpLabUbx/iyLo0FIpGl7NC0egSXCgaIZojNKZtuI/GtA2n2/Ak6Vs0pm24j8a0DffRmLbhLppi2ob7aEzbcB+NaRtOqbSYpXyLxrQN99EI0RyhMW3DfTS2bbiLxrYNd9HYtuEuGts23ENTbdtwF41tG+6ioQ0foqENH6Fxi7Kr9/2DISV+YPMW1+k6t4Zwtzeo5MGvgs9lvSXp893Wr19/FZyuk+tjbFyO7a8q57xho+vsimWj6/SKZaOrbnyQTcnrDkKuVHfPZju4hPXcVML21KSrWngixssHtsv9Et23IJXtWPpMkN3nd5yyHU5fCNL0lRUJ0vRlGAlSCBIDUtf9hBeCpEWCQOpa7XghSF13NmAg39mwWDlko2zfWCwbyyWFX5a1bvWXFe4NG8tVwoiNZfEfsZHT2aS1tVf0pY5G17R+dqz1xma3GVvMwa2D8919n6/N2F6wK+zLoiY7UbOdqMVO1Gom6gv2/3xi1Fha1Lhp5CmqzsC5fXQuyybq7Gfg1rc0LUvsRy0prT1rS8q3wZcI16yzn4KRWWc/ByOzzn4SfiirxFvW9CHrzkfH29/23b1WtxcxLrG5/i2gT9fmswsR/lGEjgj/KMLZFeMHQBiI8I8iFEUIs1tF97JmmTaXzji76SKzalLdUVZVqtu2N7hkzaedBlQZ9GsQqhLzlyBMqsT8NQhViflrEGoS88sqWEN49x7NeulMmgx6lFUMZVWluoOsqlQ33lT3/qN3T3k+59urUeXupvPirmQ0iTGWjCbfxZJ5rsa+fcWTtxF9/wr3/K/wz/+K8PyvkOd/RXz+V6Tnf0V+/lcATkplWR/WC2X4kFMUaTfB5f5e0/4jUSGs1+Egy+izh9vdO8TWcj9QXMR2cT9SXGcrrrcVN9iKK7biRltxk6242VZcW1ZVdFkVsn2Fq7oUDMtGl69h2eiSO+SG+67qMkEsGyGbQza6HBO5RbiruoQUy0aXvWLZ6FJdLBvTXtxl4xfTXjxgY9qLB2xMe/GAjWkvHrARsjlkQy8+ZkMvPmZDLz5mQy8+ZkMvPmTj6MXHbOjFx2zoxcdsbHtxr62Fd0I2h2xse3GfjW0v7rOx7cV9Nra9uM/Gthd32XjbXtxnY9uL+2xse3GfjTK/6bc0817XpQfZ0sx7XZeeAGxN5YOuSw+Wja5LD5aNWGaDamnmg65q6mUtzXywfP0D9vTwwfTFEghSTF9ZkSBNX4aRIHWViy8EqeueywtBCkFiQOpa7XghSF23fpCtqbywWDlmY3r9rdt+yYvlkmLAJlquEkZszhf/dm24YBo1KQP2x/HR24ka7EQVO1GjnajJTtRsJ2qxE7WaiZoWO1Ht2FKyY0vJji0lVdfVXo9In1SdgXs9In2e/Qz8yM7QtbSdoWu9a5xzOez3rLOfgpFZZz8HI7POfhJ+KGv7275kzR+ybkdLyGtGCXejU9k7jk4XEI/YGNs8w9mL7B+B4eyW8SMwnH1Z4EdgOPt6w/MYil/LgMuP9Z7hO5jZ3fhVYIoqk0aCUaXdj4FpZabI3cMMKxhVjv4gmNzA5LABY1foB2BED5jq2s3o6qRuqrqiyKaHWRVZ7zCrIju9ZPUta/LbrIoscphVkRhesrqW9UPrqmvWqsj1hlkV6dswqyIjq66u8lm9L9usiiRrmFVUZc0ta9iuhldN3uTTbV7rzrxq8iaf2ry+t/H+Nqsmbxpl1eRNlzvnt6xbH66avCnIbV5z/jZrWDR50yirJm8KcvsdLnGbVZM3Sdvnpsq2fg2LJm8aZRVVWZtLXFbZNlkhO1m1waGUYY901/ojR5dC/+izLGvlksV/+3BWgGw1dXfw9SP6968Iz/8Kef5XAOy4+vbSzeWvZjDLrqZ1tF+WsPm1A7xjK679iYkL28yAt0+HX5Ge/xX5+V9RAF8hS/uKVAa/HGUp61ppceFudKrXA6qTHRDgfTjwAbmzD8gl1w7o7nnKtwPa++v3qyReTgR+e/hlosN/P6A62QGlZbYDAvzGXdZt1gPykgYHlC63h1bLCX7kRMG10cGn0eh+g929Y1lPoMnfjb2ePgHP/WslE0jmgIxYJtNSppg3ZCLJHJBJJHNAJpPMAZlCMgdkKsnskwG8G/WjkHmPa0ds3+PasdX3uHYU9D2u2IprRxbf49oxwPe4drTuPa4dV3uPa0fA3uIWW1ZVbFlVsWVVxZZVAd4/mSnugx2NulvThqJLwbBsdPkalo0uucOy0WWCWDa6tBHKpupyzAfZSG0xpW5WNasuIcWy0WWvWDa6VBfLRsjmkI1pLx6wMe3F6TY83R35ysa0Fw/YmPbiARvTXtxlI4tpLx6wMe3FAzamvbjbyVwW0148YCNkc8jGtBcP2Nj24j4b217cZ2Pbi/tsbHtxl42z7cV9Nra9uM9GdLG5v/1/t83D19v/4nRdeh7shpjLesvJ51o3vwq6Lj0Pdl/Nsf1V5Zw3bHRdeqBsvK5LD5aNrtL6iW2zS1jPTSVsTk1eVzX1zO7jS2iX+yW6DUjL1z9gG3fxpi+WSJCmr6xAkMH0ZRgJUle5+EKQuu65vBAkLRIEUggSA1LXrR8YyHc2LFaO2Zhef1uWtTbzl1XcDRvLJcWIjeUqYcBGzhf/tuaV/Ie9lHdHh9sWtyF96FS9swoksW1dJ+O9CcttsaPcL3Ys7komTE7G5UYmDMgk59svpPP5fvB71NMvOqF15U6Xu9ajP5AQ2o6zssjwD2TwGqdIthW32IpbTcWNi624zlZcbytusBVXbMWNtuLasqqoy6qQL2RL1KVgWDa6fA3KJumSO+TLo5J0mSCWjS5txLLR5ZjQF93O347+B2Kjy16xbHSpLpaNaS8esDHtxQM2pr24/+JJNu3FAzamvXjAxrQXD9jY9uI+GyGbQza2vbjPxrYX99nY9uI+G9te3GVTlPnN4KXj8/ccf2pc6EvHRdelB/ryaNF16cGy0XXpgbKpukrrV710XHVVU6976fj8vYV/WJD9e8nV9MUSCdL0lRUJ0vRlGAlSV7n4QpC67rm8DGRcaJEgkLpWO14IUtetH+SLtXFhsXLMRiyvv3VfHo2L5ZJixMZylTBic774y+1l2RyGox966TivUUt0/u6jl2vWoiprbll93GatdrKev2fyC7M6Q1m9oazBUFYxlDUaypoUZY1NykpMO1l1eVO6ZU3brLq8qZ9Vlzd1s3pd3tTPqsmbYmnn4bRT53hN3hTbjlwl7VxzvCZvStI2zUopb7OK0qy5brNq8qb73+H7zdDWrKq8aZBVkzeNsmryplFWTd50lzX77fU1aPKmUVZd3tTPqtSbdrNq8qYst6z5Y9bt6FthH+V2OySVKxYxi6UdR4xlg0WTjeWyDi5lcQMsEsv66yKxxg0YTer2IJjcBTO7D8C27I1y+mVD8vp4TYofJmr39rKk9bNDDH4weri5XDx/M+bXxhVbcaOtuMlW3GwrbrEVt5qKe/5226+N62zFtWVVUZdVIbdejefvzf0DsdHla1g2uuQOufVqjLpMEMtGlzZi2ehyTOQ2kTHpElIsG132imWjS3WxbEx78YCNkM0hG9NePGBj2osHbEx78YCNaS8esKEXH7LJ9OJjNvTiYzb04mM29OJjNkI2h2zoxcdsbHtxb6vnmG17cZ+NbS/us7HtxV02xbYX99nY9uI+G9te3Gdj24v7bIRsDtnY9uI+G2V+02/zEauuSw+yzUesui49yHYNseq69GDZ6Lr0YNnoKq1f1OYjLbqqqZe1+UiL5esfcJ/rtJi+WCJBmr6yIkGavgwjQeoqF18IUtc9lxeCpEWCQOpa7XghSF23fpCtLJJjsXLMxvT6W7ddQ3KWS4oRG8tVwoiNnM0m3jbYiR/299xPW2+XkqWGPBhfJLbdQ+V+N8K3PY52zje39Y5yv95xmbN3OHF2OG2v1MvPKQzhdNugpPO3aX923N6u9On8ndpfG7fYiltNxT1/y/bXxnW24npbcYOtuKIrbr9DSvLqrCrd4qZtXHVW1Y+rzqr6cdVZVT+uMqvqN0xJQZlV9XumpKDMqvptU1JQZlX9zikpKLOqfuOJdP6O7a+Nq8yqRnGVWdUorjKr6jehSEGZVY3iqrOqblzRa1W7cZVZFaypShJlAgbrq5JEmasBW6uk8xsvTMUmd9lMb4GLv2Mz+vSQl/Ved8h39bnP+Rp3egvExp3eArFxp7dAbNzpLRAaN05vgdi401sgNu70aoeNO72vYeOKrbi2rCrasqpoy6qiLauKtqwq2bKqZMuqki2rSrasKmm77ran6y8/1k3crO1vt8YWt6ZtXNEVtyzrp4fil23c6Z25Penk3LLIYHzN7T2Uy3/4sU3fHpx1XxcJNzS770p6n9YFXe9z6Q9Ofp2i5MP90Hfi058+1BGfvnJQR3z64uVHJN7oXSJuiE9fP2kjXqYv4dQRn95E1RGfvpBVR3z6WlodcSHxP0j8HSMLSQhGVocQjCz5IBhZx0EwsjhDYKysuCAYWUZBMLI2gmBkwQPBKMSIwMgqBoKRVQwEI6sYCEZWMRCMrGIAGPPCKgaCkVUMBCOrGAhGVjEQjEKMCIysYiAYWcVAMLKKgWBkFQPByCoGgdGxioFgZBUDwcgqBoKRVQwEoxAjAiOrGAhGeuPnMIalYQzu2w5Mef5WFpNgzGX9YJ9r/e7B78x5Wccz73ezz/M39VDIXMj8dOZclXoC80faz5awfnAJm1P//C0dtE+PW25dF5e48aH5m1Con6Bu++Y8f9sM6xNE05p8goQTNPcEcYVo8gniHfTJJ4hV0OQTxNXbySeIzxOcOkFvzOfvTKSQOet9PHO/LOsai1/8ljlL+POZsyo/n/npZYK0teckyY1Gh9sMhbul6ur3Bju/Hsjlx3w/+C3q+e1Unhk1uxa1uE1UpynqbQupvaheU9QSWtTqN1GDnahiJ2q0E1XVxaYfNduJWuxErWaiJlW21I+qypb6Ue3YUrJjS0nsRLVjS0mVLYm/RQ39wfXW+LvGUjZcVKnVIZf3qKrUqh9VlVp1o2ZVatWPyiVd/JIu7lHf+Ttu6X/Ut7365Ba3nSA+JDL5BPEhkckniA+JvHyCum8zsJnT7BPEx08mnyA+qzL5BLEKmnyChBM09wTxdZPJJ4ivm0w+QVxJePkExfY2w5I2mwWx4dfsE8SVhLkniE3KZp8griRMPkFcSZh8griSMPkECSdoojpoZ4K4kjB3ocoGdrNPEFcSJp8griRMPkFcSZh6ggobBc4+QVxJmHyCuJIw+QRxJWHyCRJO0NwTxJWEySeIKwmTTxAL1ckniIXq3BPEXpCzTxAL1cknSDhBn5qg4NexPmzeJC2ONwU+ibH96vpQlg1GGhEEI70FgdHTLiAY6QAQjFxShmDkwi8EoxDj5zDGtv90yH+o4UPxXHF9AnPfxN55yRvmXEQ9nzmLqfOZs/I6nznLtGcwT64xL5trKHuTPoO51HbQUje/52w3+gLmQuanM6efP4F5cu0amu6IrMzp5+czp5+fz5x+fj5z+vnpzNlg8wXMeYPmfOasQ89nzjr0fOZC5qczZx16PnPWoeczZx16PnPWoeczZx36DOapPRedyrf75JTIOvR85qxDz2fOOvR85qxDz2cuZH46c7riE5jL0piLz/3Bve53JfFy++LpGbybl3htnnyCeCF/9QT1n5g/vzM4J+ixCeJS9eQTxHXtySeIi+CTTxCroMkniMvrc09Q5lr85BPElYTJJ4grCZNPEFcSJp8g4QSdOUHvzLk4cD5z1vvnM2cJfz5zVuXnM2ehfTrzwtr5GcwlNOZx87xmYTl8PnNWuOczZ9F6PnMh89OZsw49nznr0POZsw49nznr0POZsw49nXllHXo+c9ah5zNnHXo+c9ahz2De3euwCpmfzpx16PnMWRP9UebvGFnmQDCycgFgrAuLEQhGetczrkeg93vrIpye107PJdWyDl7cdoLoFpNPEK1l8gmiD718gnpvyFc26J59grhGPPkEcUF58gliFTT5BAknaO4J4rr25BPEh7EmnyCuJLx8gmJ7fXRJZTNBXEmYfIK4kjD3BHmuJEw+QVxJmHyCuJIw+QRxJWHyCRJO0ER10M4EcSVh7kLVcyVh8gniSsLkE8SVhMkniCsJc09Q4ErC5BPElYTJJ4grCZNPEFcSJp8g4QTNPUFcSZh8griSMPkEsVCdfIJYqM49QcJCdfIJYqE6+QTJ7BO0+Hb4NY0+PeS6TtDlx9ton/M17vTS+ljc4mSNW+5e/mpxp1dAbNzpb81g407vj9i409vYg3F9aHGD38SN07sNNu70poCNO/0CMTbu9Mut2LhiK642qxrE1WZVg7jarGoQV5tVDeLasqpky6qSLatKtqwqabOqJbe4ftnGFVtxtVnVIK42qxrE1WZVg7jarGoQV5tV9ePO338eG1ebVQ3iarOqQVxbVjV/325sXFtWNX+3amxcW1Y1f49maNz528Y++LBCezTj8uP2huf8HVsfjJt8i3v3jEuLq+y6O4qr7Lo7iqvsujuKq+y6O4qr7Lo7iqvsujuKq2w1YxB3/k6M2LjarGoQ15ZVzd/6DxtXbMW1ZVXVllXN31oPG9eWVc3fqg4Z961PjbK8cWl5Y93Jq82rRnm1idUorzazGuUVY3m1udUorza5GuXVZlejvNr0apRXm18N8s7fSQ6c15hfzd/nDJzXmF/N34ULnNeYX53f4UZybHkXNzp+Setnh3j3ssERnRBCoxPkbheK3b0wXMkNZqmDDS56TbvfmtyS4+c49nsDu+X8fhdqSQaSBJEUkvwsyd7OPheSkSRBJBNJgkhmkgSRpE2iSNInQSTP7xuglqQjSRBJ1jifJtlr7fb21SQJIikkCSLJGgdFkjUOiiRrHBRJ1jgokqxxvscnd0gKaxyQmQtrHBRJ1jgokqxxUCSFJEEkWeOgSLLGQZFkjYMiyRoHRZI1DohkZI2DIskaB0WSZo4iKSQJIkkzR5GkmaNIKrMgd3taNNw/Luq+5k3KXGWYV5lRDPMqW9sc5lXmOcO8YiyvMmcY5tV1Zfc13fIudXRld61fsHNJNhfrpGsZ7UE43q/9kZ2XvIWja2UMDEeX5mHhZF1OCIajSyAfhZNcg1O2J+TzmyHMBEduw6Xu/OboUhcwHNOeM4Jj2nOSayfkdHfkDY5pzxnBMe05AzjFtOeM4Jj2nBEcXatqYDi6luDAcIRwjuGYNuQRHNOGPIJDQ+7AoSF34NCQj+FUGnIHjm1DTu05ilS273lV24Y8gGPbkAdwhHCO4dg25AEc24bcheMW05dyWRoc8R8W2LeDu9unusX0ufsRjoNHLd1i+kQPJWn7zuIjJPtPFLnF9m1IJEnTKzJQkqaXb6AkTa/1IEk62iSKpOlVJChJ00tOUJKscVAkhSRBJFnjoEiyxtkleYXDsqUDh5VIBw6Li2M4nvVCBw5LgA4c21YvbScEiWkLx7aoD+AI4RzDsa3TAzi2DXkAx7YhD+DYNuQBHNuG3IejrPkTGI5tQx7AoSF34NCQO3CEcI7h8HX9r3C2b6Q7Ze2OwHBsG/IAjh0JfM+rrOHNOK8dVbvmtWNf17y8D7u7WL0d3H+OXFkzjac+/bzcNkl0OyR54w1EUlnjgleS5C29T5Psv9sQ+VQfiiSf6kORFJIEkaRNokjSJ1Ek+QggiiSfF0SRZI3zaZLdVt5OWcOTV5JkjYMiyRoHRZI1DoqkkCSIJGscFEnWON/jk3skWeOAzNx2mx0oSdY4IJK2G/hASbLGQZFkjYMiyRoHRVJIEkSSNQ6KJGscFEnWOCiSrHFAJG23nIKSpJmjSNLMUSRp5iiSp1tQkLySDDkMR7vb6LuHu6vfG3xZRVgHX05b94OvWbOmrO2o97MWTVlLaFmr32atdrKe3yjohVmdoazeUNZgKKsYyhoNZVXlTYOsqryp9LMa8qZqx5v8Yseb/GLHm/yiypvE37KG/uAa23HUeNeGrIFRJVmHYK5ZxVBWVZI1yKpKsgZZz78YZ1kP6LKiOBgdQljfww6yyO+jJc3L+NuSptwtUu4vaZa8wrms5nxYpdwO7m734M9vmPOjchy8Wu/Pb06ilqSQJIhkJMnPkuze+PHnNydRSzKTJIhkIUkQSdokiKSnT6JIOpIEkfQkCSLJGufTJLuvjPrzm8CoJckaB0WSNQ6KJGscFEnWOCiSrHFAJANrnO/xyT2SrHFAZh5Y46BIssZBkRSSBJFkjYMiyRoHRZI1DookaxwUSdY4IJLCGgdFkjUOiiRrHBRJIUkQSZo5iiTNHEWSZg4iGZVZkLs9LRrctomij8pcZZhXmVEM8ypb2xzmFWN5ldnIMK8yZxjm1XVlf3AjJ+fabVmXZHux1rWM9iCcy/39dbiXvIWja2UMCyfp0jwwHF1OCIajSyAfhZNcg1O2J+Sky0Ye3XbwNlzqzm+OLnUBwzHtOSM4pj0nuXZCTndH3uCY9pwBnGzac0ZwTHvOCI5pzxnB0bWqBoYjhHMMx7Qhj+CYNuQRHNOGPIJDQ+7AoSEfwyk05A4cGnIHjm1DTu05ilS273kV24Y8gCOEcwzHtiEP4Ng25AEc24bch1NNX8of6QjV3z61mj53Aztr+Wr7ZiGSpO07i4+QHDxRVG3fhkSSNL0iAyVpevkGSDIsptd6oCRpkyiSpleRoCRNLzlBSQpJgkiyxkGRZI2DIskaZ5fkFQ7Llg4cViLHcJT1VQLDYb3QgcMSoAPHttVL2wlBYtrCEcI5hmPbvQdwbOv0AI5tQx7AsW3IAzi2DbkPR1mnKDAc24Y8gGPbkAdwaMgdOEI4x3BoyB04fF3/K5ztG+lBWbsjMBzbhtyHo6yVTg/ONa8dr7vmtaNq17x27Oual/dhdxert4O7z5EHZc00nvr083LbJNFtSSprXPBKkrxLhyLJW3qfJtl9tyEIn+pDkRSSBJHkU30okrRJFEn6JIokHwFEkeTzgiCSytqSPJVkt5V3UNbw5JUkWeOgSLLGQZEUkgSRZI2DIskaB0WSNc73+OQeSdY4KDNnjQMiabsnD5QkaxwUSdY4KJKscVAkhSRBJFnjoEiyxkGRZI2DIskaB0WSNQ6IpO2WU1CSNHMUSZo5iqSQJIjk6Rbk49rsI/kSh9xdXkeHu4e7q98b7PLaNDe54u4HX7MWTVnbUe9nrZqyltCyvo34Juv5nYVemNUZyuoNZQ2GsoqhrNFQ1mQoqypvGmRV5U2DrIa8qRrypmrIm6ohb6qGvOn8jlgvzGrIm6ohb6qqvEn8LWvoD65R1k+u8a5tYAOjSrIOwVyzqpKsblZZVEnWIKsqyRpkPf9iXNqKb/DLYHRwbXTwaTT6cpcgtD3aliB3NxX2b0GUvMJxpX64q7Ad3N2eRc5v3PKjchxshSHnd9RQS7KSJIbk+b06flyS3Ru1cn5jD7UkPUmCSAaSBJEUkgSRpE+iSCaSBJHMJAkiyRrn0yS7r3iLY40DIulZ46BIssZBkWSNgyLJGgdFUkgSRJI1zvf45B5J1jggM/escVAkWeOgSLLGAZEMrHFQJFnjoEiyxkGRZI2DIikkCSLJGgdFkjUOiiRrHBRJmjmIpNDMUSRp5iiSNHMUSWUW5G5Piwa3bXoqosxVhnmVGcUwr7K1zWFeZZ4zyhuV2cgwrzJnGObVdWV/cOM159ptWZdkc7GOupbRHoTj/foqnvOSt3CEcI7h6NI8MBxdTgiGo0sgH4WTXINTtifkpMtGHt0m9DZc6vY3J+lSFzAc054zgmPac5JrJ+R0d+QNjhDOMRzTnjOCY9pzRnBMe84Ijq5VNTAcXUtwWDjZtCGP4Jg25BEc04Y8gkND7sARwjmGQ0PuwKEhd+DYNuTUnqNIZfueV7ZtyAM4tg25D6fYNuQBHNuGPIBj25AHcExfyh/p4NbfPrWYPncDO+FJtX2zEEnS9p3FR0gOniiqtm9DIkmaXpGBkhSSBJE0vdYDJUmbRJE0vYoEJWl6yQlKkjUOhmRcWOOgSLLGQZFkjbNL8gqHZUsHjhDOMRwWFx04rBc6cFgCdODYtnppOyFITFs4tkW9D0dZKywwHNs6PYBj25AHcGwb8gCOEM4xHNuGPIBj25AHcGwb8gAODbkDh4Z8DEdZIyUwHL6u/xXO9o30qKzdERiObUMewLEjgde8drzumteOql3z2rGv97zK2mm86jnyqKyZxlOffl5umyS6HZK88YYiybt0KJK8pfdpkt13G2LgU30oknyqD0RSWQuIV5KkTaJI0idRJPkIIIqkkCSIJGucT5PstvKOyhqevJIkaxwUSdY4KJKscUAklTWWeSVJ1jgokqxxvscn90iyxgGZue02O1CSrHFQJFnjoEiyxkGRZI2DIskaB0TSeLsqJEnWOCiSrHFQJFnjoEgKSYJI0sxRJGnmKJI0cxRJmjmIJKDZUSiLX9MWL4O0UdqmWVFkxCbWtLYGibXeRle/NzjHNevlx3o/+Jo1KMpa3NogOBbvtllF07y2v4/9rFFT1hJuWX1/cJX2x10l74BJmsBkaX/cZdlmzYayFkNZq52sgI48P05WZyirKskaZNUkWaOsYiirKskaZDXkTcWQNxVD3lQMeVM15E3VkDcBGvI8mlXaqorkOBgdQljfTQ6yjD77shIXwm2ZT/Joma/k9chdqR9W7raD+1sg1EiOn+M4et28FpIEkawkCSGZloUkP0uyezMkLY4kQSQ9SYJIBpIEkRSSBJGkT6JIJpIEkcwkCSLJGufTJLuvUaaFNQ6IpGONgyLJGgdFkjUOiiRrHBRJIUkQSdY43+OTeyRZ44DM3LHGQZFkjYMiyRoHRNKzxkGRZI2DIskaB0WSNQ6KpJAkiCRrHBRJ1jgokqxxUCRp5iCSgWaOIkkzR5GkmaNIKrMgd3taNLhtY8EUlLnKMK8yoxjmVba2OcyrzHNGeUWZjQzzKnOGYV5dV/YHNzdy7W0zd0GxuViLrmW0B+F4v75c57zkLRwhnGM4ujQPDEeXE4Lh6BLIR+Ek1+CU7Qk56rKRR7fiuw2Xuv3NibrUBQzHtOeM4Jj2nOTaCTnd7c3Z4AjhHMMx7TkjOKY9ZwTHtOeM4OhaVQPD0bUEh4WTTBvyCI5pQx7BMW3IIzg05A4cIZxjODTkDhwacgeObUNO7TmKVLbveSXbhjyAY9uQ+3CybUMewLFtyAM4tg15AMf0pfyRLknd7VNTNn3uBnabSsX2zUIkSdt3Fh8hOXiiqNi+DYkkaXpFBkpSSBJE0vRaD5QkbRJF0vQqEpSk6SUnKEnWOCCSlTUOiiRrHBRJ1ji7JK9wWLZ04AjhHMNhcdGBw3qhA4clQAeObauXthOCxO0jCMr6ZkHhZGWtsMBwbOv0AI5tQx7AsW3IAzhCOMdwbBvyAI5tQx7AsW3IAzg05A4cGvIxHGWNlMBw+Lr+VzjbN9KzsnZHYDi2DXkAx44EXvPa8bprXjuqds1rx77e8yprp/Gq58izsmYaT336ebltkuh2SPLGG4ok79KhSPKW3qdJdt9tyJ5P9aFI8qk+EEllLSBeSZI2iSJJn0SR5COAKJJCkiCSrHE+TbLbyjsra3jySpKscVAkWeOgSLLGAZFU1ljmlSRZ46BIssb5Hp/cI8kaB2TmttvsQEmyxkGRZI2DIskaB0WSNQ6KJGscEEnj7aqQJFnjoEiyxkGRZI2DIikkCSJJM0eRpJmjSNLMUSRp5iCSiGZHl0JpTZuzG5H0SVaSvtTR6JrWz461Lm109XuDL39h6+DLr8j94GvWoChrce0Xsni3zSqa5rX9fexnjZqylnDL6vuDq7Q/7ip5B0zSBCa3j85l2WbNhrIWQ1mrnayIjjw/TFZnKKsqyRpk1SRZo6xiKKsqyRpkNeRN2ZA3ZUPelA15UzHkTcWQNyEa8jyYta4LdzEMFwWDK+uBBJ+W30fLfJdlwdsyn+TRMl/J6wKlK/XDyt12cH8LhBLJ8XMcR6+bl0KSIJKVJDEk60KSnyXZvxlSHUmCSHqSBJEMJAkiKSQJIkmfRJFMJAkimUkSRJI1zqdJ9l+jrKxxMCTLwhoHRZI1DookaxwUSdY4KJJCkiCSrHG+xyf3SLLGwZh5WVjjoEiyxkGRZI0DIulY46BIssZBkWSNgyLJGgdFUkgSRJI1DookaxwUSdY4KJI0cxBJTzNHkaSZo0jSzFEklVmQuz0tGty2sWDxylxlmFeZUQzzKlvbHOZV5jmjvEGZjQzzKnOGYV5dV/YHNzdyrt2WdUk2F+ugaxntQTjer0fuvOQtHCGcYzi6NA8MR5cTguHoEshH4STX4JTtCVl02cijW/Hdhkvd/uaILnUBwzHtOSM4pj0nuXZCTpK2cIRwjuGY9pwRHNOeM4Jj2nNGcHStqoHh6FqCw8KJpg15BMe0IY/gmDbkERwacgeOEM4xHBpyBw4NuQPHtiGn9hxFKtv3vKJtQx7AsW3IfTjJtiEP4Ng25AEc24Y8gGP6Uv5Il6Tu9qklmT53A7tNlWz7ZiGSpO07i4+QHDxRlG3fhkSSNL0iAyUpJAkiaXqtB0qSNokiaXoVCUrS9JITlCRrHBDJwhoHRZI1Dooka5xdklc4LFs6cIRwjuGwuOjAYb3QgcMSoAPHttVL2wlB4vYRBGV9s7BwlLXCAsOxrdMDOLYNeQDHtiEP4AjhHMOxbcgDOLYNeQDHtiEP4NCQO3BoyIdwqrJGSmA4fF3/K5ztG+lVWbsjMBzbhjyAY0cCr3nteN01rx1Vu+a1Y1/veZW103jVc+RVWTONpz79vNw2SXQ7JHnjDUWSd+lQJHlL79Mku+82VMen+lAk+VQfiKSyFhCvJEmbRJGkT6JI8hFAFEkhSRBJ1jifJtlt5V2VNTx5JUnWOCiSrHFQJFnjgEgqayzzSpKscVAkWeN8j0/ukWSNAzJz2212oCRZ46BIssZBkWSNgyLJGgdFkjUOiKTxdlVIkqxxUCRZ46BIssZBkRSSBJGkmaNI0sxRJGnmKJI0cwDJ3y//9L8//f3nn/7yy1//cflv3v7l//z677/9/Ldfv/7jb//339d/cxn8/w==","brillig_names":["set_ens_registry"],"assert_messages":{"640":"attempt to add with overflow","1920":"Array index out of bounds","762":"Array index out of bounds","628":"attempt to add with overflow","1780":"attempt to add with overflow","1908":"attempt to add with overflow","811":"attempt to add with overflow","1579":"Array index out of bounds","1183":"attempt to add with overflow","153":"call to assert_max_bit_size","1043":"Array index out of bounds","1421":"Array index out of bounds","1226":"Array index out of bounds","1738":"Array index out of bounds","1860":"attempt to add with overflow","1793":"Array index out of bounds","1080":"Array index out of bounds","623":"attempt to multiply with overflow","1769":"Array index out of bounds","1062":"Array index out of bounds","928":"Array index out of bounds","1056":"attempt to add with overflow","532":"attempt to add with overflow","1361":"Array index out of bounds","14":"Not initialized","782":"Array index out of bounds","520":"attempt to add with overflow","1556":"Array index out of bounds","770":"attempt to add with overflow","959":"Array index out of bounds","636":"attempt to add with overflow","1154":"Array index out of bounds","1014":"attempt to add with overflow","1142":"attempt to add with overflow","1611":"Array index out of bounds","941":"attempt to add with overflow","1928":"Array index out of bounds","996":"Array index out of bounds","161":"call to assert_max_bit_size","1374":"attempt to add with overflow","1569":"attempt to add with overflow","277":"call to assert_max_bit_size","978":"attempt to add with overflow","1234":"Array index out of bounds","1429":"Array index out of bounds","1746":"Array index out of bounds","966":"Array index out of bounds","1027":"Array index out of bounds","1094":"attempt to add with overflow","838":"Array index out of bounds","515":"attempt to multiply with overflow","1271":"Array index out of bounds","820":"Array index out of bounds","948":"attempt to add with overflow","1198":"Array index out of bounds","1003":"Array index out of bounds","1393":"Array index out of bounds","1253":"Array index out of bounds","1442":"attempt to add with overflow","1247":"attempt to add with overflow","1448":"Array index out of bounds","1466":"Array index out of bounds","790":"Array index out of bounds","1619":"Array index out of bounds","528":"attempt to add with overflow","912":"Array index out of bounds","1162":"Array index out of bounds","1759":"attempt to add with overflow","900":"attempt to add with overflow","1345":"Array index out of bounds","1540":"Array index out of bounds","1801":"Array index out of bounds","1528":"attempt to add with overflow","1333":"attempt to add with overflow","1656":"Array index out of bounds","1936":"Array index out of bounds","1638":"Array index out of bounds","1632":"attempt to add with overflow","1949":"attempt to add with overflow","852":"attempt to add with overflow","1809":"Array index out of bounds","1035":"Array index out of bounds","1480":"attempt to add with overflow","1285":"attempt to add with overflow","1218":"Array index out of bounds","1413":"Array index out of bounds","1730":"Array index out of bounds","1401":"attempt to add with overflow","1206":"attempt to add with overflow","1590":"attempt to add with overflow","1718":"attempt to add with overflow","1846":"Array index out of bounds","1828":"Array index out of bounds","798":"Array index out of bounds","347":"attempt to add with overflow","920":"Array index out of bounds","1822":"attempt to add with overflow","1170":"Array index out of bounds","1548":"Array index out of bounds","1353":"Array index out of bounds","1670":"attempt to add with overflow","1603":"Array index out of bounds"}},{"name":"set_admin","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"new_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAAQIRAAAJAAEAQQkAAQABR8AAAAABQAAAAQAAAhDKwAIQwADIgAAAAg5AAAACEQAAAAAHgAAAAUeAAAABjAAAAAABQAAAAYAAAAHJAACAQUKAAIHBQYhAAAPAAY6AQAAKgAABSQABAIHAAAEAAcAJAEEAQUAAAQFAgcqAAcGJAAHAAgqAggGKgEFBwAABAcCByoCBwUqAAAHAAAEAAIAKgIFByQABAAFJAAHAQgkAAQBBioABQQgACIKAAQEBQkhAABKAAkgACUqAQcJAAAECQIKAAAECgULKgELBx4AAgAJCgAHBwkKIQAALQAKOgEAACoABQQgAC8KAAQEBQchAAAzAAcgADIjHAAHBAcAAAcIBwkqAAAHJAAEAgoAAAQACgAkAQQBBwAABAcCCioACgsqAgMLJAAEAQsMAAQECwwhAABAAAw6AQAAAAAEBwIMAAAEDAQLKgELCi0AAAAACgAAAAkAAAQEBgkOAAQECQohAABIAAo6AQAAKgAJBCAALyoBBwkcAAcECgAABwgKCywAAAAACwAAAAokAAQBDAwABAQMDSEAAFIADToBAAArAAAJCAMlAAQAAggEIgAAAGArAAgFAAsAAAQLAg0AAAQNBAwqAgoMAAAEBAYJDgAEBAkKIQAAXQAKOgEAACoCCwcqAAkEIAAiKwEIAwgGCwAECAYAAggHIQAAZAgHIABmKwAIAwgFIAB0KwAAAAgFAQAEAAAIBAAAJQAEAAAICQ0ABAgJCAQIChcACAoICiEAAHIICgEABAgDCAkICysBCAsICAEABAgFCAkICysCCAgICwEABAgJAAIICSAAaSUBBAABCAUgAHQjKwAYyhjK","debug_symbols":"1ZvRbtswDEX/xc95ECmJIvsrw1AkbVIYCJIiSQcMQf59dhcpnuvJKLoM5Etgx9fUsU37WpR8bp7Xq7eXx3a32R+bh2/nZrt/Wp7a/a5bO18WzerQbrfty+Pw78b1P/wuP74ud/3a8bQ8nJoHSBgWzXr33C/60AXYtNt185DcZfFBLD5dtRJTkUL0E9qAIFdxQOSiFpwQE4O/iolRhuLvi0a+DA4OitgNxHdHB/f1k55yfJG5kw4YshhQpE7OEDMFwyD0lRz+IXl30v9E7xvAezfg791AuHcDcaoBcZATAmQu7xPn+F0Dt/iJJtRRKOd9FHH17InJZ4xuEcfZQ2bJk1lyNksuVsnRmSUHs+RoltybJQ9myc16KJr1UDTroWjWQ73qOzRyIY/jPpJXnS0pFHJ2Y/L/nS2lw0bOxTo5OKFb6JvYO3pHF7PowdlFn37pwpjRg6+jB8+YSxN+LnlJqJBLGt92Ye41KtCQpd/Df3qP8Ok9Jh8G4ByWfjLCzOVFKmJknrm85CEXtcj7mZIJdbGzGHBcMomgmz1BYWcYs6Nu9kgVdq+bnUuBEGRs2zEYZo+G2ckwu/JnZJWdDbOLXXZyhtmV+2qVXbmvVtkN+yoZ9lUy7Ktk2FdJua8GvLH7urjrs96G6pnHB6rchP96oD27chOusSflJlxlV27CVfZgtTaaNI9eMJR6NOO4U55Uj16UKt0Uuep6dDGwjhxnTKCrFpZCW/pwmKqHOmpl96R6ukCNnFVPF6iSq54uUCVXPV2gSq56ukCVXLXhVslVTxeokqs23Cq52QFgNuuhbNZDxayHilkPFbMeKkY99NKt/Vge2uVqu75+2bF52z0NPvQ4/Xz9vaUT/wI=","brillig_names":["set_admin"],"assert_messages":{"81":"Array index out of bounds","63":"Array index out of bounds","92":"attempt to add with overflow","44":"Aztec Passport: Unauthorized Admin Change","71":"attempt to add with overflow","14":"Not initialized"}},{"name":"get_ens_registry","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_ens_registry"],"assert_messages":{"253":"Array index out of bounds","218":"Array index out of bounds","247":"attempt to add with overflow","285":"attempt to add with overflow","14":"Not initialized","162":"call to assert_max_bit_size","194":"Array index out of bounds","226":"Array index out of bounds","345":"Array index out of bounds","374":"attempt to add with overflow","19":"Function get_ens_registry can only be called statically","205":"attempt to add with overflow","170":"call to assert_max_bit_size","234":"Array index out of bounds","333":"attempt to add with overflow","353":"Array index out of bounds","271":"Array index out of bounds","361":"Array index out of bounds"}},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"3715688037512703171":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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IAQpKgAKJyoAJCYgBCkeAAcAJBwABCQqHAAHKikcAAQpJAwABCQgKSEABDgAKSAEMCEABDQAJyAEMioADSAgBDYqACYgIAQ2KgAgJSAEQCEABDwAIiAEOioADSAgBD4qACMgIAQ+KgAgJSAEQAAABCQlKQ4ABCQpKiEABEQAKjoBAAAqAR8lKgETKioBHisMAAQkKywhAARMACwgBEoqACogIAROKgAlICAETioCIB8qAiETKgIpHioBFB4AAAQeAh4qAh4UKgEUHgAABB4CHioCHhQqARQeAAAEHgIeKgIeFCoBFB4AAAQeAh4qAh4UKgAAHgAABAACACoBCxMAAAQTAhMqAhMLKgAAEwAABAACACoAAB8AAAQAAgAqAAAkAAAEAAIAKgEUKgAABCoCKioCKhQqAQsqAAAEKgIqKgIqCyoBFCoAAAQqAioqAioUKgELKgAABCoCKioCKgsqARQqAAAEKgIqKgIqFCoBCyoAAAQqAioqAioLKgIUHioCCxMqAg0fKgIIJCoBFCoCAAQqAioqAioUKgELKgIABCoCKioCKgsqAAYlIASGCgAEJQYqIQARqwAqIASJKgEkKgoAASoIKyEABI0AKzoBAAAqAAYlIASPDAAEJREqIQARggAqIASSKgETHyoAAB4kAAQFKgAABAAqACQBBAEeAAAEHwIqJAAEBCsAAAQeAiw+AwAAACoAAAAsKgIeEyoCCiQAAAQeAhMAAAQTBh8qAR8kHAAHKR4qAAYlIASjDAAEJREfIQARZwAfIASmKgAAJAAABAACACoBCx8AAAQfAh8qAh8LKgAAHwAABAACACoAAB4AAAQAAgAqAAATAAAEAAIAKgELKgAABCoCKioCKgsqAQsqAAAEKgIqKgIqCyoBGyoAAAQqAioqAiobKgELKgAABCoCKioCKgsqAhskKgILHyoCDR4qAggTKgEbKgIABCoCKioCKhsqAQsqAgAEKgIqKgIqCyoABiUgBMkKAAQlBiohABDoACogBMwqARMqCgABKggrIQAE0AArOgEAACoABiUgBNIMAAQlESohABC/ACogBNUqAR8kKgAAHiQABAUqAAAEACoAJAEEAR4AAAQkAiokAAQEKwAABB4CLD4DAAAAKgAAACwqAh4fKgIKEwAABB4CHwAABB8GJCoBJBMcAAUjHgQABR4aHyQABQAsCgAFLBokIQAE7AAkBgAFHxoqCgAFKh4rIQAE7AArOgEAABwABSYeAAAFHx4sDgAFHywkIQAE8QAkOgEAABwABSIeBAAFHh0fHAAFJx4EAAUeGiQAAAUfJB4OAAUfHiohAAT5ACo6AQAAAAAFHigfDgAFHh8kIQAE/QAkOgEAABwAByweHAAHHywEAAcsFx8AAAceHywqAAYlIAUDCgAEJQYrIQAQqAArIAUGKgAAJAAABAACACoBCx8AAAQfAh8qAh8LKgAAHwAABAACACoAAB4AAAQAAgAqAAATAAAEAAIAKgELKgAABCoCKioCKgsqAQsqAAAEKgIqKgIqCyoBHCoAAAQqAioqAiocKgELKgAABCoCKioCKgsqAhwkKgILHyoCDR4qAggTKgEcKgIABCoCKioCKhwqAQsqAgAEKgIqKgIqCyoABiUgBSkKAAQlBiohABApACogBSwqARMWCgABFggSIQAFMAASOgEAACoABiUgBTIMAAQlERYhABAAABYgBTUqAR8kKgAAHiQABAUWAAAEABYAJAEEAR4AAAQkAhYkAAQEEgAABB4CKj4DAAAAFgAAACoqAh4fKgIKEwAABB4CHwAABB8GJCoBJBMcAAcpHhwABSMpBAAFKRojJAAFACQKAAUkGh8hAAVNAB8GAAUjGhIKAAUSKSohAAVNACo6AQAAHAAFJikAAAUjKSYOAAUjJiQhAAVSACQ6AQAAHAAFIikEAAUpHSIcAAUnKQQABSkaJwAABSInKQ4ABSIpIyEABVoAIzoBAAAAAAUpKCcOAAUpJyIhAAVeACI6AQAAHAAHJikcAAcnJgQAByYXJwAAByknJioAACckAAQFKQAABAApACQBBAEnAAAEJwIpKgApKCoCICgAAAQoAigqAiAoAAAEKAIoKgIgKAAABCgCKCoCICgqAScpAAAEKQIpKgIpJyoAACkAAAQAAgAqAicpKgANJSAFdwwABCURKCEAD9sAKCAFeioABiggBXwKAAQoBichAA+2ACcgBX8qASknKgEUKQAABCkCKSoCKRQqARQpAAAEKQIpKgIpFCoBFCkAAAQpAikqAikUKgEUKQAABCkCKSoCKRQqAAApAAAEAAIAKgIUKSoBFSYAAAQmAiYqAiYVKgAAJgAABAACACoCFSYqAAAlAAAEAAIAKgIGJSoAACQAAAQAAgAqAggkKgAGKCAFnQwABCgEIyEADzQAIyAFoCoBJCcKAAEnCCMhAAWkACM6AQAAKgAGKCAFpgwABCgRJyEADwsAJyAFqSoBJiMqAAAiJAAEBSEAAAQAIQAkAQQBIgAABCMCISQABAQgAAAEIgIfPgMAAAAhAAAAHyoCIiYqAgokAAAEIgImAAAEJgYjKgEjJCoABiUgBbkKAAQlBiMhAA70ACMgBbwAAAQPAhY5AQAAABYAAAAAIAW/JgAHKwqslwAWCgAHAxYTKgAAFiQABAISAAAEABIAJAEEARYAAAQWAhIqABIeKgIYHiEABcoAEyAIiyoAABIkAAQCHgAABAAeACQBBAESAAAEEgIeHwQAAAANAAAADQAAAB4qARIeAAAEHgIeKgIeEioAAB4AAAQAAgAqAhIeKgAAHwAABAACACoCBh8qARIgAAAEIAIgKgIgEioAACAAAAQAAgAqAhAgKgESIQAABCECISoCIRIqARASAAAEEgISKgISECoABhMgBecKAAQTBhIhAA7UABIgBeoqAR8TAAAEEw0SDgAEExIhIQAF7wAhOgEAACoCEh8qASASKgEQIAIABCACICoCIBAAAAQSAh8AAAQfBhMqARMgHAAHIBIpAAcAAAAAAAAAAAAAAAD//////////////////////////wAfDgAHEh8TIQAF/AATOgEAAB4AAAAfHgAAABIwAAAAAB8AAAASAAAAEwoAAhMFEiEABgIAEjoBAAAqARQTAAAEEwITKgITFCoBFBMAAAQTAhMqAhMUKgEUEwAABBMCEyoCExQqARQTAAAEEwITKgITFCoAABMAAAQAAgAqAQsSAAAEEgISKgISCyoAABIAAAQAAgAqAAAfAAAEAAIAKgAAIQAABAACACoBFCIAAAQiAiIqAiIUKgELIgAABCICIioCIgsqARQiAAAEIgIiKgIiFCoBCyIAAAQiAiIqAiILKgEUIgAABCICIioCIhQqAQsiAAAEIgIiKgIiCyoCFBMqAgsSKgINHyoCCCEqARQiAgAEIgIiKgIiFCoBCyICAAQiAiIqAiILKgAGHiAGNwoABB4GIiEADlUAIiAGOioBISIKAAEiCCMhAAY+ACM6AQAAKgAGHiAGQAwABB4RIiEADiwAIiAGQyoBEh4qAAATJAAEBSIAAAQAIgAkAQQBEwAABB4CIiQABAQjAAAEEwIkPgMAAAAiAAAAJCoCExIqAgohAAAEEwISAAAEEgYeKgEeISoBFBMAAAQTAhMqAhMUKgAAEwAABAACACoCFBMqAAYfIAZZDAAEHxEeIQAOFgAeIAZcKgETHgAABB4CEgAABBIGISoBIRMcAAcTEikABwAAAAAAAAAAAAAAAP//////////////////////////ACEOAAcSISIhAAZlACI6AQAAAAAEHgISAAAEEg0iKgEiIRwAByESKQAHAAAAAAAAAAAAAAAA//////////////////////////8AIg4ABxIiIyEABm0AIzoBAAAAAAQeAhIAAAQSDCMqASMiHAAEIhIcAAcSHhwABB4iKgAAHgAABAACACoCEx4qAAATAAAEAAIAKgIhEyoAACEAAAQAAgAqAiIhKgAAIgAABAACACoBCxIAAAQSAhIqAhILKgAAEgAABAACACoAACMAAAQAAgAqAAAkAAAEAAIAKgELJQAABCUCJSoCJQsqAQslAAAEJQIlKgIlCyoBGyUAAAQlAiUqAiUbKgELJQAABCUCJSoCJQsqAhsiKgILEioCDSMqAggkKgEbJQIABCUCJSoCJRsqAQslAgAEJQIlKgIlCyoABh8gBp8KAAQfBiUhAA2XACUgBqIqASQlCgABJQgmIQAGpgAmOgEAACoABh8gBqgMAAQfESUhAA1uACUgBqsqARIiKgAAHyQABAUlAAAEACUAJAEEAR8AAAQiAiUkAAQEJgAABB8CJz4DAAAAJQAAACcqAh8SKgIKJAAABB8CEgAABBIGIioBIiQqARAfAAAEHwIfKgIfECoAAB8AAAQAAgAqAhAfKgAGIyAGwQoABCMGIiEADVgAIiAGxCoBHyIAAAQiAiMAAAQjBiQqASQfHAAHHyIoAAf/////////////////////ACMOAAciIyQhAAbNACQ6AQAAHAAFHyIcAAciIxwABSMiAgAHHyMkCAAHJBcfHAAFHyMcAAcjJBwABSQfBgAFHx0kHAABJCUcAAUlIxwAASMkBgAFIhojHAAEIyUGAAUfGiMcAAEjJxwABScmHAABJiMcAAQiJxwABScmHAAEJiIcAAQfJxwABScmHAAEJh8hAAbqACQgBucqAAgSKgAGECAG7SoAChIqACUQIAbtIQAG8gAjIAbvKgAIJSoABiQgBvUqAAolKgAiJCAG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YgATIAhsKgEZGgoAARoIEyEACHAAEzoBAAAqAAYcIAhyDAAEHBEaIQAKOQAaIAh1KgEXFSoAABMkAAQFEgAABAASACQBBAETAAAEFQISJAAEBBAAAAQTAhw+AwAAABIAAAAcKgITFyoCChkAAAQTAhcAAAQXBhUqARUZKgAGGiAIhQoABBoGFyEACiIAFyAIiAAABA8CFzkBAAAAFwAAAAAgCIsmAAdrO7ujABcKAAcDFxUhAAiPABUgCR8eAAAAFR4AAAATMAAAAAAVAAAAEwAAABIKAAISBRMhAAiVABM6AQAAHgALAAUKAAcFCRIhAAiZABI6AQAAHgAHAAUcAAQFEhwABxIJHAAECQUqARQJAAAECQIJKgIJFCoBFAkAAAQJAgkqAgkUKgEUCQAABAkCCSoCCRQqARQJAAAECQIJKgIJFCoAAAkAAAQAAgAqAQsSAAAEEgISKgISCyoAABIAAAQAAgAqAAATAAAEAAIAKgAAFQAABAACACoBFBAAAAQQAhAqAhAUKgELEAAABBACECoCEAsqARQQAAAEEAIQKgIQFCoBCxAAAAQQAhAqAhALKgEUEAAABBACECoCEBQqAQsQAAAEEAIQKgIQCyoCFAkqAgsSKgINEyoCCBUqARQQAgAEEAIQKgIQFCoBCxACAAQQAhAqAhALKgAGFyAI0goABBcGECEACaMAECAI1SoBFQ8KAAEPCAshAAjZAAs6AQAAKgAGECAI2wwABBARDyEACXoADyAI3ioBEhAqAAAPJAAEBQsAAAQACwAkAQQBDwAABBACCyQABAQJAAAEDwIHPgMAAAALAAAAByoCDxIqAgoVAAAEDwISAAAEEgYEKgEEFSoBFA8AAAQPAg8qAg8UKgAADwAABAACACoCFA8qAAYTIAj0DAAEExEUIQAJZAAUIAj3KgEPCwAABAsCCQAABAkGByoBBw8cAAcPCSkABwAAAAAAAAAAAAAAAP//////////////////////////AAcOAAcJBwQhAAkAAAQ6AQAAAAAECwIJAAAECQ0EKgEEBxwABwcNKQAHAAAAAAAAAAAAAAAA//////////////////////////8ACQ4ABw0JBCEACQgABDoBAAAAAAQLAg0AAAQNDAQqAQQJHAAECQscAAcLDBwABAwJDAAEBQkMIQAJEwAMIAkRKgAHDiAJ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LigrKgIqKyoCLSEgDI8AAAQoDSkOAAQoKSohAAyTACo6AQAAKgApKCAMPxwAByMhAAAHIiETKgAAISQABAQoAAAEACgAJAEEASEAAAQhAigqACgpKgIfKQAABCkCKSoCICkAAAQpAikqAh4pJAAEAykMAAQjKSohAAymACo6AQAAAAAEIQIqAAAEKiMpKgEpKC0AAAAAKAAAABMAAAQjDSgOAAQjKBMhAAyuABM6AQAAKgAoIyAHbyoBHigMAAQjKCkhAAy0ACkgDNMqARMoKgETKSQABAQrDAAEIyssIQAMugAsOgEAAAAABCkCLAAABCwjKyoBKyoqASEpJAAEAysMAAQjKy0hAAzCAC06AQAAAAAEKQItAAAELSMrKgErLAAAByosKSQABAQsDAAEIywtIQAMygAtOgEAACsAACgIAyUABAAFCAQiAAAWjSsACAUAKgAABCoCLQAABC0jLCoCKSwqAioTIAzTAAAEIw0oDgAEIygpIQAM1wApOgEAACoAKCMgB1skAAQBKQwABCMpKiEADN0AKjoBAAAAAAQWAioAAAQqIykqASkoKgEiKgoAASoIKSEADOQAKToBAAAqAR4qCgAEKhEpIQANAAApIAzoKgEhKSoBHioqAR4rJAAEAy0MAAQrLS4hAAzvAC46AQAAKwAAKQgDJQAEAAQIBCIAABaNKwAIBQAsAAAELAIuAAAEListKgIoLSoBLCgAAAQoAigqAigsAAAEKg0oDgAEKigrIQAM/QArOgEAACoCLCEqAigeIA0pKgAGKSANAgwABCkRKiEADS8AKiANBSoBISkqARMqKgAAKyQABAUsAAAEACwAJAEEASsAAAQqAiwkAAQELQAABCsCLj4DAAAALAAAAC4qASkqAgAEKgIqKgIqKSoBKSoAAAQqAioqAiopKgErKgAABCoCKioCKisrAAApCAMlAAQABAgEIgAAFo0rAAgFACoAAAQqAi4AAAQuBi0qAigtKgEqKQAABCkCKSoCKSoqASspAAAEKQIpKgIpKyoCKiEqAisTKgINHiANKQAABCMNKA4ABCMoKSEADS0AKToBAAAqACgjIAdSKgEeKgwABCkqKyEADTMAKyANUioBEyoqARMrJAAEBC0MAAQpLS4hAA05AC46AQAAAAAEKwIuAAAELiktKgEtLCoBISskAAQDLQwABCktLyEA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BQgEIgAAFo0rAAgFAC4AAAQuAjEAAAQxKzAqAi0wKgIuEyASJAAABCsNLA4ABCssLSEAEigALToBAAAqACwrIBHUKgEgIxwAByQiAAAHJSImLAAAAAAmAAAAIiQABAEnDAAEJCcoIQASMgAoOgEAACsAACMIAyUABAACCAQiAAAWjSsACAUAJgAABCYCKAAABCgkJyoCIicAAAQkDSMOAAQkIyIhABI9ACI6AQAAKgImICoAIyQgA/UqASQmDAAEICYnIQASRAAnIBJjKgEjJioBIyckAAQEKQwABCApKiEAEkoAKjoBAAAAAAQnAioAAAQqICkqASkoKgEiJyQABAMpDAAEICkrIQASUgArOgEAAAAABCcCKwAABCsgKSoBKSoAAAcoKickAAQEKgwABCAqKyEAEloAKzoBAAArAAAmCAMlAAQABQgEIgAAFo0rAAgFACgAAAQoAisAAAQrICoqAicqKgIoIyASYwAABCANJg4ABCAmJyEAEmcAJzoBAAAqACYgIAPcJAAEAScMAAQgJyghABJtACg6AQAAAAAEEgIoAAAEKCAnKgEnJioBJSgKAAEoCCchABJ0ACc6AQAAKgEkKAoABCgRJyEAEpAAJyASeCoBIicqASQoKgEkKSQABAMrDAAEKSssIQASfwAsOgEAACsAACcIAyUABAAECAQiAAAWjSsACAUAKgAABCoCLAAABCwpKyoCJisqASomAAAEJgImKgImKgAABCgNJg4ABCgmKSEAEo0AKToBAAAqAioiKgImJCASuSoABicgEpIMAAQnESghABK/ACggEpUqASInKgEjKCoAACkkAAQFKgAABAAqACQBBAEpAAAEKAIqJAAEBCsAAAQpAiw+AwAAACoAAAAsKgEnKAIABCgCKCoCKCcqAScoAAAEKAIoKgIoJyoBKSgAAAQoAigqAigpKwAAJwgDJQAEAAQIBCIAABaNKwAIBQAoAAAEKAIsAAAELAYrKgImKyoBKCYAAAQmAiYqAiYoKgEpJgAABCYCJioCJikqAigiKgIpIyoCDSQgErkAAAQgDSYOAAQgJichABK9ACc6AQAAKgAmICAD0yoBJCgMAAQnKCkhABLDACkgEuIqASMoKgEjKSQABAQrDAAEJyssIQASyQAsOgEAAAAABCkCLAAABCwnKyoBKyoqASIpJAAEAysMAAQnKy0h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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"512":"Function get_admin_public can only be called statically","1024":"call to assert_max_bit_size","2938":"attempt to add with overflow","4986":"attempt to add with overflow","3237":"Array index out of bounds","4261":"attempt to add with overflow","2591":"attempt to add with overflow","3292":"Array index out of bounds","5529":"attempt to add with overflow","4938":"attempt to add with overflow","2756":"Array index out of bounds","3780":"Array index out of bounds","4158":"Array index out of bounds","5316":"attempt to add with overflow","2488":"Array index out of bounds","3189":"Array index out of bounds","5292":"attempt to add with overflow","5481":"attempt to add with overflow","4134":"attempt to add with overflow","5347":"attempt to add with overflow","2464":"attempt to add with overflow","5725":"Array index out of bounds","471":"Not initialized","2196":"Not initialized","1361":"attempt to add with overflow","203":"attempt to add with overflow","3653":"Array index out of bounds","4220":"attempt to add with overflow","2550":"attempt to add with overflow","3062":"Array index out of bounds","3574":"Array index out of bounds","612":"Function get_passport_address can only be called statically","1636":"call to assert_max_bit_size","5220":"Array index out of bounds","5598":"Array index out of bounds","4172":"attempt to add with overflow","5385":"Array index out of bounds","2502":"attempt to add with overflow","3014":"Array index out of bounds","3392":"Array index out of bounds","3447":"Array index out of bounds","4471":"Array index out of bounds","4526":"Array index out of bounds","5093":"Array index out of bounds","3423":"Array index out of bounds","5337":"attempt to add with overflow","3990":"Array index out of bounds","5014":"Array index out of bounds","5069":"Array index out of bounds","2887":"Array index out of bounds","4423":"Array index out of bounds","3265":"Array index out of bounds","1272":"attempt to add with overflow","5557":"Array index out of bounds","547":"Not initialized","4887":"Array index out of bounds","4296":"Array index out of bounds","4808":"Array index out of bounds","2626":"Array index out of bounds","2303":"call to assert_max_bit_size","1980":"attempt to add with overflow","5351":"Array index out of bounds","2200":"Function get_ens_registry can only be called statically","3413":"attempt to add with overflow","2578":"Array index out of bounds","4248":"Array index out of bounds","4626":"Array index out of bounds","4681":"Array index out of bounds","2822":"attempt to add with overflow","4657":"Array index out of bounds","3310":"Array index out of bounds","5358":"Array index out of bounds","2664":"Array index out of bounds","5413":"Array index out of bounds","3042":"Array index out of bounds","3097":"Array index out of bounds","3286":"attempt to add with overflow","2451":"Array index out of bounds","4121":"Array index out of bounds","4499":"Array index out of bounds","1537":"Not initialized","3372":"attempt to add with overflow","3482":"Array index out of bounds","3860":"Array index out of bounds","5128":"Array index out of bounds","1276":"attempt to add with overflow","3324":"attempt to add with overflow","3245":"attempt to add with overflow","3434":"attempt to add with overflow","4647":"attempt to add with overflow","551":"Function is_admin can only be called statically","4056":"attempt to add with overflow","5080":"attempt to add with overflow","1740":"call to assert_max_bit_size","2764":"Array index out of bounds","4544":"Array index out of bounds","3197":"Array index out of bounds","3898":"Array index out of bounds","5434":"attempt to add with overflow","3764":"Array index out of bounds","4276":"Array index out of bounds","2606":"Array index out of bounds","1259":"attempt to multiply with overflow","4331":"Array index out of bounds","4520":"attempt to add with overflow","1369":"attempt to add with overflow","5709":"Array index out of bounds","3070":"Array index out of bounds","3582":"Array index out of bounds","4606":"attempt to add with overflow","3637":"Array index out of bounds","1644":"call to assert_max_bit_size","4716":"Array index out of bounds","5228":"Array index out of bounds","2077":"attempt to add with overflow","3613":"Array index out of bounds","3802":"attempt to add with overflow","5393":"attempt to add with overflow","4558":"attempt to add with overflow","5259":"Array index out of bounds","3400":"Array index out of bounds","5582":"Array index out of bounds","3455":"Array index out of bounds","4479":"attempt to add with overflow","4668":"attempt to add with overflow","2998":"Array index out of bounds","5369":"attempt to add with overflow","5747":"attempt to add with overflow","5101":"Array index out of bounds","2785":"attempt to add with overflow","3998":"Array index out of bounds","2840":"Array index out of bounds","3218":"attempt to add with overflow","4431":"Array index out of bounds","3273":"Array index out of bounds","4998":"Array index out of bounds","1091":"attempt to add with overflow","3840":"Array index out of bounds","2682":"Array index out of bounds","2871":"Array index out of bounds","3115":"Array index out of bounds","2792":"attempt to add with overflow","5541":"Array index out of bounds","2847":"Array index out of bounds","3091":"attempt to add with overflow","3603":"attempt to add with overflow","4304":"Array index out of bounds","2634":"Array index out of bounds","2311":"call to assert_max_bit_size","1988":"attempt to add with overflow","4816":"Array index out of bounds","4871":"Array index out of bounds","1531":"call to assert_max_bit_size","2744":"attempt to add with overflow","5249":"attempt to add with overflow","4847":"Array index out of bounds","3500":"Array index out of bounds","3177":"attempt to add with overflow","5036":"attempt to add with overflow","1373":"attempt to add with overflow","4634":"Array index out of bounds","5146":"Array index out of bounds","3476":"attempt to add with overflow","4689":"Array index out of bounds","2696":"attempt to add with overflow","4232":"Array index out of bounds","2562":"Array index out of bounds","5122":"attempt to add with overflow","3129":"attempt to add with overflow","4019":"attempt to add with overflow","5421":"Array index out of bounds","490":"Aztec Passport: Unauthorized Admin Change","3050":"attempt to add with overflow","3562":"attempt to add with overflow","4074":"Array index out of bounds","3806":"Array index out of bounds","4452":"attempt to add with overflow","3672":"Array index out of bounds","4507":"Array index out of bounds","5208":"attempt to add with overflow","1356":"attempt to multiply with overflow","3916":"Array index out of bounds","4105":"Array index out of bounds","2435":"Array index out of bounds","4349":"Array index out of bounds","3514":"attempt to add with overflow","4026":"attempt to add with overflow","5751":"Array index out of bounds","4081":"Array index out of bounds","5617":"Array index out of bounds","2411":"Array index out of bounds","3624":"attempt to add with overflow","3813":"Array index out of bounds","4325":"attempt to add with overflow","2655":"attempt to add with overflow","3868":"Array index out of bounds","4837":"attempt to add with overflow","5160":"attempt to add with overflow","5270":"attempt to add with overflow","3978":"attempt to add with overflow","4734":"Array index out of bounds","4411":"attempt to add with overflow","5758":"Array index out of bounds","181":"attempt to add with overflow","4710":"attempt to add with overflow","2906":"Array index out of bounds","3930":"attempt to add with overflow","2772":"Array index out of bounds","401":"Initializer address is not the contract deployer","4363":"attempt to add with overflow","1992":"attempt to add with overflow","3205":"Array index out of bounds","3772":"Array index out of bounds","4284":"attempt to add with overflow","2614":"attempt to add with overflow","2803":"Array index out of bounds","4796":"attempt to add with overflow","5040":"Array index out of bounds","2858":"attempt to add with overflow","4906":"Array index out of bounds","5308":"Array index out of bounds","5717":"Array index out of bounds","4748":"attempt to add with overflow","5449":"Array index out of bounds","3078":"Array index out of bounds","3590":"Array index out of bounds","3645":"Array index out of bounds","2810":"Array index out of bounds","1975":"attempt to multiply with overflow","4858":"attempt to add with overflow","817":"attempt to add with overflow","1518":"attempt to add with overflow","3889":"attempt to add with overflow","5047":"Array index out of bounds","2085":"attempt to add with overflow","5236":"Array index out of bounds","5590":"Array index out of bounds","147":"attempt to add with overflow","3463":"Array index out of bounds","3006":"Array index out of bounds","3384":"Array index out of bounds","5109":"Array index out of bounds","4140":"Array index out of bounds","2470":"Array index out of bounds","4006":"Array index out of bounds","4439":"Array index out of bounds","3793":"attempt to add with overflow","5006":"Array index out of bounds","3848":"attempt to add with overflow","4037":"Array index out of bounds","831":"Not initialized","508":"Not initialized","185":"Array index out of bounds","2422":"attempt to add with overflow","2879":"Array index out of bounds","1264":"attempt to add with overflow","3257":"Array index out of bounds","3690":"Array index out of bounds","3824":"attempt to add with overflow","4092":"attempt to add with overflow","5281":"Array index out of bounds","5549":"Array index out of bounds","5738":"attempt to add with overflow","4312":"Array index out of bounds","405":"Aztec Passport: Invalid Address","82":"attempt to add with overflow","1807":"attempt to add with overflow","2642":"Array index out of bounds","3666":"attempt to add with overflow","4044":"Array index out of bounds","4824":"Array index out of bounds","192":"Array index out of bounds","4879":"Array index out of bounds","5635":"Array index out of bounds","5769":"attempt to add with overflow","5611":"attempt to add with overflow","3752":"attempt to add with overflow","4697":"Array index out of bounds","3027":"attempt to add with overflow","4240":"Array index out of bounds","2570":"Array index out of bounds","4618":"Array index out of bounds","5697":"attempt to add with overflow","3704":"attempt to add with overflow","2924":"Array index out of bounds","2089":"attempt to add with overflow","5027":"attempt to add with overflow","608":"Not initialized","5405":"Array index out of bounds","2900":"attempt to add with overflow","4113":"Array index out of bounds","5326":"Array index out of bounds","395":"Initialization hash does not match","2443":"Array index out of bounds","4491":"Array index out of bounds","5058":"attempt to add with overflow","5570":"attempt to add with overflow","4924":"Array index out of bounds","5649":"attempt to add with overflow","2986":"attempt to add with overflow","3876":"Array index out of bounds","4900":"attempt to add with overflow","5467":"Array index out of bounds","2072":"attempt to multiply with overflow","457":"attempt to add with overflow"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"12265343917440897559":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":6,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"error_types":{},"parameters":[{"name":"_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"],"assert_messages":{"128":"attempt to add with overflow","448":"Array index out of bounds","698":"Array index out of bounds","110":"Array index out of bounds","366":"Array index out of bounds","616":"Array index out of bounds","430":"Array index out of bounds","415":"attempt to add with overflow","598":"Array index out of bounds","592":"attempt to add with overflow","394":"Array index out of bounds","522":"Array index out of bounds","510":"attempt to add with overflow","571":"Array index out of bounds","117":"Array index out of bounds","690":"Array index out of bounds","678":"attempt to add with overflow","538":"Array index out of bounds","340":"Initializer address is not the contract deployer","334":"Initialization hash does not match","462":"attempt to add with overflow","72":"attempt to add with overflow","386":"Array index out of bounds","706":"Array index out of bounds","374":"attempt to add with overflow","563":"Array index out of bounds","630":"attempt to add with overflow","106":"attempt to add with overflow","551":"attempt to add with overflow","344":"Aztec Passport: Invalid Address","402":"Array index out of bounds","530":"Array index out of bounds","719":"attempt to add with overflow","579":"Array index out of bounds"}},{"name":"set_passport_address","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"_passport_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["set_passport_address"],"assert_messages":{"1792":"Array index out of bounds","829":"Array index out of bounds","957":"Array index out of bounds","1018":"Array index out of bounds","1085":"attempt to add with overflow","1457":"Array index out of bounds","1262":"Array index out of bounds","811":"Array index out of bounds","939":"attempt to add with overflow","1189":"Array index out of bounds","994":"Array index out of bounds","1384":"Array index out of bounds","1244":"Array index out of bounds","1433":"attempt to add with overflow","1238":"attempt to add with overflow","1439":"Array index out of bounds","1750":"attempt to add with overflow","781":"Array index out of bounds","1610":"Array index out of bounds","903":"Array index out of bounds","1927":"Array index out of bounds","1153":"Array index out of bounds","518":"attempt to add with overflow","891":"attempt to add with overflow","1336":"Array index out of bounds","1531":"Array index out of bounds","1519":"attempt to add with overflow","1324":"attempt to add with overflow","1647":"Array index out of bounds","1629":"Array index out of bounds","1623":"attempt to add with overflow","1940":"attempt to add with overflow","337":"attempt to add with overflow","14":"Not initialized","843":"attempt to add with overflow","1800":"Array index out of bounds","1026":"Array index out of bounds","1471":"attempt to add with overflow","1276":"attempt to add with overflow","1209":"Array index out of bounds","1404":"Array index out of bounds","1721":"Array index out of bounds","1392":"attempt to add with overflow","1197":"attempt to add with overflow","1581":"attempt to add with overflow","1709":"attempt to add with overflow","1837":"Array index out of bounds","1819":"Array index out of bounds","789":"Array index out of bounds","1813":"attempt to add with overflow","911":"Array index out of bounds","1161":"Array index out of bounds","1539":"Array index out of bounds","1344":"Array index out of bounds","1661":"attempt to add with overflow","1594":"Array index out of bounds","631":"attempt to add with overflow","1911":"Array index out of bounds","753":"Array index out of bounds","619":"attempt to add with overflow","1771":"attempt to add with overflow","1899":"attempt to add with overflow","802":"attempt to add with overflow","1570":"Array index out of bounds","1174":"attempt to add with overflow","522":"attempt to add with overflow","1034":"Array index out of bounds","1412":"Array index out of bounds","1217":"Array index out of bounds","510":"attempt to add with overflow","1729":"Array index out of bounds","1784":"Array index out of bounds","1851":"attempt to add with overflow","1071":"Array index out of bounds","614":"attempt to multiply with overflow","1760":"Array index out of bounds","1053":"Array index out of bounds","919":"Array index out of bounds","1047":"attempt to add with overflow","267":"call to assert_max_bit_size","1352":"Array index out of bounds","773":"Array index out of bounds","1547":"Array index out of bounds","1602":"Array index out of bounds","1919":"Array index out of bounds","761":"attempt to add with overflow","505":"attempt to multiply with overflow","627":"attempt to add with overflow","950":"Array index out of bounds","1005":"attempt to add with overflow","1133":"attempt to add with overflow","1145":"Array index out of bounds","932":"attempt to add with overflow","987":"Array index out of bounds","1560":"attempt to add with overflow","1365":"attempt to add with overflow","1420":"Array index out of bounds","1737":"Array index out of bounds","1225":"Array index out of bounds","969":"attempt to add with overflow"}},{"name":"get_passport_address","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_passport_address"],"assert_messages":{"224":"Array index out of bounds","323":"attempt to add with overflow","343":"Array index out of bounds","14":"Not initialized","261":"Array index out of bounds","351":"Array index out of bounds","19":"Function get_passport_address can only be called statically","208":"Array index out of bounds","237":"attempt to add with overflow","243":"Array index out of bounds","275":"attempt to add with overflow","184":"Array index out of bounds","216":"Array index out of bounds","335":"Array index out of bounds","364":"attempt to add with overflow","195":"attempt to add with overflow"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"},{"fields":[{"name":"address","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"},{"fields":[{"name":"address","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"AztecPassport"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"total_services","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"services","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"service_indexes","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"scores","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"ENSModule"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"ens_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"passport_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"_registry","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"ENSModule::set_ens_registry_parameters"}}],"kind":"struct","path":"ENSModule::set_ens_registry_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ENSModule::set_admin_parameters"}}],"kind":"struct","path":"ENSModule::set_admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"ENSModule::get_passport_address_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ENSModule::get_passport_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"ENSModule::is_admin_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"ENSModule::is_admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"_passport_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ENSModule::set_passport_address_parameters"}}],"kind":"struct","path":"ENSModule::set_passport_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"ENSModule::constructor_parameters"}}],"kind":"struct","path":"ENSModule::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"ENSModule::get_ens_registry_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"ENSModule::get_ens_registry_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}}],"kind":"struct","path":"ENSModule::verify_parameters"}}],"kind":"struct","path":"ENSModule::verify_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"ENSModule::get_admin_public_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"ENSModule::get_admin_public_abi"}]}},"file_map":{"114":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"115":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"118":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\nunconstrained pub fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"121":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_arguments_oracle_wrapper(args)\n    };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_arguments_array_oracle_wrapper(args)\n    };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"122":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"125":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT, utils::arr_copy_slice};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    let returned_message = get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    (leaf_index, sibling_path)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MSG_TREE_HEIGHT + 1] {}\n"},"126":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"127":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"148":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        value\n    }\n}\n"},"153":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"154":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"159":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"},"162":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse dep::protocol_types::{address::{AztecAddress, EthAddress}, merkle_tree::root::root_from_sibling_path};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    let (leaf_index, sibling_path) = unsafe {\n        get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret)\n    };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n"},"169":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> where T: ToField {\n    fn serialize(self) -> [Field; 3] {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> where T: FromField {\n    fn deserialize(input: [Field; 3]) -> Self {\n        Self {\n            pre: FromField::from_field(input[0]),\n            post: FromField::from_field(input[1]),\n            block_of_change: FromField::from_field(input[2])\n        }\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"170":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32)) + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33)\n            + (self.post.is_some() as u64 * (1 << 32))\n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some {\n                Option::some(pre_inner)\n            } else {\n                Option::none()\n            },\n            post: if post_is_some {\n                Option::some(post_inner)\n            } else {\n                Option::none()\n            },\n            block_of_change\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"174":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{poseidon2_hash, poseidon2_hash_with_separator}, address::AztecAddress,\n    traits::{FromField, ToField}, utils::arrays::array_concat\n};\n\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::mem::zeroed;\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// Separators separating storage slot of different values within the same state variable\nglobal VALUE_CHANGE_SEPARATOR: u32 = 0;\nglobal DELAY_CHANGE_SEPARATOR: u32 = 1;\nglobal HASH_SEPARATOR: u32 = 2;\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, let INITIAL_DELAY: u32, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> where T: ToField + FromField + Eq {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], VALUE_CHANGE_SEPARATOR)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], DELAY_CHANGE_SEPARATOR)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], HASH_SEPARATOR)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> where T: ToField + FromField + Eq {\n\n    pub fn schedule_value_change(self, new_value: T) {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> where T: ToField + FromField + Eq {\n    pub fn get_current_value_in_private(self) -> T {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage(self) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) {\n        let header = self.context.get_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = unsafe {\n            get_public_storage_hints(address, self.storage_slot, historical_block_number)\n        };\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        if hash != 0 {\n            assert_eq(\n                hash, SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint), \"Hint values do not match hash\"\n            );\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            assert_eq(\n                value_change_hint, ScheduledValueChange::deserialize(zeroed()), \"Non-zero value change for zero hash\"\n            );\n            assert_eq(\n                delay_change_hint, ScheduledDelayChange::deserialize(zeroed()), \"Non-zero delay change for zero hash\"\n            );\n        };\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field {\n        let concatenated: [Field; 4] = array_concat(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UnconstrainedContext> where T: ToField + FromField + Eq {\n    unconstrained pub fn get_current_value_in_unconstrained(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    unconstrained fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, let INITIAL_DELAY: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) where T: ToField + FromField + Eq {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"176":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"221":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"},"230":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE: u32 = 4;\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // We choose the last SELECTOR_SIZE bytes of the hash to avoid getting the first byte that is not full\n        let hash_bytes = hash.to_be_bytes::<SELECTOR_SIZE>();\n\n        FunctionSelector::from_field(field_from_bytes(hash_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector = FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"241":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\npub struct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber { _opt: Option { _is_some: serialized[0] as bool, _value: serialized[1] as u32 } }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"263":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"276":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"277":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr","source":"mod assert_array_appended;\nmod assert_array_prepended;\nmod assert_combined_array;\nmod assert_combined_sorted_transformed_value_array;\nmod assert_combined_transformed_array;\nmod assert_deduped_array;\nmod assert_exposed_sorted_transformed_value_array;\nmod assert_sorted_array;\nmod assert_sorted_transformed_value_array;\nmod assert_split_sorted_transformed_value_arrays;\nmod assert_split_transformed_value_arrays;\nmod get_sorted_result;\nmod get_sorted_tuple;\nmod sort_by;\nmod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{assert_array_appended, assert_array_appended_reversed, assert_array_appended_scoped};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_sorted_transformed_value_array::{\n    assert_combined_sorted_transformed_value_array_asc,\n    get_combined_order_hints::{CombinedOrderHint, get_combined_order_hints_asc}\n};\npub use assert_combined_transformed_array::{assert_combined_transformed_array, combine_and_transform_arrays};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint}\n};\npub use assert_deduped_array::{assert_deduped_array, dedupe_array};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc, assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints}\n};\npub use assert_sorted_transformed_value_array::{assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N> where T: Empty + Eq {\n    let mut len = 0;\n    for elem in array {\n        if !is_empty(elem) {\n            len += 1;\n        }\n    }\n\n    BoundedVec { storage: array, len }\n}\n\nunconstrained pub fn find_index_hint<T, let N: u32, Env>(array: [T; N], find: fn[Env](T) -> bool) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32 where T: Empty + Eq {\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32 where T: Empty + Eq {\n    let length = unsafe {\n        find_index_hint(array, |elem: T| is_empty(elem))\n    };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N] where T: Empty + Eq {\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N]\n) where T: Eq + Empty {\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe {\n        find_index_hint(values, |v: Field| min.lt(v))\n    };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe {\n        find_index_hint(values, |v: Field| min.lt(v))\n    };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    pedersen_hash_with_separator_noir(input, separator)\n}\n\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator_noir(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n"},"296":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"298":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"301":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl <let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"302":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl <T, let N: u32, let M: u32> Serialize<N * M> for [T; N] where T: Serialize<M> {\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl <T, let N: u32, let M: u32> Deserialize<N * M> for [T; N] where T: Deserialize<M> {\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n"},"305":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"306":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"310":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{constants::ETH_ADDRESS_LENGTH, traits::{Empty, ToField, Serialize, Deserialize}, utils};\nuse crate::traits::FromField;\n\npub struct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for EthAddress {\n    fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"314":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"318":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\npub struct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"329":{"path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/l2-contracts/crates/passport/src/main.nr","source":"pub mod service;\n\nuse dep::aztec::macros::aztec;\n\npub global SCALE: u64 = 1000000;\n\n#[aztec]\npub contract AztecPassport {\n    use aztec::{\n        prelude::{AztecAddress, PublicMutable, Map, SharedMutable},\n        macros::{storage::storage, functions::{initializer, public, private, view}},\n        keys::getters::get_public_keys\n    };\n\n    use dep::value_note::{balance_utils::get_balance};\n\n    use dep::easy_private_state::EasyPrivateUint;\n    use crate::service::Service;\n\n    pub global SCALE: u64 = 1000000;\n\n    #[storage]\n    struct Storage<Context> {\n        // Admin of Contract\n        admin: PublicMutable<AztecAddress, Context>,\n        // Track Count of Total Services\n        total_services: SharedMutable<u64, 1, Context>,\n        // Service ID => Service\n        services: Map<u64, PublicMutable<Service, Context>, Context>,\n        // Service Address -> ID\n        service_indexes: Map<AztecAddress, SharedMutable<u64, 1, Context>, Context>,\n        //  Address => Service ID => verified(boolean)\n        scores: Map<AztecAddress, Map<u64, EasyPrivateUint<Context>, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(_admin: AztecAddress) {\n        assert(!_admin.is_zero(), \"Aztec Passport: Invalid Address\");\n        storage.admin.write(_admin);\n    }\n\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Unauthorized Admin Change\");\n        storage.admin.write(new_admin);\n    }\n\n    #[public]\n    #[view]\n    fn get_admin_public() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    #[public]\n    fn add_service(address: AztecAddress, weight: u64, base_score: u64, max_score: u64) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Only Admin\");\n        let service_id = storage.total_services.get_current_value_in_public();\n        storage.services.at(service_id).write(Service { address, weight, base_score, max_score });\n        storage.service_indexes.at(address).schedule_value_change(service_id);\n        storage.total_services.schedule_value_change(service_id + 1);\n    }\n\n    #[public]\n    #[view]\n    fn get_service(service_id: u64) -> Service {\n        storage.services.at(service_id).read()\n    }\n\n    #[public]\n    #[view]\n    fn get_total_services() -> u64 {\n        storage.total_services.get_current_value_in_public()\n    }\n\n    #[private]\n    #[view]\n    fn get_total_services_private() -> u64 {\n        storage.total_services.get_current_value_in_private()\n    }\n\n    #[public]\n    #[view]\n    fn get_service_index(address: AztecAddress) -> u64 {\n        storage.service_indexes.at(address).get_current_value_in_public()\n    }\n\n    #[private]\n    #[view]\n    fn get_service_index_private(address: AztecAddress) -> u64 {\n        storage.service_indexes.at(address).get_current_value_in_private()\n    }\n\n    unconstrained fn is_verified(address: AztecAddress, service_id: u64) -> bool {\n        let res = storage.scores.at(address).at(service_id).set;\n        let balance = get_balance(res);\n        balance as u32 >= 1\n    }\n\n    #[private]\n    fn verify_service(address: AztecAddress, service_id: u64, service_address: AztecAddress) {\n        assert(service_address.eq(context.msg_sender()), \"Aztec Passport: Only Service\");\n        let res = storage.service_indexes.at(service_address).get_current_value_in_private();\n        assert(res == service_id, \"Aztec Passport: Invalid Service\");\n        storage.scores.at(address).at(service_id).add(1, address, address);\n    }\n\n    unconstrained fn get_total_score(address: AztecAddress) -> u64 {\n        let mut total_weight: u64 = 0;\n        let mut total_base_contribution: u64 = 0;\n        let mut total_max_contribution: u64 = 0;\n        let mut verified_count: u64 = 0;\n\n        let total_services = storage.total_services.get_current_value_in_unconstrained();\n\n        for i in 0..total_services {\n            let service = storage.services.at(i).read();\n            total_weight += service.weight;\n            let res = storage.scores.at(address).at(i).set;\n            let balance = get_balance(res);\n            let verified = balance as u32 >= 1;\n            if (verified) {\n                total_base_contribution += (service.base_score * service.weight) / SCALE;\n                total_max_contribution += (service.max_score * service.weight) / SCALE;\n                verified_count += 1;\n            }\n        }\n\n        if (verified_count == 0) {\n            0\n        }\n\n        let diminishing_factor = verified_count * verified_count / (total_services * total_services);\n        let adjusted_max_score = total_max_contribution * diminishing_factor;\n        let bonus_multiplier = (verified_count * SCALE) / total_services;\n        let final_score = (total_base_contribution + adjusted_max_score) * bonus_multiplier / SCALE;\n\n        final_score\n    }\n}\n"},"331":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/address-note/src/address_note.nr","source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"},"338":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\nglobal ZERO = 0;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"6":{"path":"std/cmp.nr","source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(s, quote { Eq }, signature, for_each_field, quote { & }, body)\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"68":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"70":{"path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/l2-contracts/crates/modules/ens_module/src/main.nr","source":"use dep::aztec::macros::aztec;\n#[aztec]\ncontract ENSModule {\n    use aztec::{\n        prelude::{AztecAddress, PublicMutable, SharedMutable}, protocol_types::{address::EthAddress},\n        macros::{storage::storage, functions::{initializer, public, private, view}}\n    };\n\n    use dep::passport::AztecPassport;\n\n    #[storage]\n    struct Storage<Context> {\n        // Admin of Contract\n        admin: PublicMutable<AztecAddress, Context>,\n        // Mock ENS Address\n        ens_registry: SharedMutable<EthAddress, 1, Context>,\n        // Passport Contract Address\n        passport_address: SharedMutable<AztecAddress, 1, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(_admin: AztecAddress) {\n        assert(!_admin.is_zero(), \"Aztec Passport: Invalid Address\");\n        storage.admin.write(_admin);\n    }\n\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Unauthorized Admin Change\");\n        storage.admin.write(new_admin);\n    }\n\n    #[public]\n    #[view]\n    fn get_admin_public() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    #[public]\n    #[view]\n    fn is_admin() -> bool {\n        storage.admin.read().eq(context.msg_sender())\n    }\n\n    #[public]\n    #[view]\n    fn get_passport_address() -> AztecAddress {\n        storage.passport_address.get_current_value_in_public()\n    }\n\n    #[public]\n    fn set_passport_address(_passport_address: AztecAddress) {\n        let _ = storage.passport_address.schedule_value_change(_passport_address);\n    }\n\n    #[public]\n    fn set_ens_registry(_registry: EthAddress) {\n        let _ = storage.ens_registry.schedule_value_change(_registry);\n    }\n\n    #[public]\n    #[view]\n    fn get_ens_registry() -> EthAddress {\n        storage.ens_registry.get_current_value_in_public()\n    }\n\n    #[private]\n    fn verify(address: AztecAddress, content: Field, secret: Field) {\n        let passport_address = storage.passport_address.get_current_value_in_private();\n        let sender = storage.ens_registry.get_current_value_in_private();\n\n        context.consume_l1_to_l2_message(content, secret, sender);\n\n        assert(content as u32 == 1, \"Aztec Passport: Invalid Content\");\n\n        let index = AztecPassport::at(passport_address).get_service_index_private(context.this_address()).view(&mut context);\n        let _ = AztecPassport::at(passport_address).verify_service(address, index, context.this_address()).call(&mut context);\n    }\n}\n"},"77":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\nunconstrained pub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"86":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe {\n            unpack_returns(self.packed_returns)\n        };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"90":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](()) -> T {\n        self.original\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](()) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](()) -> () {\n        self.original\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](()) -> T {\n        self.original\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](()) -> () {\n        self.original\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"92":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn () -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        panic(f\"'delegate_call_public_function' not implemented!\")\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained pub fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"93":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"}}}