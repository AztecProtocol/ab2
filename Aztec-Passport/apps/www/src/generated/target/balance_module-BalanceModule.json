{"transpiled":true,"noir_version":"0.35.0+b848cc128d2dc2b461581f21a35509a1af9065a7-aarch64","name":"BalanceModule","functions":[{"name":"set_balance_registry","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"_registry","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["set_balance_registry"],"assert_messages":{"640":"attempt to add with overflow","1920":"Array index out of bounds","762":"Array index out of bounds","628":"attempt to add with overflow","1780":"attempt to add with overflow","1908":"attempt to add with overflow","811":"attempt to add with overflow","1579":"Array index out of bounds","1183":"attempt to add with overflow","153":"call to assert_max_bit_size","1043":"Array index out of bounds","1421":"Array index out of bounds","1226":"Array index out of bounds","1738":"Array index out of bounds","1860":"attempt to add with overflow","1793":"Array index out of bounds","1080":"Array index out of bounds","623":"attempt to multiply with overflow","1769":"Array index out of bounds","1062":"Array index out of bounds","928":"Array index out of bounds","1056":"attempt to add with overflow","532":"attempt to add with overflow","1361":"Array index out of bounds","14":"Not initialized","782":"Array index out of bounds","520":"attempt to add with overflow","1556":"Array index out of bounds","770":"attempt to add with overflow","959":"Array index out of bounds","636":"attempt to add with overflow","1154":"Array index out of bounds","1014":"attempt to add with overflow","1142":"attempt to add with overflow","1611":"Array index out of bounds","941":"attempt to add with overflow","1928":"Array index out of bounds","996":"Array index out of bounds","161":"call to assert_max_bit_size","1374":"attempt to add with overflow","1569":"attempt to add with overflow","277":"call to assert_max_bit_size","978":"attempt to add with overflow","1234":"Array index out of bounds","1429":"Array index out of bounds","1746":"Array index out of bounds","966":"Array index out of bounds","1027":"Array index out of bounds","1094":"attempt to add with overflow","838":"Array index out of bounds","515":"attempt to multiply with overflow","1271":"Array index out of bounds","820":"Array index out of bounds","948":"attempt to add with overflow","1198":"Array index out of bounds","1003":"Array index out of bounds","1393":"Array index out of bounds","1253":"Array index out of bounds","1442":"attempt to add with overflow","1247":"attempt to add with overflow","1448":"Array index out of bounds","1466":"Array index out of bounds","790":"Array index out of bounds","1619":"Array index out of bounds","528":"attempt to add with overflow","912":"Array index out of bounds","1162":"Array index out of bounds","1759":"attempt to add with overflow","900":"attempt to add with overflow","1345":"Array index out of bounds","1540":"Array index out of bounds","1801":"Array index out of bounds","1528":"attempt to add with overflow","1333":"attempt to add with overflow","1656":"Array index out of bounds","1936":"Array index out of bounds","1638":"Array index out of bounds","1632":"attempt to add with overflow","1949":"attempt to add with overflow","852":"attempt to add with overflow","1809":"Array index out of bounds","1035":"Array index out of bounds","1480":"attempt to add with overflow","1285":"attempt to add with overflow","1218":"Array index out of bounds","1413":"Array index out of bounds","1730":"Array index out of bounds","1401":"attempt to add with overflow","1206":"attempt to add with overflow","1590":"attempt to add with overflow","1718":"attempt to add with overflow","1846":"Array index out of bounds","1828":"Array index out of bounds","798":"Array index out of bounds","347":"attempt to add with overflow","920":"Array index out of bounds","1822":"attempt to add with overflow","1170":"Array index out of bounds","1548":"Array index out of bounds","1353":"Array index out of bounds","1670":"attempt to add with overflow","1603":"Array index out of bounds"}},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"3715688037512703171":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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IAQpKgAKJyoAJCYgBCkeAAcAJBwABCQqHAAHKikcAAQpJAwABCQgKSEABDgAKSAEMCEABDQAJyAEMioADSAgBDYqACYgIAQ2KgAgJSAEQCEABDwAIiAEOioADSAgBD4qACMgIAQ+KgAgJSAEQAAABCQlKQ4ABCQpKiEABEQAKjoBAAAqAR8lKgETKioBHisMAAQkKywhAARMACwgBEoqACogIAROKgAlICAETioCIB8qAiETKgIpHioBFB4AAAQeAh4qAh4UKgEUHgAABB4CHioCHhQqARQeAAAEHgIeKgIeFCoBFB4AAAQeAh4qAh4UKgAAHgAABAACACoBCxMAAAQTAhMqAhMLKgAAEwAABAACACoAAB8AAAQAAgAqAAAkAAAEAAIAKgEUKgAABCoCKioCKhQqAQsqAAAEKgIqKgIqCyoBFCoAAAQqAioqAioUKgELKgAABCoCKioCKgsqARQqAAAEKgIqKgIqFCoBCyoAAAQqAioqAioLKgIUHioCCxMqAg0fKgIIJCoBFCoCAAQqAioqAioUKgELKgIABCoCKioCKgsqAAYlIASGCgAEJQYqIQARqwAqIASJKgEkKgoAASoIKyEABI0AKzoBAAAqAAYlIASPDAAEJREqIQARggAqIASSKgETHyoAAB4kAAQFKgAABAAqACQBBAEeAAAEHwIqJAAEBCsAAAQeAiw+AwAAACoAAAAsKgIeEyoCCiQAAAQeAhMAAAQTBh8qAR8kHAAHKR4qAAYlIASjDAAEJREfIQARZwAfIASmKgAAJAAABAACACoBCx8AAAQfAh8qAh8LKgAAHwAABAACACoAAB4AAAQAAgAqAAATAAAEAAIAKgELKgAABCoCKioCKgsqAQsqAAAEKgIqKgIqCyoBGyoAAAQqAioqAiobKgELKgAABCoCKioCKgsqAhskKgILHyoCDR4qAggTKgEbKgIABCoCKioCKhsqAQsqAgAEKgIqKgIqCyoABiUgBMkKAAQlBiohABDoACogBMwqARMqCgABKggrIQAE0AArOgEAACoABiUgBNIMAAQlESohABC/ACogBNUqAR8kKgAAHiQABAUqAAAEACoAJAEEAR4AAAQkAiokAAQEKwAABB4CLD4DAAAAKgAAACwqAh4fKgIKEwAABB4CHwAABB8GJCoBJBMcAAUjHgQABR4aHyQABQAsCgAFLBokIQAE7AAkBgAFHxoqCgAFKh4rIQAE7AArOgEAABwABSYeAAAFHx4sDgAFHywkIQAE8QAkOgEAABwABSIeBAAFHh0fHAAFJx4EAAUeGiQAAAUfJB4OAAUfHiohAAT5ACo6AQAAAAAFHigfDgAFHh8kIQAE/QAkOgEAABwAByweHAAHHywEAAcsFx8AAAceHywqAAYlIAUDCgAEJQYrIQAQqAArIAUGKgAAJAAABAACACoBCx8AAAQfAh8qAh8LKgAAHwAABAACACoAAB4AAAQAAgAqAAATAAAEAAIAKgELKgAABCoCKioCKgsqAQsqAAAEKgIqKgIqCyoBHCoAAAQqAioqAiocKgELKgAABCoCKioCKgsqAhwkKgILHyoCDR4qAggTKgEcKgIABCoCKioCKhwqAQsqAgAEKgIqKgIqCyoABiUgBSkKAAQlBiohABApACogBSwqARMWCgABFggSIQAFMAASOgEAACoABiUgBTIMAAQlERYhABAAABYgBTUqAR8kKgAAHiQABAUWAAAEABYAJAEEAR4AAAQkAhYkAAQEEgAABB4CKj4DAAAAFgAAACoqAh4fKgIKEwAABB4CHwAABB8GJCoBJBMcAAcpHhwABSMpBAAFKRojJAAFACQKAAUkGh8hAAVNAB8GAAUjGhIKAAUSKSohAAVNACo6AQAAHAAFJikAAAUjKSYOAAUjJiQhAAVSACQ6AQAAHAAFIikEAAUpHSIcAAUnKQQABSkaJwAABSInKQ4ABSIpIyEABVoAIzoBAAAAAAUpKCcOAAUpJyIhAAVeACI6AQAAHAAHJikcAAcnJgQAByYXJwAAByknJioAACckAAQFKQAABAApACQBBAEnAAAEJwIpKgApKCoCICgAAAQoAigqAiAoAAAEKAIoKgIgKAAABCgCKCoCICgqAScpAAAEKQIpKgIpJyoAACkAAAQAAgAqAicpKgANJSAFdwwABCURKCEAD9sAKCAFeioABiggBXwKAAQoBichAA+2ACcgBX8qASknKgEUKQAABCkCKSoCKRQqARQpAAAEKQIpKgIpFCoBFCkAAAQpAikqAikUKgEUKQAABCkCKSoCKRQqAAApAAAEAAIAKgIUKSoBFSYAAAQmAiYqAiYVKgAAJgAABAACACoCFSYqAAAlAAAEAAIAKgIGJSoAACQAAAQAAgAqAggkKgAGKCAFnQwABCgEIyEADzQAIyAFoCoBJCcKAAEnCCMhAAWkACM6AQAAKgAGKCAFpgwABCgRJyEADwsAJyAFqSoBJiMqAAAiJAAEBSEAAAQAIQAkAQQBIgAABCMCISQABAQgAAAEIgIfPgMAAAAhAAAAHyoCIiYqAgokAAAEIgImAAAEJgYjKgEjJCoABiUgBbkKAAQlBiMhAA70ACMgBbwAAAQPAhY5AQAAABYAAAAAIAW/JgAHIOEAPAAWCgAHAxYTKgAAFiQABAISAAAEABIAJAEEARYAAAQWAhIqABIeKgIYHiEABcoAEyAIiyoAABIkAAQCHgAABAAeACQBBAESAAAEEgIeHwQAAAANAAAADQAAAB4qARIeAAAEHgIeKgIeEioAAB4AAAQAAgAqAhIeKgAAHwAABAACACoCBh8qARIgAAAEIAIgKgIgEioAACAAAAQAAgAqAhAgKgESIQAABCECISoCIRIqARASAAAEEgISKgISECoABhMgBecKAAQTBhIhAA7UABIgBeoqAR8TAAAEEw0SDgAEExIhIQAF7wAhOgEAACoCEh8qASASKgEQIAIABCACICoCIBAAAAQSAh8AAAQfBhMqARMgHAAHIBIpAAcAAAAAAAAAAAAAAAD//////////////////////////wAfDgAHEh8TIQAF/AATOgEAAB4AAAAfHgAAABIwAAAAAB8AAAASAAAAEwoAAhMFEiEABgIAEjoBAAAqARQTAAAEEwITKgITFCoBFBMAAAQTAhMqAhMUKgEUEwAABBMCEyoCExQqARQTAAAEEwITKgITFCoAABMAAAQAAgAqAQsSAAAEEgISKgISCyoAABIAAAQAAgAqAAAfAAAEAAIAKgAAIQAABAACACoBFCIAAAQiAiIqAiIUKgELIgAABCICIioCIgsqARQiAAAEIgIiKgIiFCoBCyIAAAQiAiIqAiILKgEUIgAABCICIioCIhQqAQsiAAAEIgIiKgIiCyoCFBMqAgsSKgINHyoCCCEqARQiAgAEIgIiKgIiFCoBCyICAAQiAiIqAiILKgAGHiAGNwoABB4GIiEADlUAIiAGOioBISIKAAEiCCMhAAY+ACM6AQAAKgAGHiAGQAwABB4RIiEADiwAIiAGQyoBEh4qAAATJAAEBSIAAAQAIgAkAQQBEwAABB4CIiQABAQjAAAEEwIkPgMAAAAiAAAAJCoCExIqAgohAAAEEwISAAAEEgYeKgEeISoBFBMAAAQTAhMqAhMUKgAAEwAABAACACoCFBMqAAYfIAZZDAAEHxEeIQAOFgAeIAZcKgETHgAABB4CEgAABBIGISoBIRMcAAcTEikABwAAAAAAAAAAAAAAAP//////////////////////////ACEOAAcSISIhAAZlACI6AQAAAAAEHgISAAAEEg0iKgEiIRwAByESKQAHAAAAAAAAAAAAAAAA//////////////////////////8AIg4ABxIiIyEABm0AIzoBAAAAAAQeAhIAAAQSDCMqASMiHAAEIhIcAAcSHhwABB4iKgAAHgAABAACACoCEx4qAAATAAAEAAIAKgIhEyoAACEAAAQAAgAqAiIhKgAAIgAABAACACoBCxIAAAQSAhIqAhILKgAAEgAABAACACoAACMAAAQAAgAqAAAkAAAEAAIAKgELJQAABCUCJSoCJQsqAQslAAAEJQIlKgIlCyoBGyUAAAQlAiUqAiUbKgELJQAABCUCJSoCJQsqAhsiKgILEioCDSMqAggkKgEbJQIABCUCJSoCJRsqAQslAgAEJQIlKgIlCyoABh8gBp8KAAQfBiUhAA2XACUgBqIqASQlCgABJQgmIQAGpgAmOgEAACoABh8gBqgMAAQfESUhAA1uACUgBqsqARIiKgAAHyQABAUlAAAEACUAJAEEAR8AAAQiAiUkAAQEJgAABB8CJz4DAAAAJQAAACcqAh8SKgIKJAAABB8CEgAABBIGIioBIiQqARAfAAAEHwIfKgIfECoAAB8AAAQAAgAqAhAfKgAGIyAGwQoABCMGIiEADVgAIiAGxCoBHyIAAAQiAiMAAAQjBiQqASQfHAAHHyIoAAf/////////////////////ACMOAAciIyQhAAbNACQ6AQAAHAAFHyIcAAciIxwABSMiAgAHHyMkCAAHJBcfHAAFHyMcAAcjJBwABSQfBgAFHx0kHAABJCUcAAUlIxwAASMkBgAFIhojHAAEIyUGAAUfGiMcAAEjJxwABScmHAABJiMcAAQiJxwABScmHAAEJiIcAAQfJxwABScmHAAEJh8hAAbqACQgBucqAAgSKgAGECAG7SoAChIqACUQIAbtIQAG8gAjIAbvKgAIJSoABiQgBvUqAAolKgAiJCAG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YgATIAhsKgEZGgoAARoIEyEACHAAEzoBAAAqAAYcIAhyDAAEHBEaIQAKOQAaIAh1KgEXFSoAABMkAAQFEgAABAASACQBBAETAAAEFQISJAAEBBAAAAQTAhw+AwAAABIAAAAcKgITFyoCChkAAAQTAhcAAAQXBhUqARUZKgAGGiAIhQoABBoGFyEACiIAFyAIiAAABA8CFzkBAAAAFwAAAAAgCIsmAAdvi7+1ABcKAAcDFxUhAAiPABUgCR8eAAAAFR4AAAATMAAAAAAVAAAAEwAAABIKAAISBRMhAAiVABM6AQAAHgALAAUKAAcFCRIhAAiZABI6AQAAHgAHAAUcAAQFEhwABxIJHAAECQUqARQJAAAECQIJKgIJFCoBFAkAAAQJAgkqAgkUKgEUCQAABAkCCSoCCRQqARQJAAAECQIJKgIJFCoAAAkAAAQAAgAqAQsSAAAEEgISKgISCyoAABIAAAQAAgAqAAATAAAEAAIAKgAAFQAABAACACoBFBAAAAQQAhAqAhAUKgELEAAABBACECoCEAsqARQQAAAEEAIQKgIQFCoBCxAAAAQQAhAqAhALKgEUEAAABBACECoCEBQqAQsQAAAEEAIQKgIQCyoCFAkqAgsSKgINEyoCCBUqARQQAgAEEAIQKgIQFCoBCxACAAQQAhAqAhALKgAGFyAI0goABBcGECEACaMAECAI1SoBFQ8KAAEPCAshAAjZAAs6AQAAKgAGECAI2wwABBARDyEACXoADyAI3ioBEhAqAAAPJAAEBQsAAAQACwAkAQQBDwAABBACCyQABAQJAAAEDwIHPgMAAAALAAAAByoCDxIqAgoVAAAEDwISAAAEEgYEKgEEFSoBFA8AAAQPAg8qAg8UKgAADwAABAACACoCFA8qAAYTIAj0DAAEExEUIQAJZAAUIAj3KgEPCwAABAsCCQAABAkGByoBBw8cAAcPCSkABwAAAAAAAAAAAAAAAP//////////////////////////AAcOAAcJBwQhAAkAAAQ6AQAAAAAECwIJAAAECQ0EKgEEBxwABwcNKQAHAAAAAAAAAAAAAAAA//////////////////////////8ACQ4ABw0JBCEACQgABDoBAAAAAAQLAg0AAAQNDAQqAQQJHAAECQscAAcLDBwABAwJDAAEBQkMIQAJEwAMIAkRKgAHDiAJ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LigrKgIqKyoCLSEgDI8AAAQoDSkOAAQoKSohAAyTACo6AQAAKgApKCAMPxwAByMhAAAHIiETKgAAISQABAQoAAAEACgAJAEEASEAAAQhAigqACgpKgIfKQAABCkCKSoCICkAAAQpAikqAh4pJAAEAykMAAQjKSohAAymACo6AQAAAAAEIQIqAAAEKiMpKgEpKC0AAAAAKAAAABMAAAQjDSgOAAQjKBMhAAyuABM6AQAAKgAoIyAHbyoBHigMAAQjKCkhAAy0ACkgDNMqARMoKgETKSQABAQrDAAEIyssIQAMugAsOgEAAAAABCkCLAAABCwjKyoBKyoqASEpJAAEAysMAAQjKy0hAAzCAC06AQAAAAAEKQItAAAELSMrKgErLAAAByosKSQABAQsDAAEIywtIQAMygAtOgEAACsAACgIAyUABAAFCAQiAAAWjSsACAUAKgAABCoCLQAABC0jLCoCKSwqAioTIAzTAAAEIw0oDgAEIygpIQAM1wApOgEAACoAKCMgB1skAAQBKQwABCMpKiEADN0AKjoBAAAAAAQWAioAAAQqIykqASkoKgEiKgoAASoIKSEADOQAKToBAAAqAR4qCgAEKhEpIQANAAApIAzoKgEhKSoBHioqAR4rJAAEAy0MAAQrLS4hAAzvAC46AQAAKwAAKQgDJQAEAAQIBCIAABaNKwAIBQAsAAAELAIuAAAEListKgIoLSoBLCgAAAQoAigqAigsAAAEKg0oDgAEKigrIQAM/QArOgEAACoCLCEqAigeIA0pKgAGKSANAgwABCkRKiEADS8AKiANBSoBISkqARMqKgAAKyQABAUsAAAEACwAJAEEASsAAAQqAiwkAAQELQAABCsCLj4DAAAALAAAAC4qASkqAgAEKgIqKgIqKSoBKSoAAAQqAioqAiopKgErKgAABCoCKioCKisrAAApCAMlAAQABAgEIgAAFo0rAAgFACoAAAQqAi4AAAQuBi0qAigtKgEqKQAABCkCKSoCKSoqASspAAAEKQIpKgIpKyoCKiEqAisTKgINHiANKQAABCMNKA4ABCMoKSEADS0AKToBAAAqACgjIAdSKgEeKgwABCkqKyEADTMAKyANUioBEyoqARMrJAAEBC0MAAQpLS4hAA05AC46AQAAAAAEKwIuAAAELiktKgEtLCoBISskAAQDLQwABCktLyEA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BQgEIgAAFo0rAAgFAC4AAAQuAjEAAAQxKzAqAi0wKgIuEyASJAAABCsNLA4ABCssLSEAEigALToBAAAqACwrIBHUKgEgIxwAByQiAAAHJSImLAAAAAAmAAAAIiQABAEnDAAEJCcoIQASMgAoOgEAACsAACMIAyUABAACCAQiAAAWjSsACAUAJgAABCYCKAAABCgkJyoCIicAAAQkDSMOAAQkIyIhABI9ACI6AQAAKgImICoAIyQgA/UqASQmDAAEICYnIQASRAAnIBJjKgEjJioBIyckAAQEKQwABCApKiEAEkoAKjoBAAAAAAQnAioAAAQqICkqASkoKgEiJyQABAMpDAAEICkrIQASUgArOgEAAAAABCcCKwAABCsgKSoBKSoAAAcoKickAAQEKgwABCAqKyEAEloAKzoBAAArAAAmCAMlAAQABQgEIgAAFo0rAAgFACgAAAQoAisAAAQrICoqAicqKgIoIyASYwAABCANJg4ABCAmJyEAEmcAJzoBAAAqACYgIAPcJAAEAScMAAQgJyghABJtACg6AQAAAAAEEgIoAAAEKCAnKgEnJioBJSgKAAEoCCchABJ0ACc6AQAAKgEkKAoABCgRJyEAEpAAJyASeCoBIicqASQoKgEkKSQABAMrDAAEKSssIQASfwAsOgEAACsAACcIAyUABAAECAQiAAAWjSsACAUAKgAABCoCLAAABCwpKyoCJisqASomAAAEJgImKgImKgAABCgNJg4ABCgmKSEAEo0AKToBAAAqAioiKgImJCASuSoABicgEpIMAAQnESghABK/ACggEpUqASInKgEjKCoAACkkAAQFKgAABAAqACQBBAEpAAAEKAIqJAAEBCsAAAQpAiw+AwAAACoAAAAsKgEnKAIABCgCKCoCKCcqAScoAAAEKAIoKgIoJyoBKSgAAAQoAigqAigpKwAAJwgDJQAEAAQIBCIAABaNKwAIBQAoAAAEKAIsAAAELAYrKgImKyoBKCYAAAQmAiYqAiYoKgEpJgAABCYCJioCJikqAigiKgIpIyoCDSQgErkAAAQgDSYOAAQgJichABK9ACc6AQAAKgAmICAD0yoBJCgMAAQnKCkhABLDACkgEuIqASMoKgEjKSQABAQrDAAEJyssIQASyQAsOgEAAAAABCkCLAAABCwnKyoBKyoqASIpJAAEAysMAAQnKy0h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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"512":"Function get_admin_public can only be called statically","1024":"call to assert_max_bit_size","2938":"attempt to add with overflow","4986":"attempt to add with overflow","3237":"Array index out of bounds","4261":"attempt to add with overflow","2591":"attempt to add with overflow","3292":"Array index out of bounds","5529":"attempt to add with overflow","4938":"attempt to add with overflow","2756":"Array index out of bounds","3780":"Array index out of bounds","4158":"Array index out of bounds","5316":"attempt to add with overflow","2488":"Array index out of bounds","3189":"Array index out of bounds","5292":"attempt to add with overflow","5481":"attempt to add with overflow","4134":"attempt to add with overflow","5347":"attempt to add with overflow","2464":"attempt to add with overflow","5725":"Array index out of bounds","471":"Not initialized","2196":"Not initialized","1361":"attempt to add with overflow","203":"attempt to add with overflow","3653":"Array index out of bounds","4220":"attempt to add with overflow","2550":"attempt to add with overflow","3062":"Array index out of bounds","3574":"Array index out of bounds","612":"Function get_passport_address can only be called statically","1636":"call to assert_max_bit_size","5220":"Array index out of bounds","5598":"Array index out of bounds","4172":"attempt to add with overflow","5385":"Array index out of bounds","2502":"attempt to add with overflow","3014":"Array index out of bounds","3392":"Array index out of bounds","3447":"Array index out of bounds","4471":"Array index out of bounds","4526":"Array index out of bounds","5093":"Array index out of bounds","3423":"Array index out of bounds","5337":"attempt to add with overflow","3990":"Array index out of bounds","5014":"Array index out of bounds","5069":"Array index out of bounds","2887":"Array index out of bounds","4423":"Array index out of bounds","3265":"Array index out of bounds","1272":"attempt to add with overflow","5557":"Array index out of bounds","547":"Not initialized","4887":"Array index out of bounds","4296":"Array index out of bounds","4808":"Array index out of bounds","2626":"Array index out of bounds","2303":"call to assert_max_bit_size","1980":"attempt to add with overflow","5351":"Array index out of bounds","2200":"Function get_balance_registry can only be called statically","3413":"attempt to add with overflow","2578":"Array index out of bounds","4248":"Array index out of bounds","4626":"Array index out of bounds","4681":"Array index out of bounds","2822":"attempt to add with overflow","4657":"Array index out of bounds","3310":"Array index out of bounds","5358":"Array index out of bounds","2664":"Array index out of bounds","5413":"Array index out of bounds","3042":"Array index out of bounds","3097":"Array index out of bounds","3286":"attempt to add with overflow","2451":"Array index out of bounds","4121":"Array index out of bounds","4499":"Array index out of bounds","1537":"Not initialized","3372":"attempt to add with overflow","3482":"Array index out of bounds","3860":"Array index out of bounds","5128":"Array index out of bounds","1276":"attempt to add with overflow","3324":"attempt to add with overflow","3245":"attempt to add with overflow","3434":"attempt to add with overflow","4647":"attempt to add with overflow","551":"Function is_admin can only be called statically","4056":"attempt to add with overflow","5080":"attempt to add with overflow","1740":"call to assert_max_bit_size","2764":"Array index out of bounds","4544":"Array index out of bounds","3197":"Array index out of bounds","3898":"Array index out of bounds","5434":"attempt to add with overflow","3764":"Array index out of bounds","4276":"Array index out of bounds","2606":"Array index out of bounds","1259":"attempt to multiply with overflow","4331":"Array index out of bounds","4520":"attempt to add with overflow","1369":"attempt to add with overflow","5709":"Array index out of bounds","3070":"Array index out of bounds","3582":"Array index out of bounds","4606":"attempt to add with overflow","3637":"Array index out of bounds","1644":"call to assert_max_bit_size","4716":"Array index out of bounds","5228":"Array index out of bounds","2077":"attempt to add with overflow","3613":"Array index out of bounds","3802":"attempt to add with overflow","5393":"attempt to add with overflow","4558":"attempt to add with overflow","5259":"Array index out of bounds","3400":"Array index out of bounds","5582":"Array index out of bounds","3455":"Array index out of bounds","4479":"attempt to add with overflow","4668":"attempt to add with overflow","2998":"Array index out of bounds","5369":"attempt to add with overflow","5747":"attempt to add with overflow","5101":"Array index out of bounds","2785":"attempt to add with overflow","3998":"Array index out of bounds","2840":"Array index out of bounds","3218":"attempt to add with overflow","4431":"Array index out of bounds","3273":"Array index out of bounds","4998":"Array index out of bounds","1091":"attempt to add with overflow","3840":"Array index out of bounds","2682":"Array index out of bounds","2871":"Array index out of bounds","3115":"Array index out of bounds","2792":"attempt to add with overflow","5541":"Array index out of bounds","2847":"Array index out of bounds","3091":"attempt to add with overflow","3603":"attempt to add with overflow","4304":"Array index out of bounds","2634":"Array index out of bounds","2311":"call to assert_max_bit_size","1988":"attempt to add with overflow","4816":"Array index out of bounds","4871":"Array index out of bounds","1531":"call to assert_max_bit_size","2744":"attempt to add with overflow","5249":"attempt to add with overflow","4847":"Array index out of bounds","3500":"Array index out of bounds","3177":"attempt to add with overflow","5036":"attempt to add with overflow","1373":"attempt to add with overflow","4634":"Array index out of bounds","5146":"Array index out of bounds","3476":"attempt to add with overflow","4689":"Array index out of bounds","2696":"attempt to add with overflow","4232":"Array index out of bounds","2562":"Array index out of bounds","5122":"attempt to add with overflow","3129":"attempt to add with overflow","4019":"attempt to add with overflow","5421":"Array index out of bounds","490":"Aztec Passport: Unauthorized Admin Change","3050":"attempt to add with overflow","3562":"attempt to add with overflow","4074":"Array index out of bounds","3806":"Array index out of bounds","4452":"attempt to add with overflow","3672":"Array index out of bounds","4507":"Array index out of bounds","5208":"attempt to add with overflow","1356":"attempt to multiply with overflow","3916":"Array index out of bounds","4105":"Array index out of bounds","2435":"Array index out of bounds","4349":"Array index out of bounds","3514":"attempt to add with overflow","4026":"attempt to add with overflow","5751":"Array index out of bounds","4081":"Array index out of bounds","5617":"Array index out of bounds","2411":"Array index out of bounds","3624":"attempt to add with overflow","3813":"Array index out of bounds","4325":"attempt to add with overflow","2655":"attempt to add with overflow","3868":"Array index out of bounds","4837":"attempt to add with overflow","5160":"attempt to add with overflow","5270":"attempt to add with overflow","3978":"attempt to add with overflow","4734":"Array index out of bounds","4411":"attempt to add with overflow","5758":"Array index out of bounds","181":"attempt to add with overflow","4710":"attempt to add with overflow","2906":"Array index out of bounds","3930":"attempt to add with overflow","2772":"Array index out of bounds","401":"Initializer address is not the contract deployer","4363":"attempt to add with overflow","1992":"attempt to add with overflow","3205":"Array index out of bounds","3772":"Array index out of bounds","4284":"attempt to add with overflow","2614":"attempt to add with overflow","2803":"Array index out of bounds","4796":"attempt to add with overflow","5040":"Array index out of bounds","2858":"attempt to add with overflow","4906":"Array index out of bounds","5308":"Array index out of bounds","5717":"Array index out of bounds","4748":"attempt to add with overflow","5449":"Array index out of bounds","3078":"Array index out of bounds","3590":"Array index out of bounds","3645":"Array index out of bounds","2810":"Array index out of bounds","1975":"attempt to multiply with overflow","4858":"attempt to add with overflow","817":"attempt to add with overflow","1518":"attempt to add with overflow","3889":"attempt to add with overflow","5047":"Array index out of bounds","2085":"attempt to add with overflow","5236":"Array index out of bounds","5590":"Array index out of bounds","147":"attempt to add with overflow","3463":"Array index out of bounds","3006":"Array index out of bounds","3384":"Array index out of bounds","5109":"Array index out of bounds","4140":"Array index out of bounds","2470":"Array index out of bounds","4006":"Array index out of bounds","4439":"Array index out of bounds","3793":"attempt to add with overflow","5006":"Array index out of bounds","3848":"attempt to add with overflow","4037":"Array index out of bounds","831":"Not initialized","508":"Not initialized","185":"Array index out of bounds","2422":"attempt to add with overflow","2879":"Array index out of bounds","1264":"attempt to add with overflow","3257":"Array index out of bounds","3690":"Array index out of bounds","3824":"attempt to add with overflow","4092":"attempt to add with overflow","5281":"Array index out of bounds","5549":"Array index out of bounds","5738":"attempt to add with overflow","4312":"Array index out of bounds","405":"Aztec Passport: Invalid Address","82":"attempt to add with overflow","1807":"attempt to add with overflow","2642":"Array index out of bounds","3666":"attempt to add with overflow","4044":"Array index out of bounds","4824":"Array index out of bounds","192":"Array index out of bounds","4879":"Array index out of bounds","5635":"Array index out of bounds","5769":"attempt to add with overflow","5611":"attempt to add with overflow","3752":"attempt to add with overflow","4697":"Array index out of bounds","3027":"attempt to add with overflow","4240":"Array index out of bounds","2570":"Array index out of bounds","4618":"Array index out of bounds","5697":"attempt to add with overflow","3704":"attempt to add with overflow","2924":"Array index out of bounds","2089":"attempt to add with overflow","5027":"attempt to add with overflow","608":"Not initialized","5405":"Array index out of bounds","2900":"attempt to add with overflow","4113":"Array index out of bounds","5326":"Array index out of bounds","395":"Initialization hash does not match","2443":"Array index out of bounds","4491":"Array index out of bounds","5058":"attempt to add with overflow","5570":"attempt to add with overflow","4924":"Array index out of bounds","5649":"attempt to add with overflow","2986":"attempt to add with overflow","3876":"Array index out of bounds","4900":"attempt to add with overflow","5467":"Array index out of bounds","2072":"attempt to multiply with overflow","457":"attempt to add with overflow"}},{"name":"get_balance_registry","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_balance_registry"],"assert_messages":{"253":"Array index out of bounds","218":"Array index out of bounds","247":"attempt to add with overflow","285":"attempt to add with overflow","14":"Not initialized","162":"call to assert_max_bit_size","194":"Array index out of bounds","226":"Array index out of bounds","345":"Array index out of bounds","374":"attempt to add with overflow","19":"Function get_balance_registry can only be called statically","205":"attempt to add with overflow","170":"call to assert_max_bit_size","234":"Array index out of bounds","333":"attempt to add with overflow","353":"Array index out of bounds","271":"Array index out of bounds","361":"Array index out of bounds"}},{"name":"set_passport_address","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"_passport_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["set_passport_address"],"assert_messages":{"1792":"Array index out of bounds","829":"Array index out of bounds","957":"Array index out of bounds","1018":"Array index out of bounds","1085":"attempt to add with overflow","1457":"Array index out of bounds","1262":"Array index out of bounds","811":"Array index out of bounds","939":"attempt to add with overflow","1189":"Array index out of bounds","994":"Array index out of bounds","1384":"Array index out of bounds","1244":"Array index out of bounds","1433":"attempt to add with overflow","1238":"attempt to add with overflow","1439":"Array index out of bounds","1750":"attempt to add with overflow","781":"Array index out of bounds","1610":"Array index out of bounds","903":"Array index out of bounds","1927":"Array index out of bounds","1153":"Array index out of bounds","518":"attempt to add with overflow","891":"attempt to add with overflow","1336":"Array index out of bounds","1531":"Array index out of bounds","1519":"attempt to add with overflow","1324":"attempt to add with overflow","1647":"Array index out of bounds","1629":"Array index out of bounds","1623":"attempt to add with overflow","1940":"attempt to add with overflow","337":"attempt to add with overflow","14":"Not initialized","843":"attempt to add with overflow","1800":"Array index out of bounds","1026":"Array index out of bounds","1471":"attempt to add with overflow","1276":"attempt to add with overflow","1209":"Array index out of bounds","1404":"Array index out of bounds","1721":"Array index out of bounds","1392":"attempt to add with overflow","1197":"attempt to add with overflow","1581":"attempt to add with overflow","1709":"attempt to add with overflow","1837":"Array index out of bounds","1819":"Array index out of bounds","789":"Array index out of bounds","1813":"attempt to add with overflow","911":"Array index out of bounds","1161":"Array index out of bounds","1539":"Array index out of bounds","1344":"Array index out of bounds","1661":"attempt to add with overflow","1594":"Array index out of bounds","631":"attempt to add with overflow","1911":"Array index out of bounds","753":"Array index out of bounds","619":"attempt to add with overflow","1771":"attempt to add with overflow","1899":"attempt to add with overflow","802":"attempt to add with overflow","1570":"Array index out of bounds","1174":"attempt to add with overflow","522":"attempt to add with overflow","1034":"Array index out of bounds","1412":"Array index out of bounds","1217":"Array index out of bounds","510":"attempt to add with overflow","1729":"Array index out of bounds","1784":"Array index out of bounds","1851":"attempt to add with overflow","1071":"Array index out of bounds","614":"attempt to multiply with overflow","1760":"Array index out of bounds","1053":"Array index out of bounds","919":"Array index out of bounds","1047":"attempt to add with overflow","267":"call to assert_max_bit_size","1352":"Array index out of bounds","773":"Array index out of bounds","1547":"Array index out of bounds","1602":"Array index out of bounds","1919":"Array index out of bounds","761":"attempt to add with overflow","505":"attempt to multiply with overflow","627":"attempt to add with overflow","950":"Array index out of bounds","1005":"attempt to add with overflow","1133":"attempt to add with overflow","1145":"Array index out of bounds","932":"attempt to add with overflow","987":"Array index out of bounds","1560":"attempt to add with overflow","1365":"attempt to add with overflow","1420":"Array index out of bounds","1737":"Array index out of bounds","1225":"Array index out of bounds","969":"attempt to add with overflow"}},{"name":"is_admin","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"JAAEAQIlAAQIRAAAJAAEAAMkAAQABB8AAAAABAAAAAMAAAhDIgAAAAgrAAADCEM5AAAACEMAAAABHgAAAAQeAAAABTAAAAAABAAAAAUAAAAGJAACAQUKAAIGBQQhAAAPAAQ6AQAAHgALAAUkAAcBBgoABwUGBCEAABQABDoBAAAqAAAFJAAEAgQAAAQABAAkAQQBBQAABAUCBCoABAckAAcACCoCCAcqAQUEAAAEBAIEKgIEBSoAAAQAAAQAAgAqAgUEJAAEAQgkAAQABSoABQMgACYKAAQDBQchAAAwAAcgACkqAQQDAAAEAwIGAAAEBgUHKgEHBB4AAgAFCgAHBAUDIyoBBAccAAcDCQAABwYJCiwAAAAACgAAAAkkAAQBCwwABAMLDCEAADgADDoBAAArAAAHCAMlAAQAAggEIgAAAEYrAAgFAAoAAAQKAgwAAAQMAwsqAgkLAAAEAwgHDgAEAwcJIQAAQwAJOgEAACoCCgQqAAcDIAAmKwEIAwgGCwAECAYAAggHIQAASggHIABMKwAIAwgFIABaKwAAAAgFAQAEAAAIBAAAJQAEAAAICQ0ABAgJCAQIChcACAoICiEAAFgICgEABAgDCAkICysBCAsICAEABAgFCAkICysCCAgICwEABAgJAAIICSAATyUBBAABCAUgAFojKwAYyhjK","debug_symbols":"1ZrdbuIwEIXfJddc2GN7PMOrrFZVaKGKFIUK6EorxLs3aWOThtRpS6k8N4jAsefz7xlbORYP69Xz413VbLb7YvnnWNTb+/JQbZv26XhaFKtdVdfV493w50J1H/Qq3z+VTfe0P5S7Q7HUHuyiWDcP3Vdj2wo2Vb0ull6dFhdiNr7XsvNRqp2Z0FrQ3IstAEU1w4QYSZtejAQ8FP9dFHw1uFY6itVAfHN0ra7vdB/qZ57rdA02iDUwp8lJu0BBelB1T65/kLzt9PfoXQC4dQBz6wD21gHc1QGc4xDBoZqZEZ7A9WJPlsYzAr9I05Xx3yhD3yjDXy8D02sTAOISsmpuX/EUxO0AnsfP49RYMIZ9xTGr9Fg4b3QQewOjsQAtmB0EsxvB7FYwuxPMjoLZvWB2EszOctmNYF81gn3VCPZVI9hXTeb7jKPI7sbnU5v5fPc2spMas//+fI8HZlTKpdm1YjxXfRYbha/wRjK8lQz/QSppYyHAmUO1NRRaas3cJEbGyM7+YgF+Ijl0MzQQyC3qi9ZK3pzyToJIR1Mg0CN2l3kSFJfIFHvmpkDmzA5pMbdLNdyeWn/R0MwzppT7ucwzpiS7Fcye+U1Ekj3zm4gke+Y3EUn2zE04yZ75TUSKHTM34SS74JMZCvZVFOyrKNhXUbCvomBfRbG+emqf/pW7qlzV6/7ll81zcz94F+bw/+ntn1b8Ag==","brillig_names":["is_admin"],"assert_messages":{"66":"attempt to add with overflow","55":"Array index out of bounds","14":"Not initialized","19":"Function is_admin can only be called statically"}},{"name":"set_admin","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"new_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAAQIRAAAJAAEAQQkAAQABR8AAAAABQAAAAQAAAhDKwAIQwADIgAAAAg5AAAACEQAAAAAHgAAAAUeAAAABjAAAAAABQAAAAYAAAAHJAACAQUKAAIHBQYhAAAPAAY6AQAAKgAABSQABAIHAAAEAAcAJAEEAQUAAAQFAgcqAAcGJAAHAAgqAggGKgEFBwAABAcCByoCBwUqAAAHAAAEAAIAKgIFByQABAAFJAAHAQgkAAQBBioABQQgACIKAAQEBQkhAABKAAkgACUqAQcJAAAECQIKAAAECgULKgELBx4AAgAJCgAHBwkKIQAALQAKOgEAACoABQQgAC8KAAQEBQchAAAzAAcgADIjHAAHBAcAAAcIBwkqAAAHJAAEAgoAAAQACgAkAQQBBwAABAcCCioACgsqAgMLJAAEAQsMAAQECwwhAABAAAw6AQAAAAAEBwIMAAAEDAQLKgELCi0AAAAACgAAAAkAAAQEBgkOAAQECQohAABIAAo6AQAAKgAJBCAALyoBBwkcAAcECgAABwgKCywAAAAACwAAAAokAAQBDAwABAQMDSEAAFIADToBAAArAAAJCAMlAAQAAggEIgAAAGArAAgFAAsAAAQLAg0AAAQNBAwqAgoMAAAEBAYJDgAEBAkKIQAAXQAKOgEAACoCCwcqAAkEIAAiKwEIAwgGCwAECAYAAggHIQAAZAgHIABmKwAIAwgFIAB0KwAAAAgFAQAEAAAIBAAAJQAEAAAICQ0ABAgJCAQIChcACAoICiEAAHIICgEABAgDCAkICysBCAsICAEABAgFCAkICysCCAgICwEABAgJAAIICSAAaSUBBAABCAUgAHQjKwAYyhjK","debug_symbols":"1ZvdbuIwEIXfJddceMZ/M7zKalVBC1UkBBXQlVaId1+ni51smjqqulQzN4jAyfhLPMmJx86ledqsX58f2v32cGqWPy7N7vC4OreHfdq6XBfN+tjudu3zw/DnxnQf9CY/vaz23dbpvDqemyVEdItms3/qvlqXAmzb3aZZRnNdvBOzjTct+1ik4O2E1iHwTewQqagZJ8SBwN7EgZCH4p+Lhr8MDgaK2AzEd0cH8/WTHnN85rmTDuiyGJC5Tk7gMwXBIPSNHP4jeTrp/6J3DeC9G7D3bsDduwE/1QCDyQkxSM4P8j5Sjp8a6OPHMKH2HHLee2ZTzx4fLWRxtDjOnqCWPKolJ7XkrJUcjVpyUEuOasmtWnKnllyth6JaD0W1HopqPdSKvkI9FXI/HiNZ0dkSXSEnMyb/7mwpA7ZgjK+Tg+HQh+7F1oQ3dFaL7oxe9OmHLutKWQXr6M4S5tKEnUvewKGQcxxfdm7uMcr7IUu3h/30Hu7Te0zeDFL9BvpxspnpXgxYiiBEM90bLOSiVrB2pmQSUuwsBhyXTDzIZo9Q2AnG7Cib3YcKu5XNTqVACDy2be8Us3vF7EExu/B7ZJWdFLOzXvZgFLML99Uqu3BfrbIr9tWg2FeDYl8Nin01CPdVhz27rYvTmLWfqicaH6hwE/7wQDt24SZcY4/CTbjKLtyEq+xOa200Sp69oNL3nnA8KI+iZy9KlW6KXHQ9uhhYIscZE0jVwszs4rvDFD3VUSu7R9HLBWrkJHq5QJVc9HKBKrno5QJVctHLBarkog23Si56uUCVXLThVsnVTgCTWg8ltR7Kaj2U1Xooq/VQVuqh17T1a3VsV+vd5vZmx/Z1/zh40eP8++XvP0n8Bw==","brillig_names":["set_admin"],"assert_messages":{"81":"Array index out of bounds","63":"Array index out of bounds","92":"attempt to add with overflow","44":"Aztec Passport: Unauthorized Admin Change","71":"attempt to add with overflow","14":"Not initialized"}},{"name":"get_admin_public","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAAQIRAAAJAAEAAMkAAQABB8AAAAABAAAAAMAAAhDIgAAAAgrAAADCEM5AAAACEMAAAABHgAAAAQeAAAABTAAAAAABAAAAAUAAAAGJAACAQUKAAIGBQQhAAAPAAQ6AQAAHgALAAYkAAcBBQoABwYFBCEAABQABDoBAAAqAAAGJAAEAgQAAAQABAAkAQQBBgAABAYCBCoABAckAAcACCoCCAcqAQYEAAAEBAIEKgIEBioAAAQAAAQAAgAqAgYEJAAEAQgkAAQABioABgMgACYKAAQDBgchAAAvAAcgACkqAQQFAAAEBQIDAAAEAwYHKgEHBCoABAMjKgEEBxwABwMJAAAHBQkKLAAAAAAKAAAACSQABAELDAAEAwsMIQAANwAMOgEAACsAAAcIAyUABAACCAQiAAAARSsACAUACgAABAoCDAAABAwDCyoCCQsAAAQDCAkOAAQDCQchAABCAAc6AQAAKgIKBCoACQMgACYrAQgDCAYLAAQIBgACCAchAABJCAcgAEsrAAgDCAUgAFkrAAAACAUBAAQAAAgEAAAlAAQAAAgJDQAECAkIBAgKFwAICggKIQAAVwgKAQAECAMICQgLKwEICwgIAQAECAUICQgLKwIICAgLAQAECAkAAggJIABOJQEEAAEIBSAAWSMrABjKGMo=","debug_symbols":"1ZrdbsIwDIXfJddcxHF+bF5lmqaywVSpKhOwSRPi3ddubehKFQSMKb5BDT2Jvyapj1t1r16Wi/fXp7Jerbdq/rBX1fq52JXrumntDzO12JRVVb4+Df9Wuv2hb/n2rajb1nZXbHZqDsHYmVrWL+0h2maAVVkt1Tzow+xEzBg6LbsQpeBwQmsNcCe2xlBUs5kQewLsxJ4MD8WPM8U3g4OGKNYD8d3RQd8+6aEfn/ncpIOxvRgMc5qcwPUUBIOhO3L4Q/Jm0n+jtwHMvQPgvQPYewdwNwdwjvsIzuszOyKQcZ04kKXxjvAX0rR9whV96Io+fHkfM31vgoG+DyCfyyuBoljjcf2Cn1oL9n1eccw6vRYuYM/RHJrRWhgQzG4Es6NgdiuY3Qlm94LZg2B2EszOctlRsK+iYF9Fwb6Kgn0VM88zjiK7Gz+f2sz3e7CRnfSY/f/3e3xg9lq7NDto9sehj2LU/hseJcNbyfCZlzTJ2zXvVEMQ0yQZGLNnXtLETTPB7jIvaQiP7CYtZos9B9twcqGC/cBlXv8k2TOvf5LsVjB75u8VkuyZv1dIsmduwkn2zOv9JHvmJpxi95mbcJJdsK96wb7qBfuqF+yrXrCverG+emhaH8WmLBbVsvscZPVePw++Dtl9vv2cacRf","brillig_names":["get_admin_public"],"assert_messages":{"14":"Not initialized","65":"attempt to add with overflow","54":"Array index out of bounds","19":"Function get_admin_public can only be called statically"}},{"name":"verify","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"content","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_public_storage_hints","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","get_public_storage_hints","build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","get_l1_to_l2_membership_witness","pack_arguments_oracle_wrapper","call_private_function_internal","unpack_returns","pack_arguments_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"get_passport_address","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7Z3dbts4EIXfxde5EMnhX19lsSjSNi0MBEnRpAssir77So5FK5ZEVcl4ZcyZmyJpaEnns019Q0nkr92Xu08/v33cP3x9fNp9+OvX7v7x8+3z/vGh/e3X75vdpx/7+/v9t4/D/9413T/p0Pzp++1D99vT8+2P590HEy3d7O4evnQ/Omo38HV/f7f7EJvfN6PG2cVj2+xjaWq8m2hL1uRjY7I2ldbZTjQOybhj45BsHjb++2aX333gpjGlcTNofPFDN837ocd++zkvQTeW+sbG5lw/8mR8fxTJDDZ9PHLDeOQt9NeH3u3AXnoH7tI7oEvvwL97B97nfg8+NAufiJisPzaOidL5JyKsPJruNfENr0lveE1e/xo7/d10vu/kDA2ATdKlEG3fU4ThtzPS1HthqO9XvAlu4b2gxvTvRdsLnb0X1rAee2zCq2Pv9mAvvgd38T3Q+/cQTSh7cGnpHba56d9hZ2mhtTOp37azoVlo3Z7DBp2FNafPjzNT7YPt0QQ7aPsCxiuYaTBBwUyDiQpmGkxSMNNgsoKZBOMaBTMNxiiYaTBWwUyDcQpmGgwpmGkwar4zYNR8Z8Co+c6AUfOdAQNtvr7feBhcI3gBQ9DmWwMDbb41MNDmWwMDbb41MKRgpsHgmG+XFkdnu7Q4jtqlxRHPLi2OTbZpPY4idmlxvK9LiyNzXVocQ+vSElRaKJfyUC7loVzKQ7mUh3KpAOVSAcqlApRLBSiXCgSVFsqlApRLBSiXClAuFaBcKkK5VIRyqQjlUlGWS52e1Wt/dvZV2on2yaW+efLm1LoxBzakbGbZyPI0XjayrI6XjSwH5GUjyxh52cjyy5VsKIcSM5/fypFkySgrGlnmyopGluayooF24joaUjRzaKCNOJyaBwrnaKCFuI4G2ofraKB1uI4G2oaraDK0DdfRQNtwCKW+DCmdo4G24ToaaBuuoyFFM4cG24araLBtuIoG24araLBtuIoG24ZraEyDrcN1NurD82xUiGfZGGEn8OEdIsm/YnOIK6t7dW4wyS7FpY9CtX2Hx8rqYVfiib58sWI8HxI3VlYPy8tGVg/Ly0ZW9biSTSrTGJuUzZDNuHFy/RzdyeURRlk1wwUxthssZ/zGmxFI6FPgKpDG9B/I1pPoHKSw2U43BAl9ZuUECX0a5gQp6zrBhiBJQfKAVItkAilrwGNDkLKub7CBPLDRYmWejdYfs2yETSO7jo1tmr5ute0g94gNcpWwxAZZ/JfY/P8uH/q12bxNeal1DmXptJxPbCaXTvPR9UuntT+eL51mNpghdrOoHidqwIkacaImmKgbzAV6wag+lah+tCiuF9UDx7LpmJpR1GvvgcsawKFpfD1qCqE/6hTiqbEJ+SXrtXfBnFmvvQ/mzHrtnfCarNH0PVNbZIZx1oyTdYP5IbfLeu1n11VZU1OyDm5WK1ktUNZrr1s5sxJQVknedLLhNmt+lXVioCbG/oKCjWkwrPMyLYoJkiyLl4wkJ+Mlw2xw3i9kNdmWTedgR1/vKGoIo1rsRklDGMmUIYw0GETuo167PK96V8vUH1NR07W786qoyZ2i2nrjTOW+ydwmGHERNYpVHdpJ167ZjFFFXR2qRyWcqKKuDtWjiro6VI8qSq3qUUVdHapHFaVW1ahZlFrVo+LYUsaxpYxjSxvMh7NZVBxbyji2JGwmkY2eO7XCJh256HOnTVO2bcYg9ZkqJpCkIHlA6jNVfwyy9ki5bfSZKiaQ+kwVE0h9AIsJpFokD0ijHskEUmeLYAKps0UwgdTK5o9B+vJIeRPSCCQpSB6QWtkwgdTKhgmkVjZMILWyYQKplQ0PSOxJY9/skRMgtbLhEXLs6Wg5QWplwwSSFCQPSK1smEBqZcMEUisbJpBa2TCB1MqGB6TO8M0FUisbJpBa2TCBJAXJA1KFnAmkCjkTSBVyHpDSZiM2p5tB3fBuUHOMK0xSluIKU4mluMKGMpfiElZcYRayFFeYKyzFFbaUdpl/pY3b5MUz+ukknYYn6ZcZkCwJW0x7HZx2sKtvbimODEbYatqcbLyw1bRZ2QhbTZuVjbDVtFeyCaawSTRiI0tDVrKhU3PK48+NsJXGWdlAC84CG2i/Cab0xYHCiA2039TZBGi/WWAD7TcLbKD9ZoGNrEE0XjakbGbZQHvxAhtoL15gA+3FC2zUi+fZqBfPsonqxfNs1Ivn2WB7cSgXYUIaPbkVsb24zoaUzSwbbC+us8H24jobbC+usknQ53Aqa6Ebsq/G0seNq/OeJuhuew3GhbsoE/Y1QUaQ2BcQ14A0pkzY0Kr8CCT21UZGkNBDMJwgocdrGEFm6MEdTpBqkUwgoYeNOEFCjzFxgiQFyQNSKxsmkFrZMIHUymYS5IGNFivzbLT+mGPjhC2AxMtGq4R5Nir+82ywXZ7KjAbkw4gNKZtZNtjGXWeDLdF1NtheXGeD7cV1NtheXGUjbEEnXjbYXlxng+3FdTbqxfNsSNnMslEvnmejz90fY46eLXfCViXiZYPtxVU2wpa8qbE5xMXRuUNcHEM7xMWRrkNcvdg6OS49bly7P9wJW/biorc1N6fpDc0IpLBFBjYEqRfjmEDqlbs/Bll7YsE5vWWPCSQpSB6QesseE0i1SCaQ6pFMIPX+PiaQejMgD0hh64dcFGRthW0nbGWSDUFqZcMEUisbJpCkIHlAamXDBFIrGyaQWtm8xSMnQGplwyTkWtnwgMReO4cTpFY2TCC1smECqZUNE0hSkDwgtbJhAqmVDRNIrWyYQGplwwRSKxsekNgrQ3GCVCFnAqlCzgSSFOT7Qf5uf/vn9sf+9tP93VP7mu6PPx8+P+8fH46/Pv/7/eUvbeP/AA==","brillig_names":["get_passport_address"],"assert_messages":{"224":"Array index out of bounds","323":"attempt to add with overflow","343":"Array index out of bounds","14":"Not initialized","261":"Array index out of bounds","351":"Array index out of bounds","19":"Function get_passport_address can only be called statically","208":"Array index out of bounds","237":"attempt to add with overflow","243":"Array index out of bounds","275":"attempt to add with overflow","184":"Array index out of bounds","216":"Array index out of bounds","335":"Array index out of bounds","364":"attempt to add with overflow","195":"attempt to add with overflow"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"12265343917440897559":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":6,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"error_types":{},"parameters":[{"name":"_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"],"assert_messages":{"128":"attempt to add with overflow","448":"Array index out of bounds","698":"Array index out of bounds","110":"Array index out of bounds","366":"Array index out of bounds","616":"Array index out of bounds","430":"Array index out of bounds","415":"attempt to add with overflow","598":"Array index out of bounds","592":"attempt to add with overflow","394":"Array index out of bounds","522":"Array index out of bounds","510":"attempt to add with overflow","571":"Array index out of bounds","117":"Array index out of bounds","690":"Array index out of bounds","678":"attempt to add with overflow","538":"Array index out of bounds","340":"Initializer address is not the contract deployer","334":"Initialization hash does not match","462":"attempt to add with overflow","72":"attempt to add with overflow","386":"Array index out of bounds","706":"Array index out of bounds","374":"attempt to add with overflow","563":"Array index out of bounds","630":"attempt to add with overflow","106":"attempt to add with overflow","551":"attempt to add with overflow","344":"Aztec Passport: Invalid Address","402":"Array index out of bounds","530":"Array index out of bounds","719":"attempt to add with overflow","579":"Array index out of bounds"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"},{"fields":[{"name":"address","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"},{"fields":[{"name":"address","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"AztecPassport"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"total_services","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"services","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"service_indexes","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"scores","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"BalanceModule"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"balance_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"passport_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"_registry","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"BalanceModule::set_balance_registry_parameters"}}],"kind":"struct","path":"BalanceModule::set_balance_registry_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BalanceModule::get_passport_address_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BalanceModule::get_passport_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BalanceModule::get_balance_registry_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"BalanceModule::get_balance_registry_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BalanceModule::constructor_parameters"}}],"kind":"struct","path":"BalanceModule::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}}],"kind":"struct","path":"BalanceModule::verify_parameters"}}],"kind":"struct","path":"BalanceModule::verify_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BalanceModule::set_admin_parameters"}}],"kind":"struct","path":"BalanceModule::set_admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"_passport_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BalanceModule::set_passport_address_parameters"}}],"kind":"struct","path":"BalanceModule::set_passport_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BalanceModule::get_admin_public_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"BalanceModule::get_admin_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BalanceModule::is_admin_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"BalanceModule::is_admin_abi"}]}},"file_map":{"114":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"115":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"118":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\nunconstrained pub fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"121":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_arguments_oracle_wrapper(args)\n    };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_arguments_array_oracle_wrapper(args)\n    };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"122":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"125":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT, utils::arr_copy_slice};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    let returned_message = get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    (leaf_index, sibling_path)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MSG_TREE_HEIGHT + 1] {}\n"},"126":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"127":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"148":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        value\n    }\n}\n"},"153":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"154":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"159":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"},"162":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse dep::protocol_types::{address::{AztecAddress, EthAddress}, merkle_tree::root::root_from_sibling_path};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    let (leaf_index, sibling_path) = unsafe {\n        get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret)\n    };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n"},"169":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> where T: ToField {\n    fn serialize(self) -> [Field; 3] {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> where T: FromField {\n    fn deserialize(input: [Field; 3]) -> Self {\n        Self {\n            pre: FromField::from_field(input[0]),\n            post: FromField::from_field(input[1]),\n            block_of_change: FromField::from_field(input[2])\n        }\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"170":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32)) + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33)\n            + (self.post.is_some() as u64 * (1 << 32))\n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some {\n                Option::some(pre_inner)\n            } else {\n                Option::none()\n            },\n            post: if post_is_some {\n                Option::some(post_inner)\n            } else {\n                Option::none()\n            },\n            block_of_change\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"174":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{poseidon2_hash, poseidon2_hash_with_separator}, address::AztecAddress,\n    traits::{FromField, ToField}, utils::arrays::array_concat\n};\n\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::mem::zeroed;\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// Separators separating storage slot of different values within the same state variable\nglobal VALUE_CHANGE_SEPARATOR: u32 = 0;\nglobal DELAY_CHANGE_SEPARATOR: u32 = 1;\nglobal HASH_SEPARATOR: u32 = 2;\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, let INITIAL_DELAY: u32, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> where T: ToField + FromField + Eq {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], VALUE_CHANGE_SEPARATOR)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], DELAY_CHANGE_SEPARATOR)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], HASH_SEPARATOR)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> where T: ToField + FromField + Eq {\n\n    pub fn schedule_value_change(self, new_value: T) {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> where T: ToField + FromField + Eq {\n    pub fn get_current_value_in_private(self) -> T {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage(self) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) {\n        let header = self.context.get_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = unsafe {\n            get_public_storage_hints(address, self.storage_slot, historical_block_number)\n        };\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        if hash != 0 {\n            assert_eq(\n                hash, SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint), \"Hint values do not match hash\"\n            );\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            assert_eq(\n                value_change_hint, ScheduledValueChange::deserialize(zeroed()), \"Non-zero value change for zero hash\"\n            );\n            assert_eq(\n                delay_change_hint, ScheduledDelayChange::deserialize(zeroed()), \"Non-zero delay change for zero hash\"\n            );\n        };\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field {\n        let concatenated: [Field; 4] = array_concat(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UnconstrainedContext> where T: ToField + FromField + Eq {\n    unconstrained pub fn get_current_value_in_unconstrained(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    unconstrained fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, let INITIAL_DELAY: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) where T: ToField + FromField + Eq {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"176":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"221":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"},"230":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE: u32 = 4;\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // We choose the last SELECTOR_SIZE bytes of the hash to avoid getting the first byte that is not full\n        let hash_bytes = hash.to_be_bytes::<SELECTOR_SIZE>();\n\n        FunctionSelector::from_field(field_from_bytes(hash_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector = FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"241":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\npub struct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber { _opt: Option { _is_some: serialized[0] as bool, _value: serialized[1] as u32 } }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"263":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"276":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"277":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr","source":"mod assert_array_appended;\nmod assert_array_prepended;\nmod assert_combined_array;\nmod assert_combined_sorted_transformed_value_array;\nmod assert_combined_transformed_array;\nmod assert_deduped_array;\nmod assert_exposed_sorted_transformed_value_array;\nmod assert_sorted_array;\nmod assert_sorted_transformed_value_array;\nmod assert_split_sorted_transformed_value_arrays;\nmod assert_split_transformed_value_arrays;\nmod get_sorted_result;\nmod get_sorted_tuple;\nmod sort_by;\nmod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{assert_array_appended, assert_array_appended_reversed, assert_array_appended_scoped};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_sorted_transformed_value_array::{\n    assert_combined_sorted_transformed_value_array_asc,\n    get_combined_order_hints::{CombinedOrderHint, get_combined_order_hints_asc}\n};\npub use assert_combined_transformed_array::{assert_combined_transformed_array, combine_and_transform_arrays};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint}\n};\npub use assert_deduped_array::{assert_deduped_array, dedupe_array};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc, assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints}\n};\npub use assert_sorted_transformed_value_array::{assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N> where T: Empty + Eq {\n    let mut len = 0;\n    for elem in array {\n        if !is_empty(elem) {\n            len += 1;\n        }\n    }\n\n    BoundedVec { storage: array, len }\n}\n\nunconstrained pub fn find_index_hint<T, let N: u32, Env>(array: [T; N], find: fn[Env](T) -> bool) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32 where T: Empty + Eq {\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32 where T: Empty + Eq {\n    let length = unsafe {\n        find_index_hint(array, |elem: T| is_empty(elem))\n    };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N] where T: Empty + Eq {\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N]\n) where T: Eq + Empty {\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe {\n        find_index_hint(values, |v: Field| min.lt(v))\n    };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe {\n        find_index_hint(values, |v: Field| min.lt(v))\n    };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    pedersen_hash_with_separator_noir(input, separator)\n}\n\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator_noir(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n"},"296":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"298":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"301":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl <let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"302":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl <T, let N: u32, let M: u32> Serialize<N * M> for [T; N] where T: Serialize<M> {\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl <T, let N: u32, let M: u32> Deserialize<N * M> for [T; N] where T: Deserialize<M> {\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n"},"305":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"306":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"310":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{constants::ETH_ADDRESS_LENGTH, traits::{Empty, ToField, Serialize, Deserialize}, utils};\nuse crate::traits::FromField;\n\npub struct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for EthAddress {\n    fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"314":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"318":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\npub struct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"329":{"path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/l2-contracts/crates/passport/src/main.nr","source":"pub mod service;\n\nuse dep::aztec::macros::aztec;\n\npub global SCALE: u64 = 1000000;\n\n#[aztec]\npub contract AztecPassport {\n    use aztec::{\n        prelude::{AztecAddress, PublicMutable, Map, SharedMutable},\n        macros::{storage::storage, functions::{initializer, public, private, view}},\n        keys::getters::get_public_keys\n    };\n\n    use dep::value_note::{balance_utils::get_balance};\n\n    use dep::easy_private_state::EasyPrivateUint;\n    use crate::service::Service;\n\n    pub global SCALE: u64 = 1000000;\n\n    #[storage]\n    struct Storage<Context> {\n        // Admin of Contract\n        admin: PublicMutable<AztecAddress, Context>,\n        // Track Count of Total Services\n        total_services: SharedMutable<u64, 1, Context>,\n        // Service ID => Service\n        services: Map<u64, PublicMutable<Service, Context>, Context>,\n        // Service Address -> ID\n        service_indexes: Map<AztecAddress, SharedMutable<u64, 1, Context>, Context>,\n        //  Address => Service ID => verified(boolean)\n        scores: Map<AztecAddress, Map<u64, EasyPrivateUint<Context>, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(_admin: AztecAddress) {\n        assert(!_admin.is_zero(), \"Aztec Passport: Invalid Address\");\n        storage.admin.write(_admin);\n    }\n\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Unauthorized Admin Change\");\n        storage.admin.write(new_admin);\n    }\n\n    #[public]\n    #[view]\n    fn get_admin_public() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    #[public]\n    fn add_service(address: AztecAddress, weight: u64, base_score: u64, max_score: u64) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Only Admin\");\n        let service_id = storage.total_services.get_current_value_in_public();\n        storage.services.at(service_id).write(Service { address, weight, base_score, max_score });\n        storage.service_indexes.at(address).schedule_value_change(service_id);\n        storage.total_services.schedule_value_change(service_id + 1);\n    }\n\n    #[public]\n    #[view]\n    fn get_service(service_id: u64) -> Service {\n        storage.services.at(service_id).read()\n    }\n\n    #[public]\n    #[view]\n    fn get_total_services() -> u64 {\n        storage.total_services.get_current_value_in_public()\n    }\n\n    #[private]\n    #[view]\n    fn get_total_services_private() -> u64 {\n        storage.total_services.get_current_value_in_private()\n    }\n\n    #[public]\n    #[view]\n    fn get_service_index(address: AztecAddress) -> u64 {\n        storage.service_indexes.at(address).get_current_value_in_public()\n    }\n\n    #[private]\n    #[view]\n    fn get_service_index_private(address: AztecAddress) -> u64 {\n        storage.service_indexes.at(address).get_current_value_in_private()\n    }\n\n    unconstrained fn is_verified(address: AztecAddress, service_id: u64) -> bool {\n        let res = storage.scores.at(address).at(service_id).set;\n        let balance = get_balance(res);\n        balance as u32 >= 1\n    }\n\n    #[private]\n    fn verify_service(address: AztecAddress, service_id: u64, service_address: AztecAddress) {\n        assert(service_address.eq(context.msg_sender()), \"Aztec Passport: Only Service\");\n        let res = storage.service_indexes.at(service_address).get_current_value_in_private();\n        assert(res == service_id, \"Aztec Passport: Invalid Service\");\n        storage.scores.at(address).at(service_id).add(1, address, address);\n    }\n\n    unconstrained fn get_total_score(address: AztecAddress) -> u64 {\n        let mut total_weight: u64 = 0;\n        let mut total_base_contribution: u64 = 0;\n        let mut total_max_contribution: u64 = 0;\n        let mut verified_count: u64 = 0;\n\n        let total_services = storage.total_services.get_current_value_in_unconstrained();\n\n        for i in 0..total_services {\n            let service = storage.services.at(i).read();\n            total_weight += service.weight;\n            let res = storage.scores.at(address).at(i).set;\n            let balance = get_balance(res);\n            let verified = balance as u32 >= 1;\n            if (verified) {\n                total_base_contribution += (service.base_score * service.weight) / SCALE;\n                total_max_contribution += (service.max_score * service.weight) / SCALE;\n                verified_count += 1;\n            }\n        }\n\n        if (verified_count == 0) {\n            0\n        }\n\n        let diminishing_factor = verified_count * verified_count / (total_services * total_services);\n        let adjusted_max_score = total_max_contribution * diminishing_factor;\n        let bonus_multiplier = (verified_count * SCALE) / total_services;\n        let final_score = (total_base_contribution + adjusted_max_score) * bonus_multiplier / SCALE;\n\n        final_score\n    }\n}\n"},"331":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/address-note/src/address_note.nr","source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"},"338":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\nglobal ZERO = 0;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"6":{"path":"std/cmp.nr","source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(s, quote { Eq }, signature, for_each_field, quote { & }, body)\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"68":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"70":{"path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/l2-contracts/crates/modules/balance_module/src/main.nr","source":"use dep::aztec::macros::aztec;\n\n#[aztec]\ncontract BalanceModule {\n    use aztec::{\n        prelude::{AztecAddress, PublicMutable, SharedMutable}, protocol_types::{address::EthAddress},\n        macros::{storage::storage, functions::{initializer, public, private, view}}\n    };\n\n    use dep::passport::AztecPassport;\n\n    #[storage]\n    struct Storage<Context> {\n        // Admin of Contract\n        admin: PublicMutable<AztecAddress, Context>,\n        // Balance Registry\n        balance_registry: SharedMutable<EthAddress, 1, Context>,\n        // Passport Contract Address\n        passport_address: SharedMutable<AztecAddress, 1, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(_admin: AztecAddress) {\n        assert(!_admin.is_zero(), \"Aztec Passport: Invalid Address\");\n        storage.admin.write(_admin);\n    }\n\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Unauthorized Admin Change\");\n        storage.admin.write(new_admin);\n    }\n\n    #[public]\n    #[view]\n    fn get_admin_public() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    #[public]\n    #[view]\n    fn is_admin() -> bool {\n        storage.admin.read().eq(context.msg_sender())\n    }\n\n    #[public]\n    #[view]\n    fn get_passport_address() -> AztecAddress {\n        storage.passport_address.get_current_value_in_public()\n    }\n\n    #[public]\n    fn set_passport_address(_passport_address: AztecAddress) {\n        let _ = storage.passport_address.schedule_value_change(_passport_address);\n    }\n\n    #[public]\n    fn set_balance_registry(_registry: EthAddress) {\n        let _ = storage.balance_registry.schedule_value_change(_registry);\n    }\n\n    #[public]\n    #[view]\n    fn get_balance_registry() -> EthAddress {\n        storage.balance_registry.get_current_value_in_public()\n    }\n\n    #[private]\n    fn verify(address: AztecAddress, content: Field, secret: Field) {\n        let passport_address = storage.passport_address.get_current_value_in_private();\n        let sender = storage.balance_registry.get_current_value_in_private();\n\n        context.consume_l1_to_l2_message(content, secret, sender);\n\n        assert(content as u32 == 1, \"Aztec Passport: Invalid Content\");\n\n        let index = AztecPassport::at(passport_address).get_service_index_private(context.this_address()).view(&mut context);\n        let _ = AztecPassport::at(passport_address).verify_service(address, index, context.this_address()).call(&mut context);\n    }\n}\n"},"77":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\nunconstrained pub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"86":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe {\n            unpack_returns(self.packed_returns)\n        };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"90":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](()) -> T {\n        self.original\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](()) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](()) -> () {\n        self.original\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](()) -> T {\n        self.original\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](()) -> () {\n        self.original\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"92":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn () -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        panic(f\"'delegate_call_public_function' not implemented!\")\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained pub fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"93":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"}}}