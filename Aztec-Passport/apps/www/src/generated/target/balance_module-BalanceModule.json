{"transpiled":true,"noir_version":"0.35.0+b848cc128d2dc2b461581f21a35509a1af9065a7-aarch64","name":"BalanceModule","functions":[{"name":"get_passport_address","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"JAAEAQIlAAQIRAAAJAAEAAMkAAQABB8AAAAABAAAAAMAAAhDIgAAAAgrAAADCEM5AAAACEMAAAABHgAAAAQeAAAABTAAAAAABAAAAAUAAAAGJAACAQUKAAIGBQQhAAAPAAQ6AQAAHgALAAYkAAcBBQoABwYFBCEAABQABDoBAAAeAAcABRwABAUEHAAHBAYcAAQGBSoAAAYkAAQEBAAABAAEACQBBAEGAAAEBgIEKgAEByQABwAIKgIIBwAABAcCByoCCAcAAAQHAgcqAggHKgEGBAAABAQCBCoCBAYqAQYEAAAEBAIEKgIEBioBBgQAAAQEAgQqAgQGKgEGBAAABAQCBCoCBAYqAAAEAAAEAAIAKgAAByQABAUJAAAEAAkAJAEEAQcAAAQHAgkqAAkKKgIICgAABAoCCioCCAoAAAQKAgoqAggKAAAECgIKKAAHAAAAAAAAAAIAAAAAAAAAAAALKgILCioBBwkAAAQJAgkqAgkHKgAACQAABAACACoAAAoAAAQAAgAqAAAMAAAEAAIAKgEGDQAABA0CDSoCDQYqAQcNAAAEDQINKgINByoBBg0AAAQNAg0qAg0GKgEHDQAABA0CDSoCDQcqAQYNAAAEDQINKgINBioBBw0AAAQNAg0qAg0HKgIGBCoCBwkkAAQBDSoCDQokAAEADioCDgwqAQYPAgAEDwIPKgIPBioBBw8CAAQPAg8qAg8HJAAEBAskAAcDByQABAMPKgAAECQABAIRAAAEABEAJAEEARAAAAQQAhEqABESKgIHEiQABAARKgARAyAAdAoABAMREiEAAPAAEiAAdyoBDAcKAAEHDgMhAAB7AAM6AQAAKgARECAAfQwABBAPDiEAAMcADiAAgCoBCQ4qAAAKJAAEBQcAAAQABwAkAQQBCgAABA4CByQABAQEAAAECgIDPgMAAAAHAAAAAyoCCgkkAAEBCSoCCQwAAAQKAgwAAAQMEQsqAQsJKgEGCgAABAoCCioCCgYqAAAKAAAEAAIAKgIGCioAERAgAJcMAAQQDw4hAACxAA4gAJoqAQoPAAAEDwIOAAAEDhEMKgEMCgAABA8CDgAABA4NDCoBDBEkAAQCDQAABA8CDAAABAwNCyoBCw4cAAQODxwABw8NHAAEDQ4MAAQFDg0hAACtAA0gAKsqABEQIACvKgAKECAAryoAEAMjKgEKDhwABxAMAAAHCQwLLAAAAAALAAAADCQABAMIDAAEEAgHIQAAuQAHOgEAACsAAA4IAyUABAAECAQiAAABbysACAUACwAABAsCBwAABAcQCCoCDAgAAAQQDQ4OAAQQDgwhAADEAAw6AQAAKgILCioADhAgAJcqAQoODAAEEA4HIQAAywAHIADqKgEJDioBCQckAAQEEgwABBASEyEAANEAEzoBAAAAAAQHAhMAAAQTEBIqARIDKgEEByQABAMSDAAEEBIUIQAA2QAUOgEAAAAABAcCFAAABBQQEioBEhMAAAcDEwckAAQEEwwABBATFCEAAOEAFDoBAAArAAAOCAMlAAQABQgEIgAAAW8rAAgFAAMAAAQDAhQAAAQUEBMqAgcTKgIDCSAA6gAABBANDg4ABBAOByEAAO4ABzoBAAAqAA4QIAB9JAAEARMMAAQDExQhAAD0ABQ6AQAAAAAEEAIUAAAEFAMTKgETEioBDBQKAAEUDhMhAAD7ABM6AQAAKgEKFAoABBQPEyEAARcAEyAA/yoBBBMqAQoUKgEKFSQABAMXDAAEFRcYIQABBgAYOgEAACsAABMIAyUABAAECAQiAAABbysACAUAFgAABBYCGAAABBgVFyoCEhcqARYSAAAEEgISKgISFgAABBQNEg4ABBQSFSEAARQAFToBAAAqAhYEKgISCiABQCoAERMgARkMAAQTDxQhAAFGABQgARwqAQQTKgEJFCoAABUkAAQFFgAABAAWACQBBAEVAAAEFAIWJAAEBBcAAAQVAhg+AwAAABYAAAAYKgETFAIABBQCFCoCFBMqARMUAAAEFAIUKgIUEyoBFRQAAAQUAhQqAhQVKwAAEwgDJQAEAAQIBCIAAAFvKwAIBQAUAAAEFAIYAAAEGBEXKgISFyoBFBMAAAQTAhMqAhMUKgEVEwAABBMCEyoCExUqAhQEKgIVCSoCDQogAUAAAAQDDRIOAAQDEhMhAAFEABM6AQAAKgASAyAAdCoBChQMAAQTFBUhAAFKABUgAWkqAQkUKgEJFSQABAQXDAAEExcYIQABUAAYOgEAAAAABBUCGAAABBgTFyoBFxYqAQQVJAAEAxcMAAQTFxkhAAFYABk6AQAAAAAEFQIZAAAEGRMXKgEXGAAABxYYFSQABAQYDAAEExgZIQABYAAZOgEAACsAABQIAyUABAAFCAQiAAABbysACAUAFgAABBYCGQAABBkTGCoCFRgqAhYJIAFpAAAEEw0UDgAEExQVIQABbQAVOgEAACoAFBMgARkrAQgDCAYLAAQIBgACCAchAAFzCAcgAXUrAAgDCAUgAYMrAAAACAUBAAQAAAgEAAAlAAQAAAgJDQAECAkIBAgKFwAICggKIQABgQgKAQAECAMICQgLKwEICwgIAQAECAUICQgLKwIICAgLAQAECAkAAggJIAF4JQEEAAEIBSABgyMrABjKGMo=","debug_symbols":"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","brillig_names":["get_passport_address"],"assert_messages":{"224":"Array index out of bounds","323":"attempt to add with overflow","343":"Array index out of bounds","14":"Not initialized","261":"Array index out of bounds","351":"Array index out of bounds","19":"Function get_passport_address can only be called statically","208":"Array index out of bounds","237":"attempt to add with overflow","243":"Array index out of bounds","275":"attempt to add with overflow","184":"Array index out of bounds","216":"Array index out of bounds","335":"Array index out of bounds","364":"attempt to add with overflow","195":"attempt to add with overflow"}},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"error_types":{},"parameters":[{"name":"_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"],"assert_messages":{"128":"attempt to add with overflow","448":"Array index out of bounds","698":"Array index out of bounds","110":"Array index out of bounds","366":"Array index out of bounds","616":"Array index out of bounds","430":"Array index out of bounds","415":"attempt to add with overflow","598":"Array index out of bounds","592":"attempt to add with overflow","394":"Array index out of bounds","522":"Array index out of bounds","510":"attempt to add with overflow","571":"Array index out of bounds","117":"Array index out of bounds","690":"Array index out of bounds","678":"attempt to add with overflow","538":"Array index out of bounds","340":"Initializer address is not the contract deployer","334":"Initialization hash does not match","462":"attempt to add with overflow","72":"attempt to add with overflow","386":"Array index out of bounds","706":"Array index out of bounds","374":"attempt to add with overflow","563":"Array index out of bounds","630":"attempt to add with overflow","106":"attempt to add with overflow","551":"attempt to add with overflow","344":"Aztec Passport: Invalid Address","402":"Array index out of bounds","530":"Array index out of bounds","719":"attempt to add with overflow","579":"Array index out of bounds"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"12265343917440897559":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":6,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"set_admin","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"new_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAAQIRAAAJAAEAQQkAAQABR8AAAAABQAAAAQAAAhDKwAIQwADIgAAAAg5AAAACEQAAAAAHgAAAAUeAAAABjAAAAAABQAAAAYAAAAHJAACAQUKAAIHBQYhAAAPAAY6AQAAKgAABSQABAIHAAAEAAcAJAEEAQUAAAQFAgcqAAcGJAAHAAgqAggGKgEFBwAABAcCByoCBwUqAAAHAAAEAAIAKgIFByQABAAFJAAHAQgkAAQBBioABQQgACIKAAQEBQkhAABKAAkgACUqAQcJAAAECQIKAAAECgULKgELBx4AAgAJCgAHBwkKIQAALQAKOgEAACoABQQgAC8KAAQEBQchAAAzAAcgADIjHAAHBAcAAAcIBwkqAAAHJAAEAgoAAAQACgAkAQQBBwAABAcCCioACgsqAgMLJAAEAQsMAAQECwwhAABAAAw6AQAAAAAEBwIMAAAEDAQLKgELCi0AAAAACgAAAAkAAAQEBgkOAAQECQohAABIAAo6AQAAKgAJBCAALyoBBwkcAAcECgAABwgKCywAAAAACwAAAAokAAQBDAwABAQMDSEAAFIADToBAAArAAAJCAMlAAQAAggEIgAAAGArAAgFAAsAAAQLAg0AAAQNBAwqAgoMAAAEBAYJDgAEBAkKIQAAXQAKOgEAACoCCwcqAAkEIAAiKwEIAwgGCwAECAYAAggHIQAAZAgHIABmKwAIAwgFIAB0KwAAAAgFAQAEAAAIBAAAJQAEAAAICQ0ABAgJCAQIChcACAoICiEAAHIICgEABAgDCAkICysBCAsICAEABAgFCAkICysCCAgICwEABAgJAAIICSAAaSUBBAABCAUgAHQjKwAYyhjK","debug_symbols":"1ZvdbuIwEIXfJddceMZ/M7zKalVBC1UkBBXQlVaId1+ni51smnVUtVQzN4jAyfhzMsmJx86ledqsX58f2v32cGqWPy7N7vC4OreHfdq6XBfN+tjudu3zw/DnxnQf9CY/vaz23dbpvDqemyVEdItms3/qvlqXAmzb3aZZRnNdvBOzjTct+1ik4O2E1iHwTewQqagZJ8SBwN7EgZCH4p+Lhj8NDgaK2AzEd0cH8/mDHnN85rmDDuiyGJC5Tk7gMwXBIPSNHL6QPB30f9G7BvDeDdh7N+Du3YCfaoARc0I4M5f3kXL81EAfP4YJteeQ894zm3r2+Gghi6PFcfYEteRRLTmpJWet5GjUkoNaclRLbtWSO7Xkaj0U1XooqvVQVOuhVvQV6qmQ+/EYyYrOlugKOZkx+XdnSxmwBWN8nRwMhz50L7YmvKGzWnRn9KJPP3S5vA+HmfGis5S76exc8oYULpNzHF92bu4xKsQhS7eH/fAe7sN7TN4MwGA/TnY4c3oxYCmCEM2c3mAhF7WCtTMlk5BiZzHguGTiQTZ7hMJOMGZH2ew+VNitbHYqBULgsW17p5jdK2YPitmF3yOr7KSYnfWyB6OYXbivVtmF+2qVXbGvBsW+GhT7alDsq0G4rzrs2W1dnMas/VQ90bijwk34vx3t2IWbcI09CjfhKrtwE66yO6210Sh59oKg1KMJx4PyKHr2olTppshF16OLgSVynDGBVC0szPFdN0VPddTK7lH0coEaOYleLlAlF71coEouerlAlVz0coEquWjDrZKLXi5QJRdtuFVytRPApNZDSa2HsloPZbUeymo9lJV66DVt/Vod29V6t7m92bF93T8OXvQ4/375+08S/wE=","brillig_names":["set_admin"],"assert_messages":{"81":"Array index out of bounds","63":"Array index out of bounds","92":"attempt to add with overflow","44":"Aztec Passport: Unauthorized Admin Change","71":"attempt to add with overflow","14":"Not initialized"}},{"name":"verify","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"content","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_public_storage_hints","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","get_public_storage_hints","build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","get_l1_to_l2_membership_witness","pack_arguments_oracle_wrapper","call_private_function_internal","unpack_returns","pack_arguments_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"is_admin","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"JAAEAQIlAAQIRAAAJAAEAAMkAAQABB8AAAAABAAAAAMAAAhDIgAAAAgrAAADCEM5AAAACEMAAAABHgAAAAQeAAAABTAAAAAABAAAAAUAAAAGJAACAQUKAAIGBQQhAAAPAAQ6AQAAHgALAAUkAAcBBgoABwUGBCEAABQABDoBAAAqAAAFJAAEAgQAAAQABAAkAQQBBQAABAUCBCoABAckAAcACCoCCAcqAQUEAAAEBAIEKgIEBSoAAAQAAAQAAgAqAgUEJAAEAQgkAAQABSoABQMgACYKAAQDBQchAAAwAAcgACkqAQQDAAAEAwIGAAAEBgUHKgEHBB4AAgAFCgAHBAUDIyoBBAccAAcDCQAABwYJCiwAAAAACgAAAAkkAAQBCwwABAMLDCEAADgADDoBAAArAAAHCAMlAAQAAggEIgAAAEYrAAgFAAoAAAQKAgwAAAQMAwsqAgkLAAAEAwgHDgAEAwcJIQAAQwAJOgEAACoCCgQqAAcDIAAmKwEIAwgGCwAECAYAAggHIQAASggHIABMKwAIAwgFIABaKwAAAAgFAQAEAAAIBAAAJQAEAAAICQ0ABAgJCAQIChcACAoICiEAAFgICgEABAgDCAkICysBCAsICAEABAgFCAkICysCCAgICwEABAgJAAIICSAATyUBBAABCAUgAFojKwAYyhjK","debug_symbols":"1ZrdbuIwEIXfJddc2DP22MOrrFZVaKGKFIUK6EorxLs3aWOThtRpS6k8N4jAsf3594xHORYP69Xz413VbLb7YvnnWNTb+/JQbZv26XhaFKtdVdfV493w50J1H/5Vvn8qm+5pfyh3h2KpHZhFsW4euq9o2go2Vb0ulk6dFhdiRtdr2boo1RYntAY092ID4KOaYUJMXmMvJg88FP9dFHw1uFY6itVAfHN0ra4fdBfqZ54bdA0miDUwp8m9toHC60HVPbn+QfJ20N+jdw3ArRvAWzdgbt2AvboBazm0YEnNrAjnwfZi540frwj6Ik1Xxn2jjP9GGf56GZjem4CxDFiYO1ecD+J2As/z52hqLpjCuWKZVXourEMdxA5hNBegBbODYHYUzG4Es1vB7CSY3Qlm94LZWS47CvZVFOyrKNhXUbCvYubnjPWR3Y7vpybz9e5MZPdqzP776z1emEkpm2bXiulc9VmMil7hUTK8kQz/QSgZt4mGjiEFb9BDSBDh3CImpsjO7mIDfiI4dDM0ELprSF/0VvLhlHcQ5HU0BQ96xG4zD4LiFpliz9wUPJ7ZIS3mdquG7KlxFx3NPGJKuZ/NPGJKshvB7JlnIpLsmWcikuyZZyKS7JmbcJI980xEip0yN+Eku+CbGQn2VRLsqyTYV0mwr5JgXyWxvnpqn/6Vu6pc1ev+5ZfNc3M/eBfm8P/p7Z9W/AI=","brillig_names":["is_admin"],"assert_messages":{"66":"attempt to add with overflow","55":"Array index out of bounds","14":"Not initialized","19":"Function is_admin can only be called statically"}},{"name":"get_balance_registry","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_balance_registry"],"assert_messages":{"253":"Array index out of bounds","218":"Array index out of bounds","247":"attempt to add with overflow","285":"attempt to add with overflow","14":"Not initialized","162":"call to assert_max_bit_size","194":"Array index out of bounds","226":"Array index out of bounds","345":"Array index out of bounds","374":"attempt to add with overflow","19":"Function get_balance_registry can only be called statically","205":"attempt to add with overflow","170":"call to assert_max_bit_size","234":"Array index out of bounds","333":"attempt to add with overflow","353":"Array index out of bounds","271":"Array index out of bounds","361":"Array index out of bounds"}},{"name":"set_balance_registry","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"_registry","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAAQIRAAAJAAEAQQkAAQABR8AAAAABQAAAAQAAAhDKwAIQwADIgAAAAg5AAAACEQAAAAAHgAAAAUeAAAABjAAAAAABQAAAAYAAAAHJAACAQYKAAIHBgUhAAAPAAU6AQAAKgAAByQABAIGAAAEAAYAJAEEAQcAAAQHAgYqAAYFJAAHAAgqAggFKgEHBgAABAYCBioCBgcqAAAGAAAEAAIAKgIHBiQABAAFJAAEAQkkAAcBCioABQQgACIKAAQEBQshAAezAAsgACUqAQYLAAAECwIMAAAEDAUNKgENBh4AAgALCgAHBgsMIQAALQAMOgEAACoAAAskAAQEBgAABAAGACQBBAELAAAECwIGKgAGDCoCCAwAAAQMAgwqAggMAAAEDAIMKgIIDCoBCwYAAAQGAgYqAgYLKgELBgAABAYCBioCBgsqAQsGAAAEBgIGKgIGCyoBCwYAAAQGAgYqAgYLKgAABgAABAACACgABwAAAAAAAAACAAAAAAAAAAAADCoAAA0kAAQFDgAABAAOACQBBAENAAAEDQIOKgAODyoCCA8AAAQPAg8qAggPAAAEDwIPKgIIDwAABA8CDyoCDA8qAQ0OAAAEDgIOKgIODSoAAA4AAAQAAgAqAAAPAAAEAAIAKgAAEAAABAACACoBCxEAAAQRAhEqAhELKgENEQAABBECESoCEQ0qAQsRAAAEEQIRKgIRCyoBDREAAAQRAhEqAhENKgELEQAABBECESoCEQsqAQ0RAAAEEQIRKgIRDSoCCwYqAg0OKgIJDyQAAQARKgIRECoBCxICAAQSAhIqAhILKgENEgIABBICEioCEg0kAAcCEioAABMkAAQCFAAABAAUACQBBAETAAAEEwIUKgAUFSoCEhUkAAQEFCQABAMVKgAFBCAAhgoABAQFFiEABzQAFiAAiSoBEBYKAAEWERchAACNABc6AQAAKgAFBCAAjwwABAQVFiEABwsAFiAAkioBDgYqAAAEJAAEBRYAAAQAFgAkAQQBBAAABAYCFiQABAQXAAAEBAIYPgMAAAAWAAAAGCoCBA4kAAEBDioCDhAAAAQEAgYAAAQGBRgqARgQKgELBAAABAQCBCoCBAsqAAAEAAAEAAIAKgILBCoABQ8gAKkMAAQPFQYhAAb1AAYgAKwqAQQPAAAEDwIGAAAEBgUWKgEWBBwABwQGKQAHAAAAAAAAAAAAAAAA//////////////////////////8AFg4ABwYWFyEAALUAFzoBAAAAAAQPAgYAAAQGCRcqARcWHAAHFgYpAAcAAAAAAAAAAAAAAAD//////////////////////////wAXDgAHBhcYIQAAvQAYOgEAACQABAIXAAAEDwIYAAAEGBcZKgEZBhwABAYPHAAHDxccAAQXBioAABcAAAQAAgAqAgQXKgAABAAABAACACoCFgQqAAAWAAAEAAIAKgIGFioAAAYAAAQAAgAqAQ0PAAAEDwIPKgIPDSoAAA8AAAQAAgAqAAAYAAAEAAIAKgAAGQAABAACACoBDRoAAAQaAhoqAhoNKgENGgAABBoCGioCGg0qAAAaJAAEBBsAAAQAGwAkAQQBGgAABBoCGyoAGxwqAgocAAAEHAIcKgIIHAAABBwCHCoCCBwqARobAAAEGwIbKgIbGioBDRsAAAQbAhsqAhsNKgIaBioCDQ8qAgkYKgIRGSoBGhsCAAQbAhsqAhsaKgENGwIABBsCGyoCGw0qAAUQIAD7CgAEEAUbIQAGdgAbIAD+KgEZGwoAARsRHCEAAQIAHDoBAAAqAAUQIAEEDAAEEBUbIQAGTQAbIAEHKgEPECoAAAYkAAQFGwAABAAbACQBBAEGAAAEEAIbJAAEBBwAAAQGAh0+AwAAABsAAAAdKgIGDyoCDhkAAAQGAg8AAAQPBRAqARAZKgEHBgAABAYCBioCBgcqAAAGAAAEAAIAKgIHBioABRggAR0KAAQYBRAhAAY3ABAgASAqAQYQAAAEEAIPAAAEDwUHKgEHBhwABwYQKAAH/////////////////////wAPDgAHEA8HIQABKQAHOgEAABwABQYQHAAHEA8cAAUPEAIABwYPBygABwAAAAAAAAABAAAAAAAAAAAADwgABwcPBhwABQYbHAAHGwccAAUHBicABQAAAAIAAAAAAAcGAAUGBxscAAEbHRwABR0cHAABHBsnAAUAAAABAAAAAAAcBgAFEBwdHAAEHR4GAAUGHB0cAAEdIBwABSAfHAABHx0cAAQQIBwABSAfHAAEHxAcAAQGIBwABSAfHAAEHwYhAAFJABsgAUYqABEZKgAFGCABTCoADhkqAB4YIAFMIQABUQAdIAFOKgARHioABRsgAVQqAA4eKgAQGyABVB4ABwAQ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","debug_symbols":"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","brillig_names":["set_balance_registry"],"assert_messages":{"1737":"attempt to add with overflow","1847":"Array index out of bounds","817":"Array index out of bounds","366":"attempt to add with overflow","939":"Array index out of bounds","1841":"attempt to add with overflow","1189":"Array index out of bounds","1567":"Array index out of bounds","1372":"Array index out of bounds","1689":"attempt to add with overflow","1622":"Array index out of bounds","659":"attempt to add with overflow","1939":"Array index out of bounds","781":"Array index out of bounds","647":"attempt to add with overflow","1799":"attempt to add with overflow","1927":"attempt to add with overflow","830":"attempt to add with overflow","1598":"Array index out of bounds","1202":"attempt to add with overflow","44":"Aztec Passport: Only Admin","1062":"Array index out of bounds","1440":"Array index out of bounds","1245":"Array index out of bounds","1757":"Array index out of bounds","1879":"attempt to add with overflow","1812":"Array index out of bounds","14":"Not initialized","1099":"Array index out of bounds","1989":"attempt to add with overflow","642":"attempt to multiply with overflow","1788":"Array index out of bounds","1081":"Array index out of bounds","947":"Array index out of bounds","1075":"attempt to add with overflow","551":"attempt to add with overflow","1380":"Array index out of bounds","801":"Array index out of bounds","1575":"Array index out of bounds","539":"attempt to add with overflow","1630":"Array index out of bounds","789":"attempt to add with overflow","978":"Array index out of bounds","655":"attempt to add with overflow","1173":"Array index out of bounds","1033":"attempt to add with overflow","1161":"attempt to add with overflow","1947":"Array index out of bounds","960":"attempt to add with overflow","1978":"Array index out of bounds","1015":"Array index out of bounds","180":"call to assert_max_bit_size","1393":"attempt to add with overflow","1588":"attempt to add with overflow","296":"call to assert_max_bit_size","997":"attempt to add with overflow","1253":"Array index out of bounds","1448":"Array index out of bounds","1765":"Array index out of bounds","857":"Array index out of bounds","534":"attempt to multiply with overflow","985":"Array index out of bounds","1046":"Array index out of bounds","1113":"attempt to add with overflow","1290":"Array index out of bounds","839":"Array index out of bounds","967":"attempt to add with overflow","1217":"Array index out of bounds","1022":"Array index out of bounds","1412":"Array index out of bounds","1272":"Array index out of bounds","1461":"attempt to add with overflow","1266":"attempt to add with overflow","1467":"Array index out of bounds","1485":"Array index out of bounds","809":"Array index out of bounds","1638":"Array index out of bounds","931":"Array index out of bounds","547":"attempt to add with overflow","1181":"Array index out of bounds","1778":"attempt to add with overflow","919":"attempt to add with overflow","1364":"Array index out of bounds","1559":"Array index out of bounds","1820":"Array index out of bounds","1547":"attempt to add with overflow","1352":"attempt to add with overflow","1675":"Array index out of bounds","1955":"Array index out of bounds","188":"call to assert_max_bit_size","1657":"Array index out of bounds","1651":"attempt to add with overflow","1968":"attempt to add with overflow","871":"attempt to add with overflow","1828":"Array index out of bounds","1054":"Array index out of bounds","1499":"attempt to add with overflow","1304":"attempt to add with overflow","1237":"Array index out of bounds","1432":"Array index out of bounds","1749":"Array index out of bounds","1420":"attempt to add with overflow","1865":"Array index out of bounds","1225":"attempt to add with overflow","1609":"attempt to add with overflow"}},{"name":"get_admin_public","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAAQIRAAAJAAEAAMkAAQABB8AAAAABAAAAAMAAAhDIgAAAAgrAAADCEM5AAAACEMAAAABHgAAAAQeAAAABTAAAAAABAAAAAUAAAAGJAACAQUKAAIGBQQhAAAPAAQ6AQAAHgALAAYkAAcBBQoABwYFBCEAABQABDoBAAAqAAAGJAAEAgQAAAQABAAkAQQBBgAABAYCBCoABAckAAcACCoCCAcqAQYEAAAEBAIEKgIEBioAAAQAAAQAAgAqAgYEJAAEAQgkAAQABioABgMgACYKAAQDBgchAAAvAAcgACkqAQQFAAAEBQIDAAAEAwYHKgEHBCoABAMjKgEEBxwABwMJAAAHBQkKLAAAAAAKAAAACSQABAELDAAEAwsMIQAANwAMOgEAACsAAAcIAyUABAACCAQiAAAARSsACAUACgAABAoCDAAABAwDCyoCCQsAAAQDCAkOAAQDCQchAABCAAc6AQAAKgIKBCoACQMgACYrAQgDCAYLAAQIBgACCAchAABJCAcgAEsrAAgDCAUgAFkrAAAACAUBAAQAAAgEAAAlAAQAAAgJDQAECAkIBAgKFwAICggKIQAAVwgKAQAECAMICQgLKwEICwgIAQAECAUICQgLKwIICAgLAQAECAkAAggJIABOJQEEAAEIBSAAWSMrABjKGMo=","debug_symbols":"1ZrdbsIwDIXfJddcxHF+bF5lmqaywVSpKhOwSRPi3ddubehKFQSMKb5BpD2Jvyapj1t1r16Wi/fXp7Jerbdq/rBX1fq52JXrumntDzO12JRVVb4+DQ8r3f7Qt3z7VtRta7srNjs1h2DsTC3rl/Yv2maAVVkt1Tzow+xEzBg6LbsQpeBwQmsNcCe2xlBUs5kQewLsxJ4MD8WPM8U3g4OGKNYD8d3RQd8+6aEfn/ncpIOxvRgMc5qcwPUUBIOhO3L4Q/Jm0n+jtwHMvQPgvQPYewdwNwdwjvsIzuszOyKQcZ04kKXxjvAX0rR9whV96Io+fHkfM31vAsYlAQfn8kqgKNZ4XL/gp9aCfZ9XHLNOr4ULCL04oBmthQHB7EYwOwpmt4LZnWB2L5g9CGYnwewslx0F+yoK9lUU7Kso2Fcx8zzjKLK78fOpzXy/BxvZSY/Z/3+/xwdmr7VLs4Nmfxz6KEbtv+FRMryVDJ95SZO8XfNONQQxTZKBMXvmJU3cNBPsLvOShvDIbtJitthzsA0nFyrYD1zm9U+SPfP6J8luBbNn/l4hyZ75e4Uke+YmnGTPvN5Psmduwil2n7kJJ9kF+6oX7KtesK96wb7qBfuqF+urh6b1UWzKYlEtu89BVu/18+DrkN3n28+ZRvwF","brillig_names":["get_admin_public"],"assert_messages":{"14":"Not initialized","65":"attempt to add with overflow","54":"Array index out of bounds","19":"Function get_admin_public can only be called statically"}},{"name":"set_passport_address","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"_passport_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["set_passport_address"],"assert_messages":{"1024":"attempt to add with overflow","1152":"attempt to add with overflow","524":"attempt to multiply with overflow","951":"attempt to add with overflow","1969":"Array index out of bounds","1006":"Array index out of bounds","1579":"attempt to add with overflow","1384":"attempt to add with overflow","1439":"Array index out of bounds","988":"attempt to add with overflow","537":"attempt to add with overflow","1244":"Array index out of bounds","1756":"Array index out of bounds","848":"Array index out of bounds","976":"Array index out of bounds","1037":"Array index out of bounds","1104":"attempt to add with overflow","1476":"Array index out of bounds","1281":"Array index out of bounds","958":"attempt to add with overflow","830":"Array index out of bounds","1208":"Array index out of bounds","1013":"Array index out of bounds","1403":"Array index out of bounds","1263":"Array index out of bounds","44":"Aztec Passport: Only Admin","1257":"attempt to add with overflow","1452":"attempt to add with overflow","1458":"Array index out of bounds","800":"Array index out of bounds","1629":"Array index out of bounds","922":"Array index out of bounds","1769":"attempt to add with overflow","1172":"Array index out of bounds","1946":"Array index out of bounds","14":"Not initialized","910":"attempt to add with overflow","1355":"Array index out of bounds","1550":"Array index out of bounds","1538":"attempt to add with overflow","1343":"attempt to add with overflow","1666":"Array index out of bounds","1811":"Array index out of bounds","1648":"Array index out of bounds","1642":"attempt to add with overflow","1959":"attempt to add with overflow","356":"attempt to add with overflow","862":"attempt to add with overflow","1819":"Array index out of bounds","1045":"Array index out of bounds","1490":"attempt to add with overflow","1295":"attempt to add with overflow","1228":"Array index out of bounds","1423":"Array index out of bounds","1740":"Array index out of bounds","1411":"attempt to add with overflow","1216":"attempt to add with overflow","1600":"attempt to add with overflow","1728":"attempt to add with overflow","1856":"Array index out of bounds","1838":"Array index out of bounds","808":"Array index out of bounds","1832":"attempt to add with overflow","930":"Array index out of bounds","1180":"Array index out of bounds","1558":"Array index out of bounds","1363":"Array index out of bounds","1680":"attempt to add with overflow","1613":"Array index out of bounds","650":"attempt to add with overflow","1930":"Array index out of bounds","772":"Array index out of bounds","638":"attempt to add with overflow","1790":"attempt to add with overflow","1918":"attempt to add with overflow","821":"attempt to add with overflow","1589":"Array index out of bounds","1193":"attempt to add with overflow","541":"attempt to add with overflow","1053":"Array index out of bounds","1431":"Array index out of bounds","1236":"Array index out of bounds","529":"attempt to add with overflow","1748":"Array index out of bounds","1803":"Array index out of bounds","1870":"attempt to add with overflow","1090":"Array index out of bounds","1980":"attempt to add with overflow","633":"attempt to multiply with overflow","1779":"Array index out of bounds","1072":"Array index out of bounds","938":"Array index out of bounds","1066":"attempt to add with overflow","286":"call to assert_max_bit_size","1371":"Array index out of bounds","792":"Array index out of bounds","1566":"Array index out of bounds","1621":"Array index out of bounds","1938":"Array index out of bounds","1164":"Array index out of bounds","780":"attempt to add with overflow","646":"attempt to add with overflow","969":"Array index out of bounds"}},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"3715688037512703171":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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KgIoFCoBFCgAAAQoAigqAigUKgAAKAAABAACACoCFCgqARslAAAEJQIlKgIlGyoAACUAAAQAAgAqAhslKgAAJAAABAACACoCBiQqAAAjAAAEAAIAKgIIIyoABicgBbAMAAQnBCIhAA9wACIgBbMqASMmCgABJggiIQAFtwAiOgEAACoABicgBbkMAAQnESYhAA9HACYgBbwqASUiKgAAISQABAUgAAAEACAAJAEEASEAAAQiAiAkAAQEHwAABCECHj4DAAAAIAAAAB4qAiElKgIKIwAABCECJQAABCUGIioBIiMqAAYkIAXMCgAEJAYiIQAPMAAiIAXPAAAEDwIWOQEAAAAWAAAAACAF0iYAByDhADwAFgoABwMWEyoAABYkAAQCEgAABAASACQBBAEWAAAEFgISKgASHioCFx4hAAXdABMgCLEqAAASJAAEAh4AAAQAHgAkAQQBEgAABBICHh8EAAAADQAAAA0AAAAeKgESHgAABB4CHioCHhIqAAAeAAAEAAIAKgISHioAAB8AAAQAAgAqAgYfKgESIAAABCACICoCIBIqAAAgAAAEAAIAKgIQICoBEiEAAAQhAiEqAiESKgEQEgAABBICEioCEhAqAAYTIAX6CgAEEwYSIQAPEAASIAX9KgEfEwAABBMNEg4ABBMSISEABgIAIToBAAAqAhIfKgEgEioBECACAAQgAiAqAiAQAAAEEgIfAAAEHwYTKgETIBwAByASKQAHAAAAAAAAAAAAAAAA//////////////////////////8AHw4ABxIfEyEABg8AEzoBAAAeAAAAHx4AAAASMAAAAAAfAAAAEgAAABMKAAITBRIhAAYVABI6AQAAKgEQEwAABBMCEyoCExAqAAATAAAEAAIAKgIQEyoABh4gBh0KAAQeBh8hAA76AB8gBiAqARMeAAAEHgISAAAEEgYhKgEhEx4AAgAeCgAHEx4SIQAGKAASOgEAACoBFB4AAAQeAh4qAh4UKgEUHgAABB4CHioCHhQqARQeAAAEHgIeKgIeFCoBFB4AAAQeAh4qAh4UKgAAHgAABAACACoBCxMAAAQTAhMqAhMLKgAAEwAABAACACoAABIAAAQAAgAqAAAhAAAEAAIAKgEUIgAABCICIioCIhQqAQsiAAAEIgIiKgIiCyoBFCIAAAQiAiIqAiIUKgELIgAABCICIioCIgsqARQiAAAEIgIiKgIiFCoBCyIAAAQiAiIqAiILKgIUHioCCxMqAg0SKgIIISoBFCICAAQiAiIqAiIUKgELIgIABCICIioCIgsqAAYfIAZdCgAEHwYiIQAOewAiIAZgKgEhIgoAASIIIyEABmQAIzoBAAAqAAYfIAZmDAAEHxEiIQAOUgAiIAZpKgETHioAABIkAAQFIgAABAAiACQBBAESAAAEHgIiJAAEBCMAAAQSAiQ+AwAAACIAAAAkKgISEyoCCiEAAAQSAhMAAAQTBh4qAR4hKgEUEgAABBICEioCEhQqAAASAAAEAAIAKgIUEioABh8gBn8MAAQfER4hAA48AB4gBoIqARIeAAAEHgITAAAEEwYhKgEhEhwABxITKQAHAAAAAAAAAAAAAAAA//////////////////////////8AIQ4ABxMhIiEABosAIjoBAAAAAAQeAhMAAAQTDSIqASIhHAAHIRMpAAcAAAAAAAAAAAAAAAD//////////////////////////wAiDgAHEyIjIQAGkwAjOgEAAAAABB4CEwAABBMMIyoBIyIcAAQiExwABxMeHAAEHiIqAAAeAAAEAAIAKgISHioAABIAAAQAAgAqAiESKgAAIQAABAACACoCIiEqAAAiAAAEAAIAKgELEwAABBMCEyoCEwsqAAATAAAEAAIAKgAAIwAABAACACoAACQAAAQAAgAqAQslAAAEJQIlKgIlCyoBCyUAAAQlAiUqAiULKgEdJQAABCUCJSoCJR0qAQslAAAEJQIlKgIlCyoCHSIqAgsTKgINIyoCCCQqAR0lAgAEJQIlKgIlHSoBCyUCAAQlAiUqAiULKgAGHyAGxQoABB8GJSEADb0AJSAGyCoBJCUKAAElCCYhAAbMACY6AQAAKgAGHyAGzgwABB8RJSEADZQAJSAG0SoBEyIqAAAfJAAEBSUAAAQAJQAkAQQBHwAABCICJSQABAQmAAAEHwInPgMAAAAlAAAAJyoCHxMqAgokAAAEHwITAAAEEwYiKgEiJCoBEB8AAAQfAh8qAh8QKgAAHwAABAACACoCEB8qAAYjIAbnCgAEIwYiIQANfgAiIAbqKgEfIgAABCICIwAABCMGJCoBJB8cAAcfIigAB/////////////////////8AIw4AByIjJCEABvMAJDoBAAAcAAUf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CAQiAAAW3ysACAUAKgAABCoCLgAABC4GLSoCKC0qASooAAAEKAIoKgIoKioBKygAAAQoAigqAigrKgIqISoCKxIqAg0eIA1PAAAEIg0oDgAEIigpIQANUwApOgEAACoAKCIgB3gqAR4qDAAEKSorIQANWQArIA14KgESKioBEiskAAQELQwABCktLiEADV8ALjoBAAAAAAQrAi4AAAQuKS0qAS0sKgEhKyQABAMtDAAEKS0vIQANZwAvOgEAAAAABCsCLwAABC8pLSoBLS4AAAcsLiskAAQELAwABCksLyEADW8ALzoBAAArAAAqCAMlAAQABQgEIgAAFt8rAAgFAC4AAAQuAi8AAAQvKSwqAissKgIuEiANeAAABCkNKg4ABCkqKyEADXwAKzoBAAAqACopIA0oKgEfIhwAByMTAAAHJBMQLAAAAAAQAAAAEyQABAElDAAEIyUmIQANhgAmOgEAACsAACIIAyUABAACCAQiAAAW3ysACAUAEAAABBACJgAABCYjJSoCEyUAAAQjDRMOAAQjEyIhAA2RACI6AQAAKgIQHyoAEyMgBucqASMlDAAEHyUmIQANmAAmIA23KgETJSoBEyYkAAQEKAwABB8oKSEADZ4AKToBAAAAAAQmAikAAAQpHygqASgnKgEiJiQABAMoDAAEHygqIQANpgAqOgEAAAAABCYCKgAABCofKCoBKCkAAAcnKSYkAAQEJwwABB8nKiEADa4AKjoBAAArAAAlCAMlAAQABQgEIgAAFt8rAAgFACkAAAQpAioAAAQqHycqAiYnKgIpEyANtwAABB8NJQ4ABB8lJiEADbsAJjoBAAAqACUfIAbOJAAEASYMAAQfJichAA3BACc6AQAAAAAEFgInAAAEJx8mKgEmJSoBJCcKAAEnCCYhAA3IACY6AQAAKgEjJwoABCcRJiEADeQAJiANzCoBIiYqASMnKgEjKCQABAMqDAAEKCorIQAN0wArOgEAACsAACYIAyUABAAECAQiAAAW3ysACAUAKQAABCkCKwAABCsoKioCJSoqASkoAAAEKAIoKgIoKQAABCcNKA4ABCcoJiEADeEAJjoBAAAqAikiKgIoIyAODSoABiYgDeYMAAQmESchAA4TACcgDekqASImKgETJyoAACgkAAQFKQAABAApACQBBAEoAAAEJwIpJAAEBCoAAAQoAis+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LgAAADAqASssAgAELAIsKgIsKyoBKywAAAQsAiwqAiwrKgEtLAAABCwCLCoCLC0rAAArCAMlAAQABAgEIgAAFt8rAAgFACwAAAQsAjAAAAQwBi8qAiovKgEsKgAABCoCKioCKiwqAS0qAAAEKgIqKgIqLSoCLB4qAi0TKgINHyASNwAABCQNKg4ABCQqKyEAEjsAKzoBAAAqACokIASZKgEfLAwABCssLSEAEkEALSASYCoBEywqARMtJAAEBC8MAAQrLzAhABJHADA6AQAAAAAELQIwAAAEMCsvKgEvLioBHi0kAAQDLwwABCsvMSEAEk8AMToBAAAAAAQtAjEAAAQxKy8qAS8wAAAHLjAtJAAEBDAMAAQrMDEhABJXADE6AQAAKwAALAgDJQAEAAUIBCIAABbfKwAIBQAuAAAELgIxAAAEMSswKgItMCoCLhMgEmAAAAQrDSwOAAQrLC0hABJkAC06AQAAKgAsKyASECoBICMcAAckIgAAByUiJiwAAAAAJgAAACIkAAQBJwwABCQnKCEAEm4AKDoBAAArAAAjCAMlAAQAAggEIgAAFt8rAAgFACYAAAQmAigAAAQoJCcqAiInAAAEJA0jDgAEJCMiIQASeQAiOgEAACoCJiAqACMkIAQIKgEkJgwABCAmJyEAEoAAJyASnyoBIyYqASMnJAAEBCkMAAQgKSohABKGACo6AQAAAAAEJwIqAAAEKiApKgEpKCoBIickAAQDKQwABCApKyEAEo4AKzoBAAAAAAQnAisAAAQrICkqASkqAAAHKConJAAEBCoMAAQgKishABKWACs6AQAAKwAAJggDJQAEAAUIBCIAABbfKwAIBQAoAAAEKAIrAAAEKyAqKgInKioCKCMgEp8AAAQgDSYOAAQgJichABKjACc6AQAAKgAmICAD7yQABAEnDAAEICcoIQASqQAoOgEAAAAABBICKAAABCggJyoBJyYqASUoCgABKAgnIQASsAAnOgEAACoBJCgKAAQoESchABLMACcgErQqASInKgEkKCoBJCkkAAQDKwwABCkrLCEAErsALDoBAAArAAAnCAMlAAQABAgEIgAAFt8rAAgFACoAAAQqAiwAAAQsKSsqAiYrKgEqJgAABCYCJioCJioAAAQoDSYOAAQoJikhABLJACk6AQAAKgIqIioCJiQgEvUqAAYnIBLODAAEJxEoIQAS+wAoIBLRKgEiJyoBIygqAAApJAAEBSoAAAQAKgAkAQQBKQAABCgCKiQABAQrAAAEKQIsPgMAAAAqAAAALCoBJygCAAQoAigqAignKgEnKAAABCgCKCoCKCcqASkoAAAEKAIoKgIoKSsAACcIAyUABAAECAQiAAAW3ysACAUAKAAABCgCLAAABCwGKyoCJisqASgnAAAEJwInKgInKCoBKScAAAQnAicqAicpKgIoIioCKSMqAg0kIBL1AAAEIA0mDgAEICYnIQAS+QAnOgEAACoAJiAgA+YqASQoDAAEJygpIQAS/wApIBMeKgEjKCoBIykkAAQEKwwABCcrLCEAEwUALDoBAAAAAAQpAiwAAAQsJysqASsqKgEiKSQABAMrDAAEJystIQATDQAtOgEAAAAABCkCLQAABC0nKyoBKywAAAcqLCkkAAQELAwABCcsLSEAExUALToBAAArAAAoCAMlAAQABQgEIgAAFt8rAAgFACoAAAQqAi0AAAQtJywqAiksKgIqIyATHgAABCcNKA4ABCcoKSEAEyIAKToBAAAqACgnIBLOKgETHxwAByAeAAAHIh4jLAAAAAAjAAAAHiQABAMkDAAEICQlIQATLAAlOgEAACsAAB8IAyUABAAECAQiAAAW3ysACAUAIwAABCMCJQAABCUgJCoCHiQAAAQgDR8OAAQgHx4hABM3AB46AQAAKgIjEyoAHyAgA6oqARMjDAAEICMkIQATPgAkIBNdKgEeIyoBHiQkAAQEJgwABCAmJyEAE0QAJzoBAAAAAAQkAicAAAQnICYqASYlKgEfJCQABAMmDAAEICYoIQATTAAoOgEAAAAABCQCKAAABCggJioBJicAAAclJyQkAAQEJwwABCAnKCEAE1QAKDoBAAArAAAjCAMlAAQABQgEIgAAFt8rAAgFACUAAAQlAigAAAQoICcqAiQnKgIlHiATXQAABCANIw4ABCAjJCEAE2EAJDoBAAAqACMgIAORJAAEASQMAAQgJCUhABNnACU6AQAAAAAEEgIlAAAEJSAkKgEkIyoBIiUKAAElCCQhABNuACQ6AQAAKgETJQoABCURJCEAE4oAJCATcioBHyQqARMlKgETJiQABAMoDAAEJigpIQATeQApOgEAACsAACQIAyUABAAECAQiAAAW3ysACAUAJwAABCcCKQAABCkm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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"512":"Function get_admin_public can only be called statically","4876":"Array index out of bounds","2938":"attempt to add with overflow","5175":"Array index out of bounds","2481":"Array index out of bounds","4907":"Array index out of bounds","5419":"attempt to add with overflow","5151":"Array index out of bounds","1110":"attempt to add with overflow","4694":"Array index out of bounds","3024":"attempt to add with overflow","4749":"Array index out of bounds","5639":"Array index out of bounds","4292":"Array index out of bounds","2110":"attempt to multiply with overflow","4079":"attempt to add with overflow","4134":"Array index out of bounds","2976":"attempt to add with overflow","4512":"attempt to add with overflow","3866":"Array index out of bounds","471":"Not initialized","4567":"Array index out of bounds","1550":"call to assert_max_bit_size","203":"attempt to add with overflow","3275":"Array index out of bounds","2629":"attempt to add with overflow","3330":"Array index out of bounds","3976":"Array index out of bounds","4165":"Array index out of bounds","4409":"Array index out of bounds","4086":"attempt to add with overflow","5433":"Array index out of bounds","1392":"attempt to add with overflow","4141":"Array index out of bounds","2794":"Array index out of bounds","3818":"Array index out of bounds","612":"Function get_passport_address can only be called statically","3873":"Array index out of bounds","2526":"Array index out of bounds","3227":"Array index out of bounds","3928":"Array index out of bounds","4385":"attempt to add with overflow","4897":"attempt to add with overflow","2502":"attempt to add with overflow","4038":"attempt to add with overflow","5440":"Array index out of bounds","2234":"Not initialized","4471":"attempt to add with overflow","4794":"Array index out of bounds","5495":"Array index out of bounds","3691":"Array index out of bounds","4770":"attempt to add with overflow","1375":"attempt to multiply with overflow","2588":"attempt to add with overflow","3100":"Array index out of bounds","3612":"Array index out of bounds","3990":"attempt to add with overflow","1674":"call to assert_max_bit_size","4423":"attempt to add with overflow","4344":"attempt to add with overflow","4856":"attempt to add with overflow","2540":"attempt to add with overflow","3052":"Array index out of bounds","3430":"Array index out of bounds","547":"Not initialized","4966":"Array index out of bounds","3485":"Array index out of bounds","5210":"Array index out of bounds","4808":"attempt to add with overflow","3461":"Array index out of bounds","4918":"attempt to add with overflow","2925":"Array index out of bounds","3949":"attempt to add with overflow","3303":"Array index out of bounds","5162":"attempt to add with overflow","5516":"attempt to add with overflow","2664":"Array index out of bounds","2341":"call to assert_max_bit_size","2018":"attempt to add with overflow","4066":"Array index out of bounds","4200":"Array index out of bounds","5791":"Array index out of bounds","4499":"Array index out of bounds","5066":"Array index out of bounds","3908":"attempt to add with overflow","1537":"attempt to add with overflow","2238":"Function get_balance_registry can only be called statically","3451":"attempt to add with overflow","2616":"Array index out of bounds","4097":"Array index out of bounds","4152":"attempt to add with overflow","5310":"Array index out of bounds","2860":"attempt to add with overflow","3884":"attempt to add with overflow","5097":"Array index out of bounds","5475":"attempt to add with overflow","5664":"Array index out of bounds","5341":"Array index out of bounds","3348":"Array index out of bounds","4372":"Array index out of bounds","2702":"Array index out of bounds","4884":"Array index out of bounds","3080":"Array index out of bounds","4104":"Array index out of bounds","4939":"Array index out of bounds","3135":"Array index out of bounds","3324":"attempt to add with overflow","2489":"Array index out of bounds","5183":"Array index out of bounds","5451":"attempt to add with overflow","5829":"attempt to add with overflow","551":"Function is_admin can only be called statically","1575":"Aztec Passport: Only Admin","4757":"Array index out of bounds","850":"Aztec Passport: Only Admin","3410":"attempt to add with overflow","4300":"Array index out of bounds","4678":"Array index out of bounds","1283":"attempt to add with overflow","3520":"Array index out of bounds","5623":"Array index out of bounds","3362":"attempt to add with overflow","5087":"attempt to add with overflow","3283":"attempt to add with overflow","3472":"attempt to add with overflow","4173":"Array index out of bounds","5331":"attempt to add with overflow","4551":"Array index out of bounds","5118":"attempt to add with overflow","4984":"Array index out of bounds","1778":"call to assert_max_bit_size","2802":"Array index out of bounds","5228":"Array index out of bounds","3235":"Array index out of bounds","3936":"Array index out of bounds","4960":"attempt to add with overflow","3802":"Array index out of bounds","2644":"Array index out of bounds","5204":"attempt to add with overflow","5503":"Array index out of bounds","5046":"attempt to add with overflow","5290":"attempt to add with overflow","3108":"Array index out of bounds","3620":"Array index out of bounds","4321":"attempt to add with overflow","3675":"Array index out of bounds","1682":"call to assert_max_bit_size","5833":"Array index out of bounds","4998":"attempt to add with overflow","3651":"Array index out of bounds","2115":"attempt to add with overflow","5699":"Array index out of bounds","4218":"Array index out of bounds","5242":"attempt to add with overflow","5108":"attempt to add with overflow","3438":"Array index out of bounds","5352":"attempt to add with overflow","3493":"Array index out of bounds","4194":"attempt to add with overflow","3036":"Array index out of bounds","1043":"call to assert_max_bit_size","5840":"Array index out of bounds","2823":"attempt to add with overflow","2878":"Array index out of bounds","3256":"attempt to add with overflow","4280":"attempt to add with overflow","3311":"Array index out of bounds","2720":"Array index out of bounds","2909":"Array index out of bounds","3153":"Array index out of bounds","2830":"attempt to add with overflow","5390":"Array index out of bounds","4232":"attempt to add with overflow","2885":"Array index out of bounds","5122":"Array index out of bounds","3129":"attempt to add with overflow","3641":"attempt to add with overflow","4531":"Array index out of bounds","2672":"Array index out of bounds","2349":"call to assert_max_bit_size","490":"Aztec Passport: Unauthorized Admin Change","2026":"attempt to add with overflow","1380":"attempt to add with overflow","4586":"Array index out of bounds","2782":"attempt to add with overflow","5531":"Array index out of bounds","5799":"Array index out of bounds","3538":"Array index out of bounds","3215":"attempt to add with overflow","4050":"Array index out of bounds","5074":"Array index out of bounds","5129":"Array index out of bounds","4483":"Array index out of bounds","5318":"Array index out of bounds","3514":"attempt to add with overflow","2734":"attempt to add with overflow","2600":"Array index out of bounds","5672":"Array index out of bounds","3167":"attempt to add with overflow","4947":"Array index out of bounds","3088":"attempt to add with overflow","3600":"attempt to add with overflow","5191":"Array index out of bounds","4356":"Array index out of bounds","4868":"Array index out of bounds","3710":"Array index out of bounds","181":"attempt to add with overflow","2473":"Array index out of bounds","3552":"attempt to add with overflow","4308":"Array index out of bounds","401":"Initializer address is not the contract deployer","2449":"Array index out of bounds","1291":"attempt to add with overflow","3662":"attempt to add with overflow","2693":"attempt to add with overflow","4686":"Array index out of bounds","4741":"Array index out of bounds","5631":"Array index out of bounds","5820":"attempt to add with overflow","5363":"Array index out of bounds","4717":"Array index out of bounds","5851":"attempt to add with overflow","4181":"Array index out of bounds","5717":"Array index out of bounds","4559":"Array index out of bounds","2944":"Array index out of bounds","5693":"attempt to add with overflow","2810":"Array index out of bounds","817":"attempt to add with overflow","2030":"attempt to add with overflow","3243":"Array index out of bounds","3810":"Array index out of bounds","2652":"attempt to add with overflow","2841":"Array index out of bounds","147":"attempt to add with overflow","2896":"attempt to add with overflow","3920":"Array index out of bounds","5779":"attempt to add with overflow","3841":"Array index out of bounds","5487":"Array index out of bounds","3116":"Array index out of bounds","3628":"Array index out of bounds","3683":"Array index out of bounds","2848":"Array index out of bounds","2013":"attempt to multiply with overflow","4707":"attempt to add with overflow","5408":"Array index out of bounds","1556":"Not initialized","4116":"attempt to add with overflow","5140":"attempt to add with overflow","2123":"attempt to add with overflow","5652":"attempt to add with overflow","5731":"attempt to add with overflow","831":"Not initialized","508":"Not initialized","185":"Array index out of bounds","3958":"Array index out of bounds","4604":"Array index out of bounds","4336":"Array index out of bounds","3501":"Array index out of bounds","5549":"Array index out of bounds","4391":"Array index out of bounds","3044":"Array index out of bounds","4580":"attempt to add with overflow","3422":"Array index out of bounds","405":"Aztec Passport: Invalid Address","82":"attempt to add with overflow","1295":"attempt to add with overflow","2508":"Array index out of bounds","192":"Array index out of bounds","4666":"attempt to add with overflow","3831":"attempt to add with overflow","5611":"attempt to add with overflow","4776":"Array index out of bounds","2917":"Array index out of bounds","3295":"Array index out of bounds","2460":"attempt to add with overflow","3862":"attempt to add with overflow","5398":"attempt to add with overflow","3728":"Array index out of bounds","4618":"attempt to add with overflow","1278":"attempt to multiply with overflow","4539":"attempt to add with overflow","2680":"Array index out of bounds","1845":"attempt to add with overflow","3704":"attempt to add with overflow","4728":"attempt to add with overflow","1388":"attempt to add with overflow","5374":"attempt to add with overflow","5429":"attempt to add with overflow","5563":"attempt to add with overflow","608":"Not initialized","5807":"Array index out of bounds","4058":"Array index out of bounds","3790":"attempt to add with overflow","395":"Initialization hash does not match","4491":"Array index out of bounds","5058":"Array index out of bounds","3900":"Array index out of bounds","3065":"attempt to add with overflow","5302":"Array index out of bounds","2608":"Array index out of bounds","5680":"Array index out of bounds","3742":"attempt to add with overflow","5467":"Array index out of bounds","2962":"Array index out of bounds","2127":"attempt to add with overflow","4364":"Array index out of bounds","457":"attempt to add with overflow","3852":"attempt to add with overflow","4931":"Array index out of bounds"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"},{"fields":[{"name":"address","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"},{"fields":[{"name":"address","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"AztecPassport"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"total_services","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"services","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"service_indexes","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"scores","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"BalanceModule"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"balance_registry","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"passport_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BalanceModule::constructor_parameters"}}],"kind":"struct","path":"BalanceModule::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BalanceModule::get_passport_address_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BalanceModule::get_passport_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"_registry","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"BalanceModule::set_balance_registry_parameters"}}],"kind":"struct","path":"BalanceModule::set_balance_registry_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}}],"kind":"struct","path":"BalanceModule::verify_parameters"}}],"kind":"struct","path":"BalanceModule::verify_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BalanceModule::set_admin_parameters"}}],"kind":"struct","path":"BalanceModule::set_admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BalanceModule::get_balance_registry_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}}],"kind":"struct","path":"BalanceModule::get_balance_registry_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"_passport_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BalanceModule::set_passport_address_parameters"}}],"kind":"struct","path":"BalanceModule::set_passport_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BalanceModule::get_admin_public_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"BalanceModule::get_admin_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BalanceModule::is_admin_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"BalanceModule::is_admin_abi"}]}},"file_map":{"114":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"115":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"118":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\nunconstrained pub fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"121":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_arguments_oracle_wrapper(args)\n    };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_arguments_array_oracle_wrapper(args)\n    };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"122":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"125":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr","source":"use dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT, utils::arr_copy_slice};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    let returned_message = get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    (leaf_index, sibling_path)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MSG_TREE_HEIGHT + 1] {}\n"},"126":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"127":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"148":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        value\n    }\n}\n"},"153":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"154":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"159":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"},"162":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/messaging.nr","source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse dep::protocol_types::{address::{AztecAddress, EthAddress}, merkle_tree::root::root_from_sibling_path};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    let (leaf_index, sibling_path) = unsafe {\n        get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret)\n    };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n"},"169":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> where T: ToField {\n    fn serialize(self) -> [Field; 3] {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> where T: FromField {\n    fn deserialize(input: [Field; 3]) -> Self {\n        Self {\n            pre: FromField::from_field(input[0]),\n            post: FromField::from_field(input[1]),\n            block_of_change: FromField::from_field(input[2])\n        }\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"170":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32)) + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33)\n            + (self.post.is_some() as u64 * (1 << 32))\n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some {\n                Option::some(pre_inner)\n            } else {\n                Option::none()\n            },\n            post: if post_is_some {\n                Option::some(post_inner)\n            } else {\n                Option::none()\n            },\n            block_of_change\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"174":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{poseidon2_hash, poseidon2_hash_with_separator}, address::AztecAddress,\n    traits::{FromField, ToField}, utils::arrays::array_concat\n};\n\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::mem::zeroed;\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// Separators separating storage slot of different values within the same state variable\nglobal VALUE_CHANGE_SEPARATOR: u32 = 0;\nglobal DELAY_CHANGE_SEPARATOR: u32 = 1;\nglobal HASH_SEPARATOR: u32 = 2;\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, let INITIAL_DELAY: u32, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> where T: ToField + FromField + Eq {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], VALUE_CHANGE_SEPARATOR)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], DELAY_CHANGE_SEPARATOR)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], HASH_SEPARATOR)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> where T: ToField + FromField + Eq {\n\n    pub fn schedule_value_change(self, new_value: T) {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> where T: ToField + FromField + Eq {\n    pub fn get_current_value_in_private(self) -> T {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage(self) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) {\n        let header = self.context.get_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = unsafe {\n            get_public_storage_hints(address, self.storage_slot, historical_block_number)\n        };\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        if hash != 0 {\n            assert_eq(\n                hash, SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint), \"Hint values do not match hash\"\n            );\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            assert_eq(\n                value_change_hint, ScheduledValueChange::deserialize(zeroed()), \"Non-zero value change for zero hash\"\n            );\n            assert_eq(\n                delay_change_hint, ScheduledDelayChange::deserialize(zeroed()), \"Non-zero delay change for zero hash\"\n            );\n        };\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field {\n        let concatenated: [Field; 4] = array_concat(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UnconstrainedContext> where T: ToField + FromField + Eq {\n    unconstrained pub fn get_current_value_in_unconstrained(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    unconstrained fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, let INITIAL_DELAY: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) where T: ToField + FromField + Eq {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"176":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"221":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"},"230":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE: u32 = 4;\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // We choose the last SELECTOR_SIZE bytes of the hash to avoid getting the first byte that is not full\n        let hash_bytes = hash.to_be_bytes::<SELECTOR_SIZE>();\n\n        FunctionSelector::from_field(field_from_bytes(hash_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector = FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"241":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr","source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\npub struct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber { _opt: Option { _is_some: serialized[0] as bool, _value: serialized[1] as u32 } }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"263":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"276":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"277":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr","source":"mod assert_array_appended;\nmod assert_array_prepended;\nmod assert_combined_array;\nmod assert_combined_sorted_transformed_value_array;\nmod assert_combined_transformed_array;\nmod assert_deduped_array;\nmod assert_exposed_sorted_transformed_value_array;\nmod assert_sorted_array;\nmod assert_sorted_transformed_value_array;\nmod assert_split_sorted_transformed_value_arrays;\nmod assert_split_transformed_value_arrays;\nmod get_sorted_result;\nmod get_sorted_tuple;\nmod sort_by;\nmod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{assert_array_appended, assert_array_appended_reversed, assert_array_appended_scoped};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_sorted_transformed_value_array::{\n    assert_combined_sorted_transformed_value_array_asc,\n    get_combined_order_hints::{CombinedOrderHint, get_combined_order_hints_asc}\n};\npub use assert_combined_transformed_array::{assert_combined_transformed_array, combine_and_transform_arrays};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint}\n};\npub use assert_deduped_array::{assert_deduped_array, dedupe_array};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc, assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints}\n};\npub use assert_sorted_transformed_value_array::{assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N> where T: Empty + Eq {\n    let mut len = 0;\n    for elem in array {\n        if !is_empty(elem) {\n            len += 1;\n        }\n    }\n\n    BoundedVec { storage: array, len }\n}\n\nunconstrained pub fn find_index_hint<T, let N: u32, Env>(array: [T; N], find: fn[Env](T) -> bool) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32 where T: Empty + Eq {\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32 where T: Empty + Eq {\n    let length = unsafe {\n        find_index_hint(array, |elem: T| is_empty(elem))\n    };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N] where T: Empty + Eq {\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N]\n) where T: Eq + Empty {\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe {\n        find_index_hint(values, |v: Field| min.lt(v))\n    };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe {\n        find_index_hint(values, |v: Field| min.lt(v))\n    };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    pedersen_hash_with_separator_noir(input, separator)\n}\n\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator_noir(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n"},"296":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"298":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"301":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl <let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"302":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl <T, let N: u32, let M: u32> Serialize<N * M> for [T; N] where T: Serialize<M> {\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl <T, let N: u32, let M: u32> Deserialize<N * M> for [T; N] where T: Deserialize<M> {\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n"},"305":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"306":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"310":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr","source":"use crate::{constants::ETH_ADDRESS_LENGTH, traits::{Empty, ToField, Serialize, Deserialize}, utils};\nuse crate::traits::FromField;\n\npub struct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for EthAddress {\n    fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n"},"314":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"318":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\npub struct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"329":{"path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/l2-contracts/crates/passport/src/main.nr","source":"pub mod service;\n\nuse dep::aztec::macros::aztec;\n\npub global SCALE: u64 = 1000000;\n\n#[aztec]\npub contract AztecPassport {\n    use aztec::{\n        prelude::{AztecAddress, PublicMutable, Map, SharedMutable},\n        macros::{storage::storage, functions::{initializer, public, private, view}},\n        keys::getters::get_public_keys\n    };\n\n    use dep::value_note::{balance_utils::get_balance};\n\n    use dep::easy_private_state::EasyPrivateUint;\n    use crate::service::Service;\n\n    pub global SCALE: u64 = 1000000;\n\n    #[storage]\n    struct Storage<Context> {\n        // Admin of Contract\n        admin: PublicMutable<AztecAddress, Context>,\n        // Track Count of Total Services\n        total_services: SharedMutable<u64, 1, Context>,\n        // Service ID => Service\n        services: Map<u64, PublicMutable<Service, Context>, Context>,\n        // Service Address -> ID\n        service_indexes: Map<AztecAddress, SharedMutable<u64, 1, Context>, Context>,\n        //  Address => Service ID => verified(boolean)\n        scores: Map<AztecAddress, Map<u64, EasyPrivateUint<Context>, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(_admin: AztecAddress) {\n        assert(!_admin.is_zero(), \"Aztec Passport: Invalid Address\");\n        storage.admin.write(_admin);\n    }\n\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Unauthorized Admin Change\");\n        storage.admin.write(new_admin);\n    }\n\n    #[public]\n    #[view]\n    fn get_admin_public() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    #[public]\n    fn add_service(address: AztecAddress, weight: u64, base_score: u64, max_score: u64) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Only Admin\");\n        let service_id = storage.total_services.get_current_value_in_public();\n        storage.services.at(service_id).write(Service { address, weight, base_score, max_score });\n        storage.service_indexes.at(address).schedule_value_change(service_id);\n        storage.total_services.schedule_value_change(service_id + 1);\n    }\n\n    #[public]\n    #[view]\n    fn get_service(service_id: u64) -> Service {\n        storage.services.at(service_id).read()\n    }\n\n    #[public]\n    #[view]\n    fn get_total_services() -> u64 {\n        storage.total_services.get_current_value_in_public()\n    }\n\n    #[private]\n    #[view]\n    fn get_total_services_private() -> u64 {\n        storage.total_services.get_current_value_in_private()\n    }\n\n    #[public]\n    #[view]\n    fn get_service_index(address: AztecAddress) -> u64 {\n        storage.service_indexes.at(address).get_current_value_in_public()\n    }\n\n    #[private]\n    #[view]\n    fn get_service_index_private(address: AztecAddress) -> u64 {\n        storage.service_indexes.at(address).get_current_value_in_private()\n    }\n\n    unconstrained fn is_verified(address: AztecAddress, service_id: u64) -> bool {\n        let res = storage.scores.at(address).at(service_id).set;\n        let balance = get_balance(res);\n        balance as u32 >= 1\n    }\n\n    #[private]\n    fn verify_service(address: AztecAddress, service_id: u64, service_address: AztecAddress) {\n        assert(service_address.eq(context.msg_sender()), \"Aztec Passport: Only Service\");\n        let res = storage.service_indexes.at(service_address).get_current_value_in_private();\n        assert(res == service_id, \"Aztec Passport: Invalid Service\");\n        storage.scores.at(address).at(service_id).add(1, address, address);\n    }\n\n    unconstrained fn get_total_score(address: AztecAddress) -> u64 {\n        let mut total_weight: u64 = 0;\n        let mut total_base_contribution: u64 = 0;\n        let mut total_max_contribution: u64 = 0;\n        let mut verified_count: u64 = 0;\n\n        let total_services = storage.total_services.get_current_value_in_unconstrained();\n\n        for i in 0..total_services {\n            let service = storage.services.at(i).read();\n            total_weight += service.weight;\n            let res = storage.scores.at(address).at(i).set;\n            let balance = get_balance(res);\n            let verified = balance as u32 >= 1;\n            if (verified) {\n                total_base_contribution += (service.base_score * service.weight) / SCALE;\n                total_max_contribution += (service.max_score * service.weight) / SCALE;\n                verified_count += 1;\n            }\n        }\n\n        if (verified_count == 0) {\n            0\n        }\n\n        let diminishing_factor = verified_count * verified_count / (total_services * total_services);\n        let adjusted_max_score = total_max_contribution * diminishing_factor;\n        let bonus_multiplier = (verified_count * SCALE) / total_services;\n        let final_score = (total_base_contribution + adjusted_max_score) * bonus_multiplier / SCALE;\n\n        final_score\n    }\n}\n"},"331":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/address-note/src/address_note.nr","source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"},"338":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\nglobal ZERO = 0;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"6":{"path":"std/cmp.nr","source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(s, quote { Eq }, signature, for_each_field, quote { & }, body)\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"68":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"70":{"path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/l2-contracts/crates/modules/balance_module/src/main.nr","source":"use dep::aztec::macros::aztec;\n\n#[aztec]\ncontract BalanceModule {\n    use aztec::{\n        prelude::{AztecAddress, PublicMutable, SharedMutable}, protocol_types::{address::EthAddress},\n        macros::{storage::storage, functions::{initializer, public, private, view}}\n    };\n\n    use dep::passport::AztecPassport;\n\n    #[storage]\n    struct Storage<Context> {\n        // Admin of Contract\n        admin: PublicMutable<AztecAddress, Context>,\n        // Balance Registry\n        balance_registry: SharedMutable<EthAddress, 1, Context>,\n        // Passport Contract Address\n        passport_address: SharedMutable<AztecAddress, 1, Context>,\n\n\n\n        \n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(_admin: AztecAddress) {\n        assert(!_admin.is_zero(), \"Aztec Passport: Invalid Address\");\n        storage.admin.write(_admin);\n    }\n\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Unauthorized Admin Change\");\n        storage.admin.write(new_admin);\n    }\n\n    #[public]\n    #[view]\n    fn get_admin_public() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    #[public]\n    #[view]\n    fn is_admin() -> bool {\n        storage.admin.read().eq(context.msg_sender())\n    }\n\n    #[public]\n    #[view]\n    fn get_passport_address() -> AztecAddress {\n        storage.passport_address.get_current_value_in_public()\n    }\n\n    #[public]\n    fn set_passport_address(_passport_address: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Only Admin\");\n        let _ = storage.passport_address.schedule_value_change(_passport_address);\n    }\n\n    #[public]\n    fn set_balance_registry(_registry: EthAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Only Admin\");\n        let _ = storage.balance_registry.schedule_value_change(_registry);\n    }\n\n    #[public]\n    #[view]\n    fn get_balance_registry() -> EthAddress {\n        storage.balance_registry.get_current_value_in_public()\n    }\n\n    #[private]\n    fn verify(address: AztecAddress, content: Field, secret: Field) {\n        let passport_address = storage.passport_address.get_current_value_in_private();\n        let sender = storage.balance_registry.get_current_value_in_private();\n\n        context.consume_l1_to_l2_message(content, secret, sender);\n\n        assert(content as u32 == 1, \"Aztec Passport: Invalid Content\");\n\n        let index = AztecPassport::at(passport_address).get_service_index_private(context.this_address()).view(&mut context);\n        let _ = AztecPassport::at(passport_address).verify_service(address, index, context.this_address()).call(&mut context);\n    }\n}\n"},"77":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\nunconstrained pub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"86":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe {\n            unpack_returns(self.packed_returns)\n        };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"90":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](()) -> T {\n        self.original\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](()) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](()) -> () {\n        self.original\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](()) -> T {\n        self.original\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](()) -> () {\n        self.original\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"92":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn () -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        panic(f\"'delegate_call_public_function' not implemented!\")\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained pub fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"93":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"}}}