{"transpiled":true,"noir_version":"0.35.0+b848cc128d2dc2b461581f21a35509a1af9065a7-aarch64","name":"BiometricModule","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"12265343917440897559":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":6,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"7b3RrvQ4dqX5LnntC5HaoiS/ymDQKHe7GwUUyg27eoCBke/ekSf+UOhYNOlTYlBL5HdjVLmUkdzfOhFca5Mi//23//HP//R//td/+/Nf/+e//Ntv//j//Ptvf/mX//6nv/35X/76+G///vs//PZP//rnv/zlz//rv+3/378Nf/wfG7+e/7f//ae//vFf/+1vf/rXv/32j6P9w2///Nf/8fgP6+Of/p9//ss///aP8/D7//sPv5n97Hk3LT/9B9Yf/gPB/+Af+IfDg7P/9eA8bw9O6/OTx499sn3sk6ePfXL42CfPH/vk5WOfvH7qk+fhY5/sPvbJH/sOzh/7Ds4f+w7OH/sOzh/7Ds4f+w7OH/sOzh/7Di4f+w4uH/sOLh/7Di4f+w4uH/sOLh/7Di4f+w4uH/sOLh/7Di4f+w6uH/sOrh/7Dq4f+w6uH/sOrh/7Dq4f+w6uH/sOrh/7Dq4f+w6un/oO+mH42Ce7j32y/9gnjx/7ZPvYJ08f++TwsU+eP/bJy8c++WPfQfex76D72HfQfew76D72HXQf+w66j30H3ce+g+5j30H3se+g+9h30H/sO+g/9h30H/sO+o99B/3HvoP+Y99B/7HvoP/Yd9B/7DvoP/YdHD/2HRw/9h0cP/YdHD/2HRw/9h0cP/YdHD/2HRw/9h2czikYhu3RMMzh/fAceXhcwvT63GV5D8XbcyimM5RJZyhBZyizzlAWmaEEV28o0zz/enZa3p/r1+U5kopfoDAM27PhOJJJZiRBZiSzzEjOfnncbiRzeiRmr++O2ftzx3F8jmRVGcnJ9e6SI3EyI/EyIxllRmIyI5lkRhJkRjJ/aiRfn7589NPXT376Mnz0091HP91/9NPHj366ffTTp49+evjop3/0u7p89Lu6fPS7un70u7qe/a4u4/bpD0N5JjqtXmcoo85QTGcok85Qgs5QZp2hnPyZc+9Q6abw91qvyLODf3UqbPjjX71F0Fh7cg6/nl2G3aNT7HP9uo3Bpx99yLT8etavq70fDrHGyuBemkzD6PYPf2Fewfx5zOPJjT5g/i9idmCugdmDuQbmEcw1MFtnmLdFU5vH/aNfMCZgvGEEYLxhzH3BePxqbD8a/gCjs3SShtFZhkjCcJ05/cm/Hp38fIDRmR9Pw+jMNadhdOYzpm0Mkx1hdDabhOll3sPsDjA6m02SMLzqbOKmV6Qyt7o9jK9hq/7uO5tTw1b9hXbjmhq2ap8gM2y757B7S8jXdGV8b9n7IsydpfqrMLOaWQUzq5k1MI+sZlbB3NtqZqr9PPa25piE0dvKYBKG0X5+w+itr5aE0VmGSMPobf0u1X4ee1u/S8Lobf0uBcN6W6VJLUxYZ7NJshdvnc0maRiqs0l6YcJUf/fTCxOm+gudbpVPsqtX6WHLrl6lh82u3BpdmYlduVUwG5hrYGY1swpmVjOrYGY1swrm3lYzU+3nqbc1xxSM0NvKYBJGb7ufU+3n0FtfLQmjswyRhmG0n98welu/S8Lobf0uCaO3VZrUwsTc2WyS7MXPnc0maRiqs0l6YWJW/d1PL0zMqr/Q6Vb5LLt6lR627OpVetjsyq3RlVnYlVsFM2cMVcHMamYVzKxmVsFsYK6BmdOL3klo4fSiHYzeVgaTMDi9aAeD04veMNbeTi9KwuD0oh0MTi/aweht/S4Jo7dVmtTCRG/naad68dbbqddpGLK7ylMLEyZ71nNyYcJkz05OtsptsHsOW3b1Kj1s0ZnrsYj5sqWPNZ//eDWGqZ7Emxu2aOrMDVt0Rs8MW/Uc2tywRWfJ3LBFZ8ncsEVnydywRWfJ3LBFZ8ncsO85S7p7zpKqZwHnhn3PWVL1fN3csO85S6qer5sb9j1nSdXzdXPDvucsqXpebW7Y95wlVc9TzQ37nrOk6nmfuWHfc5ZUPekyN+x7zpKqp0fmhn3PWVL1RMbcsFVnycW9FkHGZb8d7tewVWfJzLBVZ8n0sO3sLLm8Pj14c+lhu9Veq5J+cO+btkdnsacHN7/W+Nzg3fjt+a+xuxuP3d947OONx243Hvt047GHG499vvHYlxuPfb3v2Kcbz6uT8Lzq3foe++hzzzv3ckrOhfdrGuOvQoUn4bKFCs/YZQu1Zgq19fXpj/84HwoV9gJlCxU2DmULFXYZPyw0vB8PFg6FCluSsoUK+5eihQZhs1O20HacUabQdpxRptB2nFEIy1boshwKtV4KbccZZQptxxllCm3IGaULbcgZpQttyBklC50bckbpQhtyRulCG3JG6UKV59F9B3OZfv+PHcxZ+If0sUy7jX3cvYv79zz/Vavwb+kPa52n7e93ng8NkkX4t7RsocK/pWULtWYKXbaja9yye2dzjD28jK8W9rIr8cVE2Ox+kMnjA7fJaJjcgUo7P+g/opJe7Vja+ekvSGVtZ54oSaWdSaUkFWE3fyEV4abohVQMKhEqwjHxQirCvdliVL4K7cGufhXajAP1w7CdXftoGR0KbcZUpgudhmZ8Yq7Qk9bPz8Or0HF3MHK0UO+2s469n/LdrcxexOnsSV6Xjn288djtxmOfbjz2cOOxzzce+3Ljsa/3HfvZE78uHfuN51UnPK+W3BE+OeFJuGyhwjN22UKFp/eSO8InJ+wFyhYqbBzKFirsMkpuq52csCUpWqgX9i9lCxU2O2ULbccZZQptxxllCrV2Ck1t2Zt8O84oU2g7zihTaDvOKFNoQ84oXWhDzihZ6NiQM0oX2pAzShfakDNKF9qQM0oXqjyPpvf4T6PwD2nhPf6TCf+WltwRPpnwb2nZQoV/S8sWKpxJLtrjP5mw2b1sj/9k7fygl9tJOE3t/PSXpNLOPFGSSjuTSkkqwm7+QioGlQiVPt1KjopwTLyQinBvtuTW92nqwa5+FdqMA83sCA/NmMpcoc34xFyhH/uJ/vr0+aOfvnz009dPfvo8fPTT3Uc/3X/000/abhteP9XBbEh/9Zx7b7vyu0su4ldiPCa0170pU/C5N3cGezct5sw4fnTN96PD/Xp4/8F+jTw8z6/6lmH36BT7XL/dHr4TJfqoX+ftN2Vd3wbHhxi1Yft5m4b9RSLhKbchd09yT8jdk9wBuXuSe0bunuRekLsnuVfkvkTurflk87h/9A9Rzp5uiCifEMUhip4oHlGuEOUxq2yTij+IQrdHUBRDFD1R6JxcI4p/PTr5+SAK/Q1BUehC6ImyklOuEWUbw2RHUXBfl4gSptd4w+wOohii6ImC+0qL4qZX69DcbofUQ5QvfPikDD6bU/hwNBl845rCxzrFKXz0/U/gCwPO95L5/JpVsjDQ++9KblYVupKbxNyV3IbcPclNyu9KbroS18id2KYRBnodgqLQQREUhb7MJaKktmkER7dHUBR6MoKi0Dm5RpTENo3g6G8IimKIoicKOeUaURIbmoLHfV0iSmrvTPC4L0FRcF9pUZIbmoLHJ2XwpTY0hbNXq3S+pcSzTnEKH33/U/hwvpfM5xetknl6/13JzapCT3KPJOau5CaLdyU3Kb8ruelKXCN3apvGaIiiJwodFEFR6MtcIkpym8ZIt0dQFHoygqLQOblGlNQ2DaO/ISgKXQhBUQxRLhEltaHJcF+XiJLcO2O4L0FRcF9pUdIbmiZ8UgZfckPThKPJ4EtuKZlYpziFj77/KXwGvivm84tWySZ6/13JzapCV3KTmLuSmyzeldyk/J7kDnQlrpE7tU0j0OsQFIUOiqAo9GUuESW5TSMYouiJQk9GUBQ6J9eIktqmEehvCIpCF0JPlJmcco0oqQ1NsyHKFaIk987MuC9BUXBfaVHSG5pmfFIGX3JD04yjyeBLbimZWac4g2+h738KH843OYpxttcoxnnZeVR74qOXfgofXe9T+Ax8Z/CRZU7hI3WcwkfqOIWP1HEKH6njDL6V1HEKH6njFD5Sxyl8pI5T+Ax8Z/CROk7hI3WcwkfqOIWP1HEKH6njBL55IHWcwkfqOIWP1HEKH6njFD4D3xl8pI5T+Egdp/CROk7hI3WcwkfqOIPPkTpO4SN1nMJH6kjjW9xrc+647I9F+IWP1HEKn4HvDL5GUofbzil5/Fu+jeOrykbCQabKRlyUH/320bNlHl7tNQ4/uOU9DmfRb5mbx+1r5t347fk/GPpGrNSlDBvxU5cybMRUXcqwEWd1KUOD4WmGjXisSxk24uAuZdhIj/dSho00ei9lSE45zbCVq94/ydC79c1w9LnnnZu2cB3eQxl/ASfUVAZOAqoMnLhUGri9q7R1PgA3gNcFThCrDJzUVhp4eD8eLByAE/EqAycPVgZOeKwLvJVLt+8DnKRZGThJszjwsG1UCMtyAE7SrAzcAF4XOEmzMnCSZmXgJM3KwEmalYGTNOsCn0ialYGTNCsDN4Bnge93PizTt+e/GGI8sgwf49sYjrt7W/6e57+Y4z1KM5+n7Xdlng8LZ61cjXwb4K1cTnwf4PQASwNftutr3bK7R2KMPbyMr61Ayw71SxuaKVdq8/jA97ugkzuogwG6VJ30LrpWbo9sVB18lbA6MyZMWR26RcrqsIlBWR3SjrI6hjrC6rCXop46X8CJ/5WBk+gLA/fDsGyf7o/ACemVgZO76wJv5drbFtvrrdype9v2+jBsn+2O6uB+lNXBKimrg6+6Vp3kwmErN8q2qU4rF9Y2qg6LH8rqkHaU1SHvKKtjqCOsDosfyurQK7hWnWlbOBzC4W2bVm5SblQdegXK6tAr0FVnaeWa6UbVoVegrA69AmV16BXI5J2IOoY6sml0aeUG8UbVoVegrA69AmV16BUoq0OvQFidVi6Hb1QdegXK6tArUFaHXoGyOoY6wurQK1BWhzSqrA5pVFkd0qiwOp40qqwOjjqvjnu/ATXuX4FyvxgaDE8zxJ2eZ8h603mG+PDzDHHL5xniaU8zHHGe5xmyWnGeIWsK5xmSU84zNBieZkhOOc+QnHKeITnlPENyynmG5JQsQ/8e9jAOa+755Nm4ixFqSgP3fru2yO+b77+Ak4AqAycuVQZOtqoM3ABeGnhw21CW46SJWy4N3N6P23r8C8daVwaOD68LnKvLiwMP74u3g4UDcHx4ZeD48MrA8eGVgRvA6wJn9aQycJZaKgMnaVYGTtKsDJykWRd4IGlWBk7SrAycpFkZOEmzMnADeGngYXuvLSyHcwsDSbMycJJmZeAkzcrASZqVgZM06wKfsYWlgdt2Z7Mz/20R+fhw6grhZWZ+vVKbzDEKM5OxsjrM3Jeqk97RPjPNC6uz0H1WVodWtbI69LWV1SHtKKtjqCOsDu11ZXXoFSirQ69AWR16Bcrq0Cuop84fwFfif2XgJPrKwAnplYGTuysDN4DXBU46Lg7cthPybTpsr1wJvJWBk2ErAyeWVgZO0qwKfB1ImpWBkzQrAydpVgZO0qwM3ABeFzhJszJwkmZl4CTNysBJmsWBp04SXAeSZl3gjqRZGTjB5xTwL4ZkmfMMDYanGZI4zjPEYhWfgAq9Z7tymfzFb3IO7wuH3EEdj5NQVgePoqyOoc6l6qTeUV89vkpZHdq+yurQI1ZWh7SjrA55R1idkVa1sjrsoFJWh17BtepM25ucQ1gO6tArUFbHUEdYHXoFyurQK1BWh16Bsjr0CpTVoVcgk3eO6hi9AuE0avQKlNWhV6CsDr0CZXUMdYTVoVegrA69AmV16BUoq0OvQFkdegXC6kz0CpTVoVegrA5pVFkdQx1hdUijyuqQRoXVCbquIPh5U2ddMx/9ePr10dP6TcqvKnU78SWr1P0d/EmV3tnrL9Z7P+UeduP28DRnv2lu3o6pGbwbvz3/xVD31+o+DHU7XPdhqNuHug9D3W7RbRjOuj2d+zBsw2Ndy7ANB3ctQ90e030YGgxPMySnnGdITsl3Vdz6Zjj63PPJSwLXmVBTGTgJqDJw4lJp4OkTTBeyVWXgBLHKwEltpYGH9+PBDuesL0S8ysAN4HWBEx4rAydpVgZO0qwMnKRZHHjYNp2E5fBS8ULSrAt8JWlWBk7SrAycpFkZOEmzMnADeF3gJM3KwEmalYGTNKsC/+MuDYhnie+3PizTt+efELEeWYiP8W0QRzv3/BO6Ab0w9HnaflrmeT7+VuA/ahPHgNQmTiewNPFl3t4RW9Zv7/sdH05dWugG4Rt2exAn/ebmQx5s0KXyJHfTPeQx5FGWB3clLQ9WTFoeOkfS8rCjQVoeUo+yPJ4mrbQ87K2oJ8+TOI2A2sTJ9oWJ+2E7NMsPPkLcIF6ZOAm8NnFiwZXGJt1tF74zu49u+zBsn+2O8ghf/Is8f/yrkUdZHkOeS+VJLyUK3/2LPI//lcUQaXlYDJGWh9QjLQ+5R1ke4QuAkechD4sh0vLQNbhWntTV8w956BpIy2PIoywPXQNpeegaSMtD10BaHroG0vLQNZDJPRF5hK8CJpb+8f9CHmV56BpIy0PXQFoeQx5leegaSMtD10BaHroG0vLQNZCWh66BsjyBroG0PHQNpOUhlkrLY8ijLA+xVFoeYqm0PBjrvDzu/YrUuH9H6nXE7oz9LQARk1oAIgtQBSDixwtANCCeh4i3LQARB1oAIssXBSCyyFAAIonlPMSFxFIAIomlAEQSSwGIJJYCEA2I5yGSWLIQ/XvYwzisueczp+ouxJvSxL3f7j7y+3b8izhZqDZxglNt4qSsysRXIllx4sFtVS7HmZOb0IsTt/fjtkb+xg3ilYnjx2sTx4+XJh7eV3kHC0fi+PHaxPHjtYnjx+sSdwN+vDZx1lNqE2fxpTZxMmdt4gbxysTJnLWJkzlrEydz1iZO5qxNnMxZmbgjcxYnHrb338KyHImTOWsTJ3PWJk7mrE3cIF6ZOJmzNnHcYWnitt0C7cx/W1k+Ppy8k9h5JtkrxcmcuvDAhDzK8hjyXClPese788z10vLQjJaWh861tDy0uaXlIfUoyzPSQJeWh267tDx0DaTloWsgLY8hj7I8dA3qyfMkTiOgNnGyfW3ixPXaxEnglYkbobo2cXJyceK2nbFv03HnpRF9axMnzdYmbhCvTJzMWZs4mbM2cTJnbeJkztrEyZyViU9kztrEyZy1iZM5axMnc9YmbhAvTTx5/qCbyJy1iZM5axMnAZ0i/oRIqDkPMZBTCkAkehSAaEAsPQsVex+XS+ovFccNw/veIheRBz8hLQ9ORVmeGQ90rTzpt9ln3JW0PHSBpeWhZSwtjyGPsjzkHml56FxLy8PWKml56BpcK8+0vfA5hOMBhTNdA2V5FroG0vLQNZCWh66BtDx0DaTlMeRRloeugUzuiclD10A5li50DaTloWsgLQ9dA2V5VroG0vLQNZCWh66BtDx0DaTlMeRRloeugbQ8dA2k5aFrIC0PsVRYHj8QS6XlIZZKy0MslZanDWPtwrCtOgbv9w8/y2yjMe+WbciPbmluHKu9xvH4kVyyf4Vu3k57Gbwbvz3/hNiGT7kWomvDTVwMsY05/2KIbczMF0Nso617MUQD4nmIjTi5ayG20ci8GGIb7caLIZJYCkAkseSbD259Qxx97vn0TXzeE29qEycL1SZOcCpNPH0mqPekrNrEDeKViZPfShMP78eDhSNxwl5t4iTD2sSJkbWJkzkrEx/JnLWJkzmLEw/bPo2wLEfiZM7axMmctYkbxCsTJ3PWJk7mrE2czFmbOJmzNnEyZ2XiRuasTRw/nie+3xCxTN+ef0LEfmQhPsa3QRxtPvX8EzoOpDT0edp+Wub5uJZmOJDaxHEglYk3csO4EvFlfiFxy/rtXbnjw8k7AX0jFzXfVZzcW4+N3Op8W3kyG+wmDJO0PLgraXmwYsryNHKreLPysLVBWh5Sj7Q8NGml5THkqSbPkziNgNrEyfaFifthO3DKPxb1jsSJ67WJk8BrE28kVK/uTXxx6Yd/eoxd9nX8uZHoey3ERgLqtRAbiZHXQmwk7F0L0YB4HmIjKetaiI0Ep2shNpKFroXYSLy5FiKJ5TzERi6y/yjEsocrNXI3/Z2Ik4VqEyc4lSaeOVypkUvh70ScSFabOPmtNPHMMSiN3MZ+J+Ikw9rEiZGViTdyDfqdiJM5axMncxYnnn59vpH7x+9E3CBemTiZszZxMmdt4mTO2sTJnLWJkznrEh8bueP8TsTJnLWJG8SzxDMHiI0D9iMLsfQBYmMrt5cLQU8frjS2ctX5fYi3ci/6jYjTESxNvNgBYmMrFxHfVJzMAWJjK1cc31We9Aa7sZXLk1uVB3elLE8rdzi3Kg+dI2l52NogLQ+pR1oeQx5ledhhUU+eJ3EaAbWJk+0LE88crjS2ckn1jYiTwCsTb+UC3ya77a3c9XvbbvswbJ/tIvLggaTlwTBJy4O7ulae9FJiK3e3NipPKxe9tioPiyHS8pB6pOUh90jLY8ijLA+LIdLy0DW4Vp5pW0ocwvF1nFZuRW9VHroG0vLQNVCWZ6JrIC0PXQNpeegaSMtD10Am98TkMeQRjqUTXQNpeegaSMtD10BaHroG0vLQNVCWJ9A1kJaHroG0PHQNpOWhayAtjyGPsjx0DaTlIZZKy0MslZaHWKosz0wslZYHY52Xx71fkRr370i9jtidDYjnIWJSC0BkAaoARPx4AYi45gIQ8bbnIS440AIQWb4oAJFFhgIQSSwFIBoQz0MksRSASGIpAJHEUgAiiaUARBJLFqJ/D3sYhzX3fOZU3ZV4U5q499vdR37fjn8RJwvVJk5wqk2clFWbuEG8NPHgtiqXyMyJay5N3N6P2xr5G8di1yaOH69L3LgNvTjx8L7KO1g4EseP1yaOH69NHD9em7hBvDJx1lNqE2fxpTZxMmdt4mTO2sTJnJWJOzJnbeJkztrEyZy1iZM5axM3iJcmHrb338KyHImTOWsTJ3PWJk7mrE2czFmbOJmzMnGPOyxN3LZboB94v60sHx9O3klsnkn2SnEypy48/nnkUZaH6ftSedI73s0z1yvLM9KMlpaHzrW0PLS5peUh9UjLY8ijLA/ddml56BpIy0PXQFoeugbS8tA1qCfPF3GjEVCbONm+NnHiem3iJPDaxA3ilYmTk4sTt+2MfZuOOy+N6FubOGm2NnECam3iZM7KxCcyZ23iZM7axMmctYmTOWsTN4hXJk7mrE2czFmbOJmzNnEyZ3Hi6fMHJzJnZeKBzFmbOAnoFPEnREJNAYgGxPMQiR4FIOK0is9Cxd7H5ZL6S8Vxw/C+t8gd5ZnxE9Ly4FSk5THkuVSe9NvsM+5KWh66wNLy0DKWlofUIy0PuUdZnoXOtbQ8bK2SloeuwbXyTNsLn0M4HlC40DWQlseQR1keugbS8tA1kJaHroG0PHQNpOWhayCTeyLyrHQNlGPpStdAWh66BtLy0DWQlseQR1keugbS8tA1kJaHroG0PHQNpOWhayAszzTQNZCWh66BtDzEUml5DHmU5SGWSstDLJWWpxFjvYxveYbcOFZ7jcMPbsnK8xjfWx7LyrnMLyRuWV1anuSbpZNrxFbfVJzMu3GTa8S3tSqPIY+yPI34ttvKkzYGrhHf1qo8jSwntCpPI8sJrcpD6lGWx5N7pOVpZDmhVXka2YTYqjx0Da6VJ/l+wuQNeZTloWsgLQ9dA2l56BpIy0PXQFoeugbK8ox0DWRyT0weugbKsXSkayAtD10DaXkMeZTloWsgLQ9dA2l56BpIy0PXQFoeugbK8hhdA2l56BpIy0PXQFoeQx5leYil0vIQS6XlIZYqyzNhrPPyuPcrUqP7/uLvEyL2twBETGoBiCxAFYBoQDwPEddcACLetgBEHGgBiCxfFIDIIsN5iIHEUgAiiaUARBJLAYgklgIQDYjnIZJYCkAksWQh/vAgQee2FypcsN//Ywc3EG9KE/d+3arct+NfxMlCtYkTnCoTn0lZtYkTyYoTD26rcjnOnLNBvDBxez9ua+RvHItdmzh+vDZx/Hhp4sFtM2ewcCSOH69NHD9emfiCH69NHD9emzjrKbWJs/hSm7hBvDJxMmdt4mTO2sTJnLWJkzlrEydzVia+kjlrEydzFicetvffwnI873Alc9YmTuasTdwgXpk4mbM2cTJnXeJhwB2WJv6TK6OTdxKHgUn2SnEypy6EgRlZWh6m70vlSe94DwNzvbQ8NKOl5aFzLS0PbW5leRypR1oeGujS8tBtl5aHroG0PIY8yvLQNZCWh65BPXmexGkE1CZOtq9NnLhembgngdcmTqiuTZycXJy4bWfs2xSOxIm+tYkbxCsTJ6DWJk7mrE2czFmbOJmzNnEyZ2XiI5mzNnEyZ23iZM7axMmctYkbxCsTJ3MWJ548fzCMZM7axMmctYmTgE4R/4JohJoCEMkpBSASPQpAxGkVn4WKvY/LJfUXv/A5vO8tchF58BPK8nBJvbY8eKBr5Um/zT7hrqTloQssLY8hj7I8pB5pecg90vLQuZaWh61V0vLQNbhWnml74XMIxwMKA10DaXnoGkjLQ9dAWh66BtLyGPIoy0PXQFoeugYyuScmD10D5Vga6BpIy0PXQFmema6BtDx0DaTloWsgLQ9dA2l5DHmU5aFrIC0PXQNpeegaSMtD10BZnoVYKi0PsVRaHmKptDzEUmV51ppzj582hn7xGXnG9yCW9yjctMaGsbwAzja+n43is219cnLu27NPIA4g34F4gHwHMgLkOxADyHcgE0C+Awm9AZnc5i2mJfOse8zMrxF/PfHrae/dL3wz+M7gW8B3Bl/NTQ1+9Zu33V/0FMXnBjdvJ9QN3o3fnPMfg5+H4c6Dd3cevL/z4Mc7D97uPPjpzoMPdx78fOfBL3ce/J1nWCc8w3q3vgc/+m+Djzmh5C2TsxOejgtXKjx3F65UeKL/YaXpc1XnqjcMX1upsIUoXKmw3/hhpeH9eLBwrFTYnBSuVNjJFK5U2PaUrdS345FylbbjkXKVtuORQtjWiMOyHCttxyPlKrVuKm3HI+UqbcgjZSptyCNlKm3II2UqbcgjpSsdG/JImUob8kiZSpXn031jc5l+PzQ2R+Gf08f/fxv8aHNOpuTzz2KFf1F/WOw8bX/C83zsmYzCv6hlKzXhX9TClQonlB9Wuszbpy/rt/26x4eT95LMJmx8Pwgls+N5tnZ+1n+EJbMQYu1MAEWxtDNblMQytTO1FMUi7OyvxCLcKr0SS5+uJYvFwBLDItyxLYblWWkPxvVZaTNe1A/bS4n+0UQ6VtqMvcxW2oxjzFU69+mN06l76dQZp+8RnJdOvU4Oi4ElhqUHr/Pz1tVCRy+KpdOOXg5Lpx29HJZOO3oZLGuvviWDpdOOXg5Lpx29HJZeXW7yzo+57gEh98HSq8vNYOnV5Waw9OpyM1h6dbkZLL263CSWRfk4kFq+JYYFlxuxc4vyESZXYunV5WawGFhiWOjlRrHQy41ioZcbxUIvN4qFXm4Mi/KRPFdiweVGseByo1gMLDEs2LkoFuxcFAt2LoZF+TyY0b235ozu+2UUz8ErT6PZwStPdtnBKzdesoNXnk+zg1ee9bKDV56bsoNXnkGyg1eO7dnBK4fr3OCVTxPJD/7OM+x45xl2vPMMq3zaSn7wd55hR+Uzxn52uVz6LcRF+VCcH1bq/XamiLf5WKnyGWNlK1U+Y6xopcon4hSuVPmMsR9WGtxW6XL8RTLhWe+nF3smT/teTPnMzrKVtjOf5iptZz5Nn5e8KB8wVLjSdubTTKXKxwAVrrSd+TRXqfK55mUrVT7XvGyl1k2l7XikXKXteKRcpd14JOVTcgpX2o1HCt14pNCQR0qea76EhjxSptKGPFKmUuum0oY8UqbShjxSutK5nVnGtlPnnPlvHbPjw8mz2Ja5nR+vn0DJ7T6c2/mlK4qlofb6T7BkVnznhnrxJbG0E0qLYmknwRbF0k7cLYlF+bDUK7G0E6SLYmkndRfF0qnLzWExsMSw4HKjWHpwuc9KezCuz0p78KLPSnuwl1+VKh9TW7jSHkzgs9KGfJ1t7xTbdFwhUz4ftnCl1k2lDRmqTKUNeaRMpQ15pEylDXmkTKUNeaRkpavyIaeFK23II2Uq7cUjrcqnixau1LqptJc3l1blYz0LV9qQR8pUelPn8DV45bMg84O/6fz+HPxNp+zn4PtcJkjuJ1uVD/n76Map5G2Nq+t0c0MGi/Ihf1di6XRzQ3r34ap8MOGVWNjCG8ViYIlh6XRzQw5Lr74lg6XTLbw5LJ1u4c1h6dXlJm9UW5UP2rwSS68uN4OlV5ebwdKry81gMbDEsPTqcjNYcLlRLLjcmJ1r6HjXolh6dblpLA0dHFsUC73cKBZ6uVEs9HKjWAwsMSz0cqNYcLlRLLjcKBZcbgxLQ+cWF8WCnYtiwc5FsWDnolhqTtDuXacfXQbLNC2vmzSm4F3mowd7lzlnxmH26syZrZlRPOqbXw/vP9ivkYfn+VXfMuwenWLVbWOYdvehPB59qjKjyiWqhNej0xyOqiyoIqjKiip6qlQ9RxpV/quqOFQRVMWjiqAqI6oIqmKocrEqy3RUZUIVQVXI9hepsmX7NaIK2f4aVaYlpQrZXlEVsr2gKjPZ/hJVgt+4+eWoCtleURWyvaIqZHtFVQxVLlHF2abKelSFbK+oCtleURWyvaIqZHtFVcj2gqosZHtFVcj2V6syHvPKQrZXVIVsf5Eq48YtooqhyiWqDFNKFbK9oipke0VVyPbXqLKtRYbZHVUh2yuqQrYXVGUl2yuqQrZXVIVsr6gKeeUSVdJvq67klWtUSb4psZJXFFUhryiqQl6RU8UPA3lFURXyiqIq5BVFVViLvFqVw3uRD1UMVQRVIdtfpMp//rbqQxWy/TWqJN7Ae6hCtldUhWyvqArZ/hJVUu96+cGR7RVVIdsrqkK2V1SFbH+NKok3JR6qGKoIqkK2V1SFbK+oCtleURWyvaIqZHtBVTzZ/mpVxmNe8WR7RVXI9hep8p+/rfpQhWx/jSqJN/AeqhiqCKpCtldUhWx/jSqJ91ceqpDtFVUh2yuqQrYXVGUk2yuqQrZXVMVQ5QpVUm+rPlQhr1yjSvJNiZG8oqgKeUVRFfKKoirkFUFVjLyiqAp5RVEV1iKvViXyXqSxFqmoiqHKNaqk3lY1sv01qiTfwDOyvaIqZHtFVcj2l6iSftfLyPaCqkxke0VVyPaKqpDtr1El+abERLZXVMVQRVAVsr2iKmR7RVXI9oqqkO0VVSHbX61K5L3IQLZXVIVsf5EqqbdVA9n+GlWSb+AFsr2iKoYqgqqQ7a9RJfn+SiDbK6pCtldUhWyvqArZXlCVmWyvqAp55RJV0m+rzoYql6iSfFNiJq8oqkJeUVSFvKKoCnlFURXyiqAqC3lFURXWIq9WJfJe5MJapKIqZPuLVEm9rboYqlyiSvINvIVsr6gK2V5RFbL9Jaqk3/VayPaKqpDtBVVZyfaKqpDtr1El+abESrZXVIVsr6iKoYqgKmR7RVXI9oqqkO0VVSHbX61K5L3IlWyvp4obyPYXqZJ4W9UNZPtrVEm9gecGsr2iKmR7RVUMVS5RJfX+ihvI9oqqkO0VVSHbK6pCtldUhWwvqIo7mVf8PGydA/NpGo9/2yvQej+939EcnUVBPzhtpEfLPr/Mrz8Qt6w7zWMPL+NLmGVX4uPRJ5SxSyiPRs+wfbaLYAlgiWGZwRLDsnSKZXzPD5M7YlnBEsHiB7DEsDiwxLD06VqyWHr1LRksBpYYlgksMSy9utxp2j47LEcsvbrcDJZeXW4GS68uN41l7NXlZrD06nIzWHp1uRksuNwoFgNLxM6NuNwoll5dbgZLry43g4VebhQLvdwYFqOXG8VCLzeKhV5uFAsuN4rFwBLDgsuNYsHORbFg56JYsHMxLBN2LopFeYJ27605435vjnsNXnkazQ5eebLLDl658ZIdvPJ8mh288qyXHbzy3JQbfFCeQbKDV47t2cErh+vs4O88w569IPXawd95hg13nmHDnWfYcOcZNgjPsP79OtMwDmvueee2BfTH79AhuczC0/EPK/V+fT3u9/HvVanw3F24UuGJvnClwq6gcKXWTqXBbZUukV8k4Vnvh5Xa+3FbI5oKT5GFK21nPs1UurQznwa3/SIFC8dK25lPc5W2M5/mKm1nPs1V2s58mqtUOL8XrlQ47BeutB2PlKu0HY+Uq7Qdj5SpdO3GI63deKS1G4+0duORzt63oFRp2PZvhOX4vszakEfKVNqQR8pU2pBHylTakEfKVNqQR0pW6od2ZhkbtkrNf+uYHR9OnsXmh3Z+vH4CJbP70A8NdcxLYmmovf4TLOkVXz801IsviMW1E0qLYmknwRbF0k7cLYqlT9eSxWJgiWFpJ3UXxdKpy81h6dTl5rDgcqNYenC5X5Uqn5ZbuNIevOiz0h7s5bPSHhzjs1LrptKGfJ1t7xTbFI6VNmTVMpU25L4ylTZkqDKVNuSR0pUqn7VauNKGPFKm0oY8UqbShjxSplLrptJuPJLy6aKFK+3GIymfAVr0fR6vfKxn2UqVT+osXOlNncNz8Dc1A8/B250Hf9Mp+zn4PpcJ0vvJlA/5++jGqeRtjX7qdHNDDkunmxtyWG76m34aS3r3ofLBhFdiYQtvFAtbeKNYOt3ckMPSq29JY1E+WvJKLJ1u4c1h6dXlJm9U88oHbV6JxcASw9Kry81g6dXlZrD06nIzWHp1uRksuNwYloZObC1p5xo63rUoll5dbgZLry43g8XAEsNCLzeKhV5uFAu93CgWerlRLLjcGJaGzlEuigWXG8WCnYtiMbDEsGDnoliwc1EsJydot8wvLN5cGotb7VWnH9ySxfLBK0/TO+fOHuF7Uyi5vVBnz4ZtFYuBJYZl6hRL+gf37BG1rWKZwRLDsoAlhqVP15LBMg69+pYMFgeWGBYPlhiWXl1ucr/COBhYYlh6dbkZLL263AyWXl1uBkuvLjeDpVeXm8bicLlRLLjcmJ1zuNwoll5dbgaLgSWGhV5uFAu93CgWerlRLPRyo1jo5caweFxuFAsuN4oFlxvFYmCJYcHORbFg56JYsHMxLKPyBO3eW3NGdzwwbxyVp9Hs4JUnu+zglRsv2cErz6fZwSvPetnBK89N2cErzyDZwSvH9uzglcN1bvB25xnW7jzD2p1nWLvzDHv2DOlrB3/nGdaEZ9gfviCUvj3ykZOaqdT79fW4t/lYqfDcXbhS4Ym+bKWTsCsoXKmwhfhppcFtlS7HX6Szp2wLVZq+nWOchKfIwpW2M5/mKm1nPg1u+0UKFo6VtjOf5iptZz7NVBramU9zlbYzn+YqFc7vhSsVDvuFK7VuKm3HI+Uqbccj5SrtxiOFbjxS6MYjzd14pLkhjxS2/RthOb4vMzfkkTKVNuSRMpVaN5U25JEylTbkkdKVLu3MMsVuMR2Xdn68Cp7bNy7t/NIVxdJQe/0nWDIrvktDvfiSWNoJpUWxtJNgi2JpJ+6WxKJ8WOqVWNoJ0kWxtJO6i2Lp1OXmsBhYYlhwuVEsPbjcZ6U9GNdnpT140WelPdjLPyo15WNqC1fagwl8VtqQr7PtnWKbwrHShqxaplLrptKGDFWm0oY8UqbShjxSptKGPFKm0oY8UrpS5UNOC1fakEfKVNqNR1I+XbRwpdZNpb28uWTKx3oWrrQhj5Sp9KbO4WvwymdB5gd/0/n9OfibTtnPwfe5TJDcT2bKh/x9dONU8rZG851ubshgUT7k70osnW5uSO8+NOWDCa/EwhbeKBYDSwxLp5sbclh69S0ZLJ1u4c1h6XQLbw5Lry43eaOaKR+0eSWWXl1uBkuvLjeDpVeXm8FiYIlh6dXlZrDgcqNYcLkxO9fQ8a5FsfTqctNYGjo4tigWerlRLPRyo1jo5UaxGFhiWOjlRrHgcqNYcLlRLLjcGJaGzi0uigU7F8WCnYtiwc5FsZydoLdHg9ttpY5iebQCfz37CO7vkYxj7NnBv3jb8Me/+tfTfo08PM8vfsuwe3SKPDptY5h295A8Hn3SmDujEV6PTnM40ligsaOxQuNN4/Q5wW3RcNDY0fDQ2NEYobGjYd3SWKYjjQkaOxq9edGwedE1QqM3LzotKRq9edE0jd68aJLG0pkXDd5vrYjlSKMzL5qh0ZkXzdDozItmaFhnNNw2Xr8eaXTmRTM0OvOiGRqdedEMjc68aIZGZ140TWPtzYumafTmRd80xqPfWHvzomkavXlR9zp0KliEhnVGY5hSNHrzomkavXnRNI3evOjW+wqzO9LozYumafTmRVM0pqE3L5qm0ZsXTdPozYumafS2DpvaBTcN3a3DJnYsTAN7Avc02BO4p8GewB0Nx57APQ32BO5psCdwT6PfPYHHfV/T6ZPl26LR3Z7AxC64yfXmRVM7nSbHnsA9DfYE7mn01vtK7e2ZPHsC9zTYE7inwZ7APY3u1mETOxYmb9DY0WBP4J4GewL3NNgTuKfBnsA9DfYE7miM/e4JPO77mkb2BO5pdLcnMLELbhp786KpnU7T6WtT2qLBnsA9jd68aHL/xsiewD0N9gTuabAncEfD2BO4p8GewD0NYxfcjka/Z7NEdiwYewL3NNgTuKfBnsA9DfYE7mhM7Anc02BP4J5Gv3sCI/u+JvYE7mkYu+B2NHrzosmdThN7Avc02BO4p9Fb7yu5t2diT+CORmBP4J4GewL3NPo9myWyYyGwJ3BPw6Cxo8GewD0N9gTuabAncE+DPYF7Gv3uCYzs++rt/pQMje72BKZ2wfV2f0p6p1Nv96dkaBg0djR686LJ/Ru93Z+SocGewD0N9gTuabAncEeju/tT0jR6W4dN7oLr7Y6M9I6F3u7IyNBgT+CeBnsC9zTYE7inwZ7AHY3e7sjI0Oh3T2Bk31dvd2RkaHS3JzC1C663OzLSO516uyMjQ4M9gXsavfW+knt7ursjI02DPYFvGqG7OzLSNPo9m+W4YyF0d0dGmgZ7Avc0DBo7GuwJ3NNgT+CeBnsC9zT63RM4RvwGewJ3NHq7PyW5Cy70dn9KcqdT6O3+lAwN9gTuaRj7N3Y02BO4p8GewD0N9gTuabAncE+DPYE7GmfvyBjeNIY5Q2OaXwVOyy4xrcuvoYz1hvJIJFt4s8hQTGcok85Qgs5QZp2hLDpDWWWGcvYs/J8NZdieDZGhOJ2heJ2hjDpDMZ2hTDpDCTpDmXWGsugMZZUZiun82prOr63p/Nqazq+t6fzams6vrVX8XRmXbfvjuCy7d3Hs11hWnbFMg9BYnNBYvNBYRqGxBJl+wqQzPwed+TnozM9BZ34+exDa4HZDmTNDWV9/tvPwbsiNNvwaiukMZdIZStAZyqwzlEVnKKvMUM6euVRyKE5nKP5TQ3l+/PjZj7fPfvz02Y8Pn/34+bMfv3z249ePfvwyfPbj3Wc//rPf2uWz39rls9/a5bPf2rPnHgzLtu9tWJdTP95nDx0oOZRFZyirzFDOvutecihOZyheZygVtxL+50Opt+3D/Gt91synH/Xr/Noi4td1t5gbYk2XYdvNOw2j2z/85GxwrsJ5gnMVzgHOVTjPcK7CeYFzFc5rZ5zn1wvnNo/7R/+gMdd8/f4GNBw0djR8XzQevxzbD4c/0ugsp2RoGDR2NDrz/JPfDk3z85FGZ848Q6Mz/5ym4TrzG8nDnWfX2ZySfOVprvka7Q1oqM4pbnrlK3Or29N4jlv119/ZnBy36u+0G9fkuFX7Brlxq+bwzLh9b4n5mj7N7HvL4ldx7izlX8aZdc46nA3OVTizzlmHc2/rnMmetO9tNTJNo7c1wzSNzlb20j3psbdOW5pGZ2kiQ6O3lb1kT3rsbWUvTcOgsaPR2+pNcr3COptT0h1662xOydBQnVMy6xWm+uufWa8w1d/pTP/cZNe1MuOWXdfKjJv9u1X6NMb+3Tqce9u/exHniXXOOpxZ56zDmXXOOpx7W+dM9qQng8aORm9rhmkave2TTvakp946bWkanaWJDI3eVvaSPenQ28pemkZvK3tpGsZ6xY5GZ3NKukMfOptTMjRk95+n1ytm1V//zHrFrPo7nemfz7LrWplxy65rZcbd2Qx2VZ9mZv9uHc6cU1SHM+ucdTizzlmHM+ucVTgvnIC0S0ULJyDtafS2ZpimwQlIexoGjR2N3k5AStPgBKQ9DU5A2tPobWUvSWPtbfUmuV7R2xnd6Q59bydpZ2jI7j9Pr1fInh+dWa+QPY850z+XPd84Pe5F9iTi3LhFZ7BxtpdFHefjhaCL6um+2XGLptDsuO2m4xadhbPjFp0vs+MWnS+z4xadL7PjFp0vc+NWPUk3O+6bzpfupvOl6hnD2XHfdL5UPbc3O+6bzpeq5/Zmx33T+VL13N7cuFXP7c2O+6bzpeq5stlx33S+VD33NDvum86XqudyZsd90/lS9azL7LhvOl+qnh+ZHfdN50vVMxnHh8N+jWHZ7597jVt1vsyNW3W+zI377Hy5vD4+eHPpcbvVXquXfnDve75HZ7GnBze/lgLd4N347fnn4MOdBz/fefDLnQe/3njwpw/NvHTw7s6D93ce/HjnwdudB3/nGdaEZ1jv1vfgR5973rnXXjnngu1s069KhafjwpUKz92FKxWe6H9Yqa2vT3/8x/lQ6STsCgpXKmwhClcq7Dd+WGl4Px4sHCsVNieFK7VuKhW2PYUrbccj5SptxyPlKm3HI4WwbJUuy7HSdjxSptLQjkfKVdqOR8pV2pBHylTakEfKVGrdVNqQR8pU2pBHylTakEdKVzorz6f7xuYy/X5obM7CP6fj+B78uHuv9+95/lms8C/qD4udp+1PeJ6PPZNZ+Be1cKXCv6iFKxVOKD+sdNlOxHHLut+6EXl4GV+97WVX4gvKImx8Pwjl8YHbnDRM7oilnZ/1H2HJLIScPl2oUSztzBZFsbQztRTFIuzsr8Qi3Cq9EkufriWHZRUOjVdiEe7YFsPyrLQH4/qstBkv6odhOyH30UQ6VmrdVNqMY8xWetIE+nl4VTruTmCOVurddqiy91O+4ZXdtnj2lLBrB7/cefDrfQe/nj007NrBuzsP3t958OOdB293Hvx058HfeIZdB+EZtugm8nUQno4LVyo8d5et1AlP9EU3ka9O2BUUrlTYQhSuVNhvFN2Gu549te1GlQo7mcKVCtuewpW245FylbbjkXKVtuOR0tv7Vt+OR8pV2o5HylXajkfKVdqQR8pUat1U2pBHylTakEfKVNqQR8pU2pBHSlc6Ks+nmRcD1lH457T0iwHrKPyLWnQT+ToK/6IWrlT4F7VspSacUK56MWA1YeN73YsBq7Xzs15w3+Fq7UwARbG0M1sUxdLO1FIUi7CzvxKLcKv0QixTn64li0U4NF6JRbhjW3S7/Dr1YFyflVorlWY2ka9TM/YyW2kzjjFXafjYD/Xz4/1nP3787MfbZz9++uzHh89+/PzZjz9pw214/WoH++MujdRX0E3DNm1Pu4fjl3BM0/K6rGUKPvfaz2DvTsacGcePrh5/NL9/PWz7D/Zr5OF5fm1BW4bdo1Psc/12o/lOleijfp2335Z1fbsdH2LUhu1nbhr2V5eEX3qv6N2T3mfPm0Lvm+nt0LsrvT16d6X3iN5d6W3ofYneWzfK5nH/6FOVCVUEVQmoIqjKjCpXqPKYWbaJxR9Voe+jqArdGUFVFnoo16jiX49Ofj6qQqdDURX6EYqqkFeuUcVeKCaLqIIHu0SVML3GG2Z3VAUPJqjKigdLq+KmVx/R3G771EOVJz/cUoafzUl++JoMv3FN8mPd4hw/g98pfjjgS2b1q9bNVtYC+tKbVYa+9CY796U3qbwjvcdhIO/3pTf9iWv0TuzdeKhC10NRFXopiqoYqlyhSmrvxkMV+j6KqtCdUVSFHso1qiT2bjxUodOhqAr9CEFVHHnlGlUS+5wequDBLlEltaPmoQoeTFEVPFhaleQ+pwc/3FKGX2qf04MfvibDL7XPZBw86xbn+LEOcI4fDviSWf2qdTPPWkBfeht6d6U32bkvvUnlfelN3u9Lb/oT1+id3Lvh6XoIqjLSS1FUhQ7NJaqk926M9H0UVaE7o6iKocolqiT3box0OhRVoR+hqAp55RpVkvucDA92iSrpHTWGB1NUxVAlqUpmn5PhljL80vucDF+T4ZfeZ2KsW5zjxzrAOX444Etm9avWzSbWAvrSm1WGvvQmO/elN6m8L70NvbvSm/7ENXon925MdD0UVaGXoqgKHZpLVEnv3Zjo+wiqEujOKKpCD+UaVZJ7NwKdDkVV6EcoqkJeuUaV5D6ngAe7RJX0jpoZD6aoCh4srUpmn9OMW8rwS+9zmvE1GX7pfSazwe8UP9YBzvHDASdHMc72GsU4Lzuvar/40Vs/x48u+Dl+ZKVT/BZSzTl+5I9z/Mgf5/iRP87xM/id4kf+OMeP/HGOH/njHD/yxzl+5I9T/Fbyxzl+5I9z/Mgf5/iRP87xM/id4kf+OMeP/HGOH/njHD/yxzl+5I8z/NxA/jjHj/xxjh/54xw/8sc5fga/U/zIH+f4kT/O8SN/pPkt7vXwuOzPUXjxI3+c40f+OMXPNZI/3Ha2iXPrt3E8y2wkJuTKtDbK9ONrHM7Plnl4tde7PH5wy3sczqJfNDeP2zfNu/Hb80+IjViqayE24quuhdiIuboWYiMO61qIjdisSyH6RrzWtRAbcXLXQmyk63stxEZav9dCNCCeh0hiyUL0bn1DHH3u+UcK3IJ2sF2Vv4gTb2oTJwvVJk5wKk3c1tenP/7jfCROyqpMvJUryG9EnPxWmnh4Px4sHIkT9moTJxnWJm4Qr0yczFmbOJmzNnEyZ3HiYdvAEJblSJzMWZs4mbMycSNz1iZO5qxNnMxZmziZszZxg3hl4mTO2sTJnLWJ48fzxPcbIpbp2/NfEFu5bfqTEMfxDXHc3QLz9zz/hI4DKQ19nraflnk+rqW1cunyjYjjQGoTpyNYmviy3YvrlnX/AmHk4WV8EVl2qF/itHID5U3FeXzg+63RyR3lwQZdKk9mg10rd1K2Ko8hj7I8WDFpeegcScvD1gZpeUg90vLQpFWWp5Wrkm8hz5M4jYDaxMn2hYn7YVi2T/cR4sT12sQN4pWJEwuuNDbpbnsrd/Xetts+DNtnu6M8rVzF2qo8GCZpeXBX18qTXkps5Z7aVuVhMURaHhZDpOUh9UjLQ+6RlofFEGV5WrnhuFV56BpcK8+0IRnC8XWcVu5nblUeugbS8hjyKMtD10BaHroG0vLQNZCWh66BTO6JyUPXQDiW+lbuJW9VHroG0vLQNZCWh66BtDyGPMry0DWQloeugbQ8dA2k5aFrIC0PXQNleRxdA2l5iKXS8hBLpeUx5FGWh1gqLQ/GOi+Pe78iNe7fkXIviNjf8xA9JrUARBagCkDEjxeAiGsuANGAeB4iDrQARJYvCkBkkaEARBJLAYgklvMQRxJLAYgklgIQSSwFIJJYCkA0IOYg+jW8IQ5r7vn0qbp+JN6UJv6wR9tQ9u34F3GyUG3iBKfaxElZtYkTyYoTD24bynKcObkNvThxez9u6/FvnNvQqxM3iFcmjh8vTTy8r/IOFo7E8eO1iePHaxPHj9cmjh+vTHxiPaU2cRZfahMnc9YmTuasTdwgXpk4mbM2cTJnbeJkztrEyZy1iZM5ixMP2/tvYTmcd+gDmbM2cTJnbeJkztrEyZy1iRvEKxPHHZYmbtst0M78t5Xl48PJO4n9zCR7pTi5UxdmZmRpeZi+L5Uns+N9NuRRlodmtLQ8dK6l5aHNLS0PqUdaHhroyvIsdNul5aFrIC0PXQNpeegaSMtjyFNNnidxGgG1iZPtaxMnrtcmTgKvTZxQXZn4Sk4uTty2M/ZtOu68XIm+tYmTZmsTJ6DWJm4Qr0yczFmbOJmzNnEyZ23iZM7axMmcdYmPA5mzNnEyZ23iZM7axMmcxYknzx8cB4N4ZeJkztrESUCniD8hEmoKQCSnnIfoiB4FIOK0is9Cpd7HHbmk/uIXPof3vUUuIg9+QloenIq0PHiga+VJvs0+etyVtDx0gaXloWUsLQ+pR1oeQx5leehcS8vD1ippeegaXCvPtCEZwnKUh66BtDx0DZTlGekaSMtD10BaHroG0vLQNZCWx5BHJffE5KFroBxLR7oG0vLQNZCWh66BtDx0DZTlMboG0vLQNZCWh66BtDx0DaTlMeRRloeugbQ8dA2k5SGWSstDLFWWZyKWSstDLJWWR9caBD9v8qxr7qPDJs+0ftPyWaZuY75kmcI33v+kTO/s9UfrvZ9yD7txe3ias182N2+H2gzejd+ef0LU/cW6EUTddteNIOo2pW4E0YB4HqJug+dGENvwWhdDbMPJXQxRt+N0I4i6faH7QJxJLAUgkljyPRa3viGOPvd8+sLBcSbe1CZOFqpN3CBemHjm6NOZlFWbOJGsNnHyW2ni4f14sOMx7TNhrzZxkmFl4gsxsjZxMmdt4mTO2sTJnMWJh207SliOrx8vBvHKxMmctYmTOWsTJ3PWJk7mrE2czFmZ+ErmrE2czFmbOJmzNnH8eJ74fkPEMn17/gkR+5GFOI5viKOde/4JHQdSGvo8bT8t83xYSzPha71bJY4DqU3cIF6Y+DJvL5Et67dXAo8PJ68+NOG7ensQJ/NypwnfAtyFPOkNdiZ8vzDyjCZ8czHyPOTBiknLQ+dIWh62NkjLY8ijLA9NWml52GFRT54ncRoBtYmT7QsT98N2rpYffIQ4cb0yceHb7VslTiy40tiku+3CF2730W0fhu2zXUQePJC0PBgmaXlwV9fKk15KFL4yGHke8rAYIi0PiyHS8pB6pOUx5FGWh8UQaXlYDJGWh67BtfIkr6s34SuDkechD10DZXmErwxGnoc8dA2k5aFrIC0PXQNpeQx5VHJPTB66BsqxVPjKYOR5yEPXQFoeugbS8tA1UJZH+EZn5HnIQ9dAWh66BtLy0DWQlseQR1keugbS8tA1kJaHWCotD7FUWZ5ALJWWh1gqLY8hT1Ye935Faty/I+VeELG/BSBiUgtAZAGqAET8eAGIuObzEGe8bQGIONACEFm+KACRRYYCEA2I5yGSWApAJLEUgEhiKQCRxFIAIonlPMSFxJKF6Nfwhjisueczp+ouxJvSxL3f7j7y+3b8izhZqDZxglNt4gbxysSJZMWJB7cRXyIzJ665NHF7P25r5G8ci12ZOLehVyeOHy9NPLyv8g4WjsTx47WJ48drEzeIVyaOH69NnPWU2sRZfKlNnMxZmziZsy7xaSBz1iZO5qxNnMxZmziZszZxg3hl4mTO4sTD9v5bWJYjcTJnbeJkztrEyZy1iZM5KxN3ZM7axA3ihYnbdgu0M/9tZfn4cPJO4skxyV4pTubUhckxI0vLw/R9qTzpHe+TZ66XlodmtLQ8dK6l5aHNLS2PIY+yPDTQpeWh2y4tD10DaXnoGkjLQ9dAWZ6RrkE9eZ7EaQTUJk62r02cuF6buEG8MnFCdW3i5OTixG07Y9+m487LkehbmzhptjZxAmpl4kbmrE2czFmbOJmzNnEyZ23iBvHKxMmctYmTOWsTJ3PWJk7mrE2czFmcePL8wWkic9YmTuasTZwEdIr4E6IB8TxEckoBiESPAhBxWsVnoWLv43JJ/aXiuGF431vkIvLgJ6TlMeRRlgcPdK086bfZA+5KWh66wNLy0DKWlofUoyzPTO6RlofOtbQ8bK2SloeuwbXyTBuSIRwPKJwNeZTloWsgLQ9dA2l56BpIy0PXQFoeugbK8ix0DWRyT0weugbKsXShayAtD10DaXkMeZTloWsgLQ9dA2l56BpIy0PXQFoeugbK8qx0DaTloWsgLQ9dA2l5DHmU5SGWSstDLJWWh1gqLE8Y2jDWLrw/Oni/f/hZZhuNebdsQ3brkBvHaq8/Kz+4JftX6ObttJfBu/Hb80+IBsTzENtwExdDbGPOvxhiGzPzxRDbaOteDLGN5uu1EF0jTu5aiG00Mi+G2Ea78WKIJJYCEA2I2eaDW98QR597Pn0TX3DEm9rEyUK1iROcShNPnwkaHCmrNnEiWWXinvxWmnh4Px4sHIkT9moTJxnWJk6MrE3cIF6ZOJmzNnEyZ3HiYdunEZblSJzMWZs4mbM2cTJnZeIjmbM2cTJnbeJkztrEyZy1iRvEKxMnc9Ymjh/PE99viFimb89/QTTsRxbiOL4hjjafev4JHQdSGvo8bT8t83xcSzMcSG3iBvHKxOkIlia+zC8kblm/vSt3fDh5J2Bo5KLmu4qTe+uxkVudbytPZoPdhGGSlgd3JS2PIY+yPHSOpOVha4O0PKQeaXlo0krLww6LevJ8EQ80AmoTJ9sXJu6H7cAp/1jUOxInrtcmTgKvTdzaIL66N/HFpR/+6TF22dfxQyPR91qIjQTUayE2EiOvhdhI2LsWYiOR7FKIcyMp61qIjQSnayE2koWuhdhIvLkWogHxPEQSSxZi2cOVGrmb/k7EyUK1iROcShPPHK7UyKXwNyLeyD3vdyJOfitNPHMMSiO3sd+JOMmwNnGDeGXiZM7axMmctYmTOYsTT78+38j943ciTuasTLyRW8LvRJzMWZs4mbM2cTJnbeIG8crEyZy1iZM5axPHj+eJZw4QmwfsRxZi6QPE5lZuLxeCnj5caR4M4pWJ40BqE6cjWJp4sQPE5lYuIr6pOJkDxOZWrji+qzzpDXZzK5cntyqPIY+yPFgxaXnoHEnLw9YGaXlIPdLy0KRVlqeVS6pvIc+TOI2A2sTJ9oWJZw5Xmlu5pPpGxA3ilYkTC640Nulueyt3/d622z4M22e7ozytXJraqjwYJml5cFfXypNeSmzl7tZW5WExRFoeFkOk5SH1SMtD7pGWh8UQZXmMxRBpeegaXCvPtCEZwnKUh66BtDx0DaTlMeRRloeugbQ8dA2k5aFrIC0PXQOZ3BOTh66Bciyd6BpIy0PXQFoeugbS8tA1kJbHkEdZHroG0vLQNZCWh66BtDx0DaTloWugLE+gayAtD7FUWh5iqbQ8hjzK8hBLpeXBWOflce9XpMb9O1KvI3YD9vc8xBmTWgAiC1AFIOLHC0DENReAaEA8DxEHWgAiyxcFILLIUAAiiaUARBLLeYgLiaUARBJLAYgklgIQSSwFIBoQcxD9Gt4QhzX3fOZU3YV4U5q499vdR37fjn8RJwvVJk5wqk2clFWbOJGsOPHgNuLLcebkNvTixO39uK3Hv3FuQ69O3CBemTh+vDTx8L7KO1g4EseP1yaOH69NHD9emzh+vC7xZWA9pTZxFl9qEydz1iZO5qxN3CBemTiZszZxMmdt4mTO2sTJnLWJkzmLEw/b+29hOZx3uDgyZ23iZM7axMmctYmTOWsTN4hXJo47LE3ctlugnflvK8vHh5N3Ei+eSfZKcTKnLiyeGVlaHqbvS+VJ73hfvCGPsjw0o6XloXMtLQ9tbml5SD3S8tBAV5ZnpNsuLQ9dA2l56BpIy0PXQFoeQ55q8jyJ0wioTZxsX5s4cb02cRJ4beKE6srEjZxcnLhtZ+zbdNx5aUTf2sRJs7WJE1BrEzeIVyZO5qxNnMxZmziZszZxMmdt4mTOysQnMmdt4mTO2sTJnLWJkzmLE0+eP7hMBvHKxMmctYmTgE4Rf0Ik1BSASE45DzEQPQpAxGkVn4WKvY/LJfWXiuOG4X1vkYvIg5+QlgenIi0PHuhaedJvs8+4K2l56AJLy0PLWFoeUo+0PIY8yvLQuZaWh61V0vLQNbhWnmlDMoTjAYUzXQNpeegaKMuz0DWQloeugbQ8dA2k5aFrIC2PIY9K7onJQ9dAOZYudA2k5aFrIC0PXQNpeegaKMuz0jWQloeugbQ8dA2k5aFrIC2PIY+yPHQNpOWhayAtD7FUWh5iqbA860AslZaHWCotj7UhzzK+5Rly41jtxdsPbsnKM47jWx7LyrnMLyTu0ZRJy5N8s3QdGrHVNxUn827cOjTi21qVpxHf1qg8rhHfdlt50sbANeLbWpWnkeWEVuVpZDmhVXkMeZTlIfdIy9PIckKr8jSyCbFVeegaXCtP8v2E1dE1UJbH0zWQloeugbQ8dA2k5aFrIC2PIY+yPHQNZHJPTB66Bsqx1NM1kJaHroG0PHQNlOUZ6RpIy0PXQFoeugbS8tA1kJbHkEdZHroG0vLQNZCWh66BtDzEUmV5jFgqLQ+xVFoeYqm0PBjrvDzu/YrU6L6/+PuEiP0tABGTWgAiC1AFIOLHz0OccM0FIOJtC0DEgRaAyPJFAYgGxPMQSSwFIJJYCkAksRSASGIpAJHEch5iILEUgEhiyUL84UGCzm1VumC//8cObiDelCbu/fp63O/b8S/iZKHaxA3ilYmTsmoTJ5IVJx7cRnyJzJy45tLE7f24rce/8RmLXZs4frw2cfx4aeLBbTNnsHAkjh+vTdwgXpk4frw2cfx4beKsp9QmzuJLbeJkzsrEFzJnbeJkztrEyZy1iZM5axM3iFcmTuasTZzMWZx42N5/C8vxvMOFzFmbOJmzNnEyZ2XiK5mzNnEyZ23iuMPSxH9yZXT6TuKVSfZKcXKnLqzMyLry2DAwfV8qT3LH+0Me5nppeWhGS8tD51paHkMeZXlIPdLy0ECXloduu7Q8dA2k5aFroCyPo2sgLQ9dg3ryPInTCKhNnGxfm7hBvDJxEnht4oTq2sTJycWJ23bGvk3hSJzoW5s4abYycU9ArU2czFmbOJmzNnEyZ23iBvHKxMmctYmTOWsTJ3PWJk7mrE2czFmZ+EjmLE48df7ggziZszZxMmdt4gbxM8SfEAk1BSCSUwpAJHqch8g19bLv4z7EwZRdKY4bhve9RS4ijyGPsjw4FWl58EDXypN+m91wV9Ly0AWWloeWsbI8E6lHWh5yj7Q8dK6l5WFrlbQ8hjyXyjNtSIawHOWhayAtD10DaXnoGkjLQ9dAWh66BsryBLoG0vLQNZDJPTF56Boox9JA10BaHkMeZXnoGkjLQ9dAWh66BtLy0DWQloeugbI8M10DaXnoGkjLQ9dAWh66BtLyEEul5SGWSstDLJWWh1iqLM9Sde4J23ki0+oy8ozvQSzvUTz+wdgwlhfA2cb3s1F8tq1PTs59e/YJJADkO5AZIN+BLAD5DmQFyDcgda+IvwMQ1xuQyW3eYloyzzr3ti1fT/x62nv3C58H3xl8I/jO4LOK+MLgXoOZ5zGDzw1u3mgP3o3fnPNz8NOdBx/uPPj5zoNf7jz49b6Dd8Nw58G7Ow/e33nw450Hf+MZ1g3CM6x363vwo/82+JgTSt4y6Qbh6bhwpcJzd+FKhSf6H1aaPlfVDcKuoGylTthCFK5U2G/8sNLwfjxYOFYqbE4KVyrsZApXat1U2o5HylXajkfKVdqORwphWyMOy3KstB2PlKu0HY+UqdS345FylTbkkTKVNuSRMpU25JEylVo3lTbkkTKVNuSRMpUqz6f7xuYy/X5obI7CP6fj+B78aHNOpuTzz2KFf1F/WOw8re9PP/ZMRuFf1MKVCv+iFq5UOKH8sNJlfg3FLd/2j0QeTt5L4kzY+H4QSmbHs7N2ftZ/hCWzEGLtTABFsbQzWxTF0s7UUhSLsLO/Eotwq/RKLH26liwW4dB4IZZJuGNbDMuz0h6M67PSZryoH7aXEv2jiXSstBl7ma3Ueql07tMbp1P33KkzTt8j6OZOvU4OS6deJ4Nl6cHr/Lx1tdDRi2LptKOXw9JpRy+HxcASw9Krb8lg6bSjl8PSaUcvh6VXl5u888MtvbrcNJa1V5ebwdKry81g6dXlZrD06nIzWAwsMSy43CgWXG7MzikfYXIlll5dbgZLry43icUrH+hyJRZ6uVEs9HKjWOjlRrEYWGJYcLlRLLjcKBZcbhQLdi6GRflwnSuxYOeiWLBzUSzKE7R7b80Z3ffLKJ6DV55Gs4NXnuyyg1duvGQHrzyf5gavfFxKfvDKc1N28MozSHbwyrE9O3i78+DvPMMqHxCSH/ydZ1h/5xlW+bSV7ODHO8+wo/IZYz+7XC79FqJXPhTnh5U+vi+vx73Nx0qVzxgrW6l1U6nyGWNlK1U+Y+yHlYbt0/0S+UVSPmPshxd7Jk/79qZ8ZmfZStuZT3OVtjOfps9L9soHDBWutJ35NFdpO/NprtJ25tNcpcrnmpetVPlc87KVtuORMpUqn5JTuNJ2PFKu0m48kvIpOYUrtW4q7cYjTQ15pOS55n5qyCNlKm3II2UqbcgjpSsNDXmkTKUNeaRMpe3MMradOufMf+uYHR9OnsXmQzs/Xj+Bktt9GBrqmBfEMjfUXv8JlsyK79xQL74klnZCaVEs7STYolgMLDEsfbqWLJZ2gnRRLO2k7qJYOnW5OSydutwMFuWjda/E0oPLfVbag3F9VtqDF31Wat1U2oNjfFbagwl8VtqQr7PtnWKbjitkyufDFq60IfeVrlT5FNfClTbkkTKVNuSRMpU25JEylVo3lTbkkTKVNuSRMpV245GUTxctXGkvHmlUPgO06Ps8o/KxnoUrbcgjZSq1e1b6HPxNzcBz8Ded35+Dv+mU/TV45WP+rtpPNiof8vfRjVPJ2xof/wawxLB0urkhh6XTzQ3p3Yej8sGEV2JhC28UC1t4Y1iUj2m8EkuvviWDpdMtvDksnW7hzWGxTrEkb1QblQ/avBJLry43g6VXl5vB0qvLzWDp1eWmsSgflXolFlxuFAsuN2bnGjretSgWA0sMS68uN4OFXm4UC73cKBZ6uVEs9HJjWFo67bgkFlxuFAsuN4oFlxvFgp2LYsHORbFg56JYsHMxLFXP5Z2GrSU27R6OY5mm5QVxCt5lPnqwd5lzZhxhnX89Ow8uM4pHfa+Hbf/Bfo08PM8vHZdh9+gUq85eKKbdfSiPR5+qeFS5RJXwenSaw1GVEVUEVTFUEVRlQhVBVQKqCKoyo4qgKguqCKqyosrFqizTQZWqZ7Sjyn9VFbL9Raps2X6NqEK2v0aVaUmpQrZXVMVQRVAVsv0lqgS/cfPLURWyvaIqZHtFVcj2iqqQ7a9RxdmmynpQZSbbK6pCtldUhWyvqArZXlEVQxVBVcj2iqqQ7a9WZTzmlZlsr6gK2f4iVcaNW0QVsv01qmwoYqosZHtFVcj2iqqQ7a9RZVuLDLM7qkK2V1TFUEVQFbK9oipke0VVyPaCqqzklUtUSb+tupJXrlEl+abESl5RVIW8oqiKoYqgKuQVRVXIK4qqkFcUVWEt8mpVIu9FrqxF6qliA9n+IlUSb6vaQLa/RpXUG3g2kO0VVSHbK6piqHKFKsl3vWwg2yuqQrZXVIVsr6gK2f4aVVJvSthAthdUxZHtFVUh2yuqQrZXVIVsr6iKoYqgKmT7q1U5vhdpjmyvqArZ/iJVEm+rmiPbX6NK6g08c2R7QVU82V5RFbL9Naqk3l8xT7ZXVIVsr6iKoYqgKmR7RVXI9oqqkFcuUSX5tqqN5JVrVEm9KWEjeUVRFfKKoirkFUVVDFUEVSGvKKpCXlFUhbXIq1WJvBc5shapqArZ/iJVUm+rGtn+GlWSb+AZ2V5RFbK9oipk+0tUSb/rZYYqgqqQ7RVVIdsrqkK2v0aV5JsSRrZXVIVsL6jKRLZXVIVsr6gK2V5RFbK9oiqGKherEnkvciLbK6pCtr9IldTbqhPZ/hpVkm/gTWR7RVXI9oKqBLL9Naok318JZHtFVcj2iqqQ7RVVMVQRVIVsr6gKeeUSVdJvqwbyyjWqJN+UmMkriqqQVxRVIa8oqkJeUVTFUEVQFfKKoiqsRV6tSuS9yJm1SEVVyPYXqZJ6W3Um21+jSvINvIVsr6gK2V5RFbL9Jaqk3/VayPaKqhiqCKpCtldUhWx/jSrJNyUWsr2iKmR7RVXI9oKqrGR7RVXI9oqqkO0VVSHbX61K5L3I1VBFUBWy/UWqpN5WXcn216iSfANvJdsrqkK2V1SFbH+NKqn3V6aBbK+oCtleURWyvaIqZHtFVQxVBFU5mVf8PGydA/NpGt5tgdb76f2O5ugsCnocx430aNnnl/n1B+KWdU878vAyvv4+ll2Jj0efUJYuobhhGLbPdkcszoElhsWDJYZl7BTL+J4fJnfEYmCJYZnAEsMSwBLD0qdryWLp1bdksKxgiWDxA1hiWHp1udMWmYewHLH06nIzWHp1uRksBpYYll5dbgZLry43g6VXl5vBgsuNYsHlxuzciMuNYunV5Waw9OpyM1jo5UaxGFhiWOjlRrHQy41ioZcbxYLLjWLB5cawGC43igU7F8WCnYtiMbDEsGDnoliUJ2j33poz7vfmuNfglafR3OAn5ckuO3jlxkt28MrzaXbwyrNedvDKc1N28MozSHbwyrE9O3jlcJ0d/J1n2OnOM2y48wwb7jzDhjvPsOHOM+zZOw4/OXi/hvfghzX3vHPbAroLdkguQXg6/mGl3q+vx/0+/r0qFZ67C1cqPNEXrlTYFRSuVNhC/LTS4LZKl+Mv0iw86/2wUns/butR01l4iixcaTvzaa7SdubT4LZfpGDhWGk782mu0nbm01yl7cynuUrbmU8zlS7C+b1wpcJhv3Cl7XikXKXteKRcpdZNpd14pKUbj7R045GWbjzS0pBHCtv+jbAc35dZG/JImUob8kiZShvySJlKG/JImUqtm0rbmWVs2Co1/61jdnw4eRZbGNr58foJlMzuwzA01DEviaWh9vpPsKRXfMPQzm9oUSzthNKiWNpJsEWxtBN3i2Lp07VksbQTpEtice2k7qJYOnW5OSydutwcFlxuFIt1gOVZaQ/G9VlpD170WWkP9vJZaQ+O8VlpDybwq1Llw2R/Wqlt7xTbFI6VNmTVMpU25L4ylTZkqDKVWjeVNuSRMpU25JEylTbkkTKVNuSRMpU25JHSlSofRVq40m48kvKBoYUr7eXNpaB8rGfhShvySJlKb+ocnoO/qRl4Dv6m8/vX4JXPVcwPvs9lgvR+MuVD/j66cSp5W2OwTjc35LB0urkhh6XTzQ2Z3YfKBxNeiYUtvFEsbOGNYul0c0MOi4ElhqXTLbw5LJ1u4c1h6dXlJm9UC8oHbV6JpVeXm8aifDjolVh6dbkZLL263AyWXl1uBovhW2JYcLkxO9fQ8a5FsfTqcjNYenW5GSz0cmNYZnq5USz0cqNY6OVGsdDLjWIxsMSw4HKjWHC5USzYuSgW7FwMS0MnIhfFgp2LYjk5QbtlfmHx5tJY3GqvOv3gliyWD155mt45d/YI35tCye2FOns2bKtYVrBEsJw9dfa2WNI/uGePqG0ViwdLDMsIlhgWA0sMS6++JYMlgCWGZQZLDEuvLje9X2Ht1eUmscxDry43g6VXl5vB0qvLzWDp1eVmsBhYYlhwuVEsuNyInZsHXG4US68uN4OlV5ebxuLo5Uax0MuNYqGXG8VCLzeKxcASw4LLjWLB5Uax4HKjWLBzMSweOxfFgp2LYsHORbEoT9DuvTVndMcD82avPI1mB6882WUHr9x4yQ5eeT7NDX5UnvWyg1eem7KDV55BsoNXju3ZwdudB3/nGXa88ww73nmGHe88w453nmHtzjOsCc+wP3xBKH175GzC0/EPK/V+fT3ubT5WKjx3F67UuqlU2BUUrlTYQvy00uC2SpfIL5LwrFf0do55Ep4iC1faznyaq7Sd+TS47RcpWDhW2s58mqu0nfk0V2k782mu0nbm01ylwvm9cKXCYb9wpe14pEyloR2PlKu0HY+Uq7QbjxS68UhnjzC+UaXdeKTQkEcK2/6NsBzflwkNeaRMpQ15pEylDXmkdKVzQx4pU2lDHilTaTuzTLFbTOe5nR+vguf2zXNDHfOCWJaG2us/wZJZ8V0a6sWXxNJOKC2KpZ0EWxSLgSWGpU/XksXSTpAuiqWd1F0US6cuN4elU5ebwaJ8tO6VWHpwuc9KezCuz0p78KLPSq2bSntwjM9KezCBz0ob8nW2vVNs03GFTPl82MKVNuS+kpUuyqe4Fq60IY+UqbQhj5SptCGPlKnUuqm0IY+UqbQhj5SptBePtCifLlq40m48kvIZoEXf51mUj/UsXGlDHilTqd2z0ufgb2oGnoO/6fz+HPxNp+yvwSsf83fVfrJF+ZC/j26cSt7WuPib/j5+GkunmxtyWDrd3JDefbgoH0x4JRa28EaxsIU3hkX5mMYrsfTqWzJYOt3Cm8PS6RbeHBbrFEvyRrVF+aDNK7H06nIzWHp1uRksvbrcDJZeXW4ai/JRqVdiweVGseByY3auoeNdi2IxsMSw9OpyM1jo5Uax0MuNYqGXG8VCLzeGpaXTjktiweVGseByo1hwuVEs2LkoFuxcFAt2LooFOxfDcvpc3u3R4HZbqaNYwvpCOA/7kcQ+2Ab/etiGP/7Vv572a+TheX7xW4bdo1Pk0cleXblpdw/J49EnDd8ZjfB6dJrDkcYIjR0Ng8aOxgSNHY0AjR2NGRo7Ggs0djTWbmks04HG6bON26LRmxcNmxddIzR686LTkqLRmxdN0zBo7Gh05kWD91srYjnS6MyLZmh05kUzNDrzohkanXnR4Lbx+vVAY+nMi2ZodOZFMzQ686IZGp150QwNg8aORm9eNE2jNy/6pjEe/cbSmxdN0+jNi7rXoVPBIjR686LDlKCx9uZF0zR686JpGr150a33FWZ3pNGbF03TMGjsaPTmRdM0evOiaRq9edEUjXXobR02tQtuHbpbh03sWFgH9gTuabAncE/DoLGjwZ7APQ32BO5psCdwT6PfPYHHfV/rwJ7AHQ3X3Z7AxC641fXmRVM7nVbHnsA9DfYE7mkYe3t2NNgTuKfBnsA9DfYE7ml0tw6b2LGwOvYE7mh49gTuabAncE+DPYF7GuwJ3NMwaOxo9Lsn8Ljva/XsCdzT6G5PYGIX3Op786KpnU6rZ0/gjsbInsA9jd68aHL/xsiewD0N9gTuaRg0djTYE7inwZ7APY3e1mGTu+Cs37NZIjsWjD2BexrsCdzTYE/gnoZBY0eDPYF7GuwJ3NPod09gZN+XsSdwT6O7PYGpXXBTb140udNpYk/gngZ7Avc0eut9Jff2TAaNHQ32BO5psCdwT6Pfs1kiOxYm9gTuabAncEcjsCdwT4M9gXsa7Anc02BP4J6Gse9rR4M9gXsa3e0JTO2C6+3+lPROp97uT8nQYE/gjkZv96ek92/0dn9KhgZ7Avc02BO4p2HQ2NFgT+CeRm/rsMldcL3dkZHesdDbHRkZGuwJ3NNgT+CeBnsC9zQMGjsa7Anc0+h3T2Bk31dvd2RkaHS3JzC1C663OzLSO516uyMjQ4M9gXsavfW+knt7ursjI03DoLGjwZ7APY1+z2aJ7Fjo7o6MNA32BO5psCdwozENvd2fkqHBnsA9DfYE7mn0uyfwsO/rQcOgsaPR3Z7A/3wX3INGb140sdPpQYM9gXsa7Anc0+jNiyb2b0xDb/enZGiwJ3BPgz2BexrsCdzTMGjsaJz0G8ObxjBnaEzzq8Bp2SWmdfk1lKXeUMKwbuHNIkNZZYZy9mqGkkNxOkPxOkMZdYZiOkOZag5l2J4NkaEEnaHMOkNZdIayygxlHHSG4nSG4nWGMuoMxXSGovNrO+r82o46v7ajzq/tqPNraxq/tr8//uv/96d//fOf/ukv//xvj3/kj//1//z1v//tz//y11//9W////9+/i+Ph/8v","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"3715688037512703171":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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ARIYAAAEGAIYKgIYEioBHhgAAAQYAhgqAhgeKgISGioCHhsqAg8cIA1FAAAEFA8YDgAEFBgWIQANSQAWOgEAACoAGBQgARgqARwSDAAEFhIeIQANTwAeIA1uKgEbEioBGx4kAAQEIAwABBYgISEADVUAIToBAAAAAAQeAiEAAAQhFiAqASAfKgEaHiQABAMgDAAEFiAiIQANXQAiOgEAAAAABB4CIgAABCIWICoBICEAAAcfIR4kAAQEHwwABBYfIiEADWUAIjoBAAArAAASCAMlAAQABQgEIgAADZQrAAgFACEAAAQhAiIAAAQiFh8qAh4fKgIhGyANbgAABBYPEg4ABBYSHiEADXIAHjoBAAAqABIWIA0eKgEVEioBExYqARQXAAAEFwUYDgAEFxgZIQANewAZOgEAACQABAEZDAAEGBkaIQANfwAaOgEAAAAABBYCGgAABBoYGSoBGRckAAQBFgwABAUWGiEADYYAGjoBAAArAAASCAMlAAQAAggEIgAADZQrAAgFABgAAAQYAhoAAAQaBRYqAhcWAAAEBQ8XDgAEBRcSIQANkQASOgEAACoCGBUqABcFIABLKwEIAwgGCwAECAYAAggHIQANmAgHIA2aKwAIAwgFIA2oKwAAAAgFAQAEAAAIBAAAJQAEAAAICQ0ABAgJCAQIChcACAoICiEADaYICgEABAgDCAkICysBCAsICAEABAgFCAkICysCCAgICwEABAgJAAIICSANnSUBBAABCAUgDagjJQAEAAAIBw0ABAgHCAUICBcACAgICCEADbMICAEABAgDCAcICSsBCAkIBgEABAgECAcICSsCCAYICQEABAgHAAIIByANqiMrABjKGMo=","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"512":"Function get_admin_public can only be called statically","3072":"attempt to add with overflow","3273":"attempt to add with overflow","3450":"attempt to add with overflow","2804":"Array index out of bounds","2194":"Array index out of bounds","2962":"Array index out of bounds","1579":"Array index out of bounds","2603":"attempt to add with overflow","1701":"Array index out of bounds","3170":"Array index out of bounds","457":"attempt to add with overflow","2182":"attempt to add with overflow","2371":"attempt to add with overflow","2134":"Array index out of bounds","2701":"Array index out of bounds","3029":"Array index out of bounds","1543":"Array index out of bounds","2689":"attempt to add with overflow","1964":"attempt to add with overflow","3244":"Array index out of bounds","3232":"attempt to add with overflow","471":"Not initialized","2007":"Array index out of bounds","2519":"Array index out of bounds","2574":"Array index out of bounds","203":"attempt to add with overflow","2641":"attempt to add with overflow","1861":"Array index out of bounds","2952":"attempt to add with overflow","3019":"attempt to add with overflow","2550":"Array index out of bounds","2739":"attempt to add with overflow","2995":"attempt to add with overflow","1837":"attempt to add with overflow","490":"Aztec Passport: Unauthorized Admin Change","3050":"attempt to add with overflow","3184":"attempt to add with overflow","1057":"attempt to add with overflow","2337":"Array index out of bounds","2849":"Array index out of bounds","2392":"Array index out of bounds","3428":"Array index out of bounds","1935":"Array index out of bounds","2825":"attempt to add with overflow","1923":"attempt to add with overflow","1722":"attempt to add with overflow","3124":"Array index out of bounds","1777":"Array index out of bounds","2155":"attempt to add with overflow","2923":"Array index out of bounds","3301":"Array index out of bounds","2210":"Array index out of bounds","2911":"attempt to add with overflow","1619":"Array index out of bounds","1808":"Array index out of bounds","1875":"attempt to add with overflow","3088":"Array index out of bounds","2052":"Array index out of bounds","1729":"attempt to add with overflow","2174":"Array index out of bounds","3454":"Array index out of bounds","1784":"Array index out of bounds","181":"attempt to add with overflow","2229":"Array index out of bounds","2863":"attempt to add with overflow","2028":"attempt to add with overflow","2540":"attempt to add with overflow","2796":"Array index out of bounds","547":"Not initialized","1571":"Array index out of bounds","1693":"Array index out of bounds","2717":"Array index out of bounds","2973":"attempt to add with overflow","2772":"Array index out of bounds","401":"Initializer address is not the contract deployer","1681":"attempt to add with overflow","2126":"Array index out of bounds","3040":"attempt to add with overflow","2437":"Array index out of bounds","1346":"attempt to add with overflow","2114":"attempt to add with overflow","3260":"Array index out of bounds","3461":"Array index out of bounds","3320":"Array index out of bounds","2413":"attempt to add with overflow","1633":"attempt to add with overflow","2590":"Array index out of bounds","987":"call to assert_max_bit_size","2066":"attempt to add with overflow","2511":"Array index out of bounds","1999":"Array index out of bounds","2499":"attempt to add with overflow","1987":"attempt to add with overflow","3011":"Array index out of bounds","2743":"Array index out of bounds","2609":"Array index out of bounds","3054":"Array index out of bounds","1951":"Array index out of bounds","604":"Not initialized","2329":"Array index out of bounds","1238":"attempt to add with overflow","147":"attempt to add with overflow","2384":"Array index out of bounds","2451":"attempt to add with overflow","3152":"Array index out of bounds","3420":"Array index out of bounds","769":"attempt to add with overflow","2561":"attempt to add with overflow","2750":"Array index out of bounds","1592":"attempt to add with overflow","2360":"Array index out of bounds","2939":"Array index out of bounds","3061":"Array index out of bounds","3116":"Array index out of bounds","1824":"Array index out of bounds","3293":"Array index out of bounds","2202":"Array index out of bounds","508":"Not initialized","185":"Array index out of bounds","2812":"Array index out of bounds","1843":"Array index out of bounds","1709":"Array index out of bounds","2142":"Array index out of bounds","1563":"Array index out of bounds","405":"Aztec Passport: Invalid Address","82":"attempt to add with overflow","783":"Not initialized","1740":"Array index out of bounds","1551":"attempt to add with overflow","1350":"attempt to add with overflow","1795":"attempt to add with overflow","192":"Array index out of bounds","2709":"Array index out of bounds","1338":"attempt to add with overflow","2831":"Array index out of bounds","3252":"Array index out of bounds","3441":"attempt to add with overflow","2350":"attempt to add with overflow","2984":"Array index out of bounds","1759":"attempt to add with overflow","2015":"Array index out of bounds","2527":"Array index out of bounds","2582":"Array index out of bounds","1747":"Array index out of bounds","2783":"attempt to add with overflow","3472":"attempt to add with overflow","3338":"Array index out of bounds","2247":"Array index out of bounds","1601":"Array index out of bounds","3137":"attempt to add with overflow","1979":"Array index out of bounds","1333":"attempt to multiply with overflow","2034":"Array index out of bounds","2223":"attempt to add with overflow","3314":"attempt to add with overflow","2400":"Array index out of bounds","1242":"attempt to add with overflow","1943":"Array index out of bounds","3412":"Array index out of bounds","2321":"Array index out of bounds","1230":"attempt to add with overflow","395":"Initialization hash does not match","3400":"attempt to add with overflow","2309":"attempt to add with overflow","2419":"Array index out of bounds","2931":"Array index out of bounds","2730":"attempt to add with overflow","3108":"Array index out of bounds","3096":"attempt to add with overflow","3352":"attempt to add with overflow","3285":"Array index out of bounds","1816":"Array index out of bounds","2261":"attempt to add with overflow","1225":"attempt to multiply with overflow","2761":"attempt to add with overflow","2627":"Array index out of bounds"}},{"name":"get_passport_address","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["get_passport_address"],"assert_messages":{"256":"Array index out of bounds","346":"Array index out of bounds","14":"Not initialized","203":"Array index out of bounds","232":"attempt to add with overflow","238":"Array index out of bounds","270":"attempt to add with overflow","211":"Array index out of bounds","179":"Array index out of bounds","330":"Array index out of bounds","359":"attempt to add with overflow","190":"attempt to add with overflow","219":"Array index out of bounds","318":"attempt to add with overflow","338":"Array index out of bounds"}},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"error_types":{},"parameters":[{"name":"_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"],"assert_messages":{"128":"attempt to add with overflow","448":"Array index out of bounds","698":"Array index out of bounds","110":"Array index out of bounds","366":"Array index out of bounds","616":"Array index out of bounds","430":"Array index out of bounds","415":"attempt to add with overflow","598":"Array index out of bounds","592":"attempt to add with overflow","394":"Array index out of bounds","522":"Array index out of bounds","510":"attempt to add with overflow","571":"Array index out of bounds","117":"Array index out of bounds","690":"Array index out of bounds","678":"attempt to add with overflow","538":"Array index out of bounds","340":"Initializer address is not the contract deployer","334":"Initialization hash does not match","462":"attempt to add with overflow","72":"attempt to add with overflow","386":"Array index out of bounds","706":"Array index out of bounds","374":"attempt to add with overflow","563":"Array index out of bounds","630":"attempt to add with overflow","106":"attempt to add with overflow","551":"attempt to add with overflow","344":"Aztec Passport: Invalid Address","402":"Array index out of bounds","530":"Array index out of bounds","719":"attempt to add with overflow","579":"Array index out of bounds"}},{"name":"set_passport_address","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"_passport_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["set_passport_address"],"assert_messages":{"1152":"Array index out of bounds","1609":"Array index out of bounds","890":"attempt to add with overflow","1335":"Array index out of bounds","1530":"Array index out of bounds","518":"attempt to add with overflow","1518":"attempt to add with overflow","1323":"attempt to add with overflow","1646":"Array index out of bounds","902":"Array index out of bounds","1628":"Array index out of bounds","1622":"attempt to add with overflow","1939":"attempt to add with overflow","842":"attempt to add with overflow","1799":"Array index out of bounds","1025":"Array index out of bounds","1470":"attempt to add with overflow","1275":"attempt to add with overflow","1208":"Array index out of bounds","1403":"Array index out of bounds","1720":"Array index out of bounds","1391":"attempt to add with overflow","1196":"attempt to add with overflow","1580":"attempt to add with overflow","1708":"attempt to add with overflow","1836":"Array index out of bounds","1818":"Array index out of bounds","788":"Array index out of bounds","337":"attempt to add with overflow","14":"Not initialized","910":"Array index out of bounds","1160":"Array index out of bounds","1812":"attempt to add with overflow","1538":"Array index out of bounds","1343":"Array index out of bounds","1660":"attempt to add with overflow","1593":"Array index out of bounds","630":"attempt to add with overflow","1910":"Array index out of bounds","752":"Array index out of bounds","618":"attempt to add with overflow","1770":"attempt to add with overflow","1898":"attempt to add with overflow","801":"attempt to add with overflow","1569":"Array index out of bounds","1173":"attempt to add with overflow","1033":"Array index out of bounds","1411":"Array index out of bounds","1216":"Array index out of bounds","1728":"Array index out of bounds","1850":"attempt to add with overflow","1783":"Array index out of bounds","1070":"Array index out of bounds","613":"attempt to multiply with overflow","1759":"Array index out of bounds","1052":"Array index out of bounds","918":"Array index out of bounds","1046":"attempt to add with overflow","522":"attempt to add with overflow","1351":"Array index out of bounds","772":"Array index out of bounds","1546":"Array index out of bounds","510":"attempt to add with overflow","1601":"Array index out of bounds","760":"attempt to add with overflow","949":"Array index out of bounds","626":"attempt to add with overflow","1144":"Array index out of bounds","1004":"attempt to add with overflow","1132":"attempt to add with overflow","1918":"Array index out of bounds","931":"attempt to add with overflow","986":"Array index out of bounds","1559":"attempt to add with overflow","1364":"attempt to add with overflow","267":"call to assert_max_bit_size","968":"attempt to add with overflow","1224":"Array index out of bounds","1419":"Array index out of bounds","1791":"Array index out of bounds","1736":"Array index out of bounds","828":"Array index out of bounds","505":"attempt to multiply with overflow","956":"Array index out of bounds","1017":"Array index out of bounds","1084":"attempt to add with overflow","1261":"Array index out of bounds","810":"Array index out of bounds","938":"attempt to add with overflow","1188":"Array index out of bounds","993":"Array index out of bounds","1383":"Array index out of bounds","1243":"Array index out of bounds","1749":"attempt to add with overflow","1432":"attempt to add with overflow","1237":"attempt to add with overflow","1438":"Array index out of bounds","1456":"Array index out of bounds","1926":"Array index out of bounds","780":"Array index out of bounds"}},{"name":"verify","is_unconstrained":false,"custom_attributes":["private"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"actual","type":{"kind":"array","length":128,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"private"},{"name":"given","type":{"kind":"array","length":128,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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3pf7ndPBel/ud04H6329+erebWilvt58dX+9rzdf3V/v681X99f7evPV/fXKYut9vfnq/npfer66sd7F5qspbjv0yPW+3nx1d71T3NDoketdzL9qi/lXbTH/ao5bYT1wvYv5V3PcZOuB611svpri9l0PXO8UN8p65HoXmzemuAXXI9e72Lyxd1upGleXoI7FHK23+GUBrep2uN4n3hb97q839u5ANe1qD77d37tR0suutyy23vpy6727W+3dr+ll1yuLrbcvtt5XO32P1vt65+/99fpi64211quvN1/d/XZQX2++ur/e15uv7q/39ear++uVxdb7evPV/fW+3nx1f70vPV/dWO9i85UuNl/Z681X99f7evPV/fUu5l/ZYv6VLeZf2WL+lS3mX9li/pUtNl/ZYvOVLzZv+GLzhi82b/hi84Z/zXl0HzAt7khVQVQVG1JVQaqqSFUNqepLdsJHQt4l+gRLuMvmltD5l2DzL8HnX0LMsIR7kPe+1QmWcPcWen1r8y9hhnPhYAkznAt36Z99m+FcOFjCDOfCwRJmOBcOljDDuXB/CWWbfwll/iXMcDofLGGG0/lgCTOczgdLmP90LvOfzmX+07nMfzqXKU7ne1ToXqc4ne8vYYrT+f4Spjid7y9hitP5/hKmOJ3vL2GGTfVRN2vvbYa//MeFuXubwmJ74Hqn8OMeBiHtbQrz7oHrneFa4pHrneHC45HrneEq5ZHrfbXT92i9M1z/PHC9MsPF0iPX+3Lz1cF6X26+OljvYvOVyNTr/b6EuUem70uYewr6voS5B5vvS5h7Vvm+hLnHj29L6FNMFPcApr1PMSTcX8IU5/79JUxxlN9fwhSn8/0lTHE631/CFKfz/SVMcTrfX8IUp/P9JUxxOt9dgs5/Ouv8p7POfzrr/D8s/ppbKT12CVOczveXgDvavqvCnVbfVeEOoG+qDHemfFf1ak7g3d8N2BR72cMg4N1e7nu4g/W+3PdwB+t9ue/h7v8uxF/ue7iD9S72Oydf7HdO/nLfwx2s9/XO3/vrfbnfOR2s9+V+53Sw3tebr+7dhrb7681X99f7evPV3fXG681X99f7evPV/fW+3nx1f72vN1/dX6+88vl7Y72LzVdT3Hboket9vfnq/npfb766v961/Cvd1vKvdFvLv9I5boX1wPWu5V/pJoutd635Sqe4fdcj17vWvKFT3FXrgeud4hZcj1zvSvPG+Ef59tDb9xB5u12EtXdU+6rfCnX7nh33nyKff0r//FP080+xzz/l5rZnZpen+MenxKef0rbPP6V8/ik3u+9y+Uh67x+e0j7/FPn8U/rnn3Kz+65yeYq1D0+xzz/FP/+U+PRTbkeG3S+t9PjQytup2/tPqZ9/Svv8U+T+U2L7uPz++afo559ys/tRLp+xqB8+Y7fjb/efEp9+yu141/2n3Ox+vP28eKvlp+f8w2ce/O0N6rPfoD37DeTZb9Cf/Qb67DewZ7+BP/sN4slvcDvc8cg3ePZfsj77L1mf/Zesz/5L1mf/Jeuz/5L12X/J+uy/ZH32X7I9+y/Znv2XbL/+KerXq4Pub9eeNfz76/96C/T6C+Rhj/3+9X178uuXJ79+ffLrx3P7Gw+of7k8WGv78Prlya9fn/z67cmvLw/4/MT19eXD6/cnv74++fXtya/vT379eO7rl2179hs8eQctW332G7Rnv4E8+w36s99An/0G9uw38Ge/wZMnoVK2Z7/Bs/+Sy7P/ksuz/5LLs/+Sy7P/kstT/5LHv+q3R+58L9j1Cj34adbsN97Fo1592X7/oTXs8mVMjXh3RN0cd7frvNW3Vt4/+Ht9ZhVeZxXeZhUuswrvswrXWYXbLwuPdv2aqm/nCfdZhcekwus2q/Ayq/A6q/D2POF/3vtBzuNevj/35fW5L2/PfXl/7svHU1++/XpxxmXIWw6tye/eQH59kxyXNtcfvlVvv3+D9uwVyLPf4BE9iCuWe/gnv38Df/YbxJPfoG/PfoPygDfw9vYG8fs3qM9+g/bsN5Bnv0F/9hvos9/Anv0GD/hLLu36E+Wi9fdvEE9+A92e/Qbl2W9Qn/0G7dlvIM9+gwf8JZeQ66Fffj+2qD77DeLJY4s9ey6y8uw3aM9+A3n2G/Rnv4E+9Q3GP9qfdi18s+vP67eDK12pF0Ei9bSL4lLmlF3nlN3mlC1zyu5zytY5ZduvyrbLdw1iv9/Eiz/zxeOJL163Z774r+7eo6XXjv5+gKz1mS/envniv7pf9Xp5aH+XCL1nxD7qxfWZL25PfPH2yzWXiz3X5cOL/6py7ZdtTq38/sX9iS8u9YllkV/+I9JrQ03/649Yro968f7MF9dnvrg988X9mS8eT3zxvj3uxb3/1x8xhh/14r/8F6rXv9D48OK//Bd63VtuvLg888X7M1/8V/9CtV6GIq0fvkawZ764P/PF44kvrr/6F6pFri/+e09cyzNfvD7zxdszX1ye+eL9mS+uz3xxe9yLtw+fc3/mi//yX+hbekl+/+L2y3+hW99/8fLMF6/PfPFf/gu9M5+bPPPF+zNfXJ/54s+84LLnXXCNf8i3B+78oF779QszNbv/Jt9uBnV5sLQPnpE84A3syhJ6T5iroB/i9iVWqUus0pZYpS+xylhhlXVbYpXl3FWifjX+aqtsS6xSllhlX2KVusQqDbLKP+9mFb5GS3C0tA2khXIm/3nvhrJfpIVyvv15N9TyNC0H+ZGTK3OQx1FUbYykpp/+uflvZF6+Sk1FqWkoNXK2mv9GTuer1ChKjaHUOEpNkNTohlJz9l7834k4fZWahlIjKDUdpUZRagyl5uy9+L+Tb/siNVZJVzCGup4yQalRlBpDqXGUmuCoGf/o3x56G+pTyts1c+lv++bYKPZ/gH/0JP/vPCk+/aTxL/322NvfiuobScferunGq+x/xXj/KeXzT6mff0r7/FPk80+5ffvMfnXdrP70lI+fuHb98XOz9zc7vuXR12uUoar99Ng/730R8TVSjCPFOVLigVLe701xh872uJcvz33527fqjWvGfHs3b91+/bvFv228P/D15cmv35/5+uNf9v0AuA0565cn+rugfym+/9uv+0+xzz/FP/+U+PRTbh9md54y/uUvOhKMf/6///Tvf/mnf/63f/2P8aRv/+v//eu//P0vf/vrb//8+//3f378L+PB/z8=","brillig_names":["get_public_storage_hints","get_public_data_witness","lt_32_hint","decompose_hint","lte_16_hint","pack_arguments_oracle_wrapper","call_private_function_internal","unpack_returns","pack_arguments_oracle_wrapper","directive_integer_quotient","directive_invert"]},{"name":"is_admin","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"JAAEAQIlAAQIRAAAJAAEAAMkAAQABB8AAAAABAAAAAMAAAhDIgAAAAgrAAADCEM5AAAACEMAAAABHgAAAAQeAAAABTAAAAAABAAAAAUAAAAGJAACAQUKAAIGBQQhAAAPAAQ6AQAAKgAABiQABAIFAAAEAAUAJAEEAQYAAAQGAgUqAAUEJAAHAAcqAgcEKgEGBQAABAUCBSoCBQYqAAAFAAAEAAIAKgIGBSQABAEHJAAEAAYkAAcBBCoABgMgACIKAAQDBgghAAAtAAggACUqAQUEAAAEBAIDAAAEAwYHKgEHBR4AAgAGCgAHBQYEKgAEAyMqAQUIHAAHAwkAAAcECQosAAAAAAoAAAAJJAAEAQsMAAQDCwwhAAA1AAw6AQAAKwAACAgDJQAEAAIIBCIAAABDKwAIBQAKAAAECgIMAAAEDAMLKgIJCwAABAMHCQ4ABAMJCCEAAEAACDoBAAAqAgoFKgAJAyAAIisBCAMIBgsABAgGAAIIByEAAEcIByAASSsACAMIBSAAVysAAAAIBQEABAAACAQAACUABAAACAkNAAQICQgECAoXAAgKCAohAABVCAoBAAQIAwgJCAsrAQgLCAgBAAQIBQgJCAsrAggICAsBAAQICQACCAkgAEwlAQQAAQgFIABXIysAGMoYyg==","debug_symbols":"1ZrBTsMwDIbfJecdYidx4r0KQqiDDVWqOrQNJDTt3emgyUpX0gMMxZeqaf/GXyKnf13lqJ7Wq9fnh7rdbPdqeXdUzfaxOtTbtmsdTwu12tVNUz8/DC8rfT6ET/n+pWrPrf2h2h3UEjzahVq3T+dTY7sONnWzVkuvT4srMRvfa9n5JAVnJrQWgXuxRQxJzTghpgCmF1NAHorvF4p/DQ4aklgPxDdHB/37Sfexf+a5SQe0UQzInCcP4CJFgEHXPTn8IXk36d/RzwHw1gHMrQPYWwdwkwHAQXwIiOcy34ck1uYSwdOE2jHFzHfMOp8/zpvI0Z3iOH9IMLsXzB4Es7NcdtSC2UEwOwpmN4LZrWB2wb6Kgn0VBfsqCvZVU/hadSGxu3EFZQrPGW8Te9Bj9v/PmVTSkdYuzw6a6dL1RWw0fcKzYHirJcP/8DnmXXqITR7emoDxF4aZS2JiSuzsxwvQzn9g+Zkq12IcriW4Gm3hZpx7OdmyzThAMoWAMGYv/MWalsgUe+FmHMyFHfNi7pZq/L9n/dVAC6+Ic+7nCq+Is+yFV8RZ9sIr4ix74RVxlt0KZi/chLPshVfEWXbB1Y0r3ISz7IJ9lQT7Kgn2VRLsqyTYV0msr5661lu1q6tVs+63Z2xe28fBbo3D+8vXnU78AQ==","brillig_names":["is_admin"],"assert_messages":{"52":"Array index out of bounds","14":"Not initialized","63":"attempt to add with overflow"}},{"name":"get_admin_public","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"}},"bytecode":"JAAEAQIlAAQIRAAAJAAEAAMkAAQABB8AAAAABAAAAAMAAAhDIgAAAAgrAAADCEM5AAAACEMAAAABHgAAAAQeAAAABTAAAAAABAAAAAUAAAAGJAACAQUKAAIGBQQhAAAPAAQ6AQAAHgALAAYkAAcBBQoABwYFBCEAABQABDoBAAAqAAAGJAAEAgQAAAQABAAkAQQBBgAABAYCBCoABAckAAcACCoCCAcqAQYEAAAEBAIEKgIEBioAAAQAAAQAAgAqAgYEJAAEAQgkAAQABioABgMgACYKAAQDBgchAAAvAAcgACkqAQQFAAAEBQIDAAAEAwYHKgEHBCoABAMjKgEEBxwABwMJAAAHBQkKLAAAAAAKAAAACSQABAELDAAEAwsMIQAANwAMOgEAACsAAAcIAyUABAACCAQiAAAARSsACAUACgAABAoCDAAABAwDCyoCCQsAAAQDCAkOAAQDCQchAABCAAc6AQAAKgIKBCoACQMgACYrAQgDCAYLAAQIBgACCAchAABJCAcgAEsrAAgDCAUgAFkrAAAACAUBAAQAAAgEAAAlAAQAAAgJDQAECAkIBAgKFwAICggKIQAAVwgKAQAECAMICQgLKwEICwgIAQAECAUICQgLKwIICAgLAQAECAkAAggJIABOJQEEAAEIBSAAWSMrABjKGMo=","debug_symbols":"1Zphb4IwEIb/Sz/7oe211zv/yrIsuOlCQnBRt2Qx/vfBBpUhqVHn0vtiLLztPfRK34OwVy/LxfvrU1mv1ls1f9irav1c7Mp13bT2h5labMqqKl+fhoeVbn/oW759K+q2td0Vm52am2DdTC3rl/YvuGaAVVkt1Tzow+xEzBA6LfsQpcbDhNZZw53YWUtRzXZCjGSgEyNZHoofZ4pvBjfaRLEeiO+ObvTtkx768ZnPTbqxrhcby5wmJ+N7CjKDoTty84fkzaT/Rm8D2HsHgHsHcPcO4G8O4D33ETzqMysikPWdOJCj8YrAC2naPuGKPnRFH768j52+NzXamBLS5/aVQL24SeAxfwGncsHY7yueWadz4QOYXhzAjnJhjWB2K5gdBLM7wexeMDsKZg+C2UkwO8tlB8G+CoJ9FQT7Kgj2Vch8n/EU2f34+dRlvt6Di+ykx+z/v97jAzNq7dPsRjMehz6KQeM3PEiGd5LhMy9pkrdr3lsNmbhNkjVj9sxLmrhoJth95iUNwZHdpsXsoOdgF04uVLAf+MzrnyR75vVPkt0JZs/8vUKSPfP3Ckn2zE04yZ55vZ9kz9yEU+yYuQkn2QX7Kgr2VRTsqyjYV1Gwr6JYXz00rY9iUxaLatl9DrJ6r58HX4fsPt9+zjTiLw==","brillig_names":["get_admin_public"],"assert_messages":{"14":"Not initialized","65":"attempt to add with overflow","54":"Array index out of bounds","19":"Function get_admin_public can only be called statically"}},{"name":"set_admin","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"new_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"JAAEAQIlAAQIRAAAJAAEAQQkAAQABR8AAAAABQAAAAQAAAhDKwAIQwADIgAAAAg5AAAACEQAAAAAHgAAAAUeAAAABjAAAAAABQAAAAYAAAAHJAACAQUKAAIHBQYhAAAPAAY6AQAAKgAABSQABAIHAAAEAAcAJAEEAQUAAAQFAgcqAAcGJAAHAAgqAggGKgEFBwAABAcCByoCBwUqAAAHAAAEAAIAKgIFByQABAAFJAAHAQgkAAQBBioABQQgACIKAAQEBQkhAABKAAkgACUqAQcJAAAECQIKAAAECgULKgELBx4AAgAJCgAHBwkKIQAALQAKOgEAACoABQQgAC8KAAQEBQchAAAzAAcgADIjHAAHBAcAAAcIBwkqAAAHJAAEAgoAAAQACgAkAQQBBwAABAcCCioACgsqAgMLJAAEAQsMAAQECwwhAABAAAw6AQAAAAAEBwIMAAAEDAQLKgELCi0AAAAACgAAAAkAAAQEBgkOAAQECQohAABIAAo6AQAAKgAJBCAALyoBBwkcAAcECgAABwgKCywAAAAACwAAAAokAAQBDAwABAQMDSEAAFIADToBAAArAAAJCAMlAAQAAggEIgAAAGArAAgFAAsAAAQLAg0AAAQNBAwqAgoMAAAEBAYJDgAEBAkKIQAAXQAKOgEAACoCCwcqAAkEIAAiKwEIAwgGCwAECAYAAggHIQAAZAgHIABmKwAIAwgFIAB0KwAAAAgFAQAEAAAIBAAAJQAEAAAICQ0ABAgJCAQIChcACAoICiEAAHIICgEABAgDCAkICysBCAsICAEABAgFCAkICysCCAgICwEABAgJAAIICSAAaSUBBAABCAUgAHQjKwAYyhjK","debug_symbols":"1Zthb9owEIb/Sz7zwXe2z3f9K9NUQQtVJAQV0EkT4r8v6bDJ0sxR1THdfUEE3pwfJ5e88dk5N8/r1dvLY7vb7I/Nw7dzs90/LU/tftdtnS+LZnVot9v25XH4c+P6D36XH1+Xu37reFoeTs0DJAyLZr177r/60AXYtNt185DcZfFBLD5dtRJTkUL0E9qAIFdxQOSiFpwQE4O/iolRhuLvi0a+DA4OitgNxHdHB/f1g55yfJG5gw4YshhQpE7OEDMFwyD0lRz+IXl30P9E7xvAezfg791AuHcDcaoBjpBPG8lc3ifO8bsGbvETTaijUM77KOLq2ROTzxjdVxxnD5klT2bJ2Sy5WCVHZ5YczJKjWXJvljyYJTfroWjWQ9Gsh6JZD/Wqr9DIhTyOx0hedbakUMjZjcn/d7aUARs5F+vk4IRuoW9i7+gdXcyiB2cXffqhK8WMLr6OHjxjLk34ueQloUIuaXzZhbnHKKEhS7+H//Qe4dN7TN4MJOZeS4KZk4uEpQTCPHNyyUMuaZH3MwUT6mJnMeC4YBJBM3mCQs4wJkfN5JEq5F4zOZfCIMjYrmMwSx7NkpNZctV3xSo5myUXq+TkzJKr9tAquWoPrZKb9VAy66Fk1kPJrIeSag8NeCP3dXE3Hr1NwzOPu6nacP/azZ5cteHWyJNqw62SqzbcKnmwWu9MmmckGEqNmXE83E6qZyRK5W2KXHWNudhWR44zN/+uApivzZA+dFP19EWtlJ5ULwGokbPqJQBVctVLAKrkqpcAVMlVLwGokqs23Cq56iUAVXLVhlslNzupy2Y9lM16qJj1UDHroWLWQ8Woh166rR/LQ7tcbdfXtzU2b7unwcsbp5+vv//pxL8A","brillig_names":["set_admin"],"assert_messages":{"81":"Array index out of bounds","63":"Array index out of bounds","92":"attempt to add with overflow","44":"Aztec Passport: Unauthorized Admin Change","71":"attempt to add with overflow","14":"Not initialized"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"},{"fields":[{"name":"address","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"},{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000850bb34d"},{"kind":"string","value":"AddressNote"},{"fields":[{"name":"address","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"npk_m_hash","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"AztecPassport"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"total_services","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}},{"name":"services","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}],"kind":"struct"}},{"name":"service_indexes","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}],"kind":"struct"}},{"name":"scores","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"},{"fields":[{"name":"contract_name","value":{"kind":"string","value":"BiometricModule"}},{"name":"fields","value":{"fields":[{"name":"admin","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"passport_address","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"_passport_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BiometricModule::set_passport_address_parameters"}}],"kind":"struct","path":"BiometricModule::set_passport_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BiometricModule::is_admin_parameters"}},{"name":"return_type","type":{"kind":"boolean"}}],"kind":"struct","path":"BiometricModule::is_admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BiometricModule::get_admin_public_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"BiometricModule::get_admin_public_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BiometricModule::constructor_parameters"}}],"kind":"struct","path":"BiometricModule::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"new_admin","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BiometricModule::set_admin_parameters"}}],"kind":"struct","path":"BiometricModule::set_admin_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BiometricModule::get_passport_address_parameters"}},{"name":"return_type","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BiometricModule::get_passport_address_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"actual","type":{"kind":"array","length":128,"type":{"kind":"integer","sign":"unsigned","width":32}}},{"name":"given","type":{"kind":"array","length":128,"type":{"kind":"integer","sign":"unsigned","width":32}}}],"kind":"struct","path":"BiometricModule::verify_parameters"}}],"kind":"struct","path":"BiometricModule::verify_abi"}]}},"file_map":{"114":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"115":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"118":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\nunconstrained pub fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"121":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr","source":"/// Notifies the simulator that `args` will later be used at some point during execution, referenced by their hash. This\n/// allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of arguments.\npub fn pack_arguments(args: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_arguments_oracle_wrapper(args)\n    };\n}\n\n/// Same as `pack_arguments`, but using arrays instead of slices.\npub fn pack_arguments_array<let N: u32>(args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_arguments_array_oracle_wrapper(args)\n    };\n}\n\nunconstrained fn pack_arguments_oracle_wrapper(args: [Field]) {\n    let _ = pack_arguments_oracle(args);\n}\n\nunconstrained fn pack_arguments_array_oracle_wrapper<let N: u32>(args: [Field; N]) {\n    let _ = pack_arguments_array_oracle(args);\n}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<let N: u32>(_args: [Field; N]) -> Field {}\n"},"122":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(address: Field, storage_slot: Field, block_number: Field, length: Field) -> [Field; N] {}\n\nunconstrained pub fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> [Field; N] {\n    storage_read_oracle(\n        address.to_field(),\n        storage_slot,\n        block_number as Field,\n        N as Field\n    )\n}\n\nunconstrained pub fn storage_read<T, let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> T where T: Deserialize<N> {\n    T::deserialize(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::address::AztecAddress;\n\n    use std::test::OracleMock;\n    use crate::test::mocks::mock_struct::MockStruct;\n\n    global address = AztecAddress::from_field(29);\n    global slot = 7;\n    global block_number = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"storageRead\").returns(written.serialize());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"},"126":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr","source":"use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage, utils::arr_copy_slice};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: u32 = 45;\n\npub struct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field\n) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, public_data_tree_index);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n"},"127":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"148":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr","source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    address::AztecAddress, header::Header, utils::field::full_field_less_than\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header {\n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness for the tree index.\n        let witness = unsafe {\n            get_public_data_witness(\n                self.global_variables.block_number as u32,\n                public_data_tree_index\n            )\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_data_tree_index, \"Public data tree index doesn't match witness\");\n            preimage.value\n        };\n\n        value\n    }\n}\n"},"153":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"154":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"159":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"},"169":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_value_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize, FromField, ToField};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to represent a value that changes from `pre` to `post` at some block\n// called the `block_of_change`. The value can only be made to change by scheduling a change event at some future block\n// of change after some minimum delay measured in blocks has elapsed. This means that at any given block number we know\n// both the current value and the smallest block number at which the value might change - this is called the\n// 'block horizon'.\npub struct ScheduledValueChange<T> {\n    pre: T,\n    post: T,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<T> ScheduledValueChange<T> {\n    pub fn new(pre: T, post: T, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the value stored in the data structure at a given block. This function can be called both in public\n    /// (where `block_number` is simply the current block number, i.e. the number of the block in which the current\n    /// transaction will be included) and in private (where `block_number` is the historical block number that is used\n    /// to construct the proof).\n    /// Reading in private is only safe if the transaction's `max_block_number` property is set to a value lower or\n    /// equal to the block horizon (see `get_block_horizon()`).\n    pub fn get_current_at(self, block_number: u32) -> T {\n        // The post value becomes the current one at the block of change. This means different things in each realm:\n        // - in public, any transaction that is included in the block of change will use the post value\n        // - in private, any transaction that includes the block of change as part of the historical state will use the\n        //   post value (barring any follow-up changes)\n\n        if block_number < self.block_of_change {\n            self.pre\n        } else {\n            self.post\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change value and the block at which it will become the current\n    /// value. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (T, u32) {\n        (self.post, self.block_of_change)\n    }\n\n    /// Returns the largest block number at which the value returned by `get_current_at` is known to remain the current\n    /// value. This value is only meaningful in private when constructing a proof at some `historical_block_number`,\n    /// since due to its asynchronous nature private execution cannot know about any later scheduled changes.\n    /// The caller of this function must know how quickly the value can change due to a scheduled change in the form of\n    /// `minimum_delay`. If the delay itself is immutable, then this is just its duration. If the delay is mutable\n    /// however, then this value is the 'effective minimum delay' (obtained by calling\n    /// `ScheduledDelayChange.get_effective_minimum_delay_at`), which equals the minimum number of blocks that need to\n    /// elapse from the next block until the value changes, regardless of further delay changes.\n    /// The value returned by `get_current_at` in private when called with a historical block number is only safe to use\n    /// if the transaction's `max_block_number` property is set to a value lower or equal to the block horizon computed\n    /// using the same historical block number.\n    pub fn get_block_horizon(self, historical_block_number: u32, minimum_delay: u32) -> u32 {\n        // The block horizon is the very last block in which the current value is known. Any block past the horizon\n        // (i.e. with a block number larger than the block horizon) may have a different current value. Reading the\n        // current value in private typically requires constraining the maximum valid block number to be equal to the\n        // block horizon.\n\n        if historical_block_number >= self.block_of_change {\n            // Once the block of change has been mined, the current value (post) will not change unless a new value\n            // change is scheduled. This did not happen at the historical block number (or else it would not be\n            // greater or equal to the block of change), and therefore could only happen after the historical block\n            // number. The earliest would be the immediate next block, and so the smallest possible next block of change\n            // equals `historical_block_number + 1 + minimum_delay`. Our block horizon is simply the previous block to\n            // that one.\n            //\n            //      block of      historical\n            //       change         block            block horizon\n            //   =======|=============N===================H===========>\n            //                         ^                   ^\n            //                         ---------------------\n            //                             minimum delay\n\n            historical_block_number + minimum_delay\n        } else {\n            // If the block of change has not yet been mined however, then there are two possible scenarios.\n            //   a) It could be so far into the future that the block horizon is actually determined by the minimum\n            //      delay, because a new change could be scheduled and take place _before_ the currently scheduled one.\n            //      This is similar to the scenario where the block of change is in the past: the time horizon is the\n            //      block prior to the earliest one in which a new block of change might land.\n            //\n            //         historical\n            //           block                        block horizon      block of change\n            //        =====N=================================H=================|=========>\n            //              ^                                 ^\n            //              |                                 |\n            //              -----------------------------------\n            //                        minimum delay\n            //\n            //   b) It could be fewer than `minimum_delay` blocks away from the historical block number, in which case\n            //      the block of change would become the limiting factor for the time horizon, which would equal the\n            //      block right before the block of change (since by definition the value changes at the block of\n            //      change).\n            //\n            //           historical                         block horizon\n            //             block     block of change       if not scheduled\n            //        =======N=============|===================H=================>\n            //                ^           ^                     ^\n            //                |     actual horizon              |\n            //                -----------------------------------\n            //                          minimum delay\n            //\n            // Note that the current implementation does not allow the caller to set the block of change to an arbitrary\n            // value, and therefore scenario a) is not currently possible. However implementing #5501 would allow for\n            // this to happen.\n\n            // Because historical_block_number < self.block_of_change, then block_of_change > 0 and we can safely\n            // subtract 1.\n            min(\n                self.block_of_change - 1,\n                historical_block_number + minimum_delay\n            )\n        }\n    }\n\n    /// Mutates the value by scheduling a change at the current block number. This function is only meaningful when\n    /// called in public with the current block number.\n    pub fn schedule_change(\n        &mut self,\n        new_value: T,\n        current_block_number: u32,\n        minimum_delay: u32,\n        block_of_change: u32\n    ) {\n        assert(block_of_change >= current_block_number + minimum_delay);\n\n        self.pre = self.get_current_at(current_block_number);\n        self.post = new_value;\n        self.block_of_change = block_of_change;\n    }\n}\n\nimpl<T> Serialize<3> for ScheduledValueChange<T> where T: ToField {\n    fn serialize(self) -> [Field; 3] {\n        [self.pre.to_field(), self.post.to_field(), self.block_of_change.to_field()]\n    }\n}\n\nimpl<T> Deserialize<3> for ScheduledValueChange<T> where T: FromField {\n    fn deserialize(input: [Field; 3]) -> Self {\n        Self {\n            pre: FromField::from_field(input[0]),\n            post: FromField::from_field(input[1]),\n            block_of_change: FromField::from_field(input[2])\n        }\n    }\n}\n\nimpl<T> Eq for ScheduledValueChange<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"170":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/scheduled_delay_change.nr","source":"use dep::protocol_types::traits::{Serialize, Deserialize};\nuse std::cmp::min;\n\nmod test;\n\n// This data structure is used by SharedMutable to store the minimum delay with which a ScheduledValueChange object can\n// schedule a change.\n// This delay is initally equal to INITIAL_DELAY, and can be safely mutated to any other value over time. This mutation\n// is performed via `schedule_change` in order to satisfy ScheduleValueChange constraints: if e.g. we allowed for the\n// delay to be decreased immediately then it'd be possible for the state variable to schedule a value change with a\n// reduced delay, invalidating prior private reads.\npub struct ScheduledDelayChange<let INITIAL_DELAY: u32> {\n    // Both pre and post are stored in public storage, so by default they are zeroed. By wrapping them in an Option,\n    // they default to Option::none(), which we detect and replace with INITIAL_DELAY. The end result is that a\n    // ScheduledDelayChange that has not been initialized has a delay equal to INITIAL_DELAY, which is the desired\n    // effect. Once initialized, the Option will never be none again.\n    pre: Option<u32>,\n    post: Option<u32>,\n    // Block at which `post` value is used instead of `pre`\n    block_of_change: u32,\n}\n\nimpl<let INITIAL_DELAY: u32> ScheduledDelayChange<INITIAL_DELAY> {\n    pub fn new(pre: Option<u32>, post: Option<u32>, block_of_change: u32) -> Self {\n        Self { pre, post, block_of_change }\n    }\n\n    /// Returns the current value of the delay stored in the data structure.\n    /// This function only returns a meaningful value when called in public with the current block number - for\n    /// historical private reads use `get_effective_minimum_delay_at` instead.\n    pub fn get_current(self, current_block_number: u32) -> u32 {\n        // The post value becomes the current one at the block of change, so any transaction that is included in the\n        // block of change will use the post value.\n\n        if current_block_number < self.block_of_change {\n            self.pre.unwrap_or(INITIAL_DELAY)\n        } else {\n            self.post.unwrap_or(INITIAL_DELAY)\n        }\n    }\n\n    /// Returns the scheduled change, i.e. the post-change delay and the block at which it will become the current\n    /// delay. Note that this block may be in the past if the change has already taken place.\n    /// Additionally, further changes might be later scheduled, potentially canceling the one returned by this function.\n    pub fn get_scheduled(self) -> (u32, u32) {\n        (self.post.unwrap_or(INITIAL_DELAY), self.block_of_change)\n    }\n\n    /// Mutates the delay change by scheduling a change at the current block number. This function is only meaningful\n    /// when called in public with the current block number.\n    /// The block at which the new delay will become effective is determined automatically:\n    ///  - when increasing the delay, the change is effective immediately\n    ///  - when reducing the delay, the change will take effect after a delay equal to the difference between old and\n    ///    new delay. For example, if reducing from 3 days to 1 day, the reduction will be scheduled to happen after 2\n    ///    days.\n    pub fn schedule_change(&mut self, new: u32, current_block_number: u32) {\n        let current = self.get_current(current_block_number);\n\n        // When changing the delay value we must ensure that it is not possible to produce a value change with a delay\n        // shorter than the current one.\n        let blocks_until_change = if new > current {\n            // Increasing the delay value can therefore be done immediately: this does not invalidate prior contraints\n            // about how quickly a value might be changed (indeed it strengthens them).\n            0\n        } else {\n            // Decreasing the delay requires waiting for the difference between current and new delay in order to ensure\n            // that overall the current delay is respected.\n            //\n            //      current                    delay              earliest value block of change\n            //       block                 block of change         if delay remained unchanged\n            //  =======N=========================|================================X=================>\n            //         ^                         ^                                ^\n            //         |-------------------------|--------------------------------|\n            //         |   blocks until change               new delay            |\n            //         ------------------------------------------------------------\n            //                            current delay\n            current - new\n        };\n\n        self.pre = Option::some(current);\n        self.post = Option::some(new);\n        self.block_of_change = current_block_number + blocks_until_change;\n    }\n\n    /// Returns the minimum delay before a value might mutate due to a scheduled change, from the perspective of some\n    /// historical block number. It only returns a meaningful value when called in private with historical blocks. This\n    /// function can be used alongside `ScheduledValueChange.get_block_horizon` to properly constrain the\n    /// `max_block_number` transaction property when reading mutable shared state.\n    /// This value typically equals the current delay at the block following the historical one (the earliest one in\n    /// which a value change could be scheduled), but it also considers scenarios in which a delay reduction is\n    /// scheduled to happen in the near future, resulting in a way to schedule a change with an overall delay lower than\n    /// the current one.\n    pub fn get_effective_minimum_delay_at(self, historical_block_number: u32) -> u32 {\n        if self.block_of_change <= historical_block_number {\n            // If no delay changes were scheduled, then the delay value at the historical block (post) is guaranteed to\n            // hold due to how further delay changes would be scheduled by `schedule_change`.\n            self.post.unwrap_or(INITIAL_DELAY)\n        } else {\n            // If a change is scheduled, then the effective delay might be lower than the current one (pre). At the\n            // block of change the current delay will be the scheduled one, with an overall delay from the historical\n            // block number equal to the number of blocks until the change plus the new delay. If this value is lower\n            // than the current delay, then that is the effective minimum delay.\n            //\n            //       historical\n            //         block                  delay                  actual earliest value\n            //           v                block of change              block of change\n            //  =========NS=====================|=============================X===========Y=====>\n            //            ^                     ^                             ^           ^\n            //     earliest block in            |                             |           |\n            //   which to schedule change       |                             |           |\n            //           |                      |                             |           |\n            //           |----------------------|------------------------------           |\n            //           |         blocks                  new delay                      |\n            //           |      until change                                              |\n            //           |                                                                |\n            //           |----------------------------------------------------------------|\n            //                        current delay at the earliest block in\n            //                             which to scheduled value change\n\n            let blocks_until_change = self.block_of_change - (historical_block_number + 1);\n\n            min(\n                self.pre.unwrap_or(INITIAL_DELAY),\n                blocks_until_change + self.post.unwrap_or(INITIAL_DELAY)\n            )\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Serialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn serialize(self) -> [Field; 1] {\n        // We pack all three u32 values into a single U128, which is made up of two u64 limbs.\n        // Low limb: [ pre_inner: u32 | post_inner: u32 ]\n        // High limb: [ empty | pre_is_some: u8 |  post_is_some: u8 | block_of_change: u32 ]\n\n        let lo = ((self.pre.unwrap_unchecked() as u64) * (1 << 32)) + (self.post.unwrap_unchecked() as u64);\n\n        let hi = (self.pre.is_some() as u64) * (1 << 33)\n            + (self.post.is_some() as u64 * (1 << 32))\n            + self.block_of_change as u64;\n\n        let packed = U128::from_u64s_le(lo, hi);\n\n        [packed.to_integer()]\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Deserialize<1> for ScheduledDelayChange<INITIAL_DELAY> {\n    fn deserialize(input: [Field; 1]) -> Self {\n        let packed = U128::from_integer(input[0]);\n\n        // We use division and modulo to clear the bits that correspond to other values when unpacking.\n\n        let pre_is_some = ((packed.hi as u64) / (1 << 33)) as bool;\n        let pre_inner = ((packed.lo as u64) / (1 << 32)) as u32;\n\n        let post_is_some = (((packed.hi as u64) / (1 << 32)) % (1 << 1)) as bool;\n        let post_inner = ((packed.lo as u64) % (1 << 32)) as u32;\n\n        let block_of_change = ((packed.hi as u64) % (1 << 32)) as u32;\n\n        Self {\n            pre: if pre_is_some {\n                Option::some(pre_inner)\n            } else {\n                Option::none()\n            },\n            post: if post_is_some {\n                Option::some(post_inner)\n            } else {\n                Option::none()\n            },\n            block_of_change\n        }\n    }\n}\n\nimpl<let INITIAL_DELAY: u32> Eq for ScheduledDelayChange<INITIAL_DELAY> {\n    fn eq(self, other: Self) -> bool {\n        (self.pre == other.pre)\n            & (self.post == other.post)\n            & (self.block_of_change == other.block_of_change)\n    }\n}\n"},"174":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_mutable/shared_mutable.nr","source":"use dep::protocol_types::{\n    hash::{poseidon2_hash, poseidon2_hash_with_separator}, address::AztecAddress,\n    traits::{FromField, ToField}, utils::arrays::array_concat\n};\n\nuse crate::context::{PrivateContext, PublicContext, UnconstrainedContext};\nuse crate::state_vars::{\n    storage::Storage,\n    shared_mutable::{scheduled_value_change::ScheduledValueChange, scheduled_delay_change::ScheduledDelayChange}\n};\nuse crate::oracle::storage::storage_read;\nuse dep::std::mem::zeroed;\n\nmod test;\n\npub struct SharedMutable<T, let INITIAL_DELAY: u32, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\n// Separators separating storage slot of different values within the same state variable\nglobal VALUE_CHANGE_SEPARATOR: u32 = 0;\nglobal DELAY_CHANGE_SEPARATOR: u32 = 1;\nglobal HASH_SEPARATOR: u32 = 2;\n\n// This will make the Aztec macros require that T implements the Serialize<N> trait, and allocate N storage slots to\n// this state variable. This is incorrect, since what we actually store is:\n//  - a ScheduledValueChange<T>, which requires 1 + 2 * M storage slots, where M is the serialization length of T\n//  - a ScheduledDelayChange, which requires another storage slot\n//\n// TODO https://github.com/AztecProtocol/aztec-packages/issues/5736: change the storage allocation scheme so that we\n// can actually use it here\nimpl<T, let INITIAL_DELAY: u32, Context> Storage<T> for SharedMutable<T, INITIAL_DELAY, Context> {}\n\n// SharedMutable<T> stores a value of type T that is:\n//  - publicly known (i.e. unencrypted)\n//  - mutable in public\n//  - readable in private with no contention (i.e. multiple parties can all read the same value without blocking one\n//    another nor needing to coordinate)\n// This is famously a hard problem to solve. SharedMutable makes it work by introducing a delay to public mutation:\n// the value is not changed immediately but rather a value change is scheduled to happen in the future after some delay\n// measured in blocks. Reads in private are only valid as long as they are included in a block not too far into the\n// future, so that they can guarantee the value will not have possibly changed by then (because of the delay).\n// The delay for changing a value is initially equal to INITIAL_DELAY, but can be changed by calling\n// `schedule_delay_change`.\nimpl<T, let INITIAL_DELAY: u32, Context> SharedMutable<T, INITIAL_DELAY, Context> where T: ToField + FromField + Eq {\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n\n    // Since we can't rely on the native storage allocation scheme, we hash the storage slot to get a unique location in\n    // which we can safely store as much data as we need.\n    // See https://github.com/AztecProtocol/aztec-packages/issues/5492 and\n    // https://github.com/AztecProtocol/aztec-packages/issues/5736\n    // We store three things in public storage:\n    //  - a ScheduledValueChange\n    //  - a ScheduledDelaChange\n    //  - the hash of both of these (via `hash_scheduled_data`)\n    fn get_value_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], VALUE_CHANGE_SEPARATOR)\n    }\n\n    fn get_delay_change_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], DELAY_CHANGE_SEPARATOR)\n    }\n\n    fn get_hash_storage_slot(self) -> Field {\n        poseidon2_hash_with_separator([self.storage_slot], HASH_SEPARATOR)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PublicContext> where T: ToField + FromField + Eq {\n\n    pub fn schedule_value_change(self, new_value: T) {\n        let mut value_change = self.read_value_change();\n        let delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n        let current_delay = delay_change.get_current(block_number);\n\n        // TODO: make this configurable\n        // https://github.com/AztecProtocol/aztec-packages/issues/5501\n        let block_of_change = block_number + current_delay;\n        value_change.schedule_change(new_value, block_number, current_delay, block_of_change);\n\n        self.write(value_change, delay_change);\n    }\n\n    pub fn schedule_delay_change(self, new_delay: u32) {\n        let mut delay_change = self.read_delay_change();\n\n        let block_number = self.context.block_number() as u32;\n\n        delay_change.schedule_change(new_delay, block_number);\n\n        self.write(self.read_value_change(), delay_change);\n    }\n\n    pub fn get_current_value_in_public(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    pub fn get_current_delay_in_public(self) -> u32 {\n        let block_number = self.context.block_number() as u32;\n        self.read_delay_change().get_current(block_number)\n    }\n\n    pub fn get_scheduled_value_in_public(self) -> (T, u32) {\n        self.read_value_change().get_scheduled()\n    }\n\n    pub fn get_scheduled_delay_in_public(self) -> (u32, u32) {\n        self.read_delay_change().get_scheduled()\n    }\n\n    fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n\n    fn read_delay_change(self) -> ScheduledDelayChange<INITIAL_DELAY> {\n        self.context.storage_read(self.get_delay_change_storage_slot())\n    }\n\n    fn write(\n        self,\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) {\n        // Whenever we write to public storage, we write both the value change and delay change as well as the hash of\n        // them both. This guarantees that the hash is always kept up to date.\n        // While this makes for more costly writes, it also makes private proofs much simpler because they only need to\n        // produce a historical proof for the hash, which results in a single inclusion proof (as opposed to 4 in the\n        // best case scenario in which T is a single field). Private shared mutable reads are assumed to be much more\n        // frequent than public writes, so this tradeoff makes sense.\n        self.context.storage_write(self.get_value_change_storage_slot(), value_change);\n        self.context.storage_write(self.get_delay_change_storage_slot(), delay_change);\n        self.context.storage_write(\n            self.get_hash_storage_slot(),\n            SharedMutable::hash_scheduled_data(value_change, delay_change)\n        );\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, &mut PrivateContext> where T: ToField + FromField + Eq {\n    pub fn get_current_value_in_private(self) -> T {\n        // When reading the current value in private we construct a historical state proof for the public value.\n        // However, since this value might change, we must constrain the maximum transaction block number as this proof\n        // will only be valid for however many blocks we can ensure the value will not change, which will depend on the\n        // current delay and any scheduled delay changes.\n\n        let (value_change, delay_change, historical_block_number) = self.historical_read_from_public_storage();\n\n        // We use the effective minimum delay as opposed to the current delay at the historical block as this one also\n        // takes into consideration any scheduled delay changes.\n        // For example, consider a scenario in which at block 200 the current delay was 50. We may naively think that\n        // the earliest we could change the value would be at block 251 by scheduling immediately after the historical\n        // block, i.e. at block 201. But if there was a delay change scheduled for block 210 to reduce the delay to 20\n        // blocks, then if a value change was scheduled at block 210 it would go into effect at block 230, which is\n        // earlier than what we'd expect if we only considered the current delay.\n        let effective_minimum_delay = delay_change.get_effective_minimum_delay_at(historical_block_number);\n        let block_horizon = value_change.get_block_horizon(historical_block_number, effective_minimum_delay);\n\n        // We prevent this transaction from being included in any block after the block horizon, ensuring that the\n        // historical public value matches the current one, since it can only change after the horizon.\n        self.context.set_tx_max_block_number(block_horizon);\n        value_change.get_current_at(historical_block_number)\n    }\n\n    fn historical_read_from_public_storage(self) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>, u32) {\n        let header = self.context.get_header();\n        let address = self.context.this_address();\n\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for both the ScheduledValueChange and\n        // ScheduledDelayChange, but that'd require one full sibling path per storage slot (since due to kernel siloing\n        // the storage is not contiguous), and in the best case in which T is a single field that'd be 4 slots.\n        // Instead, we get an oracle to provide us the correct values for both the value and delay changes, and instead\n        // prove inclusion of their hash, which is both a much smaller proof (a single slot), and also independent of\n        // the size of T.\n        let (value_change_hint, delay_change_hint) = unsafe {\n            get_public_storage_hints(address, self.storage_slot, historical_block_number)\n        };\n\n        // Ideally the following would be simply public_storage::read_historical, but we can't implement that yet.\n        let hash = header.public_storage_historical_read(self.get_hash_storage_slot(), address);\n\n        if hash != 0 {\n            assert_eq(\n                hash, SharedMutable::hash_scheduled_data(value_change_hint, delay_change_hint), \"Hint values do not match hash\"\n            );\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized, meaning no value or delay change was ever\n            // scheduled. Therefore, the hints must then correspond to uninitialized scheduled changes.\n            assert_eq(\n                value_change_hint, ScheduledValueChange::deserialize(zeroed()), \"Non-zero value change for zero hash\"\n            );\n            assert_eq(\n                delay_change_hint, ScheduledDelayChange::deserialize(zeroed()), \"Non-zero delay change for zero hash\"\n            );\n        };\n\n        (value_change_hint, delay_change_hint, historical_block_number)\n    }\n\n    fn hash_scheduled_data(\n        value_change: ScheduledValueChange<T>,\n        delay_change: ScheduledDelayChange<INITIAL_DELAY>\n    ) -> Field {\n        let concatenated: [Field; 4] = array_concat(value_change.serialize(), delay_change.serialize());\n        poseidon2_hash(concatenated)\n    }\n}\n\nimpl<T, let INITIAL_DELAY: u32> SharedMutable<T, INITIAL_DELAY, UnconstrainedContext> where T: ToField + FromField + Eq {\n    unconstrained pub fn get_current_value_in_unconstrained(self) -> T {\n        let block_number = self.context.block_number() as u32;\n        self.read_value_change().get_current_at(block_number)\n    }\n\n    unconstrained fn read_value_change(self) -> ScheduledValueChange<T> {\n        self.context.storage_read(self.get_value_change_storage_slot())\n    }\n}\n\nunconstrained fn get_public_storage_hints<T, let INITIAL_DELAY: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32\n) -> (ScheduledValueChange<T>, ScheduledDelayChange<INITIAL_DELAY>) where T: ToField + FromField + Eq {\n    // This function cannot be part of the &mut PrivateContext impl because that'd mean that by passing `self` we'd also\n    // be passing a mutable reference to an unconstrained function, which is not allowed. We therefore create a dummy\n    // state variable here so that we can access the methods to compute storage slots. This will all be removed in the\n    // future once we do proper storage slot allocation (#5492).\n    let dummy: SharedMutable<T, INITIAL_DELAY, ()> = SharedMutable::new((), storage_slot);\n\n    (\n        storage_read(address, dummy.get_value_change_storage_slot(), block_number), storage_read(address, dummy.get_delay_change_storage_slot(), block_number)\n    )\n}\n"},"176":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext> where T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN> {\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext> where T: Deserialize<T_SERIALIZED_LEN> {\n    unconstrained pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"221":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"},"230":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE: u32 = 4;\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // We choose the last SELECTOR_SIZE bytes of the hash to avoid getting the first byte that is not full\n        let hash_bytes = hash.to_be_bytes::<SELECTOR_SIZE>();\n\n        FunctionSelector::from_field(field_from_bytes(hash_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector = FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"263":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr","source":"use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N]\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"},"276":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr","source":"pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"},"277":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr","source":"mod assert_array_appended;\nmod assert_array_prepended;\nmod assert_combined_array;\nmod assert_combined_sorted_transformed_value_array;\nmod assert_combined_transformed_array;\nmod assert_deduped_array;\nmod assert_exposed_sorted_transformed_value_array;\nmod assert_sorted_array;\nmod assert_sorted_transformed_value_array;\nmod assert_split_sorted_transformed_value_arrays;\nmod assert_split_transformed_value_arrays;\nmod get_sorted_result;\nmod get_sorted_tuple;\nmod sort_by;\nmod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{assert_array_appended, assert_array_appended_reversed, assert_array_appended_scoped};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_sorted_transformed_value_array::{\n    assert_combined_sorted_transformed_value_array_asc,\n    get_combined_order_hints::{CombinedOrderHint, get_combined_order_hints_asc}\n};\npub use assert_combined_transformed_array::{assert_combined_transformed_array, combine_and_transform_arrays};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint}\n};\npub use assert_deduped_array::{assert_deduped_array, dedupe_array};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc, assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints}\n};\npub use assert_sorted_transformed_value_array::{assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N> where T: Empty + Eq {\n    let mut len = 0;\n    for elem in array {\n        if !is_empty(elem) {\n            len += 1;\n        }\n    }\n\n    BoundedVec { storage: array, len }\n}\n\nunconstrained pub fn find_index_hint<T, let N: u32, Env>(array: [T; N], find: fn[Env](T) -> bool) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32 where T: Empty + Eq {\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32 where T: Empty + Eq {\n    let length = unsafe {\n        find_index_hint(array, |elem: T| is_empty(elem))\n    };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N] where T: Empty + Eq {\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N]\n) where T: Eq + Empty {\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = unsafe {\n        find_index_hint(values, |v: Field| min.lt(v))\n    };\n    assert_eq(index, 2);\n}\n\n#[test]\nfn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = unsafe {\n        find_index_hint(values, |v: Field| min.lt(v))\n    };\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concated = array_concat(array0, array1);\n    assert_eq(concated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    pedersen_hash_with_separator_noir(input, separator)\n}\n\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator_noir(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n"},"296":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"298":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"301":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl <let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"302":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.to_integer()]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl <T, let N: u32, let M: u32> Serialize<N * M> for [T; N] where T: Serialize<M> {\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl <T, let N: u32, let M: u32> Deserialize<N * M> for [T; N] where T: Deserialize<M> {\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n"},"305":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"306":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"314":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"318":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr","source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\npub struct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"},"328":{"path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/crates/biometric_verify/src/lib.nr","source":"pub mod utils;\n\npub global THRESHOLD: u32 = 550;\n\nuse utils::{Descriptor, get_euclidean_distance};\n\npub fn verify_biometric(actual: Descriptor, given: Descriptor) -> (u32, bool) {\n    let distance = get_euclidean_distance(actual, given);\n    (distance, distance <= THRESHOLD)\n}\n\n#[test]\nfn test_valid() {\n    let mut actual: [u32; 128] = [\n        443, 603, 546, 453, 476, 401, 522, 420, 621, 425, 706, 532, 234, 431, 558, 619, 406, 375, 344, 425, 554, 414, 667, 495, 325, 173, 382, 430, 541, 397, 502, 496, 346, 406, 458, 562, 443, 484, 754, 523, 315, 591, 537, 751, 820, 527, 590, 469, 527, 228, 581, 602, 624, 591, 588, 441, 526, 598, 320, 559, 627, 413, 453, 482, 688, 615, 369, 422, 634, 337, 487, 531, 390, 361, 166, 573, 824, 681, 409, 527, 367, 552, 503, 461, 386, 491, 405, 606, 632, 457, 429, 675, 502, 607, 559, 635, 351, 492, 351, 566, 572, 373, 574, 593, 407, 652, 454, 493, 487, 581, 350, 462, 622, 298, 725, 816, 487, 564, 685, 529, 474, 592, 369, 472, 521, 542, 634, 591\n    ];\n\n    let mut given : [u32; 128] = [\n        421, 653, 568, 460, 476, 472, 522, 422, 614, 451, 713, 589, 247, 462, 520, 596, 393, 369, 357, 414, 635, 463, 635, 432, 234, 206, 381, 404, 517, 419, 565, 467, 379, 489, 490, 541, 422, 494, 777, 551, 303, 583, 551, 784, 808, 524, 601, 465, 514, 243, 637, 622, 615, 602, 622, 405, 520, 632, 281, 553, 601, 365, 455, 505, 671, 638, 362, 419, 690, 347, 476, 511, 386, 342, 152, 572, 855, 684, 410, 548, 413, 544, 518, 520, 351, 520, 438, 610, 631, 463, 431, 719, 510, 539, 581, 594, 357, 467, 369, 543, 514, 363, 578, 631, 370, 638, 463, 464, 427, 514, 369, 474, 635, 275, 689, 800, 498, 608, 716, 501, 512, 573, 319, 513, 519, 526, 615, 605\n    ];\n\n    let (distance, valid) = verify_biometric(actual, given);\n    println(f\"Distance: {distance}\");\n    println(f\"Valid: {valid}\");\n}\n"},"329":{"path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/crates/biometric_verify/src/utils.nr","source":"pub global DESCRIPTOR_SIZE: u32 = 128;\n\npub type Descriptor = [u32; DESCRIPTOR_SIZE];\n\npub fn sqrt(num: u32) -> u32 {\n    let mut guess = num;\n    for _ in 0..12 {\n        guess = (guess + num / guess) / 2;\n    }\n    guess\n}\n\npub fn get_euclidean_distance(actual: Descriptor, given: Descriptor) -> u32 {\n    let mut distance: u32 = 0;\n    for i in 0..DESCRIPTOR_SIZE {\n        let diff= (actual[i] as i32 - given[i] as i32);\n        let squared_diff: u32 = (diff * diff) as u32;\n        distance += squared_diff;\n    }\n    distance = sqrt(distance);\n    distance\n}\n"},"331":{"path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/l2-contracts/crates/passport/src/main.nr","source":"pub mod service;\n\nuse dep::aztec::macros::aztec;\n\npub global SCALE: u64 = 1000000;\n\n#[aztec]\npub contract AztecPassport {\n    use aztec::{\n        prelude::{AztecAddress, PublicMutable, Map, SharedMutable},\n        macros::{storage::storage, functions::{initializer, public, private, view}},\n        keys::getters::get_public_keys\n    };\n\n    use dep::value_note::{balance_utils::get_balance};\n\n    use dep::easy_private_state::EasyPrivateUint;\n    use crate::service::Service;\n\n    pub global SCALE: u64 = 1000000;\n\n    #[storage]\n    struct Storage<Context> {\n        // Admin of Contract\n        admin: PublicMutable<AztecAddress, Context>,\n        // Track Count of Total Services\n        total_services: SharedMutable<u64, 1, Context>,\n        // Service ID => Service\n        services: Map<u64, PublicMutable<Service, Context>, Context>,\n        // Service Address -> ID\n        service_indexes: Map<AztecAddress, SharedMutable<u64, 1, Context>, Context>,\n        //  Address => Service ID => verified(boolean)\n        scores: Map<AztecAddress, Map<u64, EasyPrivateUint<Context>, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(_admin: AztecAddress) {\n        assert(!_admin.is_zero(), \"Aztec Passport: Invalid Address\");\n        storage.admin.write(_admin);\n    }\n\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Unauthorized Admin Change\");\n        storage.admin.write(new_admin);\n    }\n\n    #[public]\n    #[view]\n    fn get_admin_public() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    #[public]\n    fn add_service(address: AztecAddress, weight: u64, base_score: u64, max_score: u64) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Only Admin\");\n        let service_id = storage.total_services.get_current_value_in_public();\n        storage.services.at(service_id).write(Service { address, weight, base_score, max_score });\n        storage.service_indexes.at(address).schedule_value_change(service_id);\n        storage.total_services.schedule_value_change(service_id + 1);\n    }\n\n    #[public]\n    #[view]\n    fn get_service(service_id: u64) -> Service {\n        storage.services.at(service_id).read()\n    }\n\n    #[public]\n    #[view]\n    fn get_total_services() -> u64 {\n        storage.total_services.get_current_value_in_public()\n    }\n\n    #[private]\n    #[view]\n    fn get_total_services_private() -> u64 {\n        storage.total_services.get_current_value_in_private()\n    }\n\n    #[public]\n    #[view]\n    fn get_service_index(address: AztecAddress) -> u64 {\n        storage.service_indexes.at(address).get_current_value_in_public()\n    }\n\n    #[private]\n    #[view]\n    fn get_service_index_private(address: AztecAddress) -> u64 {\n        storage.service_indexes.at(address).get_current_value_in_private()\n    }\n\n    unconstrained fn is_verified(address: AztecAddress, service_id: u64) -> bool {\n        let res = storage.scores.at(address).at(service_id).set;\n        let balance = get_balance(res);\n        balance as u32 >= 1\n    }\n\n    #[private]\n    fn verify_service(address: AztecAddress, service_id: u64, service_address: AztecAddress) {\n        assert(service_address.eq(context.msg_sender()), \"Aztec Passport: Only Service\");\n        let res = storage.service_indexes.at(service_address).get_current_value_in_private();\n        assert(res == service_id, \"Aztec Passport: Invalid Service\");\n        storage.scores.at(address).at(service_id).add(1, address, address);\n    }\n\n    unconstrained fn get_total_score(address: AztecAddress) -> u64 {\n        let mut total_weight: u64 = 0;\n        let mut total_base_contribution: u64 = 0;\n        let mut total_max_contribution: u64 = 0;\n        let mut verified_count: u64 = 0;\n\n        let total_services = storage.total_services.get_current_value_in_unconstrained();\n\n        for i in 0..total_services {\n            let service = storage.services.at(i).read();\n            total_weight += service.weight;\n            let res = storage.scores.at(address).at(i).set;\n            let balance = get_balance(res);\n            let verified = balance as u32 >= 1;\n            if (verified) {\n                total_base_contribution += (service.base_score * service.weight) / SCALE;\n                total_max_contribution += (service.max_score * service.weight) / SCALE;\n                verified_count += 1;\n            }\n        }\n\n        if (verified_count == 0) {\n            0\n        }\n\n        let diminishing_factor = verified_count * verified_count / (total_services * total_services);\n        let adjusted_max_score = total_max_contribution * diminishing_factor;\n        let bonus_multiplier = (verified_count * SCALE) / total_services;\n        let final_score = (total_base_contribution + adjusted_max_score) * bonus_multiplier / SCALE;\n\n        final_score\n    }\n}\n"},"333":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/address-note/src/address_note.nr","source":"use dep::aztec::{\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext, macros::notes::note\n};\n\n// docs:start:address_note_def\n// docs:start:address_note_struct\n// Stores an address\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:address_note_struct\n\nimpl NullifiableNote for AddressNote {\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        AddressNote { address, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n    // docs:end:address_note_def\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"340":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"6":{"path":"std/cmp.nr","source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(s, quote { Eq }, signature, for_each_field, quote { & }, body)\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"},"68":{"path":"std/uint128.nr","source":"use crate::ops::{Add, Sub, Mul, Div, Rem, Not, BitOr, BitAnd, BitXor, Shl, Shr};\nuse crate::cmp::{Eq, Ord, Ordering};\n\nglobal pow64 : Field = 18446744073709551616; //2^64;\nglobal pow63 : Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    lo: Field,\n    hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field)*base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i+8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i+8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let N = N as u32;\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N-i-1])*base;\n                base = base*16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N-i])*base;\n                base = base*16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn uconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (if ascii < 58 {\n            ascii - 48\n        } else {\n            let ascii = ascii + 32 * (unsafe {\n                        U128::uconstrained_check_is_upper_ascii(ascii) as u8\n                    });\n            assert(ascii >= 97); // enforce >= 'a'\n            assert(ascii <= 102); // enforce <= 'f'\n            ascii - 87\n        }) as Field\n    }\n\n    // TODO: Replace with a faster version. \n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q,r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128 {\n        let f = crate::as_field(i);\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size(128);\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T {\n        crate::from_field(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        unsafe {\n            let (q,r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nmod tests {\n    use crate::uint128::{U128, pow64, pow63};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a= a.to_le_bytes();\n        let be_bytes_a= a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b= U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c= U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d= U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e= U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f= U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded= U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b:Field= a.to_integer();\n        let c: [u8; 17]= b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a= U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b= U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c= U128::one();\n        let d= U128::from_u64s_le(0x0, 0x1);\n        unsafe {\n            let (q,r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        unsafe {\n            let (c,d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        unsafe {\n            let (c, d)= a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start:Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start:Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start:Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start:Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(), U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff))\n        );\n    }\n}\n"},"70":{"path":"/Users/envoy1084/Projects/Core/ab2/Aztec-Passport/packages/l2-contracts/crates/modules/biometric_module/src/main.nr","source":"use dep::aztec::macros::aztec;\n\n#[aztec]\ncontract BiometricModule {\n    use aztec::{\n        prelude::{AztecAddress, PublicMutable, SharedMutable},\n        macros::{storage::storage, functions::{initializer, public, private, view}}\n    };\n\n    use dep::biometric_verify::{utils::Descriptor, verify_biometric};\n\n    use dep::passport::AztecPassport;\n\n    #[storage]\n    struct Storage<Context> {\n        // Admin of Contract\n        admin: PublicMutable<AztecAddress, Context>,\n        // Passport Contract Address\n        passport_address: SharedMutable<AztecAddress, 1, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(_admin: AztecAddress) {\n        assert(!_admin.is_zero(), \"Aztec Passport: Invalid Address\");\n        storage.admin.write(_admin);\n    }\n\n    #[public]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"Aztec Passport: Unauthorized Admin Change\");\n        storage.admin.write(new_admin);\n    }\n\n    #[public]\n    #[view]\n    fn get_admin_public() -> Field {\n        storage.admin.read().to_field()\n    }\n\n    #[public]\n    fn is_admin() -> bool {\n        storage.admin.read().eq(context.msg_sender())\n    }\n\n    #[public]\n    fn get_passport_address() -> AztecAddress {\n        storage.passport_address.get_current_value_in_public()\n    }\n\n    #[public]\n    fn set_passport_address(_passport_address: AztecAddress) {\n        let _ = storage.passport_address.schedule_value_change(_passport_address);\n    }\n\n    #[private]\n    fn verify(address: AztecAddress, actual: Descriptor, given: Descriptor) {\n        let passport_address = storage.passport_address.get_current_value_in_private();\n\n        let (_, verified): (u32, bool) = verify_biometric(actual, given);\n\n        assert(verified, \"Aztec Passport: Biometric Verification Failed\");\n\n        let index = AztecPassport::at(passport_address).get_service_index_private(context.this_address()).view(&mut context);\n        let _ = AztecPassport::at(passport_address).verify_service(address, index, context.this_address()).call(&mut context);\n    }\n}\n"},"77":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\nunconstrained pub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"86":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr","source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<let N: u32>(self) -> [Field; N] {\n        // We verify that the value returned by `unpack_returns` is the preimage of `packed_returns`, fully constraining\n        // it.\n        let unpacked: [Field; N] = unsafe {\n            unpack_returns(self.packed_returns)\n        };\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, let N: u32>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n"},"90":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr","source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    inputs::PrivateContextInputs\n};\n\nuse crate::oracle::arguments::pack_arguments;\nuse crate::hash::hash_args;\n\npub trait CallInterface<let N: u32, T, P, Env> {\n    fn get_original(self) -> fn[Env](T) -> P;\n\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        pack_arguments(self.args);\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n}\n\npub struct PrivateStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<let N: u32, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        pack_arguments(self.args);\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), T, Env> for PublicCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](()) -> T {\n        self.original\n    }\n}\n\npub struct PublicCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](()) -> T,\n    is_static: bool\n}\n\nimpl<let N: u32, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), (), Env> for PublicVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](()) -> () {\n        self.original\n    }\n}\n\npub struct PublicVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_original(self) -> fn[Env](()) -> T {\n        self.original\n    }\n}\n\npub struct PublicStaticCallInterface<let N: u32, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> T,\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<let N: u32, T, P, Env> CallInterface<N, (), (), Env> for PublicStaticVoidCallInterface<N, Env> {\n    fn get_original(self) -> fn[Env](()) -> () {\n        self.original\n    }\n}\n\npub struct PublicStaticVoidCallInterface<let N: u32, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    original: fn[Env](()) -> (),\n    is_static: bool,\n    gas_opts: GasOpts\n}\n\nimpl<let N: u32, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n"},"92":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::gas::GasOpts;\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn () -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let args = &[function_selector.to_field()].append(args);\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            PUBLIC_DISPATCH_SELECTOR\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<let RETURNS_COUNT: u32>(\n        _self: &mut Self,\n        _contract_address: AztecAddress,\n        _function_selector: FunctionSelector,\n        _args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        panic(f\"'delegate_call_public_function' not implemented!\")\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(_self: Self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [\n        user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n        user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// UNUSED: Remove.\n// unconstrained fn function_selector() -> u32 {\n//     function_selector_opcode()\n// }\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<let RET_SIZE: u32>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained pub fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// UNUSED: Remove.\n// #[oracle(avmOpcodeFunctionSelector)]\n// unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let RET_SIZE: u32>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n\npub struct FunctionReturns<let N: u32> {\n    values: [Field; N]\n}\n\nimpl<let N: u32> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n\nimpl FunctionReturns<0> {\n    pub fn assert_empty(self) {\n        assert(self.values.len() == 0);\n    }\n}\n"},"93":{"path":"/Users/envoy1084/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"}}}