{"noir_version":"0.35.0+b848cc128d2dc2b461581f21a35509a1af9065a7-x8664","name":"GetMembershipWitness","functions":[{"name":"get_the","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"block_num","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"hashed","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":33,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/81VTU/CQBDdQqG7IAiI34rCSW+FKOGIogcPetQzQiNEBUPr/3cWZuywQmJsmzjJy273482b2Z2tJRbWAFjYz2CbEj+N1nSxdaNZM0YuN0mdVow6LaaxznKdBtiY/yzAAUiAAuQAecAGoAAoAjYBJUAZUAFsAaqAbcAOYBewB9gHHAAOAUeAY0ANcAI4RQ0NEmQzQWYyxX8TbAo8x1axACioLn670aypDL+xcXfabSXC6otZd0vhISXA7eqD78kFF+knX2k2Ry35L+A8nyuI8BLe4JhuyoZ2Mptx0JknlsfOxWVyeWw15/mQYVzf+TByq8cycjnP+rOGfV1YtzhPBasLsYj9Fy+4fpsOXh8+35+9GS9vnjVhRGmaZqyEjL3pJJj1B8HVcDjzfJ8zZFewijWMOcY46o8nd0O+y/kb06M388fTCd8lf8mkEGRdbN1oNj/r3ApfeaYrxrvVMuPkJ0o+c0xT3O+mxfyQf/JFdatPrYp9OLV7T19PfzT+eBoHE3anOFedjVFrxkpr0myM95Why5xfVwH8/aJY8sjnGG9dF+fdiKb5JHsPbOaL3oQUWyOZjgz7PmOxKSmW4qc3iHj1jzuLfSXX77ONfSW2Jsv2OcY+h+merxWLn73AfH4BCfu9k6YKAAA=","debug_symbols":"pZPfCoIwFIff5Vx7sTP311eJiFkagzFDLQjx3dOaFRmI82bsbN9vfNs4HZyK/Ho+WF9WDWS7Dlx1NK2t/FB1fQJ5bZ2z58P3MpBxQPnkm4vxY9m0pm4hQ0lZAoU/jdOUDSeU1hWQSdInM1jqNLAK8Y0i/mM55YHlnHxYLvp9Aqg2uyg2sUqIBReW6sAyoWYueruLxsBqwhdcBJneRVDx60LJZhdNp7tqRpdcFAmsJLM/orjSZczQiEwakWERGR6RERGZtX2274fqZmprcleENi6v/vjV1e398toZ4Ac=","brillig_names":["get_the"]},{"name":"low_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"block_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"nullifier","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":24,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/71V30/CMBAuMFgLgoC/4EHjmz6CkQTfUPTBRHnUZ2RTFnEz24j/vlfoueOUxMhmky/Xtb3vrl97XU4sWxuQM/2isXnxveGagbGdzVo3Ra5OlnnmUswzR3JsEa0LAMvoXwLYAAlQgDKgAtgCVAE1wDagDmgAmoAdwC5gD7APODD8bQxmkWBcKPGfyfDgp8YqkhwmPBCpqN5VLG5q3P2eo0RSNSnnfabMAWTA3dGHOpRLLswfYxXIHFqMXzXzdK4qkgt2bca0abDcsVmEA888Mx37573sdOz2F3rIZF9fejBt9VhRruqsPw9NXxfNjZnHYtRFVjP9Fze+mgWT19H87ckNaelS1QTbJW+asZkwDgM/DseT+NJxQjeKKEPpB1axhrFMGKdjz791qJf9N6YHN4y8wKde8pdMWmvFxvDxQv8U78AFz4cqXyZWZRJ/+Ycqs/gYC+tLq3ts+qDuXfAxms9m3rPnhveuvlLR1Ht/9GKf3APK2yJjaPm+WyymbgWWF5/nN5W+L7iHiunb7C0amPnOhk3zSVKvFomFNZsnayTJo0i+T8ielBQr+8Y3Ann1T7Nk+kqu97OYX52sKRE/m/nZJO/FWsCRSPT8BGJZ8LT+CQAA","debug_symbols":"pZPtCoIwFIbv5fz2x87cp7cSEbM0BmOGH0GI957WLMlA1D9jZ3ve8WzjtHDJ0uZ6sj4vKkgOLbjibGpb+L5quwjS0jpnr6fpMpBhQPniq5vxQ1nVpqwhQUlZBJm/DNOY9Sfk1mWQSNJFM1jqOLAK8YMi/mM55YHlnHxZLrpjBKh2uyg2skqIBRcW68AyoWYuer+LxsBqwhdcBBnfRVDx60LJbhdNx7tqRpdcFAmsJLM/orjSZcjQDZl4Q4ZtyPANGbE20/XV3ZTWpC4LLZk3/jzp0Ppxe+/08BM=","brillig_names":["low_nullifier"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":6,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"12265343917440897559":{"error_kind":"fmtstring","length":20,"item_types":[]}}},"bytecode":"H4sIAAAAAAAA/+19C3SlWVXmSeVReVQlqWq6q6q7qnNTlXQnVZXUfSepbnqaQUBAcYEI0uJokkq1jUAPdAMiqKiAI8Oj5dEKMjSioM5iRgFhQPABSiszIMKMzlIckBYXOixAVGSpCJM/db/ky3f3f/7/P/eem6qRf63uuvnvfp199t5nn30et89desY3/+trfR5s/Tvk2h/A3Nr6t9zZU+kirXJMOfuuEDn3XSFy9l8hcg50Uc5ENvWpbss7GEGv3ZZx6AqQcf8VIOPwFSDjyBUg46jrro9DxoHW57HN/w5s/nfQXRpn277khiUBvL/1feLMibMkxph0dqLMUYJPY/AFoofnSP/O52Otfx/yzGeuPrd0x9MvbPxA6c5n3V2682Jp7c5nPf3CXYw4FYp4YyhinRCPt/5dvfvujaf9+7tLd99ZWr1wofScO+7+vtKdz9545sWn3vkcxn1oKNPvCEVc70DaV3WAe1+owL8YivgroYjv66CZBwcCmV4dingiFPH0QHgzV0KZPjoU8UkdSPuTHeC+JlTg/xSK+OZQxLd30MwHDwYyfVgo4reGIt42GN7MO0KZPi8U8Sc7kPY9HeB+MFTgj4Qi/lEo4gMdNPMLoUz/IRTxa6GIY0Phzbx2KJDp2VDE8x1I+5QOcJ8dKvAPhyK+OBTxVR0086uhTAf2ByIeCEU8tj+8mXOhTM+HIn5zB9L+QAe4LwwV+KWhiK8ORfy5Dpr5S6FM39kB0/eEMv39Dph+NJTpn3XA9M9DmX6xA6b/EMq0fzic6f7hQKbXdMD0RCjT0x0wXQxl+uAOmD4ylOljQxGfFIp4sYNmPiuU6U+EIr6mA2k/2AHux0IF/pNQxE+HIn6hg2b+UyjTfSOBiKOhiEdGwpt5QyjT5VDEh3cg7bM7wP2xUIFfEor4ylDE+zpo5ltCmb6jA6b/LZTp/R0w/Ugo0z/tgOknQ5l+vgOmfx/KtG80nOngaCDTB3XA9LpQpnMdMD0byvSmDpj+21CmjwxFfHwH0r7iQCDTnw5FvC8U8a0Hwpv53lCmHwlF/EQH0o4dDMc9cjBQ4KlQxBtDEesdNPNFoUxfFor4mlDEN3XQzLeFMv2dUMSPdSBt33g47sHxQIGvDkU8EYp4uoNmvjOU6W+EIn4wFPHjHTTz06FM/y4UsW8iXNpKB7gPnggU+GGhiN8ainhbB828GMr06aGIzw5F/PEOmvnKUKa/EIr49g6kfaAD3C+ECvwPoYhfC0Ucmwxv5t2TgUyfH4r4wlDEn+qgmW8MZfr2UMTf7kDav+kA96uhAg8cCkQ8EIp47FB4M0uhTBc6YFoJZXprB0wfEcr08R0w/c5Qprd3wPTpoUyf1wHTHwll+vIOmL4mlOmbOmD6llCm7+yA6ftDmX4oFPFjoYif7KCZnw9l+vVQxIOHw6V9cAe4jzwcKPBjQxGfFIp4sYNmPjOU6Q+GIv5YKOIrOmjmG0KZ/moo4m92IO0XOsD9p1CB910ViDgainjkqvBmXh/K9EwHTM+FMr2lA6YPC2X6uA6YPiGU6UYHTJ8ayvS5HTD9oVCmL+2A6atCmb6xA6a/EMr0HR0w/fVQpu8PRfxwQWm3D4P9ZQsxWYvd13qXfNfFk64VWuftLu3lRnWkJXsEudf4gF2XaZeTPYEPHd7RvSNeyfmoR7S+w799rf8Otr53hH/Q7Rz++yZ6h530D6N32Bf9cHqH/YmPIHmGo/RXfTlifzUPut0HItGWsTj8lvqEF50P2uY56qLZ0NYtBGPCH7zgy1v20urMYXo3MLxbzi17EXtM/izR98PUJnx/RtrGsvSLLAndwRi6WK5vJLSHYtAul+uswwFDh4OGDocMHSah9jFCJ5F7/3AUubdOHw+TjAPEC3LuI5hhkmOQ/j7tdt6P0AbCAdIL6CZl7iHY0XA63oDgTRLMEOHtF7z9JPcW7OZ/063PY679UPStrX/Lgc+FZqNaK1eaoL+lO7fTv+DVbb6tp5bQPWDQrdTqlQvNpcbF1XKtvLG+UatUaqsXGrX11Vr94oVKba2ystbcWFlqVsv15tLmu3qlvlytr9cvNFcvbNQaCV0sdmNs6ZLM5YT2ONHumk1XyuVEZlpK2db9ZAx+m77vi/GTZAMTcfhvxfhJ4Q9eHOMPiUyT9I7Hn0NC65DQSnRJk+mu2QTLc7iAPBYe93cHMtb0xYjIk5NuJeP7LbpXGXRr5Xq1udGsr25sbPrwysryeqW2vry+sbF+YbW2urS0XF66sLax6dXVtfXqxdraxfLG6sZyo7JWX1uqlNe38uoHkS676MNbtK/uXMdtdBNbvcbtfhJeR6gdXfSfhs9/wXOUZIrhv0eEP3ix/x4VmSbpHfvLUaF1VGjtJR58kvszeW5t/Vvu5Klc8qOjBt3Noa/SaK6Wm8sXm5teXa1V6+X1leZa/cJqo75UbzY33ai2trxUqaw3qpX1pc2BsFJdrTTW1su1+sZqM6F7jNrcxf7fGr+vjUN7a+57XRzaW/5/3OrDeqVarVXqS2vN5c35d/nC+nJ1Y3m10VhdaVQv1C9crJarjebFjXJjpXZhpb6y+bpeWV8tly+WV9cuVrbyjhMG3epytbG+tLK+3lxtrK+tbWxcXNrMVJYvVtaaq5XqWm2zw1ZrteV6vby6cXFjrV5baW4mNOvLK5uirJfrKwnd6y15O3pqjcQ3p9zuJ+FViqN3b74BnqMkU4x4VRL+4MXxalpkmqR3HD+mhda00OomHveLY52sLq8vVTea5Qvlzf9dbFxYLtcb9ZUL9eWLm0Nw/UJ505TKayvLGxeWKkurK2uNWnX1YrO2OcI2auWllS1fmDboVqora5u5dhJl1pbKzeqF5lqjXt9Y2qg111bKS7VmrVG+2Ly4tlre9Jnl9U0/WKqWV1Ya5ZWLjaVyZWvOetKSt0MbSvrnlNv9JLxmSL+9slnwHCWZYtjsjPAHL7bZWZFpkt5dT7LNCq1ZocV4hzvEO+h2y548IwTXy74Cz1EXzVYqlp5mRE+JTm4QmSbp3UmS7QahdYPQYrzDHeJxvzjWycaFtcpGdaW2XlvfWKmsXdwckDY2P66ubo6P1fXNAfDi6sqF8kri/5tDV7m2cXGtsn5xtbq+Vqs1li6OEK9u93dC+8Y4tLfysbkotCvlpMaCest3tiawSc3lR6kv5q2+CHxqFzaWlqvNlYQG6l1c55mnd/j+z92OXC8iubgvu3cD66UcZzYK7aUlHR+6KPeWDZ6KQru6VQ/iMRR9ME38umiX3vkkeI663TGq2/FTcyPw4vhZEpkSnUxF6YNGY5L4MY+SyFkSOTln765MzQ2W6fqCMp2II9May3SigEydtOV4nLZcZJmOB7Zltgc6YLxTPeZXRC86l+9ibK+zTNcVlOnaKDI1d8WMawvI1I3+LKqDY1F0sLTCMh0rKNPRODKVWaajBWTay/68IRCP851pwkn+xtoY6uuDBPOx1r88zuKJV8uuNPuEl1XLPkifS61/R0WmTm6F36zCLW0uJW7W5yqbVY3K1h4IrW/jb95PdI3AaM7C6w1d1tuu9ftrSE9Yg2bdYV0csvD6/YiLtU5Qqfv0CJ6T9I7ndFn6P0xt4Pbf6HY/miP2ah0GPEddtLnqVt48JfxvFD0lOjkuMk3SO64fHBdax4XW5YCXtAdzaLQ1mat+aWjne55Dg5cTXs7gBTzoKVmTPi3v+ugdaJ02aAH+NMk9ZMj9VwZd7GsB/DF6D5hbqH7wOZJX5/YTRrv66B1sct7ThnkDz4mM+4x2OKF9I8mk+rHwLNpnBAY41xFt8DvjwbNonxUY4FxLtMEPsNyvjmg5oeWE30GRqQje2UC8hUC8xUC8c4F45QC8xF7RDxznoON5egf9naZ30E0/vVsUfsk7tGmQ3kHeG6kNFbf7ScahqttpT/fGgWrFpx/wHCWZYoxDVeEPXuifZA9Kkneib8ZFvpIj5TExCJzWQDYA4PFgUQukVTNo1QNpAe9qooU9gDwYXN+3Q7fReo/BAPBz9B4wR2gwmG7RmCAc6GWCPrNeaiTzIcFxbne7hz34iUxTgjNI38+1ZOPNWHjSFqVBp5dOA56xF6Xrwl8XpeE0CF7jIl/JkfI6Nc5YTtMIpAU8dhpEFXaaFXKaZus9nAbw7DSA+ZuRHRo3k9OoAU/Q5yyn4T7gdk958BOZ5gWHneahGU6j+uVVpF46DXiOkkwxnEYzUPBSp8HoPi7ylRwpr9OpQiynaQbSAl6W0zyenGap9d7nNID5EDnNE8lp0AnWtCPLabgPuN0NDz5Phdjp8f2/y3Ca0/JuhOj00mnAc9Ttngp122mawl+nrHAapLXjIl/JkfI6Nc5YTrMUSAt4WU5zJznNcuu9z2kA8yZymmeS06gBT9DnLKfhPuB2n/bgD7qdDmanx/fPzXCaQXk3QnS6bLQXfH0HnqMu0tmrltMsCX/w4rlqTWRi27yKZKsJrZrQYryjgXgHA/FOBOJN91jO2UC8Az2W83ggXqlDOa0YOEJwXfaRFZ+PgueoixYjKpaelkRPiU6WRaZJesdngpeF1rLQYrxqIN5UIF49EK8RiDcfiHc6EA/jmZUTjBBcl23Iu3cUPEddNB+qWHrScSZp/0oc/usJvfPCf8ngf1Mc/ssJvZuFv8a6Q60+gJ6gC8gN2UCnn2Q9nUHbmlECh9cr4O+ADc1dOe+7xiOntaYEeF5TOh0gQ+jEl8uWRfB4gshtbgiezuS5zY3ItCYK0pqIKBeP7RP0Tu2GCxHX0Tu+E0Fls9rZ57rXzr4C7UybZ32C5lkYL3WedS29B8y1NM/6pFHR0/s/nNvZGzNFMjG/5HkgY15kteEzOdpwzGjDl+iuhc9SG9DP7PtWuXxA2nhr6+9yZ493rwM+xy6XK09ds46Y69bzlusPk5yQpU44yYO9XezTvGYJO+Vz0KczeOcdx0CbxzG1o38N41jIaknSZvQptznPXA3wtci0ZgrSmokoF+8hmaF3eccx9NFBQzarnX2ue+3sK9DOtDHg6L52ur5xDDB30Bhw3b4deYGjS6LO7YxjFZKJ+SXPVItW2jhWM9owTW2oCE3A8zgGmFupDTNGG9j31Ycvhz17cVbQ7D17ulci4ji+NY71C38dRzGOTRGMIzzfOMb7bGCnvnFMebOdAcYax0CbbRJ3vjVbxBLbq7c+s33D/pPvHxjaoXma3uMdPp+hd/h8lt7h8wK9w+dFeofP5+gdPpfdjqz4jOdyWNUtR+Fvr+qC156v6oYkRzzwMa39gbSAl7VA9RgK1qDlW6ACzDEK1o+lYI1O8G0m5c9pq7rc7rIHn1d199M7fP+dGQOY6nfExVpV9TsNeI6STDGcRoMpeKnTIIiNi3wlR8oLycA58sdymoFAWnif5TR3kNNghPM5DWD+dv8OjaeS06AToBdrFzl/ZqfRDsWz34PPJ7rZ6fH9XRlOo/qNl335nYazr0jZj5l9gZc6DUb5cZGv5Eh53TT0/kBa/Qat2JvuXkhOU2TT3f8gp/kJcprtKYrbeYfPrBe+fvWQ4DjXXm5Nw09kOiM47Nwvz3Aaa9OdXht7a+vvckeP32nAM/amOz0+kbbpDuntuMhXcqQ8+kXAbYHTGsjGCTw29JAzFHwuoJsOmOU095HTANbnNID5BXKaN5HTABZ6mXDtiufP7DTcB3w/5JwHP5FpUXDYkX45w2kOybsRotfLvQngOUoyxXCaReGv94Cy/QKWbZPnW+qAZ4SWddalKN7+QLzTgXgDgXhTgXhzgXjwFessVLzA79+bwIE/kg+Zgd/amxDpntN1jpPgb93t2x+H/7K1frso/LE3AXqCLiA3ZGvI3wnt8QzaCcx+gQEO18JKrc/sv3x2LfnvnODtI1psP4P0/rdawibjzkepjhZyHpDrZlxvz+OHgMd3nZyd7OU6E4/R3OY5wZsTPG7zXGRaEwVpTUSUi89c8r4HtRuuOvB6Ea9pqmxWO/tc99rZV6CdXN/l/PBv97XTRX4IeF4vAswS+emXjfyQ8wHsoR0QPrxeBJh/zMjnrDb8c442HDPaME5t+JpRgmTft8bgSIcnGnnLfDHHYK0KaW083p2Fl3KQWeFvjYGHSU7IwraWPLxeZOW9sFNeLzqTwbvP7V4r4TGEx0jQ5jUWzLnwXWJ77+/fwUE72LbQJrVptvXt+1DJpisGXV5TmpV3se9jnkppR4neA+ZoS3YrDjAt16Kld8T2EV3AAKdMOpgWGVgvi/H1UkvoncihF8CUMvRywhXXywlDL22VR7fbJ6E3wEVcP6/7dMQ2BZg5j474DqM5kn0gzm8HNRKyf3jVDm/obZD4aZ8BhvtM7V37jAu8fNcvfBs0OS5YORPo8d1us4SbFX8aGbpXXB6/D7rd8iRPxDuca75xlu9wjjTOmXc4ay7HNsP9incLJNu00FI7YrxS6994d7yWq76YP03vAfNNBWO+6srSgRXzZ0WGtLyV96Kk5a2AebRH9rRxnelze6w9urfTuP5txrjOc5hp4WXdfaR3mnbbr45SG7gfjtN7wDzh8onXdY3X2+MO8dPfcgEM26HeMwYc6z402CPbJp+PzHMf/gmhZeHBLji2Q54hgeGcEzAXPP3E8+gT9O600Ev43NOiw/F+1+o4jU8cJ9J8BDD3ko88NaeP8BzP2tvO/dCrOR54xt7bnpV3RIwRdcuP0va2Q07IcpRwkgdzPO5XHrN1fLPGRcBP56TlAmlNFaQ1JbT2Oh5a+evRjHb44uGN1FZfPOQ+zBMPpz20pgrSsvLqRZHLWiuyaoYc/2Lk368OyL//lmpfmjtYOZzaN48Rr6MY/J7+drpcf5iSd72KN9oOKyd5Y0YumhW7fDbP9V2NbayXxfh62crVjuTQC2B+KUMvRwL0csTQy1GRwbnd4zP0BriIY3XdpyOuSwDmV3Pms9Mke6/qD9s+QPy0z/S3Ca1cQfuMc1DrLkzQ5LhgjYGg58tRffHnNzJ0r7icb3J9tkTfv5/kzbPGiXe6xon37xzYof1B4h26xokaAK8RLQjeguDxGhG+6+S+1l6ujXJtndus+/mt+4UBPx+Z1kxBWjMR5eJ8ZYbeqd2wv/IaJ5+bUtmsdva5Yu086drbeVJonfS08yTJp/64dd91f7uMiOOA5zVOwCyQn36OchngcI6EszioFZ0jmUAXMF/MiFHWPr4vURvOSRuss92AGaA2/D21ATjs++fc7ifiXjnv/Jf3yp2Lw9/cK2ediTsbh/9WTqHrjOeEP+a/kBOy6F42XuNEf56jd7BTXuNcyODd59rPxAGH1zhBm8+AYo7BZ9teR2fezkk72H/UptnWATNMNn3jQDtdPg+nZ+R6tW7t22MLmPGW7Gm5tM5N0RbuI50/AqdCOpgXGVgvi/H1sjXHmMmhF8Bck6GXGVdcLzOGXmZFBud233MPvQEu3nnIS7aTpiMeswBzvUdHPMc4R7L3ao6x7QPET/vMWpfW3Eb7jPdrnKV38G2ukyAu8HgJuqDHc4yzhJsVf85k6F5xefxOO3se0/ectB8PeMY+e66+qHkh2wzPJ/GOx+A89TqNgRHXkKuW36LfeSwAzPmCsc06q646AA6f79b9UNZ9PswPeavuZ2TZH+KRnemfSaHP7Tlm0P9uGtcfNtBOl9dvdO/SBNHheuI0ydJtvypRG7gfuC4BmG/JGa/nSfZe1fQxf+J4XSL5rPmXVbsBDs8xdQ2F+5PneHnmtYCf9+DBLji2c62bYXhcBcxtnn7iefRJeqdnYBI+L27R4XjP87nvofFJc0bLRwDzUvKRtZw+wnM8ji/JM+Ki/caud44HnrF/I/2k8NfxImKMqFt+NCP8MceDnJClRDjJw2ucar9sQ30ufVzUfDaLlgukNVOQ1ozQ2ut4aOWvpYx2+OIhr3Fa8VDHaitnsvb4z3pozRSkNSO0ONbxuueC0Ldqhhz/rBh9TuCtGA0YK0a/JGMsVVyuAVq5g5XDqX1znnIPxeBfGWiny/WHGXnXq3ij7bByknszctES/W3FLp/NW/XdaUMvi/H1UuM1JJ9eAPOGDL1MBehlytBLSWRwbvf4DL0BLuJYXffp6CS9B8xbcuazXDvpVf2hBHmJn/YZYLjPNFfQPuMclOMffLvU+pfjgjUGgh7HvxnCzYo/78jQveJyvpk8i0QTsh+md/j+3qEd/HdTPhuy1se14ivx7s65ADweE7jNeXIiwM9GpjVRkNZERLk4l+CzmHnv7tT92Vnt9OXKVjtHXXs7R4XWqKedoyQffGzXHdSeOSHgeZ1yex2B/PSTlI8Ah2uL8HfUexZJJtAFzAM565y77qCmNixKG6x1SsD85eAOjc8abWDf1z0KEe9D8M5h+T6EhTj8zfsQ9Dxi7HUJ9WXdS4I5rNZBZgkneay7OxfoHezUd3en8mY7A4x1d6fuAQ/d63K5jGOhv488G4D3jf02xeRKmydb4xj6kccxroOobFY7+9ze7bcx76Ae3KHF9zjxGMDjGGC+m8aA6wZ35MX6D4/bvAeiz+3+bXSlO9WiVWQcm6Y2pO1N4HEMMHVqwwy1wbqD2rpTINI44h3HwDP2nQK652Sv99uk3SkAOfPst0F/8p0CsFPfOGbdKZDnDmpd2+R6F8/3fob22+heD59fsq0DZpls+omGX/I5Q72fK/Z+m5mUdlj7Sm7xxAGm5Vq09F4gq5YKnKz9NqDVg31INY7nPr0A5uEZejkZoJeThl60xuzcbp/UMW7ERVsbqvt0xDYFmMdkjCGod50l2XtV79qukRM/7TNrH4Hau/YZ5w9n6J3eu89xgcdL0LX225wh3Kz48105x2/ew4Px26pXRZwveffbgCff3RZjnNWcVf2V14E5Z50RPVo2orVua+0oot9Wi/rtU7oQ27L8xMrPOebPGvyQt/L5Y5X9GR7Zmf5iCn1uzzGD/stoXH/WYDtdax2L9xeclHdJv5dIlm77la5P6PoIr088P2e85r1Ce3mGVtcnAMN2WBIY4EAPk85ef9O1rrzz2mmhZeHBLji2Q54hgeG1XMC8xNNPPI+epneLQi/h8y4j3vN87hU0PmnOaPkIYN5HPvLKnD7CczyOL8kTcZ3TO8cDz1EXbQ2xYq176ngRMUbULT/SOgbmeJATsujvDvF+G82B2Ib6XPq4CPiZnLRcIK2TBWnpGuZex8Ntf/TEQ22HLx7yfhvAxK4ZnixIS/cyZtUMOcZrzZDjn1XnsPJvjp0Mw3UBwPx6zvybc/qjFCs1d7ByOLVvHiN+m2Lwpwy6XH84Ke96FW+0HSV6D5j7M3LRrNjls3leN9XYxnpZiK8X805DSy+A+YMMvZwI0MsJQy/WnYY8PkNvfKdhpLG67tPRNL0HzB/nzGe5dtKr+sO2D3juNLTugdBcQfuMc1COf/rLRhwXfHU8X47qiz9/kaF7xeV8k9ewOY9eID4cf629OX9N8W94qJ0ux78Fedfr/YZoB9swYL6Y4ecl+nvA2Wu9ajPAsc71TRt66dXZkKkcegHMVwqOC3n0MmXopSQyOLd7TQZ6A1zEc1N1n4547wtgvp4z/nEt4nLfb6j7KrTPeC2J90noT+lxXOhz6efaOf4tEG5W/DnQop2V/y0STewDsvYcxPY9J+3Hw3PgSHZtzoF1fxnbDNc18I7XgEtCqyS0GI/PO5bitM+80xX9XqL3gLnOYzuWn6iufDmvdZ9jid6B1pzBD/VX3WvBsp/0yJ52dkbvdAWMdafrLbRv74ahdrqcu5aEF+ezfEbmcrnTdSEjZvRwf/ie3OnKuQe+5/vJ1O41P7bu0/KNK777AktCh/eO3uTpJ6478Z2u80IvIXF7iw7He66/3krjU4nkSPMRwDyNfOShOX2E66//2u90LbU+c/31SrvTtdT6zGN2Sdqg7eTcqZSTlgukNVWQltYh9joeQg5fPNR2+OKhdacrx0Mdq62caVr4cZ5j0er0Xl2OdSV6p7UG6+wBxz+Ov+Cv9VqWcUhgeO4DmO/PGEsVl88SWLmDlcOpfXOe8gyKwfcMtdPdo3vmzTtd0Q4rJ3lORi7ayZ2us6QD352uPbjr1rzT1dILYH4kQy+d3OnKegm50/Uo8ei27aTpiG0KMD+RM58tkey9qj9Y+az2mZXPqr1rn006O8eFb4MmxwVrDAQ9352uvvjz6gzdKy7nm7w/tkLf/wx9X2695/uaXmfg40n69l/TvYh6N+ABt2Mrt2/c/eiN5z5h9al3XFi9+447n/64jWc8a+Ouu/tIvEVpCn+X1tx99G6IPh82vucnj/hc/gIMcDAFmSC+visyfd21j2iB/jUeOXVLOB+54GNLoUd/Qo47JXhnA/B4i0ynP70ai9apgrRORZQreXdO5OKlfj4yhH7kI0N6/CWrnX2uWDtPGe08JbROedp5iuSzjtvcP9Quoy4LWEeGjtPP1H+IUlOEdN7KqkeGyiST0v1IzpI3t+Gj1IZyShu4xAGYv6P0+uPUBi2r81CFJxmKIg0F3qEIPEfd7p+M7/ZQdE74W0eGIh2ZMo8MlYU/yhmQU5cZtZzBPl2md7BTPjJ0NoO3NYYAh48MgSbbUU34JWb3AKU8fBQpeUZctH722hl4jpJMMeysLPzVznjs537DuyrJpjar+QfjDQfi1QPxatSesdZnTou/RDYw0no/Rt/fMXnpM8dY9r+02M3xEDBfobh3zf52ury8o1vdYx95n0tph3Ud1b9kTJ/1aJR1xEC3DAKHl+/12A3r5Vx8vdS4tOXTyzbMfr9eZgP0MmvoZU5kcG533NafiI59JDFNR9YV4Ac9OuKyQplk71VZAXrjsoL2mV5zYNm79hlf9cD5r25n4rjgi9F5jpVZ8efaDN0rLud4acfKIv0kvHdbA/8kfMxjZXqE2TpWNi8ycbmc84c8W6R5i3LyRIxt1aIxfz4jtvUi5p81+GFuYx0rA0zZI7t1tEXpc3uOGfS/heZk9f3tdM8Rr3nhxfGctyrPkCzd9qtT1Abuhxl6D5ibcsbrvThGsT3uEL9TJB/HYrbDGYEBDl8FChhe6tGfdrVihHUNzqzQsvB0iY1tUK/I2x6nCOaRnn7ifJhL3bp1dutYZItO2rGyx9D4xHEizUcA8zzykcfm9BGev+l1dBG3anrnZ+DZ659J1/Ei9lUB6kd6hS7qAJATspwinOThbQ1oA4/Zea700Wu2smi5QFpzBWlpHr7X8dC6FuFURjt88ZC3NVjxUHVp1Y+seqv2HdOaK0jLyqvPiVyca3OM17oyxz+Lv5V/c+xkGK4LAOa5OfNvzunvp/qo5g5WDqd9wmPEj1AMfsP+drpcf9Dr43oVb7QdVk7yooxcNCt2+WyebVJjG+vlXHy9mNfa+I7tvCxDLyddcb2cNPRySmRwbvf4DL0BbsS1r53c2vq73NlT9+mIbQowr8mZz/IW4738GSntMyufVXvXPuM1Lt919xwXrDHQOlamOaov/rwpQ/eKy/lmYndXt96Pt/5N+maJZOle31TLCb1lagPH9iV6D5hfzvC9Zfo7odVofeZ+XBIY4PD8uCky9BNck/AZtp/eLxFfC48/Xy04ic2MCxzzOeNpi9YE+4i+jp2sX8C8y6PfEWpLDDtYIXkGSD62D8D8eoYdrLjderHsQG1lRfTCvgDYfvr+asJnWLaDFeJr4XH/NQWH82iWiW3Sx+cI0ekXOEtHVt4FWmo73FeA+VDOvGuFaN63b6ddaD8fk+6lvUE+y97+sKC9YV6Wx9447qjN97t2u1TYBr1fJr4WnmVvwOHtyz57s9pixR3QV9th/QLm/2TEHbbbbtvBeZKHxwO2D8B8OsMOzrvderHsQG3lvOiFfQGwecYftoPzxNfC4/5bEhyOFyzTck4+HHcaAmfpyIo7oKW2w30FmL/JGXfOE80XUtxBW3lreZNk6ba98bjLbWvSe8B8JcPedPxvge+yt6bAAIfjTkNk4HGO+5thB+h9k/haePy5X3B462/D4DPlaYsVd0BfbYf1CxjMOdLiTi/zXs052caHPXJa8diyg7S8l3PMfpGh39n5LcOyHfD4Y+Fx/zUEh8cfK+/N4sNxZ0DgfGMWx50iY9YRT58cNHC39rlQ3IGMPAdukCzdtje2f25bw2jb9Rn2pn5o7SFrCAxwOO70iwx57G0/vee83sLrFxkYh2uk/QafKU9brLgD+mo7rF/AnMmIO70cfzT28/hzLsMONKZYdpA2/nCsHxAZ+p09zjAs2wHPty08a/zh+faUIVMjJx+OO/sFzjdH57gDWr45OmBuyRl3eO72GIo7uv+AbRc2gf18FXmfPN80vEN3fbidLq9dDMi7eDHuUo2ymdIOK8Y9qmCMs3L5tBhXIx1ojGO9TMXXS83yeUsvgHlcQZ/Po5clQy/WvIV9VvPEEbd7Dtpt20nTUT+9B8xtGT6I+jZfndKr+va2DxA/7TPO1wGjY6X2Gc8LB+gdfJtzp3XirT8/AXoc/3Ts9MWf2zN0r7hb17bva/8ezwjRjuF7Ttqvn0dJphh7HJQnePH+Oh0zee7OPqe+qnVVxmt1U8zYVi2a1z67YMxXXeXNazXXnCBadYPfQOtv3kevsv+QR3amP59Cn9tzzKD/WhrXf3S4ne4U8WoIL47nPJ+JU7+95Fdav9V6Jtdv/0POeF0j2Xu1n2R73CF+WiPkvBMwafVkrqss0/fJY61tWXav48MkwTc9eLALju3Q6ZBLn28A5l5PP1n1aZ7D8fjzgRYdjve8v+5nSdc6P7N8BDC/Tz7yhpw+wtcGsb6SJ16Nyb+/DjxHXay55qWxR/MOHS8ixoi65Udq19hfp+suK4STPLy/Dm3gMVvHN2tc1Jw7i5YLpNUsSEvz8L2Oh9v+6ImHRdZzeX+dFQ91rLZyJp3jcJ5j0WoWpKU1TqsmYeXaadcGfYB0VxP+Vv0hrXYFXM6/789Zf+C4f5TqD5o7FJ23f5hi8OeG2+ly/aEp73oVb7QdVk7y8YxcNCt2+Wye59ka23q71n4pVzufQy+A+dMMvZwP0Mt5Qy8rIoNzu8dn6A1w8dahL9lOmo6sdegHcuazDZK9V/UHK5/VPrPy2bR1ca4/WDkufJvrnZ8z8jvQteoPuu7jiz9fzFl/4Jruz1Kc0utVrforYqhep5Y8X6b496CRdrqXU/3VNxf/54j1V56L10UG1kstvl5qvjV/q/7aP+LXSyf1V2uPY1r9FXrj+mukuUK96L6IMY+OOP7x+Nar+Ae9+eqvgCmyTyMtT4RvgybHhT7XfrVvkfzPij9HM3SvuFvXtvftfG9dnVsXWW5t/V3u7PHWX8Ez9tW5deGv1xzynAew1vyiaP212vr3cqq/3pgR29QHrCshQ2M+aA0b/FB/BYxVf130yJ42rmv9FTBW/fVRLfqJv1SNcZ1z1yut/rpy+cTrPam/wh7ZNrnupzFCxweuv9Y9eFb9VXNbjTVsg4/w9BPXnaz6K48/d7XocLzn+uu30Pik9VfLRwDzXPKRb8vpI9+ov+7w//+p/mrtz/LVX317fHx7vYrS6mb9dS/iYS/qr1Y85D7MEw8bHlrNgrSaQsuqsRepv95VMP/m2JmWfwPmOQH59ydawShv/VXte9c6NMXg14+0072c6q9oh5WT/HhGLtpJ/ZXXAX3111p8vZj1V0svgPmPGXrppP7Kegmpv0Yaq+s+HXFdAjCvypnP7kX9ddsHPPVXPi8IGM0VtM+sPQAcE/lc3+uN/A50t3/Ci3hrjuqLP2/M0L3icr7J55i4rsXnk7rXN5f2W99EbeDYzvYGmF/M8L2b6O+ElnVPnvY1cHh+vCIy9BMcxz2GZfvgc18WHn9eFhweb1cMPjVPW6x990XOiv2aR78j1JYYdnAzycP+xfYBmHdn2MHNbrdeLDtQW7lZ9MK+ANh+134eUWHZDm4mvhYe99+K4HCOxTKdz8nnCNFZEjhLR1bexWcCGYb7CjC/lzPvuplo3kl5F2Tk+kwvz7VaZ7cB8wcFx3wr/09bv+O4o/O7PPbGOQGPWxaeda6Vz9PPCxzzqXnaYsWdImfjP5ERd3o5/mjs5/HnUwXHH8sO0sYfjvV65jjPOXe2g5uIr4VnjT/A4bhjjT9ZfDjuNAXO0pEVdzhXYhjuK8B8IWfcuYloPp7ijs5tL6d7Fb5ccA5mrQdcCfcqaM2X+dQ8ben0XoV9o5f+vdzvVRjyyGnFFMsOroR7FWqGTJfrvQpXe/ok7V6FFaPOxOuQvTxPj3U+6zz98Qx7S/PDPOfpwTf0HimuVxa5R6ohOImdVAXOqj1ZbUEbOO7wfDpNv9u1xYy4c7ncI7WQYQdpeWCe8Ydjvd51kOd+DbYD634nxrPGH857a4ZMSzn5cNypC5ylI9iF7x6pYaHDufLNGXFHcROa11Pc0bvNE3vjO827WHtrJvQWqA0Dbude+bP0HjAPzbC3Bfqb9cT2pr/fs0B6gA70LveIOtiqLy/m0AFgHpXRv6id8ppBr9a+tvuS+OlvIQHG1yfAgR74t5j4/j69nxzwvt+eAAzfTw6Y7/Dolue//NuDSi/5+6+M7x3J5ERuPLymBjyu+c/Luz6X7w5o3VvDvzPE+wq+d7SdLmwS8MfoPWDeddUOjfXRHXmHiTbeDRltGKLP3EdWG4YMPOfS/V31Axz+LS5r79F8DtpZ9+Nze3336lu09V5n4FxLtPWOao7vjmg5oeWEH/+uTFG8M4F4Ib9f2cnvZYb+Pue5ALzEXtEP1k/0clzT+2Q51vXTuwXhx3fjDtI7yHsjtaHsdj/JmBDnd9uqFZ9+wDP27xPqnQnW7wMmv7GHfhgX+UqOlMfEIHBaA9kAgHeYaFUDaVUNWrVAWsC7mmhZg8G9NBjwZjceDOboPWBeQYPBa2kw0B+240tvWC9VkvmQ4Di3u91jHvxBt9PBfBAP378xI5HSgXvExbpowu804Dnq2gfK7vC/5DR60FEHYTgNAtW4yFdypLxOjTOW09QDaQGPnQZRhZ3mbeQ0ujMT8Ow0gPk+cppfI6dRA+bT8llOw33A7R7y4HNWx06P79+b4TSq3xEX69fB/E4DnqMu2umIipUl6u44OA2ygHGRr+RIeUwMAqc1kI0TeLGcphFIC3hZTvNhchrdSmc5DWAeQk7zUXIadAJv78fnLKfhPuB21z34iUzWlht8/8cZTqP6HXGxjtT4nQY8R120Iy9b/HVLpy6DwmmQ1o6LfCVHytPzUHmNE3ixnKYZSAt4WU7zWXIaPftnOQ1griWn+b/kNLqXm+fFWU7DfWDV1NOcZlBw2Gm+lOE01lkE0Ouy0a74+g48Y59FGBT+um+U7Zfng3g3RrJVhVZVaDFeJRBvKBCvFohXD8SbD8RrBOLxGTnu0+QZcbt/s7yLNnTBZ8PgOeqi+VDF0tOg6InPk1VJd3h3gmTTNTc9Y8Z404F4BwPxZgPxDvRYzqsC8Y72WM7jgXilDuW0coLY++idyImHz7xFihHmmTf10YhnLdat9dCmwT/Ofr/yckJP959pLD/U6oO0M3e6L5nv/5zPoJ3AjAkMcHi9AmMyYENzV54YXeOR01pTAjyvKYVMYLn8WBQvJMfmCSK3Oc85N8DXI9OaKEhrIqJcnLtM0Du1m+Qd+vE6eoc+OmjIZrWzz3WvnX0F2pk2z/r2sR1aaRW9a+k9YF55eIfGE8ba5eW5AnLeAZGf71EAzG0tWlnFBG7Dk6kNWsoHPK/rAuYOasP3GG1g37fuhY40TjXy5rIx74XWXFZtLGl/pDWuulVE0buWcTYcckKWKcJJnhta/7JP851hsNMHUVvmM3hbscYax3TPXujKweUyjoWsLoTWsJI2o0+5zWXB07VPbnM5Mq2ZgrRmIsrFq0sz9M4ax9CPPI7p3TZZ7exz3WtnX4F2po0B99AYwHUiHgN4HAPMpw/t0HgVjQFaz2B5B4QPj2OA+emAcey1OdpwzGjDu6kNr//GOIbnshjHdL6TdxwbI5zkyRrHYKcxxjHQ5twKv2X0X1uCJrb31tZntm/Yf/L9bZM7NCEL74fHZ74jAp/5t891/+oEfV6gd/i8SO/wGfuIrD1Q8XzCv0DFPnEuCn/bJ8BLF6jQH+MiX8mR8rq5qFQOpFU2aHW62swLVDB8Dtb3U7CGsyJYA54XqADzUxSsP0TBGp3Ak1ENCvyZF6i4D7jd5zz4iUzDgsMD2B9mDGCq33iB1O804DnqYm3FuOQ0mpRpsg2nQcAaF/lKjpTXTUMPqS5xNYNp7Q+kBbwsp/k0OQ1W0HxOA5inkNN8hpwGnWBlmqyXMZL5kOA4t7vd8x78RKbTgsPO/bkMp1H9jrjdO6d75TTgOUoyxXAa3QmuvzwLp0E2MC7ylRwpL2QL9yThxXKaTo9AZDnNV8lpQMvnNIB5KDnN18lp0AlWmpXlNNwH3O79Hnwu77HT4/uh1rpgmtNYU5Y4O0X9TgOesacseuzDmjIkToP0dlzkKzlS3rjb/eQ1TuB109C76YBZTnPkwA5dwPqcBjDHyWmubdHg+Qr0MuHaFc+f2Wm4Dw7R55oHn88FHqJ3+H46w2kOybsRotfL/UPgOUoyxXCaBeEPXlyHHBKZ2DZ5vqUOaJ3X0l3GRfHmA/HKgXj7A/FOB+LVAvHgK9ZZqHiB3783gQN/JB8yA7+1N2EuDv+tvQlHhP8hg//VcfgvW7UyPUuLvQnQE3QBuSEb6PDehPEM2la9DDhcCyu1PrP/8tm15L9FwdtHtNh+Bun9UquInLTtEa3Y3sm+h26tK4TOVkPPFlp+n7fNiFXcZp2B6F143ObTkWlNFKQ1EVGutH0PajfJO/QjrxfxGXGVzWpnn+teO/sKtJMnEJwfPuVAO139bS1eLwLMrxzYofG0A+3ysn8jRgwIH14vAswzck6CuA135WjDMaMNL6Y2PNvIcdn3rf2BkWrT3vUi8Iy9P/Cc8NfJV7yKzaUcJGsPHdaLIKfeZ2KtF6E/ec8x7JTXi8oZvHkvD2B0TxGvu/DvVWPOxfeRrBzcwUE72Lb0jgbQY1sHzEvIpn/Z8EuuEGrVMOlT3tPc7T6dTmnHLL0HzD2eOMC0nLPL0H1EFzDA4VOWcyKDdYgsol627oUpuWy9AOZnMvRScsX1UjL0Mi0yOLfbJ6E3wEXMyes+HXHtAjBvzBhDenh3Ttu949s+QPxKJB/bKffZnMAAh9e+AcN3TMC3QZPjgpUzWb/7OE+4WfHnv+Qcv/mOjLsoz9fidryTxf7fPeOTxZHGOfNkseZyiU6sfsU7vq9KbWROaDFeqfVvRL+tcqzx+S1g3pcR2zRuqa4sHQCHY9u8yJCWt84SnbS8FTC/45E9bVxn+tyeYwb9T9G4/nvGuM5zmDnhNUF08C7pdz5n1W2/Ok5t4H44Qe8B8weXT7yu54nXx0m+tHh9QmCAAz1MEgwfYEcbp4lWnnkt4H33T8EufLF9TuhwbP8zTz/xPHqa3ml+nvAZbjkQx/tdq+M0PumCnuUjgBmn2tFncvoIz/E4viTPiNvdD72a44HnqIuWd1asHFrHi4gxom750azwxxwPckKW44STPJjjcb+yH+j4Zo2LgJ/LScsF0potSGtWaO11PNz2R0881Hb44iH/7pkVD3WstnIma7//nIfWbEFas0KLY90cvSsLfatmyPEvRv59oEW7SP79FIqVmjtYOZzaN+cphykGVw620+X6w6y861W80XZYOclRjx7zxC6fzXN9V2Mb66UaXy9budrRHHoBTClDL0ddcb0cNfRyXGRwbvf4DL0BLuJYXffpiGtagJnL8EHE7zmSvVf1h20fIH7aZ4DhPtNcQfuMc1COf/Bt0OS4YI2BoMfxb5Zws+JPI0P3isv5JtdnS/T9CslbJVnT1jjxjuvzg/R+YXyH9oMpFw5ZX+Qt07xGpPV73dvOa0S+MwB5ZEjwQu9dDV3jRN2D26z3S58VPG7z2ci0ZgrSmokoF/vhDL1Tu0neoR+z1jh97exzxdp50rW386TQOulp50mSDz63677rg+0yIo4Dntc4AfNmymXWKZcBDteKgINakXUmDjC3Z8Qoax/fHUYM0n181pm451MbnkptAA77vrXGGelMmHf+y0cZYq5x6jqfdSZuMQ7/uuXLaWuckBOysK0lD69x6vGZtDXOcxm8+1z7mTjgWGuc1tluXuM8PLmDU5X2WH6pFzGy/7yAbPo+wy+57nlW3vVq3VrbYc3VXpyRS+vcVOOpNX/UW135nOBpQy/l+HqpWXU8Sy+AeXmGXuYC9DJn6GVeZHBut0/qne0jbvfvUnTbdtJ0dIbeA+benHMMnkP2ao6x7QPET/vMWpfW30LQPpt07WdeOeZxneQ+Y7wEXT33z/FnyGXHn5/POX7zHYl3UJ6vv4kQ2/ectB8Pn36K9Ls35ukn9Ve2GZ5P4h37XJ56ncbAiGvIVctv9c5J9tu3dyG2qQ6Aw+sbuh/KOhvO/JC3AuagIft7PLIz/cUU+twea/3mj2hc/42D7XStvUt8pn1O3iX9zvOTbvvVSWoD98MMvQfM7+aM1/xbVL2q6W/Xd4nfSZIvrY43IzDA4Zo4YDj36NZaiG9c8cV2XVPg2P5xTz+l1fgXhV7C52tGvOf53P+m8UlzRstHtvc1Uu3oT3P6CM/xWF/JE3Fvm3eOB56jLtr+kwrXDsFfx4uIMaJu+ZHaNeZ4kBOynCSc5OE1TrSBx2wd36xxEfDzOWm5QFqdrtXtdTy08teTGe3wxUNe47TioY7VVs5k7fmY99CaK0hL17o51vG65zmhb9UMOf756hzXGTIOCQzXBbblbsXAtLFUcbkGaOUOVg6n9s15yjDF4BvH2+ly/UHXU3sVb7QdVk4y7tFjntjls3mu72pss9aDY+dq0y5bL4C5JkMv0664XqYNvZwUGZzbPT5Db4Abce118Vtbf5c7e+o+HbFNAeb6DB9E/ObaSa/qD1Y+q31m5bNq79pnk87OceHbvE6JuOCr43H849wxK/6cydC94nK+mTxlognYw/QO349P7uCXx3foh6wRJvaOeMvrPPq7sYuCx+s8+K7X643WvvS8bUYfdHpfaSxaEwVpTUSUi32Jz2Kq3fCaBq9T6v7srHb6cmWrnaOuvZ2jQmvU085Rkk/Pi23dQW3EDMRiwPM65fY6wsQOjSdQPgIcri3qOiXvfwVdwNyWEWesdconUxvK0gZrnRIw301t+B6jDez7Gn+SsYVrWr2aw4LnqIt7T+GC8Nfz6kn7I9VvzbOYupcEc1jIqeOPtU6p90+y//I65WIGb7YzwOieHJ4Xsb1fyeNYyF4hntsWwfvGfpticvE4NkPvrHEM/cjjGNdBVDarnX1u7/bbWGPAPTQGICboGMDjGGD+iObVr6IxAN/zuK3jmO5R4nHspwPGsdfmaMMxow1vpTa8ntoAHPZ99eEkjkcaR3LfKRBpv495p4C13ybSOG7ut9FxVO8U0PHMN46V6R3s1DeOKe8+177fxhrHdG2T610835uk/TYLIiPrQm2abR0wv0o2/VHDL3kNTtcAY++3KbKv5F0ZdZ1u7Svx7bfpwT6kGq97+PQCmN/M0MtsgF5mDb1ojdk5e78N74uPud8mTUe83wYw9+esdy2Q7L2qd1lnsrTPrBql7rfRPkvbb2Otd37UGC9Bt8h+Gyv+/M+c4zfvN3wt1au05hNxvuTdbwOeoy7u/Xk6zoEXzwP0/gBeA2Kfy7Mur3494np7p4B1jylgHigY21RXlg6s2HZWZEjLW/VOAStvBcxfe2RPG9eZPrfHulNgkGounzfGdWsdK+v8XqT1CXMNR9dHeH3i7y+feN22vjwDeT3rE4DJsz7Be1Gs9Te0keeOGqPV7nnuuODBg134Yvuc0OHYvq9lg2n7bax5dFnoJXwWW3Q43vN8bv/EjnyaM1o+sp3XkY+Mtj5n+QjP8Ti+JE/EdU7vHA88Y98pMCP8dbzo1Rom+KfdKQA5Ics04SSPdaeAtW+yz6WPi4Cfy0nLBdLqdB/dXsdDK3+dzmiHLx7yfhsrHupYnbfON+ehNVuQ1qzQytpbY52p5f02ixTfup1/Vz0xOi3/vofyCc0drBxO7ZvzlGWKwU+caKfL9YdZedfrPRNoh5WT3OLRY57Y5bP5BdKBxjbWy7n4ejHvNLT0ApiHZ+il5IrrpWToZVpkcG73+Ay9AS72Xq2S29EF62iG3gPmMRk+uJd3Cmz7APErkXxsp749UsCBHjgHtfZbgybHBWsM1L0CHH+GXHb8+a4M3Ssu55u8hs1jflr91dqbs0rx7wUG3az6a6S5eL3oXPz2DD/PU2fMMxfXfchp9ddIejHnqpZeAHNnwXEhj16mDb1o3ufc7lwFegNcxLMBdZ+O2KYA85yc8Y9rEXt53lH7zNovrvaufZaWJ8K3eb3nBRT/dD9EkfzPij8vzJn/lYnmk6n+qnsOYvuek/bjAc9RF+08YMXyRe17rgtwrq99bdmI5j6Mx+cdI/lt1fJbPRPFfvuqgrGtiJ9wLVLnwjwOnDb4of6qey1Y9td5ZGf6Cyn0uT3HDPrvonH9DRPtdLm2NCu8OJ/lOXsv73QFf+v+tDfnjNc92B/eVm8oQV7ip/e5AYbtMO0+N+hhkmCsOk2JaOWp05SEli//4djOeTHDWLnHO3LWX0v0zsp3P0X1V/Qp11/fTeOT5oyWjwDmL8lH3pvTR7j+yvEleUbc7n7oVf0VPEddtHvqKnnmyhFjhHmnq877UH8ttf7Oc6cr2mCto/W59HFR89ksWi6Q1nRBWtNCa6/j4bY/euKhVXMpcqcrx0PVJY/DoGXtyde+Y1rTBWlNCy3rHI9Va7DOHnD8s/hrvZbj+JDAWOd9/iJjLFVcPktg5Q5WDqd9wmPEX1MMHp5sp8v1h2l516t4o+2wcpIvZuSindzrzjZZEhlYL+fi68W809XSC2C+kqGXowF6OWroxbrTlcfnUutfvtP1OPHotu2k6YhtCjBfz5nPcu2kV/WHEuQlftpngOE+U3vXPpt0do4L3y61/uW4YI2BoOfLUX3x50CLdpruFZfzTd4fW6fvsT82+R731fF9TYcn2/HxJH0baZ/0ZXkvot4NeMDt/Nbo7Rt3P3rjuU9YfeodF1bvvuPOpz9u4xnP2rjr7j4SryxN4e/SmruP3g3T58PG9/zkET+BOScwwMEUZIL4AtYyBV938fEZ0L8Sf4Y05IgSb5HhNufZdgT4hci0ThWkdSqiXMm7qsjFS/1ZP0PKU16VzWpnnyvWzlNGO08JrVOedp4i+azjNrdMtsuoywLWkaFXT+7QeAilpgjpfMUHcFD6459lVLoPyxhyrDY8gtpQS2kDlzgA8/3UhkdRG7SszkMVnmQoijQUeIci8Bx1u3/ivNtDUdrVjVzOOBeHf93yZf0ZVJQz9OpZtrXksX6GlH+6D3bKR4bwOY23NYYAh48M6RGlxI4arc/4LrG92yjl4aNIyTPiovWz187Ac5RkimFn+nOuamc89nO/4V2FZFOb1fyD8ZqBeFOBeA1qz0jrM6fFd5AN4GfjAZf8nDzHVva7tJjNcRAwd1K8e7kRs3lZR7e4xz4SdDqlHXwkCDDP8owRTMs5e6ztc+1HcIBjHS04Y+ilGl8vNS5p+fQCmB/K0Mt8gF7mDb2cFhmc2x2voTc+lnK5XP39ooz8AuWEGsneq3LC9tYk4qd9FnIV+aRr/5lNHg95S8LLjVwKdK3tDLz1NCv+vDJnblcjmo+guLggON84TmYfEzwjerT8+ozQYjzMvyPGtmrRmP9zl0HMXzT4YU4DmIOG7L/kkd060qL0uT3HDPq/S+P6W43j53w99RnhxfG8V1v0dBna97NS78gZr/fi+IS1/SytBJtnKyVfAeo78mBdxwFa1pGHeaFl4cEufFeDaqxhG3y/p584D7aW/Xj8+bwR73mufz+NTxwn0nwEMH9HPvKhnD7C8za9hm7ERdvK5p2Xgeeo6+3Po+t40avtzeCvV+di/q9bjmcJJ3l4OwPawGO2jm/WuAj4MzlpuUBapwvS0jx8r+Phtj964qG2wxcPeTuDLx5yH+aJh2c8tE4XpHVaaHGsO0PvykLfqidz/LNqYJ0eJ/tSzvybc/pbKFZq7mDlcGrfPEZ8hWLwNYfa6XL9Qa+N6/VxCt+xlH/JyEWzYpfP5rn2bx2n0J9Uj52rzbhsvWzDHPLrZcYV18uMoRfrOAWPz9Zxikhjdd2nI65LAOagR0ccv8+Q7Ht5fbP2mbUdTXMF7TPOQa1r7nn7AOKCNQZax8k0R/XFn2szdK+4nG8mdnd1631rh9dW3/STLN3rm2o5obdEbeDY3k/vATOd4XtL9Hfamka/wACH58cDIkM/wXGeyrBj9L6f+Fp4/PlqwUm6YlzgmM+Qpy16DKyP6OvYyfoFzKJHvyPUlhh2sEzyDJB8bB+AqWbYwbLbrRfLDtRWlkUv7AtL9B2+v5rwGZbtYJn4WnhXiwyMk9jBkMDl4YPvjxCdMYGzdGTlXWm2w30FmIdkxB3FTWgeObDTLrSf6+m9tDfIZ9nbNxe0t/2tz3nsjeOO2ny/a7dLhR2i90vE18LTeME4nOf3G3zGPG2x4g7HqzT9AuY7MuLOstC9tfV3uaPnkh2siDyQj+0DME/KsIMVt1svlh2orayIXtgXuA+zxh+2gxXimzX+9AsOxwvf+KN88D3HnSGBs3RkxZ0029G+Sp7vyxl3VojmV8d22gUZeQ52ueQ7dxbMd6w6bKx8Zz+9L5LvDAkO58iWvY152mLFnSHik6ZfwDz/Csl3XlBw/LHsIE++MyQycL7Dfs+wbAdWvsN4QyID43DcGSrAB99z3NkvcHnznTTb4b4CzCsC8p1PU9xBW7nGwbl9t+1tgNrAbRuS98lzb4a9qW+jVsb2pn0NHI47+0WGfmfHF4blefgQ8bXw+LPaFtcw9xt8yp62WHGH6afpFzA/nxF3Bohut+2A4+AAycf2AZhfzLADjceWHaitaFxgX+BxCN/zPIdh2Q54/LHw+PN+weHxZ6wAH3zPcWde4HxjFsedNNvhvgLMu3LGHdbz/RR39LgK7/OETWAfH/88OWDed2iH7icOtdPlI1l6dDBejLtUoxxIaYcV4z5QMMbp+QlfjGuQDqwxTffoRtRLzfJ5Sy+A+e8FfT6PXvoNvVjziTJ91pgQLy5esp00HVlx8eM569s8tveqvg29cX1b+wwweeI09DBJMGV6B99mO/8E1bd1/zDocfwrE25W/PlUhu4Vd+u69rGd76uCE/G4nXd/3eVy3I5thvsV73gsGxNaakeMh73nI273HK6L7atyrFG/HaP3gPlCRmzTuGWd7VMdAIdjm5VPWHvrOfdiXzloyP5lj+xp4zrT5/YcM+gfahFO/v5HY1yvEa8x4cXzNL4mKs78+ZJf6fxZ5648f4bSLoN43bafZHt8IX46VwVMnvk8z28Aw3sOtNZixQgd063Yb+HBLnxzao01bIPjnn5KZKgRL7yzroc73yLA8Z731111eEc+jhNpPgKYW8lHrml9zvIRvgKM40vyRMxpvPvr8HnURcs7K1ZOoeNFxBhRt/xoSPhjf52uhSwTTvLc0PrXqtuwDfW59HER8GM5ablAWkMFael8ea/joZW/Lme0wxcPeX+dFQ9Vl1bOap15075jWkMFaQ0JLY51Y/RuXuhz/OP9decPp/PvNP++JWMstfLve4y6p5WnaAy2crhvohi8fridLtcfhuRdr+KNtsPKSR7l0WOe2OWzebZJjW2sl1p8vdSsNVZLL4B5XIZeVgL0smLoZVlkcM6/PhFvHfqS7aTpyFqHvi1nPjtGsveq/mDls9pnVj6bti7OMdHKcecJB9+tG/kdYEDPl6P64s/tGbpXXM43+d4FHm/0PgfE0Dq9B8zTKP691KDL8a8m7xI74Plnt204bS4+Re8Bc1eGn6svWnu4pgTGNxefMvRSja+XGufBPr0A5nkZehkI0ItVlx4SGZzbfRaWc4LkiVgn89budW0ieX48Z/zjWkSv4t+2Dwg/PGljls6ltc94nYrviNCckONCn2v/2V8r/+OzyFnx556c+R+vfz55rP17PCMu2t0b3voreI6STDHmwGn65/prTWSyah3cT3ivvs94uDMk4t0qVY418E+10UGCuS8jtmncUl1ZOgAOz+n0jP0E0Woa/FB/5ftLVPa3eGRn+mMp9Lk9xwz6H6Bx/T8fbqfLuavODSeIDud8vay/gr8113lbznjdINl7VW+w4nUncy/ogesNXCfXtVe2O9BSu+caQcODB7vg2M5xmGGAO0gwv5VRf9X6BtdBuF2fo/or3nP99XdpfErLfa27zL5EPvJ7OX2E668cX5In4rq7t/4KnqMuWt5ZyZND97r+OiX8UX/VtRtf/VXtl22oz6WPi4Cv5aTlAmlNFaQ1JbT2Oh5u+6MnHhY5T2PVXzke6lht5Ux6XxrnORatqYK0poQWxzor1+YYr2teHP+sGF0WeCtGA8aK0V/MGEsVN6H57VR/1dzByuHUvjlP+TLF4Add1U6X6w9T8q7X9Ve0w8pJ/rlg/VVjl8/mrXn2kqGXany9mPVXSy+A6b/Kr5eVAL2sGHqx6q88PkNvXH+NuXcwTUdc0wLMmEdHe32/2rYPeOqvvH8eMJoraJ9xDsrxD77NtVnEBWsMtOoPU4SbFX+OZuhecTnfTOxuSdqQ9A2fT+pe31zab32e2sCxne0NMFMZvnee/k6bH2tfA4fnx8siQz/Bcdxj2Ca953NfFh5/XhIcHm+XDT5VT1vQBt53D/o6drJ+AXPWo98RaksMO7iJ5GH/YvsATDnDDm5yu/Vi2YHayk2iF/YFwPa79vOICst2cBPxtfD487LgcI61VIAPvj9CdJoCZ+nIyrvSbIf7CjD/JiPuKG5C87OjO+2CjJwL9fJcK+Sz1hMfXnDM1xzat37HcUfnd3nsjfNnHrey7K0pODxWWfZW9bTFijugr7bD+gXMt2fEnV6OPxr7efx5YsHxx7KDtPGHY31TZOBz7uz3DMt2cJ74Wnj8WWMcx51mAT74nuNOQ+AsHVlxJ812uK8AczFn3DlPND9McUfzoV6fa4V81hzsaRn21kkdluNOU2TIY29cN7DuVUizN51bca3Csreqpy1W3OF5SZp+AfODGXHncrlX4YcLjj+WHeS5V6EhMvA5d/Z7hmU7sO5VYDz+rDGO406jAB98z3FH7zTw5cocd9Jsh/sKMC/LGXf4XoW3UdyBjLwOyWtv3bY3vVdBz6FwLvfqDHtL80O2t6bAAIfX5HTNMY+98Xy5SXyz7K0uOImdVATOWiux2oI2cNzRGqWlX8D8XEbc6eX4o7Gfx583Fxx/LDtIG3841uvdN/3OHmeserhzu/NeC48/a4zjuOOruysffM9xpyZwlo6sMyBptsN9BZhfy4g7ipvQvJfiju6HiXi/ezOhx/dEc9v4bj7AvDfD3vQu1lYJb5e96X2BwOG4o3fmxv79joUcOgDMB3LWTnme3Ku1L+u3KRZIPta3r0+Aw3v3rfuP9T5/y3fYnhnG+t2Pj3h0y/VbtOGgQS+B+V7yp6GWLvpJJ/uHd2QeIJh9JBNg/tdVO3T/mHQ9KHST7z9jfI/Ht54O+0hsZSSOrWyNLaPDO+0bIF4D1H7AjJIcg/T3A1QbHxve3R7oAnQT/Q9jL/dwOt6g4E0SzDDhjQjeiPRb0gd/0pJv1LXvYby1BVfu7KlwXyf29/8ArIoz7lSpAgA=","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]}],"outputs":{"structs":{},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"NFT"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"private_nfts","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"nft_exists","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"public_owners","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000d6523016"},{"kind":"string","value":"NFTNote"},{"kind":"struct","fields":[{"name":"npk_m_hash","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"token_id","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}]}}]}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000d6523016"},{"kind":"string","value":"NFTNote"},{"kind":"struct","fields":[{"name":"npk_m_hash","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"token_id","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":true}}]}}]}]},{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"kind":"struct","fields":[{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"npk_m_hash","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]}]}},"file_map":{"24":{"source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"29":{"source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    pedersen_hash_with_separator_noir(input, separator)\n}\n\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator_noir(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n","path":"std/hash/mod.nr"},"34":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"59":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"70":{"source":"use dep::aztec::macros::aztec;\n#[aztec]\ncontract GetMembershipWitness {\n    // use dep::aztec::prelude::{AztecAddress, PrivateImmutable};\n    use dep::nft_contract::types::nft_note::NFTNote;\n    use dep::aztec::{\n        oracle::{\n            header::{Header, get_header_at},\n            get_membership_witness::{\n                get_note_hash_membership_witness, MembershipWitness,\n                get_membership_witness_oracle,\n            },\n            get_nullifier_membership_witness::{\n                get_low_nullifier_membership_witness_oracle, NullifierMembershipWitness,\n                NULLIFIER_MEMBERSHIP_WITNESS // 24\n            }\n        }, \n        note::{\n            utils::compute_note_hash_for_nullify, \n            note_header::NoteHeader\n        },\n        context::PrivateContext\n    };\n    use dep::protocol_types::address::AztecAddress;\n\n    // #[storage]\n    // struct Storage<Context> {phantom: PrivateImmutable<Field, Context>}\n\n    unconstrained pub fn low_nullifier(\n        block_number: u32,\n        nullifier: Field\n    ) -> pub [Field; NULLIFIER_MEMBERSHIP_WITNESS] {\n        get_low_nullifier_membership_witness_oracle(block_number, nullifier)\n    }\n\n    // TODO does it make sense to have authwit version here?\n    // #[private] \n    // #[noinitcheck]\n    // #[view]\n    unconstrained pub fn get_the(\n        // collection: AztecAddress, // the problem is that we're proving historical, so getter isn't much helpful here\n        // token: NFTNote,\n        // note_hashed: Field,\n        // storage_slot: Field,\n        \n        // note_content: [Field; 3],\n        block_num: u32,\n        // note_header: [Field; 3],\n\n        hashed: Field\n    // ) -> pub (MembershipWitness<32, 33>, Header) {\n    // ) -> pub MembershipWitness<32, 33> {\n    ) -> pub [Field; 33] {\n        // let notes = NFT::at(collection).get_private_nfts();\n        // if notes.len() > 0, \"no NFT at \"\n        \n        // let note_the: NFTNote = context.get_note(note_hashed);\n\n        // let mut note_the = \n        //     // NFTNote::\n        //     dep::value_note::value_note::ValueNote::\n        //         deserialize_content(note_content);\n        // note_the.set_header(NoteHeader::new(\n        //     AztecAddress::from_field(note_header[0]),\n        //     note_header[1],\n        //     note_header[2],\n        // ));\n\n        // let mut w: MembershipWitness<32, 33> = std::mem::zeroed();\n        // let mut w = [0; 33];\n        // unsafe {\n            // w = get_note_hash_membership_witness(\n            //     block_num, compute_note_hash_for_nullify(note_the)\n            // );\n            // w = get_membership_witness_oracle(block_num, 1, note_the.compute_note_hash());\n        // }\n\n        // (w, get_header_at(block_num, context))\n        // w\n        get_membership_witness_oracle(block_num, 1, hashed)\n    }\n}\n","path":"/home/serge/Desktop/aztec_part/src/main.nr"},"97":{"source":"use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"110":{"source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{execution::{get_chain_id, get_version, get_contract_address, get_block_number}, storage::storage_read};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr"},"140":{"source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"156":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"165":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\nunconstrained pub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"211":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"237":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"273":{"source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"335":{"source":"use dep::aztec::{\n    note::utils::compute_note_hash_for_nullify, keys::getters::get_nsk_app, oracle::random::random,\n    prelude::{NullifiableNote, NoteHeader, PrivateContext},\n    protocol_types::{constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator, traits::{Empty, Eq}},\n    macros::notes::partial_note\n};\n\n#[partial_note(quote { token_id})]\npub struct NFTNote {\n    // ID of the token\n    token_id: Field,\n    // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    // Randomness of the note to hide its contents\n    randomness: Field,\n}\n\nimpl NullifiableNote for NFTNote {\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl NFTNote {\n    pub fn new(token_id: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        NFTNote { token_id, npk_m_hash, randomness, header: NoteHeader::empty() }\n    }\n}\n\nimpl Eq for NFTNote {\n    fn eq(self, other: Self) -> bool {\n        (self.token_id == other.token_id)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/noir-contracts/contracts/nft_contract/src/types/nft_note.nr"},"352":{"source":"use dep::aztec::{\n    protocol_types::{traits::Serialize, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator},\n    macros::notes::note,\n    note::{note_header::NoteHeader, note_interface::NullifiableNote, utils::compute_note_hash_for_nullify},\n    oracle::random::random, keys::getters::get_nsk_app, context::PrivateContext\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n   // The nullifying public key hash is used with the nsk_app to ensure that the note can be privately spent.\n    npk_m_hash: Field,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let secret = context.request_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let secret = get_nsk_app(self.npk_m_hash);\n        poseidon2_hash_with_separator(\n            [\n            note_hash_for_nullify,\n            secret\n        ],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, npk_m_hash: Field) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe {\n            random()\n        };\n        let header = NoteHeader::empty();\n        ValueNote { value, npk_m_hash, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.npk_m_hash == other.npk_m_hash)\n            & (self.randomness == other.randomness)\n    }\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.57.0/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}