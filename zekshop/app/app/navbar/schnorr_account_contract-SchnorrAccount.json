{"transpiled":true,"noir_version":"0.35.0+b848cc128d2dc2b461581f21a35509a1af9065a7-x8664","name":"SchnorrAccount","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"12265343917440897559":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"constructor","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"signing_pub_key_x","type":{"kind":"field"},"visibility":"private"},{"name":"signing_pub_key_y","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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f5WuGPJ59iuo6ILvLxzit183uuoIftNwH73/p6PRdsyjrphgncEx4r5izz1G3FchxrrqqqHJIbjtVklBf1GXz52n7mrH4POkz/ctI/TZKVWcfwcieukVtvvsQNAffE/lf+DUKezQPb3um0hx13bwc4u6tjOjDUr8izYIvueO/9EGobdA5foXbVDCtR383OKubXfewfe5x29x12eE1pUjhP9e52/omHbnqqvbva92f/MIzqd856k3d0iu7quQg+8531xx7yuC76np/D3ft4x/2v/8r/3E+Y5S/OJsM7+dpFTy7htEbFyoUvfq20nekH7L5Spzn73K6ZQFv53crSkLfhupqikLXixSTVMWvGjkHk1Z8OKRezVluqsrg2XBK9vu15QFH1hSXVMWfHBJDU1Z8AEmD2jKgg8yeVBTFnygyUOasuCDTWpqyh52fA9rymo5vlqaskcc3yOaskcd36Oasscc32Oasscd3+Oasicc3xOasicd35Oasqcc31Oasqcd39Oasmcc3zOasmcd37Oasucc33Oasucd3/Oashcc3wuashcd34uashTHl6IpS3V8qZqyNMeXpilLd3zprrLgepjh+DJCyjw7+54UH+fhPtDK5PORsYTzke6riN0X4+XOfy6n+ypi92m3Ku56nG3dnU7priNTwTU7w/UZ1V1tEPoQolBt5tkYSUpM9G6djA/8ryu282raOt952npA/rPtY7/so3e1Hd8drnbK7ldf3+8768+OV18H29LWl5m7/4hHXM8QemY4p9zne3hmOD6gO2hXMKRt3Y8/cPdx6DGQ0Ef85HS9x318KI/r3087f4v7zn3MUfC9oY8kKuSq236FHjcJ8rnHQmjf5Q+pw31Hmztnd1ywLl9IXT5NXaEM3l01cKb/znd1rPszg30SembMfYNC8D0Zzt/zHTMo6IpxH39w5+vVdyw356uunOo42+7v1O4zd+/9C/48mrZo4KqjrqaOHL7zn7l3n8k835n74Hvecv6e7zhB6N2Tdp3vaMrznaf8n9rEw6tazrnj3M32oevz3GPQ3ZbuM27B93zuKvvY2T7fMdbQenTarNB54nX7xdD++6c+do+x4HuaOH/Pd9zUo6toLPeZ8WAbhz5ax31mvMU/cLrrCraF7phh6CPUgjHBz3U/Hq2wqw28OdZ/Zj8Zul65z+EE/cH3tP+HNnDr13Pu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","debug_symbols":"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hd739ELve3qh9z290PuWXhq97+mF3vf0Qu97eqH3Pb0EXiy90PueXuh9Ty/0vqcXet/TC71v6WWk9z290PueXuh9Ty/0vqeXwIulF3rf0wu97+mF3vf0Qu97eqH3Lb1M9L6nF3rf0wu97+mF3vf0Enix9ELve3qh9z290PueXuh9Ty/0vqWXoPc9vdD7nl7ofU8v9L6nl8CLpRd639MLve/phd739ELve3qh9y29dHrf0wu97+mF3vf0Qu97egm8WHqh9z290PueXuh9Ty/0vqcXet/Sy0zve3qh9z290PueXuh9Ty+BF0sv9L6nF3rf0wu97+mF3vf0Qu9belnofU8v9L6nF3rf0wu97+kl8GLphd739ELve3qh9z290PueXuh9Sy8rve/phd739ELve3qh9z29BF4svdD7nl7ofU8v9L6nF3rf0wu9b+llo/c9vdD7nl7ofU8v9L6nl8CLpRd639MLve/phd739ELve3qh9w29TMNA73t6ofc9vdD7nl7ofU8vgRdLL/S+pxd639MLve/phd739ELvW3pp9L6nF3rf0wu97+mF3vf0Enix9ELve3qh9z290PueXuh9Ty/0vqWXkd739ELve3qh9z290PueXgIvll7ofU8v9L6nF3rf0wu97+mF3rf0MtH7nl7ofU8v9L6nF3rf00vgxdILve/phd739ELve3qh9wu99DcSQ1yATcSXwe7jeiLRp7F/hB2UuRA2uS2ETUMLYRPGQtgBbB1sElYImy4VwiY2hbApSCFsClIHu1OQQtgUpBA2BSmETUEKYQewdbApSCFsClIIm4IUwqYghbApSB3smYIUwqYghbApSCFsClIIO4Ctg01BCmFTkELYFKQQNgUphE1B6mAvFKQQNgUphE1BCmFTkELYAWwdbApSCJuCFMKmIIWwKUghbApSB3ulIIWwKUghbApSCJuCFMIOYOtgU5BC2BSkEDYFKYRNQQphU5A62BsFKYRNQQphU5BC2BSkEHYAWwebghTCpiCFsClIIWwKUgibgpTBbgMFKYRNQQphU5BC2BSkEHYAuwx2X86v7dt2ATYFKYRNQQphU5BC2BSkEDYFqYPdKEghbApSCJuCFMKmIIWwA9g62BSkEDYFKYRNQQphU5BC2BSkDvZIQQphU5BC2BSkEDYFKYQdwNbBpiCFsClIIWwKUgibghTCpiB1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","brillig_names":["get_contract_instance_internal","get_public_keys_and_partial_address","decompose_hint","notify_created_note_oracle_wrapper","get_key_validation_request","random","lt_32_hint","lte_16_hint","build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","build_msg_block_iter","emit_encrypted_note_log_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"entrypoint","is_unconstrained":false,"custom_attributes":["private","noinitcheck"],"abi":{"error_types":{"12265343917440897559":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"},"visibility":"private"},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"},"visibility":"private"},{"name":"cancellable","type":{"kind":"boolean"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs26cs22cs22cs22cs22cs22cLKpWNZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfuMZfucZfucZfucZfucZft8QaWys2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2yfs2xfsGxfsGxfsGxfsGxfLKhUDpbtC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5btC5bt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sHxmud61Hlg+s1zvWg8sn1mud60Hls8Gy2eD5bPB8tlg+cx6LuhaDyyfWc8FXeuB5TPruaBrPbB8ZrnetR5YPjssnx2WzwHL54Dlc8DymeV613pg+RywfGY9F3StB5bPAcvngOUzy/Wu9cDymeV613pg+cxyvWs9sHxOWD4nLJ9ZzwVd64HlM+u5oGs9sHxmPRd0rQeWz6zngq71wPKZ5XrXemD5XLB8Llg+T1g+T1g+T1g+T1g+T1g+T1g+s54LutYDy+cJy+fJyuexsPJ5LKx8HgsrnwfruaBrPax8Hgsrn8fCyuexsPJ5wPzggPnBAfODA+YHB8wPDpgfHDA/OGB+cMD84ID5wQHzgwPmBwfMDw6YHxwwPzhgfnDA/OCA+cEB84MD5gcHzA8OmB8cMD84YH5wwPzggPnBAfODA+YHB8wPDpgfHDA/OGB+cMD84ID5wQHzgwPmBwfMDw6YHxwwPzhgfnDA/OCA+cEB84MD5gcHzA8OmB8cMD84YH5wwPzggPnBAfODA+YHB8wPDpgfHDA/OGB+cMD84ID5wQHzgwPmBwfMDw6YHxwwPzhgfnDA/OCA+cEB84MD5gcHzA8OmB8cMD84YH5wwPzggPnBAfODA+YHB8wPDpgfHDA/OGB+cMD84ID5wQHzgwPmBwfMDw6YHxwwPzhgfnDA/OCA+cEB84MD5gcF5gcF5gcF5gcF5gdlYeWzwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwPygwvygwvygwvygwvygLqx8VpgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfVJgfNJgfNJgfNJgfNJgftIWVzwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgwbzgw7zgw7zgw7zgw7zg76w8tlhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhftBhfjBgfjBgfjBgfjBgfjAWVj4HzA8GzA8GzA8GzA8GzA8GzA8GzA8GzA8GzA8GzA8GzA8GzA8GzA8GzA8GzA8GzA8GzA8GzA8GzA8GzA8G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mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng0mhcejeaFR6N54dFoXng817zwKfO6Vvu41qfqm+6uNR8+L1zDL3u2Me6vdfj6vrvs2ueYv1vrt/rHyesXdP3T80f9ZTfq15PXbyev309ef5DrX29lXupY/zt08xqq16wtjw9Zm43WWo3WOvusdaD7hZ3Xiu4tfnmt9/r7HOg+ZOe1onuWnddqjdaK7oV2Xutz9U331/pcfdP9tT5X33R/rc/VN91dqzxX33R/rY36JmnUN0mjvunhc7K/cq2N+iZp1DdJo75JGvVN0qhv0kZ9kzbqm7RR36SN+qaHz8n+yrU26pu0Ud+kjfombdQ3aaO+yRr1Tdaob7JGfZM16psePif7K9faqG+yRn2TNeqbrFHfZI36Jm/UN3mjvskb9U3eqG96+Jzsr1xro77JG/VN3qhv8kZ9kzfqm6JR3xSN+qZo1DdFo77p4XOyv3KtjfqmaNQ3RaO+KRr1TdGob8pGfVM26puyUd+Ujfqmh8/J/sq1NuqbslHflI36pmzUN2Wjvqka9U3VqG+qRn1TNeqbHj4n+yvX2qhvqkZ9UzXqm6pR31SN+qbZqG+ajfqm2ahvmo36pofPyf7KtTbqm2ajvmk26ptmo75p9umbij0ne+e19umbij1/e+e19umbarFGa+3TN9WTzQu/v9Y+fVM92bzw+2tt1Dc92bzw+2tt1Dc1mhdejeaFV6N54dVoXng1mhdejeaFV6N54dVoXng1mhdejeaFV6N54dVoXng1mhdejeaFV6N54dVoXng1mhdejeaFV6N54dVoXng1mhdejeaFV6N54dVoXng1mhdejeaFV6N54dVoXng1mhdejeaFV6N54dVoXng1mhdejeaFV6N54dVo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mB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB9UmB80mB80mB80mB80mB+0hZXPBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODBvODDvODDvODDvODDvODvrDy2WF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+0GF+MGB+MGB+MGB+MGB+MBZWPgfMDwbMDwbMDwbMDwbMDwbM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84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MK84MG84MG84MG84MG84O2sPLZYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYH7QYX7QYX7QYX7QYX7QF1Y+O8wPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPOswPBswPBswPBswPBswPxsLK54D5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYD5wYT5wYT5wYT5wYT5wVxY+ZwwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP5gwP1gwP1gwP1gwP1gwP1gLK58L5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcL5gcnzA9OmB+cMD84YX5wLqx8njA/OGF+cML84IT5wQnzgxPmByfMD06YH5wwPzhh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ftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBgftBhftBhftBhftBhftAXVj47zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA86zA8GzA8GzA8GzA8GzA/GwsrngPnBgPnBgPnBgPnBgPnBgPnBgPnBgPnBgPnBgPnBgPnBgPnBgPnBgPnBgPnBgPnBgPnBgPnBgPnBeLQflEX1sucl6309tzbOuVy3LvlRyFC7sX1Mmd83j2nvFvt9rd5ordFordlordVorbPPWkHO9MbGnnbZeP2G57qxin2vnnPV/0z1nB7hM9Ur+CxZl1rXXU+btXGWiK7faF72ruunkd9t/2291my95K7liPWSO5cj1svuXpZp1611sRv1P1VHUnq9SpfHh6v0U3Uk99f6aFn9pWsdjdYqjdZK7o1+fa3XzWOOD58gHi3Zv3StT3UnZ2OtT3UnZ2OtT3UnZ2Otz9U33V/rc/VNd9fqz9U33V/rc/VN99f6XH3T/bU26psePWHiS9faqG/yRn2TN+qbvFHf5I36pmjUN0Wjvika9U3RqG969OSXL11ro74pGvVN0ahvikZ9UzTqm7JR35SN+qZs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","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","enqueue_public_function_call_internal","call_private_function_internal","debug_log_oracle_wrapper","notify_set_min_revertible_side_effect_counter_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"verify_private_authwit","is_unconstrained":false,"custom_attributes":["private","noinitcheck","view"],"abi":{"error_types":{"12265343917440897559":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"storage_contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"authwit::aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"authwit::aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"authwit::aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7Z3dbiTHkYXfZa51UfGTkZl+lYVhyLZsDCCMDEteYGHo3bc4mm5ySE6npthBfTHNG0O0qipOJTMiMlr9Hf733d9/+Ot//vmX9x/+8dPP7/70P/999+NPf/v+l/c/fdh/+u87sY//38//+v7D3Y8///L9v3959yfp6t+9++HD3+/+0fzX79794/2PP7z7U5dfv3tysfZ2ulh7j/PFYvOZq82tfbra2jYWV8vW+3ZSsvVxL0W1P3f96Hq6fEw5X333Dk8vFjlJEQl/ePGfv3sn/rYyX1iZ9rYyX1iZeFuZL6xMf/HK2LBxetfR/cG7/hZhpEeYXxlhv0e35+5Rn6e10qZtsSPmdvql2fZAVbfnLt7a+degW8ztfPnYnt0ROuO8I2ybqx3h22mFxO+uOL4jVN5W5gsro28r84WVMfjKmNn9ynh/vfqq/rYyX1iZ9rYyX1iZePHK2N4aTysjfVuszNhOb6p7p12s+Wh6vng8ONlIe06Hyvk3pH6/KlM/vmi/lRcd386Lup2u3pNiPnzRZ/Z5hJzPYFt7vCrzRlelP1iVGY9WxbZvZ1WazPMU1Farsvm4n4EeVOfnCqifTzpte/B+zxVy37R/utYfPlfnx9WWt9W+6mrvE+5pteVBG/y02vq22q+4t+1ttV9xb/vbar/i3m5vq/2Ke/sbmkgIq23dTydA6+PBaPlx/rNvaCz6qtWWfl5tmZ+t9t2qfEMz1BVX5Ruaoa63Kn6rM5Sex1DRBx+IPVuvZHqcPw+Tsfp864/7PMxvdUb7Nn+btzoDfpu/zW9pxozzf7OPBye4Z3+bcxunX9Dcl/z+0c+uoVobp3alFtI/u/5uGf1tGa+xjK89Fc7zjKqzffbkOzWvPDXZFqfFtG3oYzUdpWag1EySmrah1AhKjaLUGEqNo9Q0lBpULW6oWtxQtbihanGganGganGganGganGganGganGganGganGganGganFH1eKOqsUdVYs7qhZ3VC3uqFrcUbW4o2pxR9XijqrFA1WLB6oWD1QtHqhaPFC1eKBq8UDV4oGqxQNViweqFk9ULZ6oWjxRtXiiavFE1eKJqsUTVYsnqhZPVC2eqFosG6oYy4aqxrKhyrFsqHosG6ogy4aqyLKhSrJsqJosG6ooy8aqysKqysKqysKqysKqysKqysKqysKqysKqysKqysKqysqqysqqysqqysqqysqqysqqysqqysqqysqqysqqysaqysaqysaqysaqysaqysaqysaqysaqysaqysaqys6qys6qys6qys6qys6qys6qyixMT1icnrBAPWGResJC9YTF6gkL1hMWrScsXE9YvJ6wgD1hEXvCQvaExewJC9oTFrUnLGxPWNyesMA9YZF7wkL3hMXuCQveExa9Jyx8T1j8nrAAPmERfMJC+ITF8AkL4hMWxScsjE9YHJ+wQD5hkXzCQvmExfIJC+YTFs0nLJxPWDyfsIA+YRF9wkL6hMX0CQvqExbVJyysT1hcn7DAPmGRfcJC+4TF9imL7VMW26cstk9ZbJ9uqKqsLLZPWWyfstg+ZbF9ymL7lMX2KYvtUxbbpyy2T1lsn7LYPmWxfcpi+5TF9imL7VMW26cstk9ZbJ+y2D5lsX3KYvuUxfYpi+1TFtunLLZPWWyfstg+ZbF9ymL7lMX2KYvtUxbbpyy2T1lsn7LYPmWxfcpi+5TF9imL7VMW26cstk9ZbJ+y2D5lsX3KYvuUxfYpi+1TFtunLLZPWWyfstg+ZbF9ymL7lMX2KYvtUxbbpyy2T1lsn7LYPmWxfcpi+5TF9imL7VMW26cstk9ZbJ+y2D5lsX3KYvuUxfYpi+1TFtunLLZPWWyfstg+ZbF9ymL7lMX2KYvtUxbbpyy2T1lsn7LYPmWxfcpi+5TF9imL7VMW26cstk9ZbJ+y2D5lsX3KYvuUxfYpi+0zFttnLLbPWGyfsdg+21BV2Vhsn7HYPmOxfcZi+4zF9hmL7TMW22csts9YbJ+x2D5jsX3GYvuMxfYZi+0zFttnLLbPWGyfsdg+Y7F9xmL7jMX2GYvtMxbbZyy2z1hsn7HYPmOxfcZi+4zF9hmL7TMW22csts9YbJ+x2D5jsX3GYvuMxfYZi+0zFttnLLbPWGyfsdg+Y7F9xmL7jMX2GYvtMxbbZyy2z1hsn7HYPmOxfcZi+4zF9hmL7TMW22csts9YbJ+x2D5jsX3GYvuMxfYZi+0zFttnLLbPWGyfsdg+Y7F9xmL7jMX2GYvtMxbbZyy2z1hsn7HYPmOxfcZi+4zF9hmL7TMW22csts9YbJ+x2D5jsX3GYvuMxfYZi+0zFttnLLbPWGyfsdg+Y7F9xmL7jMX2GYvtMxbb5yy2z1lsn7PYPmexfb6hqrKz2D5nsX3OYvucxfY5i+1zFtvnLLbPWWyfs9g+Z7F9zmL7nMX2OYvtcxbb5yy2z1lsn7PYPmexfc5i+5zF9jmL7XMW2+csts9ZbJ+z2D5nsX3OYvucxfY5i+1zFtvnLLbPWWyfs9g+Z7F9zmL7nMX2OYvtcxbb5yy2z1lsn7PYPmexfc5i+5zF9jmL7XMW2+csts9ZbJ+z2D5nsX3OYvucxfY5i+1zFtvnLLbPWWyfs9g+Z7F9zmL7nMX2OYvtcxbb5yy2z1lsn7PYPmexfc5i+5zF9jmL7XMW2+csts9ZbJ+z2D5nsX3OYvucxfY5i+1zFtvnLLbPWWyfs9g+Z7F9zmL7nMX2OYvtcxbb5yy2z1lsn7PYPmexfc5i+5zF9jmL7XMW2+cstq+x2L7GYvsai+1rLLavbaiq3FhsX2OxfY3F9jUW29dYbF9jsX2NxfY1FtvXWGxfY7F9jcX2NRbb11hsX2OxfY3F9jUW29dYbF9jsX2NxfY1FtvXWGxfY7F9jcX2NRbb11hsX2OxfY3F9jUW29dYbF9jsX2NxfY1FtvXWGxfY7F9jcX2NRbb11hsX2OxfY3F9jUW29dYbF9jsX2NxfY1FtvXWGxfY7F9jcX2NRbb11hsX2OxfY3F9jUW29dYbF9jsX2NxfY1FtvXWGxfY7F9jcX2NRbb11hsX2OxfY3F9jUW29dYbF9jsX2NxfY1FtvXWGxfY7F9jcX2NRbb11hsX2OxfY3F9jUW29dYbF9jsX2NxfY1FtvXWGxfY7F9jcX2NRbb11hsX2OxfY3F9jUW29dYbF9jsX2NxfY1FtvXWGxfY7F9jcX2BYvtCxbbFyy2L1hsX2yoqhwsti9YbF+w2L5gsX3BYvuCxfYFi+0LFtsXLLYvWGxfsNi+YLF9wWL7gsX2BYvtCxbbFyy2L1hsX7DYvmCxfcFi+4LF9gWL7QsW2xcsti9YbF+w2L5gsX3BYvuCxfYFi+0LFtsXLLYvWGxfsNi+YLF9wWL7gsX2BYvtCxbbFyy2L1hsX7DYvmCxfcFi+4LF9gWL7QsW2xcsti9YbF+w2L5gsX3BYvuCxfYFi+0LFtsXLLYvWGxfsNi+YLF9wWL7gsX2BYvtCxbbFyy2L1hsX7DYvmCxfcFi+4LF9gWL7QsW2xcsti9YbF+w2L5gsX3BYvuCxfYFi+0LFtsXLLYvXp3t0y6ni3Xa5Se7bfbpYjeZ54s1nrm4qZ4ubury8OKPL9pv5UXHrbzovJEXfXWG8g97UbmVF9VbeVG7lRf1W3nRdisveisno3krJ6N5KyejeSMno77dyMmobzdyMurbjZyM+nYjJ6O++a286I2cjPp2Iyejvt3IyahvN3Iy6tutnIzkVk5GcisnI7mVk5Hcysno1T0b/rAXvZWTkdzKyUhu5WQkt3Iykls5GemtnIz0Vk5GeisnI72Vk9Gr+6b8YS96KycjvZWTkd7KyUhv5WSkt3Iysls5GdmtnIzsVk5Gdisno1f3LvrDXhR9Mop2utgj+hPt6MPOQjv6/LLQjj6SLLSjTxl905P2/bO/x9odfXBYaEefBRba0e19oR3dsRfa0U34cp3xwn3VC/dVL9xXHd1XF7lauK+2wn21Fe6rrXBfbYX76qubjV1TO7qvLrSj++pCO7qvLrQX7qutcF+Nwn01CvfVQPfVy2fgQPfVhXZ0X11oLzyvRuG+GoX7ahTuq1G4r/bCfbUX7qu98LzaC8+rr274d03thefVXriv9sJ9tRfuq71wXx3ovnr5DDzQfXWhvfC8OgrPq69u2XjNXC3cV9lmkAvthfsq27Jxob1wX2UbKy60F55X2faHC+2F51W2SeFCe+G+yrYSXGgv3FfZhn+Xz8BsD7+L2gfblm+hve68OtjmeRdzdbD98Bba6/bVwXatW2iv21cH21tuob3uvDrYDnCXtbNN3Rba686rg229ttBeuK+yDdIW2gv3VbaN2eUzMNuZbKG97rw62P5hl7WzLcEu5yrb5WuhvXBfZXtxLbQX7qtsx6yF9sLzKtvXaqG98LzKdp+6rJ1tKLXQXrivsm2fFtoL91W2OdPlM3Bhv6VR2G9pFPZbGmy/pUWuFu6rhf2WRmG/pVHYb2kU9lsabL+lhfbC8yrbb2mhvfC8WthvaRT2WxqF/ZZGYb+lwfZbunwGZvstLbSj++pCe+F5tbDf0ijstzQK+y2Nwn5Lo7Df0ijstzTYfksL7YXnVbbf0kJ74Xm1sN/SKOy3NAr7LY3CfkuD7bd0+QzM9ltaaC88r7L9lhbaC/fVwn5Lo7Df0ijstzQK+y2Nwn5Lg+23tNBeeF5l+y0ttBeeVwv7LY3CfkujsN/SKOy3NNh+S5fPwGy/pcva2X5LC+2F59XCfkujsN/SKOy3NAr7LY3CfkujsN/SYPstLbTXnVcn229pob3uvDoL+y3Nwn5Lc6vbV2dhv6XJ9lu6eAaebL+lhfa68+pk+y1d1l7Yb2kW9luahf2WZmG/pVnYb2kW9luabL+lhfa68+pk+y0ttBeeVwv7Lc3CfkuzsN/SLOy3NNl+S5fPwGy/pYX2wvMq229pob1wXy3stzQL+y3Nwn5Ls7Df0izstzTZfksL7YXnVbbf0kJ74Xm1sN/SLOy3NAv7Lc3CfkuT7bd0+QzM9ltaaEf31YX2wvNqYb+lWdhvaRb2W5qF/ZZmYb+lWdhvabL9lhbaC8+rbL+lhfbC82phv6VZ2G9pFvZbmoX9libbb+nyGZjtt7TQXnheZfstLbQX7quF/ZZmYb+lWdhvaRb2W5qF/ZYm229pob3wvMr2W1poLzyvFvZbmoX9lmZhv6VZ2G9psv2WLp+B2X5Ll7Wz/ZYW2gvPq4X9lmZhv6VZ2G9pFvZbmoX9lmZhv6XJ9ltaaC88r7L9lhbaC8+rhf2WZmG/pVnYb2kW9luabL+ly2dgtt/SQnvheZXtt3RRu2yFDZd28XU76y6+bmvdxdftrbv4us11F1+3u+7i646tu/i6c+suvu7guouvO7nKVth6aRdfucMWNl/axVfusGz7pcWRmO2/tBJfd4DdxdedYHfxlTtsYQ8m2QqbMO3iK3fYwjZMu/jKHZZtxLQSX3mGZVsxrcRXnmELmzHt4it32MJ2TLv4yh2Wbci0OBKzHZlW4tEddiW+8gxb2JRpF1+5wxa2ZdrFV+6whY2ZdvGVOyzbmmklvvIMyzZnWomvPMMWtmfaxVfusIUNmnbxlTss26JpcSRmezStxFeeYdkuTSvxlTtsYZ+mXXzlDlvYqWkXX7nDFvZqko1t1rQSX3mGZds1rcRXnmELGzbt4it32MKWTbv4yh2Wbdq0OBKzXZsW4tm2TSvxlWfYwsZNu/jKHbawddMuvnKHLWzetIuv3GHZ9k0r8ZVnWLaB00p85Rm2sIXTLr5yhy1s4rSLr9xh2TZOiyMx28dpJb7yDMt2clqIL2zltIuv3GELmznt4it32MJ2Trv4yh2Wbei0El95hmVbOq3EF55hpbKnk1T2dJLKnk5S2dNJNnSHvXwkFran00p84RlW2J5OK/GFO6xU9nSSyp5OUtnTSSp7OkllTydhezqtxBeeYYXt6bQSX3iGlcqeTlLZ00kqezpJZU8nYXs6LY7EbE+nlXh0h12JrzzDVvZ0ksqeTlLZ00kqezpJZU8nqezpJGxPp5X4yjMs29NpJb7yDFvZ00kqezpJZU8nqezpJGxPp8WRmO3ptBJfeYZlezqtxFfusJU9naSyp5NU9nSSyp5OUtnTSdieTivxlWdYtqfTSnzlGbayp5NU9nSSyp5OUtnTSdieTosjMdvTaSGe7em0El95hq3s6SSVPZ2ksqeTVPZ0ksqeTlLZ00nYnk4r8ZVnWLan00p85Rm2sqeTVPZ0ksqeTlLZ00nYnk6LIzHb02klvvIMy/Z0Woiv7OkklT2dpLKnk1T2dJLKnk5S2dNJ2J5OK/GVZ1i2p9NKfOUZtrKnk1T2dJLKnk5S2dNJ2J5OiyMx29NpJb7yDMv2dFqJr9xhK3s6aWVPJ63s6aSVPZ20sqeTbugOuxJfeIZVtqfTSnzhGVYrezppZU8nrezppJU9nZTt6XT5SKxsT6eVeHSHXYkvPMNqZU8nrezppJU9nbSyp5NW9nTSyp5OyvZ0WomvPMOyPZ1W4ivPsJU9nbSyp5NW9nTSyp5OyvZ0WhyJ2Z5OK/GVZ1i2p9NKfOUOW9nTSSt7OmllTyet7OmklT2dlO3ptBJfeYZlezqtxFeeYSt7OmllTyet7OmklT2dlO3ptDgSsz2dFuLZnk4r8ZU7bGVPJ63s6aSVPZ20sqeTVvZ0Uran06pUVu6wlT2dlO3ptNjzbE+nlfjKHbayp5NW9nTSyp5OyvZ0WpXKyh2W7em0El+5w1b2dNLKnk5a2dNJK3s6aWVPJ63s6aRsT6eV+MqfErM9nVbiK/932MqeTsr2dBo6TuKHbU/Fv3aHlXZaTDORh0/+Tc+1m+Z4qOe3EM+2Nul6uku6+eUQ4SM+XRxN799C7m58evV2vtj1/trRfv3z/tNf//3+xx/f//MvP/70t+9/ef/Th5/v7tzu/ud5JKbb+dffbdyvxdSPrxcH7ukH7hkH7plff8/zlMHiHjlwjx64xw7c4wfuObAP9MA+0AP7QA/sAz2wD+zAPrAD+8AO7AM7sA/swD6wA/vADuwDO7AP7MA+sAP7wA/sAz+wD57/flL3OU/3DP3snu8uX2xPAlh2AM8O0LIDRHaAnh1gvDiAtzhd7NPvzyUyt+fOPrbZ6ewTUz67+k7PZOl5/tshf6AegelRmB6D6XGYngbTEzA9HaYHVp8brD4HrD4HrD4HrD4HrD4HrD4HrD4HrD4HrD4HrD4HrD53WH3usPrcYfW5w+pzh9XnDqvPHVafO6w+d1h97rD6PGD1ecDq84DV5wGrzwNWnwesPg9YfR6w+jxg9XnA6vO8Qn2eEWc9vT2JIOkRND2CXTfC0CcRPD1CS4/w8lrUNjtFaJs//T309AgjO4LINV4i/BziaVKLvjyr27DT15TaaPE0hOSH0PwQlh/id2T2eBji403tyE1x5KZ+5KZx5KZ54CbbjtwkR27SIzfZkZuO7Ag7siPsyI6wIzvCjuwIO7Ij/MiO8CM7wo/sCD+yI/zIjvAjO8KP7Ag/siP8yI7wIzuiHdkR7ciOaEd2RDuyI9qRHdGO7Ih2ZEe0IzuiHdkR7ciOiCM7Io7siDiyI+LIjogjOyKO7Ig4siPiyI6IIzsijuyIfmRH9CM7oh/ZEf3IjuhHdkQ/siP6kR3Rj+yIfmRH/I4PvW1xit+fsX26WMZ2/6FKGx8j/I6PsV8aQdIjaHoES4/g6RFaeoRIj9DTI4z0COk5PdNzeqbn9EzP6Zme0zM9p2d6Ts/0nJ7pOT3Tc3pm5/QX/qzsVSNIegRNj2DpETw9QkuPEOkRenqEkR4hPaclPaclPaclPaclPaclPaclPaclPaclPaclPaclPac1Pac1Pac1Pac1Pac1Pac1Pac1Pac1Pac1Pac1PactPactPactPactPactPactPactPactPactPactPac9Pac9Pac9Pac9Pac9Pac9Pac9Pac9Pac9Pac9Padbek639Jxu6Tl9BfC7yXbybGsi9//V8tM3A/UKrHKzcQ7hEk9DeH6Ilh8i8kP0/BAjP8RMD3EF4HYZ4gpfLbbQiyE0P4Tlh/D8EFfIbvf7ECFPQ0R+iJ4fYuSHmOkhroBrLkNIfogrZHc7W5a2z/xNTyEsP4Tnh2j5Ia6R3eeL9xD6NETPDzHyQ8z0EHPLDyH5ITQ/hF05xHwawvNDtPwQV8jumGeWrW/PhOj5IUZ+iJkdwrYrZHeEnUPI9lmIZyZoOXuA7/94bwtv6r8JEpogpQkymiCnCWo0QeOVBbXeTxePh0n/8c8XmLx2jsV2+tQstngqR1lyjCXHWXKukFvdzueDPmQhx+c9GP/gr2T81r4kUGo6Ss1AqZkkNdfwOriiGkGpUZQaQ6m5QjHu5z/K08ajYvwxxBUK7GV3CdPID9HzQ4z8EDM9hG35ISQ/hOaHsPwQnh8iP7stP7stP7stP7stP7s9P7s9P7s9P7s9P7s9P7s9P7s9P7s9P7s9P7s9P7tbfna3/Oxu+dnd8rO75Wd3y8/ulp/dLT+7W352t/zsjvzsjvzsjvzsjvzsjvzsjvzsjvzsjvzsjvzsjvzs7vnZ3fOzu+dnd8/P7p6f3T0/u3t+dvf87O752d3zs3vkZ/fIz+6Rn90jP7tHfnaP/Owe+dk98rN75Gf3yM/umZ/dMz+7Z352z/zsnvnZPfOze+Zn98zP7pmf3TM9u33b8kNIfgjND2H5ITw/RMsPEfkhen6IkR8iP7slP7slP7slP7slP7slP7slP7slP7slP7slP7slP7vz/4aQ5/8NIc//G0Ke/zeEXPOzO/+7ap7/XTXP/66a539XzfO/SOb5XyTz/C+Sef4XyfwaX8G6Hu/h1/i61tchBHK6ONSeyhksORMlxzeWnNdnheZZjj+Voyw5xpLjLDmNJSdYcjpLzqtX5UucmftEyWkbSw6K4PSGIji9oQhOb86S01hygiWns+SwqnJjVeVgVeVgVeVgVeUAVeX9J7m78gv/NaKfENDxAAG9E/fkUteT+n00uXypzj4+Xatz3h/ANJ570+08lbXN5OHFf777c/A1ZWtN2VZTtteU3WrKjpqy+0tl99Mnod7t4aV3Dx+ZD5+JD9ct8+Evrd77r/T8G9XHD9fMh1vmw19ar5qenRu0P354y3x4ZD68Jz7cXrzmfu/K/OThL1Ue7VTmosvjh4/Eh7smLou/OIni/Avt8fjhnvnwlvnwyHx4z3z4yHz4THx426738NEeP1wyH/7iDI1zhs4nD39xhp5ryzMP98yHt8yHvzRDQ0+HotDx+OE98+Ej8+Ez8eHx0gwN8fPD5+OHS+bDNfPhlvlwz3x4y3x4ZD68X+/h9mSfj8yHvzhD778i4Y8f3l+coec/+PPMwyXz4Zr58Bdn6IXzeffMh7fMh0fmwzMHrp43cO0/6N2Fz3/05/ffbZP7z7q6fvlTt4t39K++Y3z1HfNr73j+86Yv37H/YHcXfuGLhnaqhT3uP2WRcWkqv3jL+Ppb5lfe8uv+4/9+/+/33//1xx9+3m+5+7f/+fC3X97/9OHTj7/8379++zf7xf8P","brillig_names":["get_note_internal","decompose_hint","get_auth_witness","pack_returns_oracle_wrapper","directive_invert","directive_integer_quotient"]},{"name":"lookup_validity","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{},"parameters":[{"name":"consumer","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"inner_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["lookup_validity"]}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"00000000000000000000000000000000000000000000000000000000a74a8dc0"},{"kind":"string","value":"PublicKeyNote"},{"fields":[{"name":"x","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"y","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"owner","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"SchnorrAccount"}},{"name":"fields","value":{"fields":[{"name":"signing_public_key","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"inner_hash","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrAccount::verify_private_authwit_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrAccount::verify_private_authwit_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"signing_pub_key_x","type":{"kind":"field"}},{"name":"signing_pub_key_y","type":{"kind":"field"}}],"kind":"struct","path":"SchnorrAccount::constructor_parameters"}}],"kind":"struct","path":"SchnorrAccount::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"app_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":4,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}}],"kind":"struct","path":"authwit::entrypoint::app::AppPayload"}},{"name":"fee_payload","type":{"fields":[{"name":"function_calls","type":{"kind":"array","length":2,"type":{"fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"authwit::aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"target_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"authwit::aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"is_public","type":{"kind":"boolean"}},{"name":"is_static","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::function_call::FunctionCall"}}},{"name":"nonce","type":{"kind":"field"}},{"name":"is_fee_payer","type":{"kind":"boolean"}}],"kind":"struct","path":"authwit::entrypoint::fee::FeePayload"}},{"name":"cancellable","type":{"kind":"boolean"}}],"kind":"struct","path":"SchnorrAccount::entrypoint_parameters"}}],"kind":"struct","path":"SchnorrAccount::entrypoint_abi"}]}},"file_map":{"115":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr","source":"use dep::protocol_types::{constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator};\n\nuse crate::context::{PrivateContext, UnconstrainedContext};\nuse crate::note::{\n    lifecycle::create_note, note_getter::{get_note, view_notes},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::Storage;\n\n// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> Storage<T> for PrivateImmutable<T, Context> {}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    // docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    // The following computation is leaky, in that it doesn't hide the storage slot that has been initialized, nor does it hide the contract address of this contract.\n    // When this initialization nullifier is emitted, an observer could do a dictionary or rainbow attack to learn the preimage of this nullifier to deduce the storage slot and contract address.\n    // For some applications, leaking the details that a particular state variable of a particular contract has been initialized will be unacceptable.\n    // Under such circumstances, such application developers might wish to _not_ use this state variable type.\n    // This is especially dangerous for initial assignment to elements of a `Map<AztecAddress, PrivateImmutable>` type (for example), because the storage slot often also identifies an actor.\n    // e.g. the initial assignment to `my_map.at(msg.sender)` will leak: `msg.sender`, the fact that an element of `my_map` was assigned-to for the first time, and the contract_address.\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    // docs:start:initialize\n    pub fn initialize<let N: u32>(\n        self,\n        note: &mut Note\n    ) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n        // Nullify the storage slot.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    // docs:start:get_note\n    pub fn get_note<let N: u32>(self) -> Note where Note: NoteInterface<N> + NullifiableNote {\n        let storage_slot = self.storage_slot;\n        get_note(self.context, storage_slot).0\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UnconstrainedContext> {\n    // docs:start:is_initialized\n    unconstrained pub fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    // view_note does not actually use the context, but it calls oracles that are only available in private\n    // docs:start:view_note\n    unconstrained pub fn view_note<let N: u32>(self) -> Note  where Note: NoteInterface<N> + NullifiableNote {\n        let mut options = NoteViewerOptions::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n"},"127":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr","source":"use dep::protocol_types::{address::AztecAddress, traits::Deserialize};\nuse crate::oracle::{execution::{get_chain_id, get_version, get_contract_address, get_block_number}, storage::storage_read};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    fn version(self) -> Field {\n        self.version\n    }\n\n    fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    unconstrained fn raw_storage_read<let N: u32>(self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    unconstrained fn storage_read<T, let N: u32>(\n        self,\n        storage_slot: Field\n    ) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n}\n"},"134":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n    set_public_teardown_function_call_internal\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    call_context::CallContext, function_selector::FunctionSelector, max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_request::PublicCallRequest, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NOTE_HASHES_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests : BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() });\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            returns_hash,\n            start_side_effect_counter,\n            end_side_effect_counter\n        }\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let call_request = PublicCallRequest { contract_address, call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let function_selector = comptime {\n            FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR)\n        };\n        let call_context = self.generate_call_context(\n            contract_address,\n            function_selector,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            contract_address,\n            call_context,\n            args_hash,\n            counter,\n        };\n    }\n\n    fn generate_call_context(\n        self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> CallContext {\n        let msg_sender = if is_delegate_call {\n            self.msg_sender()\n        } else {\n            self.this_address()\n        };\n        let storage_contract_address = if is_delegate_call {\n            self.this_address()\n        } else {\n            contract_address\n        };\n        CallContext { msg_sender, storage_contract_address, function_selector, is_static_call, is_delegate_call }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n"},"139":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, GENERATOR_INDEX__FUNCTION_ARGS},\n    point::Point, traits::Hash,\n    hash::{sha256_to_field, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice}\n};\nuse crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(contract_address: AztecAddress, log: [u8; N]) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"144":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use dep::protocol_types::address::AztecAddress;\nuse crate::{\n    oracle::{keys::get_public_keys_and_partial_address, key_validation_request::get_key_validation_request},\n    keys::{public_keys::PublicKeys, constants::{NULLIFIER_INDEX, OUTGOING_INDEX}}\n};\n\nmod test;\n\nunconstrained pub fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\nunconstrained pub fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) = unsafe {\n        get_public_keys_and_partial_address(account)\n    };\n    assert_eq(\n        account, AztecAddress::compute(hinted_canonical_public_keys.hash(), partial_address), \"Invalid public keys hint for address\"\n    );\n\n    hinted_canonical_public_keys\n}\n"},"146":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/point_to_symmetric_key.nr","source":"use dep::protocol_types::{constants::GENERATOR_INDEX__SYMMETRIC_KEY, scalar::Scalar, point::Point, utils::arr_copy_slice};\nuse crate::utils::point::point_to_bytes;\nuse std::{hash::sha256, embedded_curve_ops::multi_scalar_mul};\n\n// TODO(#5726): This function is called deriveAESSecret in TS. I don't like point_to_symmetric_key name much since\n// point is not the only input of the function. Unify naming with TS once we have a better name.\npub fn point_to_symmetric_key(secret: Scalar, point: Point) -> [u8; 32] {\n    let shared_secret: Point = multi_scalar_mul([point], [secret]);\n    let shared_secret = point_to_bytes(shared_secret);\n    let mut shared_secret_bytes_with_separator = [0 as u8; 33];\n    shared_secret_bytes_with_separator = arr_copy_slice(shared_secret, shared_secret_bytes_with_separator, 0);\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n    sha256(shared_secret_bytes_with_separator)\n}\n\n#[test]\nunconstrained fn test_point_to_symmetric_key_matches_noir() {\n    // Value taken from \"derive shared secret\" test in encrypt_buffer.test.ts\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = Point {\n        x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n        y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n        is_infinite: false\n    };\n\n    let key = point_to_symmetric_key(secret, point);\n\n    // The following value was generated by `encrypt_buffer.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let key_from_typescript = [\n        251, 232, 177, 34, 2, 174, 35, 92, 165, 118, 168, 3, 153, 140, 46, 210, 203, 154, 184, 158, 236, 33, 95, 77, 93, 120, 72, 88, 190, 209, 64, 159\n    ];\n    assert_eq(key, key_from_typescript);\n}\n"},"148":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/keys/public_keys.nr","source":"use dep::protocol_types::{\n    address::PublicKeysHash, constants::GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    hash::poseidon2_hash_with_separator, point::{Point, POINT_LENGTH},\n    traits::{Deserialize, Serialize, Empty, is_empty, Hash}\n};\n\nglobal PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Empty for PublicKeys {\n    fn empty() -> Self {\n        PublicKeys {\n            npk_m: NpkM { inner: Point::empty() },\n            ivpk_m: IvpkM { inner: Point::empty() },\n            ovpk_m: OvpkM { inner: Point::empty() },\n            tpk_m: TpkM { inner: Point::empty() }\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(\n            if is_empty(self) {\n            0\n        } else {\n            poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field)\n        }\n        )\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM { inner: Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool } },\n            ivpk_m: IvpkM { inner: Point { x: serialized[3], y: serialized[4], is_infinite: serialized[5] as bool } },\n            ovpk_m: OvpkM { inner: Point { x: serialized[6], y: serialized[7], is_infinite: serialized[8] as bool } },\n            tpk_m: TpkM { inner: Point { x: serialized[9], y: serialized[10], is_infinite: serialized[11] as bool } }\n        }\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash = 0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_empty_hash() {\n    let keys = PublicKeys::empty();\n\n    let actual = keys.hash();\n    let test_data_empty_hash = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    assert(actual.to_field() == test_data_empty_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } }\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"170":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/header.nr","source":"use dep::protocol_types::{address::AztecAddress, scalar::Scalar, point::Point};\n\nuse crate::keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::ToPoint};\n\nuse std::aes128::aes128_encrypt;\n\npub struct EncryptedLogHeader {\n    address: AztecAddress,\n}\n\nimpl EncryptedLogHeader {\n    fn new(address: AztecAddress) -> Self {\n        EncryptedLogHeader { address }\n    }\n\n    fn compute_ciphertext<T>(self, secret: Scalar, pk: T) -> [u8; 48] where T: ToPoint {\n        let full_key = point_to_symmetric_key(secret, pk.to_point());\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n\n        for i in 0..16 {\n            sym_key[i] = full_key[i];\n            iv[i] = full_key[i + 16];\n        }\n\n        let input: [u8; 32] = self.address.to_field().to_be_bytes();\n        aes128_encrypt(input, iv, sym_key).as_array()\n    }\n}\n\n#[test]\nunconstrained fn test_encrypted_log_header_matches_noir() {\n    let address = AztecAddress::from_field(0xdeadbeef);\n    let header = EncryptedLogHeader::new(address);\n    let secret = Scalar {\n        lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n        hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n    };\n    let point = crate::keys::public_keys::IvpkM {\n        inner: Point {\n            x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n            y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n            is_infinite: false\n        }\n    };\n\n    let ciphertext = header.compute_ciphertext(secret, point);\n\n    // The following value was generated by `encrypted_log_header.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_header_ciphertext_from_typescript = [\n        226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 194, 44, 7, 131, 160, 83, 64, 181, 98, 38, 153, 214, 62, 171, 253, 161, 111, 191, 28, 247, 216, 26, 222, 171, 176, 218, 48, 209, 73, 89, 200, 209\n    ];\n\n    assert_eq(ciphertext, expected_header_ciphertext_from_typescript);\n}\n"},"171":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypted_note_emission.nr","source":"use crate::{\n    context::PrivateContext, note::{note_emission::NoteEmission, note_interface::NoteInterface},\n    keys::{getters::get_ovsk_app, public_keys::{PublicKeys, OvpkM, IvpkM}},\n    encrypted_logs::payload::compute_encrypted_log\n};\nuse dep::protocol_types::{hash::sha256_to_field, address::AztecAddress, abis::note_hash::NoteHash};\n\nfn compute_raw_note_log<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let note_header = note.get_header();\n    let note_hash_counter = note_header.note_hash_counter;\n    let storage_slot = note_header.storage_slot;\n\n    // TODO(#8589): use typesystem to skip this check when not needed\n    let note_exists = context.note_hashes.storage.any(|n: NoteHash| n.counter == note_hash_counter);\n    assert(note_exists, \"Can only emit a note log for an existing note.\");\n\n    let contract_address: AztecAddress = context.this_address();\n\n    let plaintext = note.to_be_bytes(storage_slot);\n    let encrypted_log: [u8; 416 + N * 32] = compute_encrypted_log(contract_address, ovsk_app, ovpk, ivpk, recipient, plaintext);\n    let log_hash = sha256_to_field(encrypted_log);\n\n    (note_hash_counter, encrypted_log, log_hash)\n}\n\nunconstrained fn compute_raw_note_log_unconstrained<Note, let N: u32>(\n    context: PrivateContext,\n    note: Note,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> (u32, [u8; 416 + N * 32], Field) where Note: NoteInterface<N> {\n    let ovsk_app = get_ovsk_app(ovpk.hash());\n    compute_raw_note_log(context, note, ovsk_app, ovpk, ivpk, recipient)\n}\n\n// This function seems to be affected by the following Noir bug:\n// https://github.com/noir-lang/noir/issues/5771\n// If you get weird behavior it might be because of it.\npub fn encode_and_encrypt_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        let ovsk_app: Field  = context.request_ovsk_app(ovpk.hash());\n\n        let (note_hash_counter, encrypted_log, log_hash) = compute_raw_note_log(*context, e.note, ovsk_app, ovpk, ivpk, recipient);\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\npub fn encode_and_encrypt_note_unconstrained<Note, let N: u32>(\n    context: &mut PrivateContext,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress\n) -> fn[(&mut PrivateContext, OvpkM, IvpkM, AztecAddress)](NoteEmission<Note>) -> () where Note: NoteInterface<N> {\n    | e: NoteEmission<Note> | {\n        //   Having the log hash be unconstrained here is fine because the way this works is we send the log hash\n        // to the kernel, and it gets included as part of its public inputs. Then we send the tx to the sequencer,\n        // which includes the kernel proof and the log preimages. The sequencer computes the hashes of the logs\n        // and checks that they are the ones in the public inputs of the kernel, and drops the tx otherwise (proposing\n        // the block on L1 would later fail if it didn't because of txs effects hash mismatch).\n        //   So if we don't constrain the log hash, then a malicious sender can compute the correct log, submit a bad\n        // log hash to the kernel, and then submit the bad log preimage to the sequencer. All checks will pass, but\n        // the submitted log will not be the one that was computed by the app.\n        //   In the unconstrained case, we don't care about the log at all because we don't do anything with it,\n        // and because it's unconstrained: it could be anything. So if a sender chooses to broadcast the tx with a log\n        // that is different from the one that was used in the circuit, then they'll be able to, but they were already\n        // able to change the log before anyway, so the end result is the same. It's important here that we do not\n        // return the log from this function to the app, otherwise it could try to do stuff with it and then that might\n        // be wrong.\n        //   Regarding the note hash counter, this is used for squashing. The kernel assumes that a given note can have\n        // more than one log and removes all of the matching ones, so all a malicious sender could do is either: cause\n        // for the log to be deleted when it shouldn't have (which is fine - they can already make the content be\n        // whatever), or cause for the log to not be deleted when it should have (which is also fine - it'll be a log\n        // for a note that doesn't exist).\n        let (note_hash_counter, encrypted_log, log_hash) = unsafe {\n            compute_raw_note_log_unconstrained(*context, e.note, ovpk, ivpk, recipient)\n        };\n        context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n    }\n}\n\n/// Encrypts a partial log and emits it. Takes recipient keys on the input and encrypts both the outgoing and incoming\n/// logs for the recipient. This is necessary because in the partial notes flow the outgoing always has to be the same\n/// as the incoming to not leak any information (typically the `from` party finalizing the partial note in public does\n/// not know who the recipient is).\npub fn encrypt_and_emit_partial_log<let M: u32>(\n    context: &mut PrivateContext,\n    log_plaintext: [u8; M],\n    recipient_keys: PublicKeys,\n    recipient: AztecAddress\n) {\n    let ovsk_app: Field  = context.request_ovsk_app(recipient_keys.ovpk_m.hash());\n\n    let encrypted_log: [u8; 352 + M] = compute_encrypted_log(\n        context.this_address(),\n        ovsk_app,\n        recipient_keys.ovpk_m,\n        recipient_keys.ivpk_m,\n        recipient,\n        log_plaintext\n    );\n    let log_hash = sha256_to_field(encrypted_log);\n\n    // Unfortunately we need to push a dummy note hash to the context here because a note log requires having\n    // a counter that corresponds to a note hash in the same call.\n    let note_hash_counter = context.side_effect_counter;\n    context.push_note_hash(5);\n\n    context.emit_raw_note_log(note_hash_counter, encrypted_log, log_hash);\n}\n"},"172":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/payload.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, scalar::Scalar, point::Point, constants::GENERATOR_INDEX__SYMMETRIC_KEY,\n    hash::poseidon2_hash_with_separator\n};\nuse std::{\n    aes128::aes128_encrypt, embedded_curve_ops::fixed_base_scalar_mul as derive_public_key,\n    hash::from_field_unsafe as fr_to_fq_unsafe, field::bn254::decompose\n};\n\nuse crate::{\n    oracle::random::random, utils::point::point_to_bytes, encrypted_logs::{header::EncryptedLogHeader},\n    keys::{point_to_symmetric_key::point_to_symmetric_key, public_keys::{OvpkM, IvpkM}}\n};\n\npub fn compute_encrypted_log<let P: u32, let M: u32>(\n    contract_address: AztecAddress,\n    ovsk_app: Field,\n    ovpk: OvpkM,\n    ivpk: IvpkM,\n    recipient: AztecAddress,\n    plaintext: [u8; P]\n) -> [u8; M] {\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let header = EncryptedLogHeader::new(contract_address);\n\n    let incoming_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ivpk);\n    let outgoing_header_ciphertext: [u8; 48] = header.compute_ciphertext(eph_sk, ovpk);\n    let incoming_body_ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n    let outgoing_body_ciphertext: [u8; 144] = compute_outgoing_body_ciphertext(recipient, ivpk, fr_to_fq(ovsk_app), eph_sk, eph_pk);\n\n    let mut encrypted_bytes: [u8; M] = [0; M];\n    // @todo We ignore the tags for now\n\n    let eph_pk_bytes = point_to_bytes(eph_pk);\n    for i in 0..32 {\n        encrypted_bytes[64 + i] = eph_pk_bytes[i];\n    }\n    for i in 0..48 {\n        encrypted_bytes[96 + i] = incoming_header_ciphertext[i];\n        encrypted_bytes[144 + i] = outgoing_header_ciphertext[i];\n    }\n    for i in 0..144 {\n        encrypted_bytes[192 + i] = outgoing_body_ciphertext[i];\n    }\n    // Then we fill in the rest as the incoming body ciphertext\n    let size = M - 336;\n    assert_eq(size, incoming_body_ciphertext.len(), \"ciphertext length mismatch\");\n    for i in 0..size {\n        encrypted_bytes[336 + i] = incoming_body_ciphertext[i];\n    }\n\n    // Current unoptimized size of the encrypted log\n    // incoming_tag (32 bytes)\n    // outgoing_tag (32 bytes)\n    // eph_pk (32 bytes)\n    // incoming_header (48 bytes)\n    // outgoing_header (48 bytes)\n    // outgoing_body (144 bytes)\n    // incoming_body_fixed (64 bytes)\n    // incoming_body_variable (P + 16 bytes padding)\n    encrypted_bytes\n}\n\n/// Converts a base field element to scalar field element.\n/// This is fine because modulus of the base field is smaller than the modulus of the scalar field.\nfn fr_to_fq(r: Field) -> Scalar {\n    let (lo, hi) = decompose(r);\n\n    Scalar { lo, hi }\n}\n\nfn generate_ephemeral_key_pair() -> (Scalar, Point) {\n    // @todo Need to draw randomness from the full domain of Fq not only Fr\n\n    // We use the randomness to preserve the privacy of both the sender and recipient via encryption, so a malicious\n    // sender could use non-random values to reveal the plaintext. But they already know it themselves anyway, and so\n    // the recipient already trusts them to not disclose this information. We can therefore assume that the sender will\n    // cooperate in the random value generation.\n    let randomness = unsafe {\n        random()\n    };\n\n    // We use the unsafe version of `fr_to_fq` because multi_scalar_mul (called by derive_public_key) will constrain\n    // the scalars.\n    let eph_sk = fr_to_fq_unsafe(randomness);\n    let eph_pk = derive_public_key(eph_sk);\n\n    (eph_sk, eph_pk)\n}\n\npub fn compute_incoming_body_ciphertext<let P: u32>(plaintext: [u8; P], eph_sk: Scalar, ivpk: IvpkM) -> [u8] {\n    let full_key = point_to_symmetric_key(eph_sk, ivpk.to_point());\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(plaintext, iv, sym_key)\n}\n\n/// Encrypts ephemeral secret key and recipient's ivpk --> with this information the recipient of outgoing will\n/// be able to derive the key with which the incoming log can be decrypted.\npub fn compute_outgoing_body_ciphertext(\n    recipient: AztecAddress,\n    recipient_ivpk: IvpkM,\n    ovsk_app: Scalar,\n    eph_sk: Scalar,\n    eph_pk: Point\n) -> [u8; 144] {\n    // Again, we could compute `eph_pk` here, but we keep the interface more similar\n    // and also make it easier to optimise it later as we just pass it along\n\n    let mut buffer = [0 as u8; 128];\n\n    let serialized_eph_sk_high: [u8; 32] = eph_sk.hi.to_be_bytes();\n    let serialized_eph_sk_low: [u8; 32] = eph_sk.lo.to_be_bytes();\n\n    let address_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let serialized_recipient_ivpk = point_to_bytes(recipient_ivpk.to_point());\n\n    for i in 0..32 {\n        buffer[i] = serialized_eph_sk_high[i];\n        buffer[i + 32] = serialized_eph_sk_low[i];\n        buffer[i + 64] = address_bytes[i];\n    }\n    for i in 0..32 {\n        buffer[i + 96] = serialized_recipient_ivpk[i];\n    }\n\n    // We compute the symmetric key using poseidon.\n    let full_key: [u8; 32] = poseidon2_hash_with_separator(\n        [ovsk_app.hi, ovsk_app.lo, eph_pk.x, eph_pk.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY as Field\n    ).to_be_bytes();\n\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n\n    for i in 0..16 {\n        sym_key[i] = full_key[i];\n        iv[i] = full_key[i + 16];\n    }\n    aes128_encrypt(buffer, iv, sym_key).as_array()\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::payload::{compute_encrypted_log, compute_incoming_body_ciphertext, compute_outgoing_body_ciphertext},\n        keys::public_keys::{OvpkM, IvpkM}\n    };\n    use std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\n    use dep::protocol_types::{address::AztecAddress, point::Point, scalar::Scalar};\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn test_encrypted_log_matches_typescript() {\n        // All the values in this test were copied over from `tagged_log.test.ts`\n        let contract_address = AztecAddress::from_field(0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04);\n        let ovsk_app = 0x03a6513d6def49f41d20373d2cec894c23e7492794b08fc50c0e8a1bd2512612;\n        let ovpk_m = OvpkM {\n            inner: Point {\n                x: 0x1961448682803198631f299340e4206bb12809d4bebbf012b30f59af73ba1a15,\n                y: 0x133674060c3925142aceb4f1dcd9f9137d0217d37ff8729ee5ceaa6e2790353d,\n                is_infinite: false\n            }\n        };\n        let ivpk_m = IvpkM {\n            inner: Point {\n                x: 0x260cd3904f6df16e974c29944fdc839e40fb5cf293f03df2eb370851d3a527bc,\n                y: 0x0eef2964fe6640e84c82b5d2915892409b38e9e25d39f68dd79edb725c55387f,\n                is_infinite: false\n            }\n        };\n\n        let plaintext = [\n            0, 0, 0, 1, 48, 22, 64, 206, 234, 117, 131, 145, 178, 225, 97, 201, 44, 5, 19, 241, 41, 2, 15, 65, 37, 37, 106, 253, 174, 38, 70, 206, 49, 9, 159, 92, 16, 244, 140, 217, 239, 247, 174, 91, 32, 156, 85, 124, 112, 222, 46, 101, 126, 231, 145, 102, 134, 134, 118, 183, 135, 233, 65, 126, 25, 38, 14, 4, 15, 228, 107, 229, 131, 183, 31, 74, 181, 183, 12, 38, 87, 255, 29, 5, 204, 207, 29, 41, 42, 147, 105, 98, 141, 26, 25, 79, 148, 78, 101, 153, 0, 0, 16, 39\n        ];\n\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk);\n\n        let recipient = AztecAddress::from_field(0x10ee41ee4b62703b16f61e03cb0d88c4b306a9eb4a6ceeb2aff13428541689a2);\n\n        let log: [u8; 448] = compute_encrypted_log(contract_address, ovsk_app, ovpk_m, ivpk_m, recipient, plaintext);\n\n        // The following value was generated by `tagged_log.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let encrypted_log_from_typescript = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 141, 70, 12, 14, 67, 77, 132, 110, 193, 234, 40, 110, 64, 144, 235, 86, 55, 111, 242, 123, 221, 193, 170, 202, 225, 216, 86, 84, 159, 112, 31, 167, 126, 79, 51, 186, 47, 71, 253, 172, 99, 112, 241, 59, 197, 241, 107, 186, 232, 87, 187, 230, 171, 62, 228, 234, 42, 51, 145, 146, 238, 242, 42, 71, 206, 13, 244, 66, 111, 195, 20, 203, 98, 148, 204, 242, 145, 183, 156, 29, 141, 54, 44, 220, 194, 35, 229, 16, 32, 204, 211, 49, 142, 112, 82, 202, 116, 241, 254, 146, 42, 217, 20, 189, 70, 228, 182, 171, 205, 104, 27, 99, 171, 28, 91, 244, 21, 30, 130, 240, 5, 72, 174, 124, 97, 197, 157, 248, 193, 23, 193, 76, 46, 141, 144, 70, 211, 45, 67, 167, 218, 129, 140, 104, 190, 41, 110, 249, 209, 68, 106, 135, 164, 80, 235, 63, 101, 80, 32, 13, 38, 99, 145, 91, 11, 173, 151, 231, 247, 65, 153, 117, 229, 167, 64, 239, 182, 126, 235, 83, 4, 169, 8, 8, 160, 4, 235, 252, 21, 96, 84, 161, 69, 145, 145, 215, 254, 161, 117, 246, 198, 65, 89, 179, 194, 90, 19, 121, 12, 202, 114, 80, 195, 14, 60, 128, 105, 142, 100, 86, 90, 108, 157, 219, 22, 172, 20, 121, 195, 25, 159, 236, 2, 70, 75, 42, 37, 34, 2, 17, 149, 20, 176, 32, 18, 204, 56, 117, 121, 34, 15, 3, 88, 123, 64, 68, 74, 233, 63, 59, 131, 222, 194, 192, 167, 110, 217, 10, 128, 73, 129, 172, 61, 43, 12, 98, 165, 203, 191, 154, 161, 150, 4, 239, 95, 48, 60, 159, 33, 222, 142, 102, 73, 193, 236, 145, 197, 160, 216, 254, 113, 243, 25, 244, 251, 192, 222, 35, 7, 114, 101, 35, 152, 151, 112, 24, 32, 94, 138, 71, 160, 91, 68, 131, 217, 117, 140, 19, 147, 37, 197, 192, 21, 43, 172, 239, 239, 205, 15, 110, 76, 26, 211, 42, 117, 4, 15, 135, 145, 247, 37, 73, 84, 164, 149, 250, 35, 0, 205, 105, 178, 143, 104, 98, 100, 250, 193, 154, 136, 175, 177, 109, 225, 207, 252, 147, 250, 250, 189, 117, 147, 101, 230, 132\n        ];\n        assert_eq(encrypted_log_from_typescript, log);\n    }\n\n    #[test]\n    fn test_incoming_body_ciphertext_matches_typescript() {\n        // All the values in this test were copied over from `encrypted_note_log_incoming_body.test.ts`\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000649e7ca01d9de27b21624098b897babd,\n            hi: 0x0000000000000000000000000000000023b3127c127b1f29a7adff5cccf8fb06\n        };\n        let ivpk = IvpkM {\n            inner: Point {\n                x: 0x2688431c705a5ff3e6c6f2573c9e3ba1c1026d2251d0dbbf2d810aa53fd1d186,\n                y: 0x1e96887b117afca01c00468264f4f80b5bb16d94c1808a448595f115556e5c8e,\n                is_infinite: false\n            }\n        };\n        let plaintext = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3\n        ];\n\n        // `compute_incoming_body_ciphertext(...)` function then derives symmetric key from `eph_sk` and `ivpk` and encrypts\n        // the note plaintext using AES-128.\n        let ciphertext = compute_incoming_body_ciphertext(plaintext, eph_sk, ivpk);\n\n        // The following value was generated by `encrypted_note_log_incoming_body.test.ts`.\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let note_body_ciphertext_from_typescript = [\n            226, 240, 253, 6, 28, 52, 19, 131, 33, 132, 178, 212, 245, 62, 14, 190, 147, 228, 160, 190, 146, 61, 95, 203, 124, 153, 68, 168, 17, 150, 92, 0, 99, 214, 85, 64, 191, 78, 157, 131, 149, 96, 236, 253, 96, 172, 157, 30, 27, 176, 228, 74, 242, 190, 138, 48, 33, 93, 46, 37, 223, 130, 25, 245, 188, 163, 159, 223, 187, 24, 139, 206, 131, 154, 159, 130, 37, 17, 158, 114, 242, 141, 124, 193, 232, 54, 146, 96, 145, 100, 125, 234, 57, 43, 95, 115, 183, 39, 121, 232, 134, 229, 148, 25, 46, 77, 87, 127, 95, 7, 77, 188, 37, 234, 245, 142, 232, 87, 252, 28, 67, 67, 90, 214, 254, 89, 47, 68, 66, 187, 227, 8, 59, 162, 25, 141, 97, 141, 217, 197, 115, 15, 212, 202, 157, 41, 150, 62, 219, 57, 224, 92, 185, 212, 142, 94, 146, 41, 178, 145, 68, 169, 23, 185, 206, 138, 70, 47, 176, 210, 165, 236, 23, 206, 229, 108\n        ];\n\n        assert_eq(note_body_ciphertext_from_typescript.len(), ciphertext.len());\n\n        for i in 0..note_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], note_body_ciphertext_from_typescript[i]);\n        }\n    }\n\n    #[test]\n    fn test_encrypted_log_outgoing_body_matches_typescript() {\n        let eph_sk = Scalar {\n            lo: 0x00000000000000000000000000000000d0d302ee245dfaf2807e604eec4715fe,\n            hi: 0x000000000000000000000000000000000f096b423017226a18461115fa8d34bb\n        };\n        let recipient_ivsk = Scalar {\n            lo: 0x000000000000000000000000000000004828f8f95676ebb481df163f87fd4022,\n            hi: 0x000000000000000000000000000000000f4d97c25d578f9348251a71ca17ae31\n        };\n        let sender_ovsk_app = Scalar {\n            lo: 0x0000000000000000000000000000000074d2e28c6bc5176ac02cf7c7d36a444e,\n            hi: 0x00000000000000000000000000000000089c6887cb1446d86c64e81afc78048b\n        };\n\n        let eph_pk = derive_public_key(eph_sk);\n        let recipient_ivpk = IvpkM { inner: derive_public_key(recipient_ivsk) };\n\n        let recipient = AztecAddress::from_field(0xdeadbeef);\n\n        let ciphertext = compute_outgoing_body_ciphertext(recipient, recipient_ivpk, sender_ovsk_app, eph_sk, eph_pk);\n\n        // The following value was generated by `encrypted_log_outgoing_body.test.ts`\n        // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n        let outgoing_body_ciphertext_from_typescript = [\n            127, 182, 227, 75, 192, 197, 54, 47, 168, 134, 233, 148, 251, 46, 86, 12, 73, 50, 238, 50, 31, 174, 27, 202, 110, 77, 161, 197, 244, 124, 17, 100, 143, 150, 232, 14, 156, 248, 43, 177, 16, 82, 244, 103, 88, 74, 84, 200, 15, 65, 187, 14, 163, 60, 91, 22, 104, 31, 211, 190, 124, 121, 79, 92, 239, 65, 185, 106, 51, 178, 168, 137, 84, 43, 79, 158, 151, 152, 83, 42, 170, 13, 106, 209, 254, 74, 39, 145, 73, 215, 17, 234, 196, 89, 30, 58, 120, 127, 88, 69, 121, 61, 18, 206, 89, 118, 243, 238, 177, 71, 73, 47, 147, 4, 155, 25, 173, 248, 206, 52, 17, 180, 122, 186, 106, 191, 252, 102, 197, 91, 16, 39, 94, 91, 224, 30, 168, 177, 26, 144, 5, 124, 128, 6\n        ];\n\n        for i in 0..outgoing_body_ciphertext_from_typescript.len() {\n            assert_eq(ciphertext[i], outgoing_body_ciphertext_from_typescript[i]);\n        }\n        assert_eq(outgoing_body_ciphertext_from_typescript.len(), ciphertext.len());\n    }\n}\n"},"174":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/random.nr","source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\nunconstrained pub fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(getRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n"},"175":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr","source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: u32 = 24;\n\npub struct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n"},"177":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr","source":"use dep::protocol_types::{abis::{function_selector::FunctionSelector}, address::AztecAddress};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> Field {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> Field {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> Field {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> Field {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    unsafe {\n        notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter)\n    };\n}\n\nunconstrained pub fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(notifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"},"182":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr","source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; 2] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"},"184":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{KeyValidationRequest, key_validation_request::KEY_VALIDATION_REQUEST_LENGTH};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\nunconstrained pub fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"185":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr","source":"/// Notifies the simulator that `returns` will be later fetched once the function return is processed, referenced by\n/// their hash. This allows the simulator to know how to respond to this future request.\n///\n/// This is only used during private execution, since in public it is the VM itself that keeps track of return values.\npub fn pack_returns(returns: [Field]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call. When\n    // unpacking however the caller must check that the returned value is indeed the preimage.\n    unsafe {\n        pack_returns_oracle_wrapper(returns)\n    };\n}\n\nunconstrained pub fn pack_returns_oracle_wrapper(returns: [Field]) {\n    let _ = pack_returns_oracle(returns);\n}\n\nunconstrained pub fn unpack_returns<let N: u32>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n\n#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle(_returns: [Field]) -> Field {}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<let N: u32>(_return_hash: Field) -> [Field; N] {}\n"},"186":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use crate::keys::{PublicKeys, public_keys::{NpkM, IvpkM, OvpkM, TpkM}};\nuse dep::protocol_types::{address::{AztecAddress, PartialAddress}, point::Point};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\nunconstrained pub fn get_public_keys_and_partial_address(address: AztecAddress) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool } }\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"187":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/logs.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n/// Informs the simulator that an encrypted note log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_note_log<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_note_log_oracle_wrapper(note_hash_counter, encrypted_note, counter)\n    }\n}\n\n/// Informs the simulator that an encrypted event log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_encrypted_event_log<let M: u32>(contract_address: AztecAddress, randomness: Field, encrypted_event: [u8; M], counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_encrypted_event_log_oracle_wrapper(contract_address, randomness, encrypted_event, counter)\n    }\n}\n\n/// Informs the simulator that an unencrypted log has been emitted, helping it keep track of side-effects and easing\n/// debugging.\npub fn emit_unencrypted_log_private<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        emit_unencrypted_log_private_oracle_wrapper(contract_address, message, counter)\n    }\n}\n\nunconstrained fn emit_encrypted_note_log_oracle_wrapper<let M: u32>(note_hash_counter: u32, encrypted_note: [u8; M], counter: u32) {\n    emit_encrypted_note_log_oracle(note_hash_counter, encrypted_note, counter)\n}\n\nunconstrained fn emit_encrypted_event_log_oracle_wrapper<let M: u32>(\n    contract_address: AztecAddress,\n    randomness: Field,\n    encrypted_event: [u8; M],\n    counter: u32\n) {\n    emit_encrypted_event_log_oracle(contract_address, randomness, encrypted_event, counter)\n}\n\nunconstrained fn emit_unencrypted_log_private_oracle_wrapper<T>(contract_address: AztecAddress, message: T, counter: u32) {\n    let _ = emit_unencrypted_log_private_oracle(contract_address, message, counter);\n}\n\n/// Temporary substitute for `emit_unencrypted_log_private` that is used for handling contract class registration. This\n/// variant returns the log hash, which would be too large to compute inside a circuit.\nunconstrained pub fn emit_contract_class_unencrypted_log_private<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {\n    emit_contract_class_unencrypted_log_private_oracle(contract_address, message, counter)\n}\n\n// = 480 + 32 * N bytes\n#[oracle(emitEncryptedNoteLog)]\nunconstrained fn emit_encrypted_note_log_oracle<let M: u32>(\n    _note_hash_counter: u32,\n    _encrypted_note: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitEncryptedEventLog)]\nunconstrained fn emit_encrypted_event_log_oracle<let M: u32>(\n    _contract_address: AztecAddress,\n    _randomness: Field,\n    _encrypted_event: [u8; M],\n    _counter: u32\n) {}\n\n#[oracle(emitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_private_oracle<T>(\n    _contract_address: AztecAddress,\n    _message: T,\n    _counter: u32\n) -> Field {}\n\n#[oracle(emitContractClassUnencryptedLog)]\nunconstrained fn emit_contract_class_unencrypted_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32\n) -> Field {}\n"},"189":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, constants::CONTRACT_INSTANCE_LENGTH,\n    utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = unsafe {\n        ContractInstance::deserialize(get_contract_instance_internal(address))\n    };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n"},"190":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr","source":"use crate::note::{note_header::NoteHeader, note_interface::NoteInterface};\n\nuse dep::protocol_types::{address::AztecAddress, utils::arr_copy_slice};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(storage_slot, note_type_id, serialized_note, note_hash, counter)\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter)\n    };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    serialized_note: [Field; N],\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_created_note_oracle(storage_slot, note_type_id, serialized_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _serialized_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32\n) -> Field {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32\n) {\n    let _ = notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) -> Field {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let S: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n    _placeholder_fields: [Field; S]\n) -> [Field; S] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let S: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_fields: [Field; S]\n) -> [Field; S] {\n    let return_size = placeholder_fields.len() as u32;\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        return_size,\n        placeholder_fields\n    )\n}\n\nunconstrained pub fn get_notes<Note, let N: u32, let M: u32, let S: u32, let NS: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    mut placeholder_opt_notes: [Option<Note>; S], // TODO: Remove it and use `limit` to initialize the note array.\n    placeholder_fields: [Field; NS], // TODO: Remove it and use `limit` to initialize the note array.\n    _placeholder_note_length: [Field; N] // Turbofish hack? Compiler breaks calculating read_offset unless we add this parameter\n) -> [Option<Note>; S] where Note: NoteInterface<N> {\n    let fields = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        placeholder_fields\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n    for i in 0..placeholder_opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n            let nonce = fields[read_offset];\n            let note_hash_counter = fields[read_offset + 1] as u32;\n            let header = NoteHeader { contract_address, nonce, storage_slot, note_hash_counter };\n            let serialized_note = arr_copy_slice(fields, [0; N], read_offset + 2);\n            let mut note = Note::deserialize_content(serialized_note);\n            note.set_header(header);\n            placeholder_opt_notes[i] = Option::some(note);\n        };\n    }\n    placeholder_opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\nunconstrained pub fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier) == 1\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> Field {}\n"},"191":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\nunconstrained pub fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\nunconstrained pub fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\nunconstrained pub fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\nunconstrained pub fn get_version() -> Field {\n    get_version_oracle()\n}\n"},"192":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, hash::poseidon2_hash_with_separator, constants::GENERATOR_INDEX__CONSTRUCTOR,\n    abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n"},"196":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"199":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"227":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256([log_hash.contract_address.to_field(), log_hash.log_hash.value])\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n                0\n            )\n        )\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(\n    inputs: [Field; N],\n    separator: T\n) -> Field where T: ToField {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field where T: ToField {\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv : Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n        message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n        contract_address: AztecAddress::from_field(3)\n    },\n        version,\n        chainId\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"228":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    contract_class_id::ContractClassId, constants::CONTRACT_INSTANCE_LENGTH,\n    traits::{Deserialize, Hash, Serialize}\n};\n\npub struct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4])\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n"},"230":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::utils::field::field_from_bytes;\nuse crate::meta::{derive_deserialize, derive_serialize};\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool where T: Empty + Eq {\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool where T: Empty + Eq {\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl <let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::ops::arith::{Add, Sub, Neg};\nuse crate::cmp::Eq;\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    x: Field,\n    y: Field,\n    is_infinite: bool\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    lo: Field,\n    hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a,b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset+31 - i] as Field) * v;\n            hi = hi + (bytes[offset+15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the \n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N]\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\nfn multi_scalar_mul_array_return<let N: u32>(points: [EmbeddedCurvePoint; N], scalars: [EmbeddedCurveScalar; N]) -> [Field; 3] {}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_slice(points: [EmbeddedCurvePoint], scalars: [EmbeddedCurveScalar]) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint { x: 1, y: 17631683881184975370165255887551781615748388533673675138860, is_infinite: false };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint { x: point1.x + (x_coordinates_match as Field), y: point1.y, is_infinite: x_coordinates_match };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result= point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(_point1: EmbeddedCurvePoint, _point2: EmbeddedCurvePoint) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(point1: EmbeddedCurvePoint, point2: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained pub(crate) fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size(128);\n        rhi.assert_max_bit_size(128);\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size(128);\n            xhi.assert_max_bit_size(128);\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size(self, bit_size: u32) {\n        // docs:end:assert_max_bit_size\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    /// \n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n     // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    /// \n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self', \n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let  p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        crate::assert_constant(radix);\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N-1-i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n"},"281":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{traits::{Empty, Serialize, Deserialize}, point::Point};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.pk_m.is_infinite as Field,\n            self.sk_app\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self { pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool }, sk_app: fields[3] }\n    }\n}\n"},"287":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr","source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\npub struct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self { nullifier: 0, next_nullifier: 0, next_index: 0 }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable<ScopedReadRequest> for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.next_nullifier == other.next_nullifier)\n            & (self.next_index == other.next_index)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::collections::vec::Vec;\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_slice};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    pedersen_hash_with_separator_noir(input, separator)\n}\n\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let value = __pedersen_commitment_with_separator(input, separator);\n    if (value[0] == 0) & (value[1] == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value[0], y: value[1], is_infinite: false }\n    }\n}\n\n#[no_predicates]\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n#[no_predicates]\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: Vec<EmbeddedCurveScalar> = Vec::from_slice([EmbeddedCurveScalar { lo: 0, hi: 0 }; N].as_slice()); //Vec::new();\n\n    for i in 0..N {\n        scalars.set(i, from_field_unsafe(input[i]));\n    }\n    scalars.push(EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field });\n    let domain_generators :[EmbeddedCurvePoint; N]= derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let mut vec_generators = Vec::new();\n    for i in 0..N {\n        vec_generators.push(domain_generators[i]);\n    }\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    vec_generators.push(length_generator[0]);\n    multi_scalar_mul_slice(vec_generators.slice, scalars.slice)[0]\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator_noir(input, 0)\n}\n\n#[foreign(pedersen_hash)]\nfn __pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe {\n        crate::field::bn254::decompose_hint(scalar)\n    };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, |fields| fields)\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H> where H: Hasher {\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default {\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1), 0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1), EmbeddedCurvePoint {\n        x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n        y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n        is_infinite: false\n    }\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2), 0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2), EmbeddedCurvePoint {\n        x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n        y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3), 0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3), EmbeddedCurvePoint {\n        x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n        y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4), 0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4), EmbeddedCurvePoint {\n        x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n        y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5), 0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5), EmbeddedCurvePoint {\n        x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n        y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6), 0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6), EmbeddedCurvePoint {\n        x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n        y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7), 0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7), EmbeddedCurvePoint {\n        x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n        y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), 0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8), EmbeddedCurvePoint {\n        x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n        y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), 0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9), EmbeddedCurvePoint {\n        x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n        y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n        is_infinite: false\n    }\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), 0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10), EmbeddedCurvePoint {\n        x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n        y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n        is_infinite: false\n    }\n    );\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    /// \n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    /// \n    /// example\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    /// \n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let first_elem = f(self[0]);\n        let mut ret = [first_elem; N];\n\n        for i in 1..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    /// \n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    /// \n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    /// \n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    /// \n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Ord + Eq {\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N] where T: Eq {\n    /// Returns a new sorted array by sorting it with a custom comparison function. \n    /// The original array remains untouched. \n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    /// \n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    /// \n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]), \"Array has not been sorted correctly according to `ordering`.\"\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    /// \n    /// Example:\n    /// \n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n"},"320":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{traits::{Deserialize, Empty, Hash, Serialize}, hash::poseidon2_hash};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"322":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr","source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to call.\n    unsafe {\n        debug_log_oracle_wrapper(msg, args)\n    };\n}\n\nunconstrained pub fn debug_log_oracle_wrapper<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"},"323":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{salted_initialization_hash::SaltedInitializationHash, aztec_address::AztecAddress},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS, contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator, traits::{ToField, Serialize, Deserialize}\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner : Field\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer)\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash\n    ) -> Self {\n        PartialAddress::from_field(\n            poseidon2_hash_with_separator(\n                [\n            contract_class_id.to_field(),\n            salted_initialization_hash.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"324":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    address::{partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    hash::poseidon2_hash_with_separator, traits::{Empty, FromField, ToField, Serialize, Deserialize},\n    utils\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash_with_separator(\n                [pub_keys_hash.to_field(), partial_address.to_field()],\n                GENERATOR_INDEX__CONTRACT_ADDRESS_V1\n            )\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"327":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress}, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(\n            poseidon2_hash_with_separator(\n                [\n            salt,\n            initialization_hash,\n            deployer.to_field()\n        ],\n                GENERATOR_INDEX__PARTIAL_ADDRESS\n            )\n        )\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field;3],\n    state: [Field;4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result = Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32, is_variable_length: bool) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv : Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher{\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv : Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"35":{"path":"std/hash/sha256.nr","source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N as u64)\n}\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\nunconstrained fn build_msg_block_iter<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> ([u8; 64], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE = 64;\nglobal ZERO = 0;\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe {\n            build_msg_block_iter(msg, message_size, msg_start)\n        };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if crate::runtime::is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..BLOCK_SIZE {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..BLOCK_SIZE {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe {\n        attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size)\n    };\n\n    if !crate::runtime::is_unconstrained() {\n        for i in 0..56 {\n            let predicate = (i < msg_byte_ptr) as u8;\n            let expected_byte = predicate * last_block[i];\n            assert_eq(msg_block[i], expected_byte);\n        }\n\n        // We verify the message length was inserted correctly by reversing the byte decomposition.\n        let len = 8 * message_size;\n        let mut reconstructed_len: Field = 0;\n        for i in 56..64 {\n            reconstructed_len = 256 * reconstructed_len + msg_block[i] as Field;\n        }\n        assert_eq(reconstructed_len, len as Field);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; 64],\n    mut msg_byte_ptr: u32\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(mut msg_block: [u8; BLOCK_SIZE], msg_byte_ptr: u32, message_size: u32) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d, 0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0, 0x8f, 0xfe, 0x73, 0x2b\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94, 24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154, 60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213, 165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117, 101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112, 108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115, 99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46, 48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45, 52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55, 64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32, 50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32, 43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64, 103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56, 51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48, 87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75, 57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101, 114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186, 55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17, 48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12, 201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48, 37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6, 242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2, 1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89, 110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2, 1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75, 193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1, 12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189, 233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4, 32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45, 105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4, 32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188, 194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212, 181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253, 179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9, 236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214, 72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107, 218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198, 149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126, 32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36, 137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59, 245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97, 3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180, 170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216, 116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70, 86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246, 215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193, 104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74, 134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210, 188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210, 186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69, 79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22, 121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175, 169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53, 101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200, 157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86, 119, 30, 63, 129, 143, 32, 96\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n/// \n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n/// \n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n/// \n/// Example:\n/// \n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a \n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    /// \n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    /// \n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    /// \n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    /// \n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    /// \n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure. \n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    /// \n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    /// \n    /// Panics if the new length of the vector will be greater than the max length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// \n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    /// \n    /// v.push(100);\n    /// assert(v.len() == 1);\n    /// \n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    /// \n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    /// \n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    /// \n    /// Note that uninitialized elements may be zeroed out!\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    /// \n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    /// \n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    /// \n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    /// \n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    /// \n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    /// \n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    /// \n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input. \n    /// The maximum length of the vector is determined based on the type signature.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    /// \n    /// Panics if the vector is empty.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    /// \n    /// let two = v.pop();\n    /// let one = v.pop();\n    /// \n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    /// \n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.  \n    /// \n    /// Example:\n    /// \n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    /// \n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen> where T: Eq {\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2)  as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with=\"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"70":{"path":"/home/anon/ZeKshop/zekshop/contracts/schnorr_account_contract/src/public_key_note.nr","source":"use dep::aztec::{\n    keys::getters::{get_nsk_app, get_public_keys}, macros::notes::note,\n    note::utils::compute_note_hash_for_nullify,\n    protocol_types::{address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER, hash::poseidon2_hash_with_separator}\n};\nuse dep::aztec::prelude::{NoteHeader, NullifiableNote, PrivateContext};\n\n// Stores a public key composed of two fields\n// TODO: Do we need to include a nonce, in case we want to read/nullify/recreate with the same pubkey value?\n#[note]\npub struct PublicKeyNote {\n    x: Field,\n    y: Field,\n    owner: AztecAddress,\n}\n\nimpl NullifiableNote for PublicKeyNote {\n    fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field\n        )\n    }\n}\n\nimpl PublicKeyNote {\n    pub fn new(x: Field, y: Field, owner: AztecAddress) -> Self {\n        PublicKeyNote { x, y, owner, header: NoteHeader::empty() }\n    }\n}\n"},"71":{"path":"/home/anon/ZeKshop/zekshop/contracts/schnorr_account_contract/src/main.nr","source":"mod public_key_note;\n\n// Account contract that uses Schnorr signatures for authentication.\n// The signing key is stored in an immutable private note and should be different from the encryption/nullifying key.\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract SchnorrAccount {\n    use dep::std;\n\n    use dep::authwit::{\n        account::AccountActions, auth::{compute_authwit_message_hash, compute_authwit_nullifier},\n        auth_witness::get_auth_witness, entrypoint::{app::AppPayload, fee::FeePayload}\n    };\n    use dep::aztec::encrypted_logs::encrypted_note_emission::encode_and_encrypt_note;\n    use dep::aztec::{hash::compute_siloed_nullifier, keys::getters::get_public_keys};\n    use dep::aztec::macros::{functions::{initializer, noinitcheck, private, view}, storage::storage};\n    use dep::aztec::oracle::get_nullifier_membership_witness::get_low_nullifier_membership_witness;\n    use dep::aztec::prelude::{AztecAddress, PrivateContext, PrivateImmutable};\n\n    use crate::public_key_note::PublicKeyNote;\n\n    #[storage]\n    struct Storage<Context> {\n        signing_public_key: PrivateImmutable<PublicKeyNote, Context>,\n    }\n\n    // Constructs the contract\n    #[private]\n    #[initializer]\n    fn constructor(signing_pub_key_x: Field, signing_pub_key_y: Field) {\n        let this = context.this_address();\n        // Not emitting outgoing for msg_sender here to not have to register keys for the contract through which we\n        // deploy this (typically MultiCallEntrypoint). I think it's ok here as I feel the outgoing here is not that\n        // important.\n        let mut pub_key_note = PublicKeyNote::new(signing_pub_key_x, signing_pub_key_y, this);\n        let this_ovpk_m = get_public_keys(this).ovpk_m;\n        let this_ivpk_m = get_public_keys(this).ivpk_m;\n        storage.signing_public_key.initialize(&mut pub_key_note).emit(encode_and_encrypt_note(&mut context, this_ovpk_m, this_ivpk_m, this));\n    }\n\n    // Note: If you globally change the entrypoint signature don't forget to update account_entrypoint.ts file\n    #[private]\n    #[noinitcheck]\n    fn entrypoint(app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.entrypoint(app_payload, fee_payload, cancellable);\n    }\n\n    #[private]\n    #[noinitcheck]\n    #[view]\n    fn verify_private_authwit(inner_hash: Field) -> Field {\n        let actions = AccountActions::init(&mut context, is_valid_impl);\n        actions.verify_private_authwit(inner_hash)\n    }\n\n    #[contract_library_method]\n    fn is_valid_impl(context: &mut PrivateContext, outer_hash: Field) -> bool {\n        // docs:start:is_valid_impl\n        // Load public key from storage\n        let storage = Storage::init(context);\n        let public_key = storage.signing_public_key.get_note();\n        // Load auth witness\n        let witness: [Field; 64] = unsafe {\n            get_auth_witness(outer_hash)\n        };\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n\n        // Verify signature of the payload bytes\n        std::schnorr::verify_signature(\n            public_key.x,\n            public_key.y,\n            signature,\n            outer_hash.to_be_bytes::<32>()\n        )\n        // docs:end:is_valid_impl\n    }\n\n    /**\n    * @notice Helper function to check validity of private authwitnesses\n    * @param consumer The address of the consumer of the message\n    * @param message_hash The message hash of the message to check the validity\n    * @return True if the message_hash can be consumed, false otherwise\n    */\n    unconstrained fn lookup_validity(consumer: AztecAddress, inner_hash: Field) -> pub bool {\n        let public_key = storage.signing_public_key.view_note();\n\n        let message_hash = compute_authwit_message_hash(consumer, context.chain_id(), context.version(), inner_hash);\n\n        let witness: [Field; 64] = get_auth_witness(message_hash);\n        let mut signature: [u8; 64] = [0; 64];\n        for i in 0..64 {\n            signature[i] = witness[i] as u8;\n        }\n        let valid_in_private = std::schnorr::verify_signature(\n            public_key.x,\n            public_key.y,\n            signature,\n            message_hash.to_be_bytes::<32>()\n        );\n\n        // Compute the nullifier and check if it is spent\n        // This will BLINDLY TRUST the oracle, but the oracle is us, and\n        // it is not as part of execution of the contract, so we are good.\n        let nullifier = compute_authwit_nullifier(context.this_address(), inner_hash);\n        let siloed_nullifier = compute_siloed_nullifier(consumer, nullifier);\n        let lower_wit = get_low_nullifier_membership_witness(context.block_number(), siloed_nullifier);\n        let is_spent = lower_wit.leaf_preimage.nullifier == siloed_nullifier;\n\n        !is_spent & valid_in_private\n    }\n}\n"},"72":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/authwit/src/auth_witness.nr","source":"#[oracle(getAuthWitness)]\nunconstrained fn get_auth_witness_oracle<let N: u32>(_message_hash: Field) -> [Field; N] {}\n\n/**\n * Oracle wrapper to fetch an `auth_witness` for a given `message_hash` from the PXE.\n * \n * @param message_hash The hash of the message for which the `auth_witness` is to be fetched.\n * @return The `auth_witness` for the given `message_hash` as Field array.\n */\nunconstrained pub fn get_auth_witness<let N: u32>(message_hash: Field) -> [Field; N] {\n    get_auth_witness_oracle(message_hash)\n}\n"},"73":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/authwit/src/account.nr","source":"use dep::aztec::{\n    context::PrivateContext,\n    protocol_types::constants::{GENERATOR_INDEX__COMBINED_PAYLOAD, GENERATOR_INDEX__TX_NULLIFIER},\n    hash::poseidon2_hash_with_separator\n};\n\nuse crate::entrypoint::{app::AppPayload, fee::FeePayload};\nuse crate::auth::{IS_VALID_SELECTOR, compute_authwit_message_hash};\n\npub struct AccountActions<Context> {\n  context: Context,\n  is_valid_impl: fn(&mut PrivateContext, Field) -> bool,\n}\n\nimpl<Context> AccountActions<Context> {\n    pub fn init(context: Context, is_valid_impl: fn(&mut PrivateContext, Field) -> bool) -> Self {\n        AccountActions { context, is_valid_impl }\n    }\n}\n\n/**\n * An implementation of the Account Action struct for the private context.\n *\n * Implements logic to verify authorization and execute payloads.\n */\nimpl AccountActions<&mut PrivateContext> {\n\n    /**\n     * Verifies that the `app_hash` and `fee_hash` are authorized and then executes them.\n     *\n     * Executes the `fee_payload` and `app_payload` in sequence.\n     * Will execute the `fee_payload` as part of the setup, and then enter the app phase.\n     *\n     * @param app_payload The payload that contains the calls to be executed in the app phase.\n     * @param fee_payload The payload that contains the calls to be executed in the setup phase.\n     */\n    // docs:start:entrypoint\n    pub fn entrypoint(self, app_payload: AppPayload, fee_payload: FeePayload, cancellable: bool) {\n        let valid_fn = self.is_valid_impl;\n\n        let combined_payload_hash = poseidon2_hash_with_separator(\n            [app_payload.hash(), fee_payload.hash()],\n            GENERATOR_INDEX__COMBINED_PAYLOAD\n        );\n        assert(valid_fn(self.context, combined_payload_hash));\n\n        fee_payload.execute_calls(self.context);\n        self.context.end_setup();\n        app_payload.execute_calls(self.context);\n        if cancellable {\n            let tx_nullifier = poseidon2_hash_with_separator([app_payload.nonce], GENERATOR_INDEX__TX_NULLIFIER);\n            self.context.push_nullifier(tx_nullifier);\n        }\n    }\n    // docs:end:entrypoint\n\n    /**\n     * Verifies that the `msg_sender` is authorized to consume `inner_hash` by the account.\n     *\n     * Computes the `message_hash` using the `msg_sender`, `chain_id`, `version` and `inner_hash`.\n     * Then executes the `is_valid_impl` function to verify that the message is authorized.\n     *\n     * Will revert if the message is not authorized.\n     *\n     * @param inner_hash The hash of the message that the `msg_sender` is trying to consume.\n     */\n    // docs:start:verify_private_authwit\n    pub fn verify_private_authwit(self, inner_hash: Field) -> Field {\n        // The `inner_hash` is \"siloed\" with the `msg_sender` to ensure that only it can\n        // consume the message.\n        // This ensures that contracts cannot consume messages that are not intended for them.\n        let message_hash = compute_authwit_message_hash(\n            self.context.msg_sender(),\n            self.context.chain_id(),\n            self.context.version(),\n            inner_hash\n        );\n        let valid_fn = self.is_valid_impl;\n        assert(valid_fn(self.context, message_hash) == true, \"Message not authorized by account\");\n        IS_VALID_SELECTOR\n    }\n    // docs:end:verify_private_authwit\n}\n"},"77":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/authwit/src/entrypoint/app.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__SIGNATURE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize}\n};\n\nuse crate::entrypoint::function_call::FunctionCall;\n\n// FUNCTION_CALL_SIZE * ACCOUNT_MAX_CALLS + 1\nglobal APP_PAYLOAD_SIZE: u32 = 21;\n// FUNCTION_CALL_SIZE_IN_BYTES * ACCOUNT_MAX_CALLS + 32\nglobal APP_PAYLOAD_SIZE_IN_BYTES: u32 = 424;\n\nglobal ACCOUNT_MAX_CALLS: u32 = 4;\n\n// Note: If you change the following struct you have to update default_entrypoint.ts\n// docs:start:app-payload-struct\npub struct AppPayload {\n  function_calls: [FunctionCall; ACCOUNT_MAX_CALLS],\n  nonce: Field,\n}\n// docs:end:app-payload-struct\n\nimpl Serialize<APP_PAYLOAD_SIZE> for AppPayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; APP_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, APP_PAYLOAD_SIZE> = BoundedVec::new();\n        for call in self.function_calls {\n            fields.extend_from_array(call.serialize());\n        }\n        fields.push(self.nonce);\n        fields.storage\n    }\n}\n\nimpl Hash for AppPayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__SIGNATURE_PAYLOAD)\n    }\n}\n\nimpl AppPayload {\n    // Serializes the payload as an array of bytes. Useful for hashing with sha256.\n    fn to_be_bytes(self) -> [u8; APP_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, APP_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..ACCOUNT_MAX_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n\n        bytes.storage\n    }\n\n    // Executes all private and public calls\n    // docs:start:entrypoint-execute-calls\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                }\n            }\n        }\n    }\n    // docs:end:entrypoint-execute-calls\n}\n"},"78":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/authwit/src/entrypoint/fee.nr","source":"use dep::aztec::prelude::PrivateContext;\nuse dep::aztec::protocol_types::{\n    constants::GENERATOR_INDEX__FEE_PAYLOAD, hash::poseidon2_hash_with_separator,\n    traits::{Hash, Serialize}\n};\nuse crate::entrypoint::function_call::FunctionCall;\n\n// 2 * 5 (FUNCTION_CALL_SIZE) + 2\nglobal FEE_PAYLOAD_SIZE: u32 = 12;\n\n// 2 * 98 (FUNCTION_CALL_SIZE_IN_BYTES) + 32\nglobal FEE_PAYLOAD_SIZE_IN_BYTES: u32 = 228;\n\nglobal MAX_FEE_FUNCTION_CALLS: u32 = 2;\n\n// docs:start:fee-payload-struct\npub struct FeePayload {\n  function_calls: [FunctionCall; MAX_FEE_FUNCTION_CALLS],\n  nonce: Field,\n  is_fee_payer: bool,\n}\n// docs:end:fee-payload-struct\n\nimpl Serialize<FEE_PAYLOAD_SIZE> for FeePayload {\n    // Serializes the entrypoint struct\n    fn serialize(self) -> [Field; FEE_PAYLOAD_SIZE] {\n        let mut fields: BoundedVec<Field, FEE_PAYLOAD_SIZE> = BoundedVec::new();\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            fields.extend_from_array(self.function_calls[i].serialize());\n        }\n        fields.push(self.nonce);\n        fields.push(self.is_fee_payer as Field);\n        fields.storage\n    }\n}\n\nimpl Hash for FeePayload {\n    fn hash(self) -> Field {\n        poseidon2_hash_with_separator(self.serialize(), GENERATOR_INDEX__FEE_PAYLOAD)\n    }\n}\n\nimpl FeePayload {\n    fn to_be_bytes(self) -> [u8; FEE_PAYLOAD_SIZE_IN_BYTES] {\n        let mut bytes: BoundedVec<u8, FEE_PAYLOAD_SIZE_IN_BYTES> = BoundedVec::new();\n\n        for i in 0..MAX_FEE_FUNCTION_CALLS {\n            bytes.extend_from_array(self.function_calls[i].to_be_bytes());\n        }\n        bytes.extend_from_array(self.nonce.to_be_bytes::<32>());\n        bytes.push(self.is_fee_payer as u8);\n\n        bytes.storage\n    }\n\n    fn execute_calls(self, context: &mut PrivateContext) {\n        for call in self.function_calls {\n            if !call.target_address.is_zero() {\n                if call.is_public {\n                    context.call_public_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                } else {\n                    let _result = context.call_private_function_with_packed_args(\n                        call.target_address,\n                        call.function_selector,\n                        call.args_hash,\n                        call.is_static,\n                        false\n                    );\n                }\n            }\n        }\n        if self.is_fee_payer {\n            context.set_as_fee_payer();\n        }\n    }\n}\n"},"80":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/authwit/src/auth.nr","source":"use dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::{\n    GENERATOR_INDEX__AUTHWIT_INNER, GENERATOR_INDEX__AUTHWIT_OUTER, GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    CANONICAL_AUTH_REGISTRY_ADDRESS\n},\n    hash::poseidon2_hash_with_separator\n};\nuse dep::aztec::{context::{PrivateContext, PublicContext, gas::GasOpts}, hash::hash_args_array};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\nglobal IS_VALID_SELECTOR = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` have authorized the current call with a valid authentication witness\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([context.msg_sender().to_field(), context.selector().to_field(), context.args_hash]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that have authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context.static_call_private_function(\n        on_behalf_of,\n        comptime {\n        FunctionSelector::from_signature(\"verify_private_authwit(Field)\")\n    },\n        [inner_hash]\n    ).unpack_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allow same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` have authorized the current call in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress\n) {\n    let inner_hash = compute_inner_authwit_hash(\n        [(*context).msg_sender().to_field(), (*context).selector().to_field(), (*context).get_args_hash()]\n    );\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` have authorized a speicifc `inner_hash` in the authentication registry\n *\n * Computing the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then making a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n */\npub fn assert_inner_hash_valid_authwit_public(context: &mut PublicContext, on_behalf_of: AztecAddress, inner_hash: Field) {\n    let result: Field = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime {\n        FunctionSelector::from_signature(\"consume((Field),Field)\")\n    },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default()\n    ).deserialize_into();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N]\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash = compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computs the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that have authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(consumer: AztecAddress, chain_id: Field, version: Field, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [\n        consumer.to_field(),\n        chain_id,\n        version,\n        inner_hash\n    ],\n        GENERATOR_INDEX__AUTHWIT_OUTER\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub fn set_authorized(context: &mut PublicContext, message_hash: Field, authorize: bool) {\n    context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime {\n        FunctionSelector::from_signature(\"set_authorized(Field,bool)\")\n    },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime {\n        FunctionSelector::from_signature(\"set_reject_all(bool)\")\n    },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default()\n    ).assert_empty();\n}\n"},"82":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr","source":"use crate::context::{PrivateContext, PublicContext};\nuse crate::note::{\n    note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote},\n    utils::{compute_note_hash_for_read_request, compute_note_hash_for_nullify_internal},\n    note_emission::NoteEmission\n};\nuse crate::oracle::notes::{notify_created_note, notify_nullified_note};\n\npub fn create_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: &mut Note\n) -> NoteEmission<Note> where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    let note_hash_counter = context.side_effect_counter;\n\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    let serialized_note = Note::serialize_content(*note);\n    notify_created_note(\n        storage_slot,\n        Note::get_note_type_id(),\n        serialized_note,\n        note_hash,\n        note_hash_counter\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(*note)\n}\n\npub fn create_note_hash_from_public<Note, let N: u32>(\n    context: &mut PublicContext,\n    storage_slot: Field,\n    note: &mut Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let contract_address = (*context).this_address();\n    // Public note hashes are transient, but have no side effect counters, so we just need note_hash_counter != 0\n    let header = NoteHeader { contract_address, storage_slot, nonce: 0, note_hash_counter: 1 };\n    note.set_header(header);\n    let note_hash = note.compute_note_hash();\n\n    context.push_note_hash(note_hash);\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n\n    destroy_note_unsafe(context, note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note, let N: u32>(\n    context: &mut PrivateContext,\n    note: Note,\n    note_hash_for_read_request: Field\n) where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_nullify = compute_note_hash_for_nullify_internal(note, note_hash_for_read_request);\n    let nullifier = note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash_counter = note.get_header().note_hash_counter;\n    let notification_note_hash = if (note_hash_counter == 0) {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifyng so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    let nullifier_counter = context.side_effect_counter;\n    notify_nullified_note(nullifier, notification_note_hash, nullifier_counter);\n\n    context.push_nullifier_for_note_hash(nullifier, notification_note_hash)\n}\n"},"84":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NullifiableNote, NoteInterface}}\n};\n\nuse dep::protocol_types::{\n    hash::{\n    compute_unique_note_hash, compute_siloed_note_hash as compute_siloed_note_hash,\n    compute_siloed_nullifier as compute_siloed_nullifier_from_preimage\n},\n    utils::arr_copy_slice\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field\n) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field where Note: NoteInterface<N> + NullifiableNote {\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\nunconstrained pub fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S]\n) -> [Field; 4] where T: NoteInterface<N> + NullifiableNote {\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"91":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/note_emission.nr","source":"/**\n * A note emission struct containing the information required for emitting a note.\n * The exact `emit` logic is passed in by the application code\n */\npub struct NoteEmission<Note> {\n    note: Note\n}\n\nimpl<Note> NoteEmission<Note> {\n    pub fn new(note: Note) -> Self {\n        Self { note }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](Self) -> ()) {\n        _emit(self);\n    }\n\n    pub fn discard(_self: Self) {}\n}\n\n/**\n * A struct wrapping note emission in `Option<T>`.\n * This is the struct provided to application codes, which can be used to emit\n * only when a note was actually inserted.\n * It is fairly common to have cases where a function conditionally inserts,\n * and this allows us to keep the same API for emission in both cases (e.g. inserting\n * a change note in a token's transfer function only when there is \"change\" left).\n */\npub struct OuterNoteEmission<Note> {\n    emission: Option<NoteEmission<Note>>,\n}\n\nimpl<Note> OuterNoteEmission<Note> {\n    pub fn new(emission: Option<NoteEmission<Note>>) -> Self {\n        Self { emission }\n    }\n\n    pub fn emit<Env>(self, _emit: fn[Env](NoteEmission<Note>) -> ()) {\n        if self.emission.is_some() {\n            _emit(self.emission.unwrap());\n        }\n    }\n\n    pub fn discard(_self: Self) {}\n}\n"},"92":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/note/note_getter/mod.nr","source":"use dep::protocol_types::{constants::{MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, GET_NOTES_ORACLE_RETURN_LENGTH}};\nuse crate::context::PrivateContext;\nuse crate::note::{\n    constants::{GET_NOTE_ORACLE_RETURN_LENGTH, VIEW_NOTE_ORACLE_RETURN_LENGTH},\n    note_getter_options::{NoteGetterOptions, Select, Sort, SortOrder, NoteStatus, PropertySelector},\n    note_interface::{NoteInterface, NullifiableNote}, note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request\n};\nuse crate::oracle;\nuse crate::utils::comparison::compare;\n\npub use crate::note::constants::MAX_NOTES_PER_PAGE;\n\nmod test;\n\nfn extract_property_value_from_selector<let N: u32>(\n    serialized_note: [Field; N],\n    selector: PropertySelector\n) -> Field {\n    // Selectors use PropertySelectors in order to locate note properties inside the serialized note.\n    // This allows easier packing and custom (de)serialization schemas. A note property is located\n    // inside the serialized note using the index inside the array, a byte offset and a length.\n    let value: [u8; 32] = serialized_note[selector.index].to_be_bytes();\n    let offset = selector.offset;\n    let length = selector.length;\n    let mut value_field = 0 as Field;\n    let mut acc: Field = 1;\n    for i in 0..32 {\n        if i < length {\n            value_field += value[31 + offset - i] as Field * acc;\n            acc = acc * 256;\n        }\n    }\n    value_field\n}\n\nfn check_note_header<Note, let N: u32>(\n    context: PrivateContext,\n    storage_slot: Field,\n    note: Note\n) where Note: NoteInterface<N> {\n    let header = note.get_header();\n    let contract_address = context.this_address();\n    assert(header.contract_address.eq(contract_address), \"Mismatch note header contract address.\");\n    assert(header.storage_slot == storage_slot, \"Mismatch note header storage slot.\");\n}\n\nfn check_note_fields<let N: u32>(\n    serialized_note: [Field; N],\n    selects: BoundedVec<Option<Select>, N>\n) {\n    for i in 0..selects.len {\n        let select = selects.get_unchecked(i).unwrap_unchecked();\n        let value_field = extract_property_value_from_selector(serialized_note, select.property_selector);\n\n        assert(\n            compare(value_field, select.comparator, select.value.to_field()), \"Mismatch return note field.\"\n        );\n    }\n}\n\nfn check_notes_order<let N: u32>(\n    fields_0: [Field; N],\n    fields_1: [Field; N],\n    sorts: BoundedVec<Option<Sort>, N>\n) {\n    for i in 0..sorts.len {\n        let sort = sorts.get_unchecked(i).unwrap_unchecked();\n        let field_0 = extract_property_value_from_selector(fields_0, sort.property_selector);\n        let field_1 = extract_property_value_from_selector(fields_1, sort.property_selector);\n        let eq = field_0 == field_1;\n        let lt = field_0.lt(field_1);\n        if sort.order == SortOrder.ASC {\n            assert(eq | lt, \"Return notes not sorted in ascending order.\");\n        } else if !eq {\n            assert(!lt, \"Return notes not sorted in descending order.\");\n        }\n    }\n}\n\npub fn get_note<Note, let N: u32>(\n    context: &mut PrivateContext,\n    storage_slot: Field\n) -> (Note, Field) where Note: NoteInterface<N> + NullifiableNote {\n    let note = unsafe {\n        get_note_internal(storage_slot)\n    };\n\n    // Constraining that we got a valid note from the oracle is fairly straightforward: all we need to do is check that\n    // the metadata is correct, and that the note exists.\n    check_note_header(*context, storage_slot, note);\n\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    context.push_note_hash_read_request(note_hash_for_read_request);\n\n    (note, note_hash_for_read_request)\n}\n\npub fn get_notes<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    let opt_notes = unsafe {\n        get_notes_internal(storage_slot, options)\n    };\n\n    // We apply the constraints in a separate function instead of inlining them here to make it easier to test that\n    // these checks correctly reject bad notes.\n    constrain_get_notes_internal(context, storage_slot, opt_notes, options)\n}\n\nunconstrained fn apply_preprocessor<Note, PREPROCESSOR_ARGS>(\n    notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor: fn([Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL], PREPROCESSOR_ARGS) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    preprocessor_args: PREPROCESSOR_ARGS\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] {\n    preprocessor(notes, preprocessor_args)\n}\n\nfn constrain_get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    opt_notes: [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> (BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>, BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>) where Note: NoteInterface<N> + NullifiableNote + Eq {\n    // The filter is applied first to avoid pushing note read requests for notes we're not interested in. Note that\n    // while the filter function can technically mutate the contents of the notes (as opposed to simply removing some),\n    // the private kernel will later validate that these note actually exist, so transformations would cause for that\n    // check to fail.\n    let filter_fn = options.filter;\n    let filter_args = options.filter_args;\n    let filtered_notes = filter_fn(opt_notes, filter_args);\n\n    let notes = crate::utils::collapse_array(filtered_notes);\n    let mut note_hashes: BoundedVec<Field, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL> = BoundedVec::new();\n\n    // We have now collapsed the sparse array of Options into a BoundedVec. This is a more ergonomic type and also\n    // results in reduced gate counts when setting a limit value, since we guarantee that the limit is an upper bound\n    // for the runtime length, and can therefore have fewer loop iterations.\n    assert(notes.len() <= options.limit, \"Got more notes than limit.\");\n\n    let mut prev_fields = [0; N];\n    for i in 0..options.limit {\n        if i < notes.len() {\n            let note = notes.get_unchecked(i);\n            let fields = note.serialize_content();\n            check_note_header(*context, storage_slot, note);\n            check_note_fields(fields, options.selects);\n            if i != 0 {\n                check_notes_order(prev_fields, fields, options.sorts);\n            }\n            prev_fields = fields;\n\n            let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/1410): test to ensure\n            // failure if malicious oracle injects 0 nonce here for a \"pre-existing\" note.\n            context.push_note_hash_read_request(note_hash_for_read_request);\n            note_hashes.push(note_hash_for_read_request);\n        };\n    }\n\n    (notes, note_hashes)\n}\n\nunconstrained fn get_note_internal<Note, let N: u32>(storage_slot: Field) -> Note where Note: NoteInterface<N> {\n    let placeholder_note = [Option::none()];\n    let placeholder_fields = [0; GET_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n    oracle::notes::get_notes(\n        storage_slot,\n        0,\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        [],\n        1, // limit\n        0, // offset\n        NoteStatus.ACTIVE,\n        placeholder_note,\n        placeholder_fields,\n        placeholder_note_length\n    )[0].expect(f\"Failed to get a note\") // Notice: we don't allow dummies to be returned from get_note (singular).\n}\n\nunconstrained fn get_notes_internal<Note, let N: u32, PREPROCESSOR_ARGS, FILTER_ARGS>(\n    storage_slot: Field,\n    options: NoteGetterOptions<Note, N, PREPROCESSOR_ARGS, FILTER_ARGS>\n) -> [Option<Note>; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL] where Note: NoteInterface<N> {\n    // This function simply performs some transformations from NoteGetterOptions into the types required by the oracle.\n\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL];\n    let placeholder_fields = [0; GET_NOTES_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let opt_notes = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    apply_preprocessor(opt_notes, options.preprocessor, options.preprocessor_args)\n}\n\nunconstrained pub fn view_notes<Note, let N: u32>(\n    storage_slot: Field,\n    options: NoteViewerOptions<Note, N>\n) -> BoundedVec<Note, MAX_NOTES_PER_PAGE> where Note: NoteInterface<N> {\n    let (num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order) = flatten_options(options.selects, options.sorts);\n    let placeholder_opt_notes = [Option::none(); MAX_NOTES_PER_PAGE];\n    let placeholder_fields = [0; VIEW_NOTE_ORACLE_RETURN_LENGTH];\n    let placeholder_note_length = [0; N];\n\n    let notes_array = oracle::notes::get_notes(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        options.limit,\n        options.offset,\n        options.status,\n        placeholder_opt_notes,\n        placeholder_fields,\n        placeholder_note_length\n    );\n\n    let mut notes = BoundedVec::new();\n    for i in 0..notes_array.len() {\n        if notes_array[i].is_some() {\n            notes.push(notes_array[i].unwrap_unchecked());\n        }\n    }\n\n    notes\n}\n\nunconstrained fn flatten_options<let N: u32>(\n    selects: BoundedVec<Option<Select>, N>,\n    sorts: BoundedVec<Option<Sort>, N>\n) -> (u8, [u8; N], [u8; N], [u8; N], [Field; N], [u8; N], [u8; N], [u8; N], [u8; N], [u8; N]) {\n    let mut num_selects = 0;\n    let mut select_by_indexes = [0; N];\n    let mut select_by_offsets = [0; N];\n    let mut select_by_lengths = [0; N];\n    let mut select_values = [0; N];\n    let mut select_comparators = [0; N];\n\n    for i in 0..selects.len {\n        let select = selects.get(i);\n        if select.is_some() {\n            select_by_indexes[num_selects] = select.unwrap_unchecked().property_selector.index;\n            select_by_offsets[num_selects] = select.unwrap_unchecked().property_selector.offset;\n            select_by_lengths[num_selects] = select.unwrap_unchecked().property_selector.length;\n            select_values[num_selects] = select.unwrap_unchecked().value;\n            select_comparators[num_selects] = select.unwrap_unchecked().comparator;\n            num_selects += 1;\n        };\n    }\n\n    let mut sort_by_indexes = [0; N];\n    let mut sort_by_offsets = [0; N];\n    let mut sort_by_lengths = [0; N];\n    let mut sort_order = [0; N];\n    for i in 0..sorts.len {\n        let sort = sorts.get(i);\n        if sort.is_some() {\n            sort_by_indexes[i] = sort.unwrap_unchecked().property_selector.index;\n            sort_by_offsets[i] = sort.unwrap_unchecked().property_selector.offset;\n            sort_by_lengths[i] = sort.unwrap_unchecked().property_selector.length;\n            sort_order[i] = sort.unwrap_unchecked().order;\n        };\n    }\n\n    (\n        num_selects, select_by_indexes, select_by_offsets, select_by_lengths, select_values, select_comparators, sort_by_indexes, sort_by_offsets, sort_by_lengths, sort_order\n    )\n}\n"},"99":{"path":"/home/anon/nargo/github.com/AztecProtocol/aztec-packagesaztec-packages-v0.57.0/noir-projects/aztec-nr/aztec/src/utils/point.nr","source":"use dep::protocol_types::point::Point;\n\n// I am storing the modulus divided by 2 plus 1 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field = 10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a public key to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(pk: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!pk.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = pk.x.to_be_bytes();\n\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    if !BN254_FR_MODULUS_DIV_2.lt(pk.y) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\nmod test {\n    use dep::protocol_types::point::Point;\n    use crate::utils::point::point_to_bytes;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122, 205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115\n        ];\n\n        assert_eq(expected_compressed_point_positive_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_positive_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_positive_sign[i]);\n        }\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169, 34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign.len(), compressed_point.len());\n        for i in 0..expected_compressed_point_negative_sign.len() {\n            assert_eq(compressed_point[i], expected_compressed_point_negative_sign[i]);\n        }\n    }\n}\n"}}}